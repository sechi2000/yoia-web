<?xml version="1.0" encoding="UTF-8"?>
<javascript app="core">
 <file javascript_app="global" javascript_location="library" javascript_path="" javascript_name="app.js" javascript_type="framework" javascript_version="5001403" javascript_position="250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * app.js - Our main app script
 *
 * Author: Rikki Tissier
 */

// Our namespace
var ips = ips || {};

jQuery.migrateMute = true;

( function($, _, undefined){

	class CustomSubmitEvent extends Event {
		/** @type {Element|undefined}*/
		submitter = undefined;
		/** @type {SubmitEvent} */
		originalEvent = undefined;

		/**
		 * @param {SubmitEvent}	originalEvent
		 */
		constructor(originalEvent) {
			super('submit', {bubbles: true});
			this.submitter = originalEvent.submitter;
			this.originalEvent = originalEvent;
		}
	}

	"use strict";
	let logTimeIndent = 0;
	ips = ( function () {

		var _settings,
			_strings = {},
			_graphData = {},
			uid = 1,
			urand = Math.ceil( Math.random() * 10000 ),
			elemContainer,
			_location = 'front';

		/**
		 * Boot methods - sets up the app
		 *
		 * @returns 	{void}
		 */ 
		var boot = function (config) {
			_settings = config;

			// Set our ajax handler default
			_setAjaxConfig();

			_setAjaxEventListeners();
			document.addEventListener('submit', e => {
				const form = e.target;
				if (e instanceof SubmitEvent && form instanceof HTMLFormElement && form.method.toUpperCase() === 'POST' && !getSetting('memberID') && getCsrfKeyExpiry() < Date.now() / 1000) {
					Debug.log(`Intercepted form submission... fetching fresh CSRF key`);
					e.preventDefault();
					e.stopPropagation();
					e.stopImmediatePropagation();
					getFreshCsrfKey()
						// .then(() => new Promise(resolve => setTimeout(resolve, 2000))) // DEBUG - wait a couple seconds so I can read the logs
						.then(() => {
							Debug.log(`Got a new CSRF key, resuming the form submission`);
							let submitButton = (e instanceof SubmitEvent || e.submitter instanceof Element) ? e.submitter : form.querySelector('button[type="submit"], button:not([type]), input[type="submit"]');
							if (submitButton) {
								submitButton.click();
							} else {
								// the click() causes the native submit event to fire. However, if there was no submitter (e.g. the user pressed 'Enter'), we need to dispatch our own submit event and see if they call prevent default.
								const ev = new CustomSubmitEvent(e);
								form.dispatchEvent(ev);
								if (ev.defaultPrevented) {
									return;
								}
								form.submit();
							}
						});
				}
			}, {capture: true});


			// popover polyfill. todo at somepoint, e.g. 2027 or later, we can remove this and expect devices support popovers natively
			if (!(HTMLElement.prototype.showPopover instanceof Function)) {
				Debug.log(`Loading popover polyfill`);
				setTimeout(() => {
					ips.loader.getStatic('/applications/core/interface/static/popover/popover.min.js');
				});
			}


				// Add a little jQuery plugin that allows us to add callbacks
			// to CSS animations
			$.fn.animationComplete = function (callback) {
				// Use native JS DOM APIs and promises to handle animationComplete, rather than waiting for an animation event.
				if ('getAnimations' in Element.prototype) {
					const elements = [...this];
					
					// .animationComplete() is usually called before animations begin, so we wait for a full event loop cycle
					(new Promise(resolve => setTimeout(resolve, 0)))
						.then(() => Promise.allSettled((elements.map(el => el.getAnimations()).flat()).map(anim => anim.finished)))
						.then(() => callback.apply(this));

					return $(this);
				}

				// fallback to the jquery system.
				return $( this ).one('webkitAnimationEnd animationend', function (e) {
					// Important fix: ignore bubbled transition events
					if( e.target == this ){
						callback.apply( this );
					}
				});
			};

			// In case we already have ips_uid elements on the page, start at the highest found

			// jQuery plugin that adds a unique id to an element if an ID doesn't
			// already exist. Based on jQueryUI method.
			$.fn.identify = function () {
				return this.each( function () {
					if( !this.id ) {
						this.id = 'ips_uid_' + urand + '_' + (++uid);
					}
				});
			};

			// Redefine .prop() so that we can observe events when properties are changed
			// See: http://stackoverflow.com/questions/16336473/add-event-handler-when-checkbox-becomes-disabled
			var oldProp = $.fn.prop;
			var newProp = function () {
				var retFunc = oldProp.apply( this, arguments );
				this.trigger( 'propChanged', this );
				return retFunc;
			};

			$.fn.prop = newProp;

			// Add a utility function for easily adding
			// methods to a prototype. 
			// From "Javascript: The Good Parts" by Douglas Crockford
			Function.prototype.method = function (name, func) {
				this.prototype[name] = func;
				return this;
			};

			// Set up mustache-style templates for language interpolation in underscore
			_.templateSettings = {
				interpolate: /\{\{(.+?)\}\}/g
			};
											
			// Warn users about pasting stuff into the console
			if( !Debug.isEnabled() && window.console ){
				window.console.log("%cThis is a browser feature intended for developers. Do not paste any code here given to you by someone else. It may compromise your account or have other negative side effects.", "font-weight: bold; font-size: 14px;");
			}

			// Signal that we're ready to begin
			$( document )
				.trigger('doneBooting')
				.ready( function () {
					// Set our location
					_location = $( 'body' ).attr('data-pageLocation') || 'front';
				});
		},

			/**
			 * Allows us to use mock ajax objects if necessary, and fetches a fresh CSRF token if we're on a guest page before sending the request
			 *
			 * @returns 	{object} 	Ajax object (jQuery's $.ajax by default)
			 */
			getAjax = function () {
				const wrap = method => (...args) => {
					let options = {}, url;
					if (typeof args[0] === 'string') {
						url = args[0];
						options = args[1] || {};
					} else if (typeof args[0] === 'object' && args[0]) {
						options = args[0];
					}

					// In this case, we completely skip redirects on both the front and back end
					if (options?.bypassRedirect === 'none') {
						options.headers = options.headers || {};
						options.headers['x-bypass-ajax-redirect'] = '1';
					}

					if ((options.method || options.type)?.toLowerCase() !== 'post' || getSetting('memberID') || getCsrfKeyExpiry() >= Date.now() / 1000) {
						return method(...args);
					}

					// Guest with an expired CSRF key? Oh boy, we need to return a proxy object for an api encompassing its own polyfill (our polyfill > $.ajax > XMLHttpRequest)
					let requestInstance;
					const decoratorQueues = {};
					const properties = {};
					let thenResolve,
						thenReject,
						mimeTypeOverride;
					const uploadEventListeners = new Map();
					const uploadDispatchedEvents = [];
					const proxyXHRObject = {
						_promise: new Promise((resolve, reject) => {
							thenResolve = resolve;
							thenReject = reject
						}),
						then(cb) {
							this._promise.then(cb);
						},
						catch(...args) {
							this._promise.catch(...args)
						},
						finally(...args) {
							this._promise.finally(...args);
						},
						_aborted: false,
						get aborted() {
							return this._aborted;
						},
						_abortedStatusText: undefined,
						get abortedStatusText() {
							return this._abortedStatusText;
						},
						abort(statusText) {
							this._aborted = true;
							this._abortedStatusText = statusText;
							requestInstance?.abort(statusText);
						},
						getAllResponseHeaders() {
							return requestInstance?.getAllResponseHeaders() || null;
						},
						getResponseHeader(header) {
							return requestInstance?.getResponseHeader(header) || null;
						},
						overrideMimeType(mimeType) {
							if (requestInstance) {
								requestInstance.overrideMimeType(mimeType);
								return;
							}
							mimeTypeOverride = mimeType;
						},
						get readyState() {
							return requestInstance ? requestInstance.readyState : 0;
						},
						get response() {
							return requestInstance ? ('response' in requestInstance ? requestInstance.response : null) : null;
						},
						get responseText() {
							if (typeof requestInstance?.responseText === 'string') {
								return requestInstance.responseText;
							}
							return "";
						},
						get responseType() {
							if (typeof requestInstance?.responseType === 'string') {
								return requestInstance.responseType;
							}
							return "";
						},
						get responseURL() {
							return requestInstance ? requestInstance.responseURL : (url || options.url || window.location.href);
						},
						get responseXML() {
							return requestInstance ? requestInstance.responseXML : null;
						},
						get status() {
							return requestInstance ? requestInstance.status : 0;
						},
						get statusText() {
							return requestInstance ? requestInstance.statusText : "";
						},
						get timeout() {
							return properties.timeout || 0;
						},
						set timeout(val) {
							properties.timeout = val;
							if (requestInstance) {
								requestInstance.timeout = val;
							}
						},
						get withCredentials() {
							return !!(requestInstance ? requestInstance.withCredentials : properties.withCredentials);
						},
						set withCredentials(val) {
							val = !!val;
							properties.withCredentials = val; // track this in case it was set before the request instance was defined
							if (requestInstance) {
								requestInstance.withCredentials = val;
							}
						},
						_upload: {
							_getEventCollection(event, options) {
								const path = [
									event,
									(options && options.capture) ? "true" : "false"
								];

								let collection = uploadEventListeners;
								for (let i = 0; i < path.length; i++) {
									const cmp = path[i];
									collection.set(cmp, collection.get(cmp) || new Map());
									collection = collection.get(cmp);
								}

								return collection;
							},
							addEventListener(event, cb, options={}) {
								requestInstance?.upload?.addEventListener?.(event, cb, options);
								this._getEventCollection(event, options).set(cb, {options, event});
							},
							removeEventListener(event, cb, options={}) {
								requestInstance?.upload?.removeEventListener?.(event, cb, options);
								this._getEventCollection(event, options).delete(cb);
							},
							dispatchEvent(...args) {
								if (requestInstance?.upload?.dispatchEvent instanceof Function) {
									requestInstance.upload.dispatchEvent(...args);
									return;
								}
								uploadDispatchedEvents.push(args);
							},
							set onabort(cb) {
								this.addEventListener('abort', cb);
							},
							set onerror(cb) {
								this.addEventListener('error', cb);
							},
							set onload(cb) {
								this.addEventListener('load', cb);
							},
							set onloadend(cb) {
								this.addEventListener('loadend', cb);
							},
							set onloadstart(cb) {
								this.addEventListener('loadstart', cb);
							},
							set onprogress(cb) {
								this.addEventListener('progress', cb);
							},
							set ontimeout(cb) {
								this.addEventListener('timeout', cb);
							}
						},
						get upload() {
							return requestInstance ? requestInstance.upload : this._upload;
						}
					}

					for (const chainableMethod of ['done','always', 'fail', 'success', 'error', 'complete']) {
						proxyXHRObject[chainableMethod] = (function(...args) {
							decoratorQueues[chainableMethod] = decoratorQueues[chainableMethod] || [];
							decoratorQueues[chainableMethod].push(args);
							requestInstance?.[chainableMethod]?.(...args);
							return this;
						}).bind(proxyXHRObject);
					}

					for (const simpleMethod of ['getAllResponseHeaders', 'getResponseHeader']) {
						proxyXHRObject[simpleMethod] = (function(...args) {
							return requestInstance?.[simpleMethod]?.(...args);
						}).bind(proxyXHRObject);
					}


					getFreshCsrfKey()
						.then(() => {
							Debug.log(`Intercepted Fetch request and get fresh CSRF Key`);
							requestInstance = method(url, options);
							if (requestInstance.upload) {
								if (Object.keys(uploadEventListeners).length) {
									function evalCollection(collection) {
										for (const [key, childCollection] of collection.entries()) {
											if (key instanceof Function) {
												requestInstance.upload.addEventListener(childCollection.event, key, childCollection.options);
											} else {
												evalCollection(childCollection);
											}
										}
									}
									evalCollection(uploadEventListeners);
								}

								for (const args of uploadDispatchedEvents) {
									requestInstance.upload.dispatchEvent(...args);
								}
							}
							if (mimeTypeOverride) {
								requestInstance.overrideMimeType(mimeTypeOverride);
							}

							for (const queue in decoratorQueues) {
								requestInstance[queue](...decoratorQueues[queue]);
							}

							for (const property in properties) {
								requestInstance[property] = properties[property];
							}

							requestInstance
								.then((...result) => {
									thenResolve(...result);
								}).catch(err => {
								thenReject(err);
							});

							if (proxyXHRObject.aborted) {
								proxyXHRObject.abortedStatusText ? requestInstance.abort(proxyXHRObject.abortedStatusText) : requestInstance.abort();
							}
						});

					return proxyXHRObject;
				}

				if( getSetting('mock_ajax') ){
					return wrap(getSetting('mock_ajax'));
				}

				return wrap($.ajax);
			},
		/**
		 * Async wrapper for our getAjax method to act like fetch. Resolves the response data or throws an error on reject
		 *
		 * @typedef ajaxOptions
		 * @property {string}		[accepts='depends on dataType']		The content type accpeted in a response
		 * @property {Function}		[beforeSend] An optional callback which modifies the jqXHR request before sending it out; see http://api.jquery.com/Types/#jqXHR
		 * @property {boolean}		[cache=true]	Whether to allow the browser to cache the response of this request
		 * @property {string}		[contentType='application/x-www-form-urlencoded; charset=UTF-8'|false] The content type of the data being sent out, or false to not send a content type request header
		 * @property {boolean}		[crossDomain=false] Whether to force a cross domain request. NOTE this is automatically set when the url is cross domain, and rarely if ever should be set manually
		 * @property {object|string|array} [data]		The request body
		 * @property {"html"|"xml"|"script"|"json"|"jsonp"|"text"|string}		[dataType]	The content type you are expecting in the response; This is usually not needed and will be interpreted by the mime type. You can also pass a space delimited list of types
		 *@property  {Object.<string, string>}	[headers]	Additional request headers to send
		 * @property {boolean}	[ifModified=false]	Only treat the response as successful if the response changed since the last request, determined by the lastModified response header
		 * @property {"GET"|"POST"|"PUT"|"DELETE"|"PATCH"|string}	[method="GET"]	The HTTP Request method
		 * @property {string}		[mimeType]		A string to overload the XHR mimetype
		 * @property {string}		[password]		A password to use for HTTP basic auth
		 * @property {boolean}		[processData=false]	Whether to process data passed in the `data` property before sending it to the server to match the content type (e.g. an object is converted to a query string)
		 * @property {string}		[scriptCharset]	If you are using script transport (e.g. appending a <script> element and setting the source), this will set the charset of the script element before requesting the script
		 * @property {number}		[timeout]		The timeout of the request; `0` means the request never times out
		 * @property {string}		[username]      A username to use for HTTP Basic Auth
		 *
		 * @param {string|ajaxOptions}		url		The url being requested
		 * @param {ajaxOptions}		[settings={}]		Additional settings to use for the request
		 *
		 * @returns {Promise<object>}
		 */
		fetch = function(url, settings={}) {
			return new Promise((resolve, reject) => {
				const options = {};
				if (typeof settings === 'object') {
					Object.assign(options, settings)
				} else if (settings) {
					return resolve(new TypeError(`Could not generate an ajax request because the settings is supposed to be of type object. Got a(n) ${typeof settings}`));
				}

				if (typeof url === 'string') {
					options.url = url;
				} else if (typeof url === 'object') {
					Object.assign(options, url)
				} else {
					return reject(new TypeError(`Could not generate an ajax request because url is supposed to be a string or an object. Got a ${typeof url}`));
				}

				options.async = true
				const getXHRHook = options.getXHRHook;
				delete options.getXHRHook;
				delete options.error
				delete options.success
				delete options.complete
				delete options.contents
				delete options.context
				delete options.converters
				delete options.dataFilter
				delete options.global
				delete options.isLocal
				delete options.jsonp
				delete options.jsonpCallback
				delete options.scriptAttrs
				delete options.statusCode
				delete options.traditional
				delete options.xhr
				delete options.xhrFields

				if (options.type && !options.method) {
					options.method = options.type;
					delete options.type;
				}
				let jqxhr;
				jqxhr = getAjax()(options).done(resolve).fail((e,...args) => {
					try {
						if (e instanceof Error || typeof e === 'object') {
							e.jqxhr = jqxhr;
							e.additionalArgs = args;
							reject(e);
						} else {
							throw new Error("Expected the first argument of the fail method to be an Error or a writable Object");
						}
					} catch (anotherError) {
						let finalError = new Error("Got a really weird type passed to the fail method of a jquery ajax call");
						finalError.additionalArgs = args;
						finalError.jqxhr = jqxhr;
						finalError.additionalError = anotherError;
						Debug.error(anotherError);
						reject(anotherError);
					}
				});

				if (getXHRHook instanceof Function) {
					try {
						getXHRHook(jqxhr);
					} catch (e) {
						e.message = `Something went wrong when assigning the jqxhr hook - ${e.message}`;
						Debug.error(e);
					}
				}
			})
		},

		/**
		 * Returns our main wrapper (body by default)
		 * With custom skins, sometimes inserting into the body can cause styling issues.
		 * With the container setting, we can choose to insert them somewhere else.
		 *
		 * @returns 	{element} 	The container
		 */ 
		getContainer = function () {
			var tryThis = $( getSetting('container') );
			return ( tryThis.length ) ? tryThis : $('body');
		},

		/**
		 * Refresh teh csrf key if needed
		 * @return {Promise<void>}
		 * @private
		 */
		_refreshCsrfKey = async function() {

			// we do this before refreshing to prevent any infinite loops.
			setSetting('csrfKeyExpiry', Math.floor(Date.now() / 1000 + 20));
			try {
				// we use fetch() directly to not use the existing csrf key that getAjax uses
				const response = await window.fetch(getSetting('baseURL').toString().replace(/\/+$/, '') + '/?app=core&module=system&controller=ajax&do=getCsrfKey&path=' + window.location.pathname );
				const data = await response.json();

				Debug.log(`Got new CSRF Key: ${data.key}`);
				setSetting('csrfKey', data.key);
				setSetting('csrfKeyExpiry', typeof data.expiry === "number" ? data.expiry : Math.floor(Date.now() / 1000 + 500));
				_setAjaxConfig();

				// All csrfKey inputs
				document
					.querySelectorAll(`form input[name="csrfKey"]`)
					.forEach(input => {
						input.value = data.key;
					});


				// Make sure the form's action is updated
				document.querySelectorAll(`form:is([action*="?csrfKey="],[action*="&csrfKey="])`)
					.forEach(form => {
						const url = new URL(form.action);
						if ((url.toString().startsWith('https:' + ips.getSetting('baseURL')) || url.toString().startsWith('http:' + ips.getSetting('baseURL'))) && (url.searchParams.has('csrfKey') || form.method.toLowerCase() !== 'get')) {
							url.updateSearchParams({param: 'csrfKey', value: data.key});
							form.action = url.toString();
						}
					});

				// Any links need updating too
				document.querySelectorAll(`[href*="?csrfKey="], [href*="&csrfKey="]`)
					.forEach(linkLikeEl => {
						const url = new URL(linkLikeEl.href || linkLikeEl.getAttribute('href'));
						if ((url.toString().startsWith('https:' + ips.getSetting('baseURL')) || url.toString().startsWith('http:' + ips.getSetting('baseURL'))) && url.searchParams.has('csrfKey')) {
							url.updateSearchParams({param: 'csrfKey', value: data.key});
							linkLikeEl.setAttribute('href', url.toString());
						}
					});

				// Dispatch an event so third party code can listen
				document.dispatchEvent(new CustomEvent('ips:csrfKeyUpdated'));
			} catch (e) {
				Debug.warn(e);
			}
		},


		/**
		 * Get the time the csrf key should expire. If there is no current csrf key, we return null
		 *
		 * @return {number}
		 */
		getCsrfKeyExpiry = function() {
			const setting = getSetting('csrfKeyExpiry');
			if (typeof setting === "number" && !Number.isNaN(setting) && getSetting('csrfKey')) {
				return setting;
			}

			return 0; // in this case, we assume it's expired
		},

		/**
		 * Refresh the csrf key on the page to make sure it's valid
		 *
		 * @returns {Promise<string>}
		 */
		getFreshCsrfKey = async function() {
			// Logged In and we know the key? Return it now
			if (getSetting('memberID') && getSetting('csrfKey')) {
				return getSetting('csrfKey');
			}

			if (Date.now() / 1000 >= getCsrfKeyExpiry()) {
				await _refreshCsrfKey();
			}

			return getSetting('csrfKey');
		},

		/**
		 * Sets up our global ajax handlers
		 *
		 * @returns 	{void}
		 */ 
		_setAjaxConfig = function () {
			var data = {
				csrfKey: getSetting('csrfKey')
			};

			$.ajaxSetup({
				data: data,
				cache: true
			});
		},

		/**
		 * Set up the event listeners for ajax requests
		 * @private
		 */
		_setAjaxEventListeners = function() {

			// Add global loading indicator ability
			var count = 0;

			$( document )
				.ajaxSend( function (event, request, settings) {
					if( !_.isUndefined( settings ) && settings.showLoading === true ){
						if( !$('#elAjaxLoading').length ){
							getContainer().append( templates.render('core.general.ajax') );
						}

						count++;
						ips.utils.anim.go( 'fadeIn fast', $('#elAjaxLoading') );
					}
				})
				.ajaxComplete( function (event, request, settings) {
					if( !_.isUndefined( settings ) && settings.showLoading === true ){
						count--;

						if( count === 0 ){
							ips.utils.anim.go( 'fadeOut fast', $('#elAjaxLoading') );
						}
					}

					// Check for redirect response
					if( !_.isUndefined( settings ) && !settings.bypassRedirect ){
						var responseJson = null;

						if( !_.isUndefined( request.responseJSON ) && !_.isUndefined( request.responseJSON.redirect ) )
						{
							responseJson = request.responseJSON;
						}
						else if( !_.isUndefined( request.responseText ) )
						{
							try
							{
								var jsonResponse = $.parseJSON( request.responseText );

								if( jsonResponse && !_.isUndefined( jsonResponse.redirect ) )
								{
									responseJson = jsonResponse;
								}
							}
							catch( err ){}
						}

						if( responseJson ){
							// Do we have a flash message to show?
							if( !_.isUndefined( responseJson.message ) && responseJson.message != '' ){
								ips.utils.cookie.set( 'flmsg', responseJson.message );
							}
							
							if ( responseJson.redirect.match( /#/ ) ) {
								window.location.href = responseJson.redirect;
								window.location.reload();
							} else {
								window.location = responseJson.redirect;
							}
						}
					}

					// Re-parse cookies
					ips.utils.cookie.init();
				});
		},

		/**
		 * Config getter
		 *
		 * @param 	{string} 	key 	Setting key to return
		 * @returns {*} 	Config setting, or undefined if it doesn't exist
		 */ 
		getSetting = function (key) {
			return _settings[ key ];
		},

		/**
		 * Return full settings object
		 *
		 * @returns 	{object} 	Settings object
		 */
		getAllSettings = function () {
			return _settings;
		},

		/**
		 * Config setter
		 *
		 * @param 	{string} 	key 	Key to set
		 * @param 	{mixed} 	value	Setting value
		 * @returns {void}
		 */
		setSetting = function (key, value) {
			_settings[ key ] = value;
		},

		/**
		 * Adds strings to our language object
		 *
		 * @param 	{mixed} 	strings 	Either an {object} of key/values, or a {string} as a key
		 * @param 	{string} 	[...]		If strings is a string, this param is the value
		 * @returns {void}
		 */
		setString = function (strings) {

			if( _.isString( strings ) && arguments.length == 2 && _.isString( arguments[1] ) ){
				strings = {};
				strings[ arguments[0] ] = arguments[1];
			} else if( !_.isObject( strings ) ){
				Debug.warn("Invalid strings object passed to addString");
				return;
			}

			$.each( strings, function (key, value ){
				_strings[ key ] = value;
			});
		},
		
		/**
		 * Detect if a language string exists
		 *
		 * @param 	{string} 	key		The key
		 * @returns {boolean}
		 */	
		haveString = function (key) {
			return !_.isUndefined( _strings[ key ] );
		},

		/**
		 * Retrieves a string from storage, and interpolates values if needed
		 *
		 * @param 	{string} 	key 		The key of the string
		 * @param 	{?Object.<string, string|number|boolean>} 	[values]		The values to interpolate into the string
		 * @param	{boolean}	[showMissingError=true]		Whether to return an error message when the string is missing and debug mode is enabled. Only disable this when a lang string is intentionally missing
		 *
		 * @returns {string}	The interpolated string ('' if the key does not exist)
		 */	
		getString = function (key, values, showMissingError=true) {

			if (!(key in _strings)) {
				Debug.warn("The string '" + key + "' doesn't exist");
				return Debug.isEnabled() && showMissingError ? `[${key}]` : '';
			}

			/**
			 * @type {string}
			 */
			let thisString = _strings[ key ];
			values = values || {};

			// Do we have special values to parse?
			if (thisString.indexOf('{{') === -1) {
				return thisString;
			}

			// Add some vars into the values
			Object.assign(values, {
				baseURL: ips.getSetting('baseURL')
			});

			try {
				return _.template(thisString)(values);
			} catch (err) {
				Debug.error(err);
				return Debug.isEnabled() ? "[Error using language string " + key + "]" : "";
			}
		},

		/**
		* GraphQL Response setter
		*
		* @param 	{string} 	key 	Key to set
		* @param 	{mixed} 	value	Response value
		* @returns {void}
		*/
		setGraphQlData = function (key, value) {
			_graphData[ key ] = value;
		},

		/**
		 * GraphQL Responses getter
		 *
		 * @param 	{string} 	key 	Key to return
		 * @returns {mixed} 	Data, or undefined if it doesn't exist
		 */
		getGraphQlData = function (key) {
			return _graphData[ key ];
		},

		/**
		 * Returns the location in which we're running
		 *
		 * @returns {string} 	Location key
		 */
		getLocation = function () {
			return _location;
		},

		/**
		 * Create a module, checking that each namespace is ready to accept
		 * modules. If the init method exists on the given module, it is added
		 * to the document.ready queue.
		 *
		 * @param	{string} 	name 	The full module path to create
		 * @param 	{function} 	fn 		The module definition
		 * @returns {void}
		 */
		createModule = function (name, fn) {
			
			var bits = name.split('.'),
				currentPath = window;

			var tmpName = [];

			// Loop through the path pieces and ensure they exist
			if( bits.length ){
				for( var i = 0; i < bits.length; i++ ){

					if( _.isUndefined( currentPath[ bits[i] ] ) ){
						currentPath[ bits[i] ] = {};
					}

					currentPath = currentPath[ bits[i] ];
				}
			} else {
				return false;
			}

			// Assign our module to the path
			currentPath = _.extend( currentPath, fn.call( currentPath ) );

			// Set up init if it exists
			if( _.isFunction( currentPath.init ) ){
				// support external loading. If the script is embedded in another webpage after it loads, the document is already 'ready'. We will instead listen for a 'ipsScriptsReady' event
				if (window.ipsScriptsExternallyLoaded) {
					$(document.body).on('ipsScriptsReady', function () {
						currentPath.init.call(currentPath);
					})
				} else {
					$(document).ready(function () {
						currentPath.init.call(currentPath);
					});
				}
			}

			$( document ).trigger( 'moduleCreated', [ name ] );
		},

		/**
		 * Provides a pluralized version of a string based on the supplied value
		 *
		 * @param	{string} 	stringKey 	The key of the language string containing the pluralization tag
		 * @param 	{number} 	value 		The value to be pluralized
		 * @returns {string}
		 */
		pluralize = function (stringKey, params) {
			// Get the string we'll work with
			var word = stringKey;

			// Get the pluralization tags from it
			var i = 0;

			if( !_.isArray( params ) ){
				params = [ params ];
			}
			
			word = word.replace( /\{(!|\d+?)?#(.*?)\}/g, function (a,b,c,d) {
				// {# [1:count][?:counts]}
				if( !b || b == '!' ){
					b = i;
					i++;
				}

				var value;
				var fallback;
				var output = '';
				var replacement = params[ b ] + '';

				c.replace( /\[(.+?):(.+?)\]/g, function (w,x,y,z) {
					var xLen = x.length * -1;
					
					if( x == '?' ){
						fallback = y.replace( '#', replacement );
					} 
					else if( x.charAt(0) == '%' && x.substring( 1 ) == replacement.substring( 0, x.substring( 1 ).length ) ){
						value = y.replace( '#', replacement );
					}
					else if( x.charAt(0) == '*' && x.substring( 1 ) == replacement.substr( -x.substring( 1 ).length ) ){
						value = y.replace( '#', replacement );	
					}
					else if( x == replacement ) {
						value = y.replace( '#', replacement );
					}
				});

				output = a.replace( /^\{/, '' ).replace(/\}$/, '' ).replace( '!#', '' );
				output = output.replace( b + '#', replacement ).replace( '#', replacement );
				output = output.replace( /\[.+\]/, value == null ? fallback : value ).trim();

				return output;
			});

			return word;
		},

		testConsole = function () {
			if( window.atob && window.console ){
				console.log( window.atob("ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgd293ICAgICAgICAgICAgICAgICAgICAgICAgICAgI\
CAgIAogICAgICAgICAgICAgICAgICAgICAgICBzdWNoIGZvcnVtICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAga\
G93IGFqYXggICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICB2ZXJ5IGNvbW11bml0eSAgICAgIC\
AgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWNoIG1lbWJlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\
ICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCg==")
				);
			}

			return '';
		};

		var templates = function () {
			var _templateStore = {};
			const _defaults = {};

			/**
			 * Sets a mustache template
			 *
			 * @param	{string} 	key 		Key name for this template
			 * @param 	{string|function():string} 	template 	Template, as string or function which returns a string
			 * @param 	{Object}					[defaults]	Default template params
			 * @returns {void}
			 */
			var set = function (key, template, defaults={}) {
				_templateStore[ key ] = template;
				_defaults[key] = defaults;
			},

			/**
			 * Return a mustache template
			 *
			 * @param	{string} 	key 		Key name for the template to retrieve
			 * @returns {string}	Template contents
			 */
			get = function (key) {
				if( _templateStore[ key ] ){
					if( _.isFunction( _templateStore[ key ] ) ){
						return _templateStore[ key ]();
					} else {
						return _templateStore[ key ];
					}
				}

				return '';
			},

			/**
			 * Renders a mustache template
			 *
			 * @param	{string} 	key 		Key name for this template
			 * @param 	{?Object} 	[obj] 		Object of values with which to render the template
			 * @returns {string} 	The rendered contents
			 */
			render = function (key, obj) {
				obj = (obj && typeof obj === 'object') ? obj : {};
				const defaults = _defaults[key] || {};
				const options = {
					...defaults,
					...obj,
					baseURL: ips.getSetting('baseURL'),
					lang: _lang,
					blankImg: ips.getSetting('blankImg') || ''
				};

				return Mustache.render( get( key ), options );
			},

			/**
			 * Returns a compile mustache template ready for us
			 *
			 * @param	{string} 	key 		Key name for this template
			 * @returns {function} 	A compiled template function
			 */
			compile = function (key) {
				if( _templateStore[ key ] ){
					const compiled = Mustache.parse(get(key));
					return (options, ...otherArgs) => {
						options = (options && typeof options ==='object') ? options : {};
						const defaults = _defaults[key] || {};
						options = {...defaults, ...options};
						return compiled(options, ...otherArgs);
					};
				}

				return $.noop;
			},

			/**
			 * Returns a function that Mustache can use to swap out language strings
			 * Allows {{#lang}}key{{/lang}} to be used in the templates
			 *
			 * @returns {function} 	A closure
			 */
			_lang = function () {
				return function (text, render) {
					return ips.getString(render(text));
				}
			};

			return {
				set,
				get,
				render,
				compile
			};
		}();

		/**
		 * Clean the contents of an element.
		 *
		 * @param elem
		 */
		function cleanContentsOf(elem) {
			elem = $(elem)
			if (!elem.length) {
				Debug.log(`Skipped the cleaning of IPS modules and controllers from an empty content selection`)
				return
			}
			Debug.log('Cleaning up IPS modules and controllers from content');

			// Clean the controllers from this element
			window.ips.controller.cleanContentsOf(elem, false)

			// Remove any widgets that exist in this elem
			window.ips.ui.destructAllWidgets( $( elem ) );

			elem.each(function() {
				const elem = $(this)
				for (const group of ['ui', 'utils']) {
					for (const module in window.ips[group]) {
						if (window.ips[group][module].onCleanup instanceof Function) {
							try {
								window.ips[group][module].onCleanup(elem);
							} catch (e) {
								e.message = `An error occurred when calling ips[${JSON.stringify(group)}][${JSON.stringify(module)}].onCleanup() an an element`
								e.cleanupTarget = elem
								Debug.error(e)
							}
						}
					}
				}
			})

			$(document).trigger('contentCleanup', [elem])
		}

		return {
			boot,
			createModule,
			getSetting,
			getAllSettings,
			setSetting,
			getGraphQlData,
			setGraphQlData,
			getAjax,
			fetch,
			getContainer,
			setString,
			haveString,
			getString,
			pluralize,
			getLocation,
			templates,
			testConsole,
			cleanContentsOf,
			/**
			 * Create a unique ID
			 * @return {string}
			 */
			uid() {
				return `${Math.round(Math.random() * Math.pow(16, 5)).toString(16)}-${Math.round(Math.random() * Math.pow(16, 5)).toString(16)}-${Math.round(Math.random() * Math.pow(16, 5)).toString(16)}-${Math.round(Math.random() * Math.pow(16, 5)).toString(16)}`
			},
			/**
			 * Log the time that a callback takes to execute to the console, while JS debug mode is enabled.
			 *
			 * @template {*} T
			 * @param {function():T}	cb
			 * @param {string|(function(number):string|*)|*} [message='Done timing code']
			 * @param {{threshold?:number}} [options={threshold:0}]
			 * @param {number}	[options.threshold=0]		A threshold for logging. If the execution time does not exceed the threshold, the log will not be logged.
			 *
			 * @return {T}
			 */
			logTime(cb, message="Done timing code", {threshold=0}={}) {
				const stack = (new Error()).stack;
				const lastLine = stack.split('\n').slice(0,3).pop().trim().replace(/^at\s*/, '');
				logTimeIndent++;
				const now = window.performance.now instanceof Function ? () => window.performance.now() : Date.now;
				const start = now();
				const doneExecuting = () => {
					const end = now();
					if (message instanceof Function) {
						try {
							message = message(end - start);
						} catch (e) {
							e.message = "\t".repeat(Math.max(0, logTimeIndent - 1)) + e.message;
							Debug.warn(e);
							message = "Done timing code, but a message generator failed";
						}
					}
					if ((end - start >= threshold) && Debug.isEnabled()) {
						if (typeof message === "string") {
							console.log(`${"\t".repeat(Math.max(0, logTimeIndent - 1))}${end - start}ms: ${message}\n${"\t".repeat(Math.max(1, logTimeIndent))}${lastLine}`);
						} else {
							console.log(`${"\t".repeat(Math.max(0, logTimeIndent - 1))}${end - start}ms: `, message, `\n${"\t".repeat(Math.max(1, logTimeIndent))}${lastLine}`);
						}
					}
					logTimeIndent--;
				}
				const res = cb();
				if (res instanceof Promise) {
					return res.then((result) => {
						doneExecuting();
						return result;
					})
				}

				doneExecuting();
				return res;
			}
		};

	}());
	
	ips.boot( ipsSettings );
}(jQuery, _));

// Polyfill for event.submitter not existing in safari
// Taken from https://gist.github.com/nuxodin/3ae174f2a6a112df3ccad22459237a91
!function(){
	var lastBtn = null
	document.addEventListener('click',function(e){
		if (!e.target.closest) return;
		lastBtn = e.target.closest('button, input[type=submit]');
	}, true);
	document.addEventListener('submit',function(e){
		if ('submitter' in e) return;
		var canditates = [document.activeElement, lastBtn];
		lastBtn = null;
		for (var i=0; i < canditates.length; i++) {
			var candidate = canditates[i];
			if (!candidate) continue;
			if (!candidate.form) continue;
			if (!candidate.matches('button, input[type=button], input[type=image]')) continue;
			e.submitter = candidate;
			return;
		}
		e.submitter = e.target.querySelector('button, input[type=button], input[type=image]');
	}, true);
}();

// Safari popover polyfill:
// #1. Retrieve the trigger since document.activeElement always returns body when clicking a button. Last tested in 26.0
// #2. Fix a bug where the browser freezes when an input in a popover gains/loses focus. Fixed in 18.4
// #3. Fix a bug where popovers aren't light-dismissed on iOS and iPadOS. Fixed in 18.3
// #4. Fix a bug where popovertarget buttons fail inside forms. Fixed in 18.2

// Only apply to Safari
if(CSS.supports("-webkit-hyphens: none")){
    // Toggle popover using API (1, 2)
    document.addEventListener("click", safariTogglePopoverFix);
    function safariTogglePopoverFix(e){
        // Get trigger (1, 2)
        const trigger = e.target.closest("[popovertarget]");
        if(!trigger) return;
        // Get popover (1, 2)
        const popoverEl = document.querySelector(`#${trigger.getAttribute("popovertarget")}`);
        if(!popoverEl) return;
        // Move focus to trigger so we can reference it in components (i-dropdown, etc) (1)
		trigger.focus({ focusVisible: false });

		if(
			// Target 18.3 and below (2)
			(!CSS.supports("selector(::details-content)") && popoverEl.querySelector('input:not([type="radio"], [type="checkbox"]), select'))
			||
			// Target 18.1 and below (4)
			(!CSS.supports("text-box-edge: auto") && trigger.closest("form"))
		){
			e.preventDefault();
			popoverEl[`${trigger.popoverTargetAction || "toggle"}Popover`]({source:trigger});
		}
	}
	// Fixes light-dismiss (3). There's no conditional for <18.3, so we just target 18.3 and below.
	if(!CSS.supports("selector(::details-content)")){
    	document.addEventListener("pointerdown", e => {});
	}
}]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="" javascript_name="Debug.js" javascript_type="framework" javascript_version="5001403" javascript_position="200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * Debug.js - A simple logging module. Allows adapters to be passed in to enable
 * alternatives to simple window.console logging.
 *
 * Author: Rikki Tissier
 */

var Debug = Debug || {};

;( function($, _, undefined){
	"use strict";

	Debug = function () {

		var options = {
			enabled: false,
			level: 1,
			adapters: [ ]
		};

		var LEVEL = {
			DEBUG: 1,
			INFO: 2,
			WARN: 3,
			ERROR: 4
		};

		/**
		 * Logs a Debug message
		 *
		 * @param 	{string}	msg 	Message to log
		 * @returns {object} 	Returns Debug
		 */
		var debug = function (msg) {
			logMessage( LEVEL.DEBUG, msg);
			return Debug;
		},

		/**
		 * Logs an Info message
		 *
		 * @param 	{string}	msg 	Message to log
		 * @returns {object} 	Returns Debug
		 */
		info = function (msg) {
			logMessage( LEVEL.INFO, msg );
			return Debug;
		},

		/**
		 * Logs a Warn message
		 *
		 * @param 	{*}	msg 	Message to log
		 * @returns {object} 	Returns Debug
		 */
		warn = function (msg) {
			logMessage( LEVEL.WARN, msg );
			return Debug;
		},

		/**
		 * Logs an Error message
		 *
		 * @param 	{string}	msg 	Message to log
		 * @returns {object} 	Returns Debug
		 */
		error = function (msg) {
			logMessage( LEVEL.ERROR, msg );
			return Debug;
		},

		/**
		 * Checks our debugging level is met, and passes the message off to the
		 * adapter being used
		 *
		 * @param 	{string}	msg 	Message to log
		 * @returns {object} 	Returns Debug
		 */
		logMessage = function (level, message) {

			if( options.enabled && level >= options.level && options.adapters.length ){
				for( let i = 0; i < options.adapters.length; i++ ){
					options.adapters[ i ].write( level, message );
				}
			}

			return Debug;
		},

		/**
		 * Sets the enabled/disabled status of logging
		 *
		 * @param	{boolean}	enabled 	Whether logging should be enabled
		 * @returns {object} 	Returns Debug
		 */
		setEnabled = function (enabled) {
			options.enabled = ( enabled === false ) ? false : true;
			return Debug;
		},

		/**
		 * See whether debugging is enabled
		 *
		 * @returns 	{boolean}
		 */
		isEnabled = function () {
			return options.enabled;
		},

		/**
		 * Sets the debugging severity threshold
		 *
		 * @param 	{number} 	level 	Level to set as minimum threshold
		 * @returns {object} 	Returns Debug
		 */
		setLevel = function (level) {
			if( LEVEL[ level ] ){
				options.level = LEVEL[ level ];
			}

			return Debug;
		},

		/**
		 * Adds an adapter to use for logging
		 *
		 * @param 	{number} 	level 	Level to set as minimum threshold
		 * @returns {object} 	Returns Debug
		 */
		addAdapter = function (adapter) {

			if( _.isObject( adapter ) ){
				options.adapters.push( adapter );
			}

			return Debug;
		},

		/**
		 * Clears all adapters
		 *
		 * @returns 	{object} 	Returns Debug
		 */
		clearAdapters = function () {
			options.adapters = [];
			return Debug;
		};

		return {
			// logging methods
			debug: debug,
			log: debug, // Alias for matt
			info: info,
			warn: warn,
			error: error,

			// other methods
			setEnabled: setEnabled,
			setLevel: setLevel,
			addAdapter: addAdapter,
			clearAdapters: clearAdapters,
			isEnabled: isEnabled
		};
	}();

	/** Default Console adapter	 */
	var Console = function() {};

	Console.prototype.write = function ( level, msg ){
		
		if( window.console ){
			switch( level ){
				case 1:
					if( _.isObject( msg ) ){
						console.dir( msg );
					} else {
						console.log( msg );
					}
					break;
				case 2:
					console.info( msg );
					break;
				case 3:
					console.warn( msg );
					break;
				case 4:
					console.error( msg );
					break;
			}
		}
	};

	Debug.addAdapter( new Console );

	if ( ipsDebug || ( !_.isUndefined( window.localStorage ) && 'localStorage' in window && window['localStorage'] !== null && window.localStorage.getItem('DEBUG') ) ) {
		Debug.setEnabled( true ).setLevel( 'DEBUG' ).info("Enabled logging");
	}
	
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="" javascript_name="ipsMethods.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000300"><![CDATA["use strict";

function eventSuppressor(e) {
    e.preventDefault();
    e.stopPropagation();
}

let uuid = 0;
const METHODS = {
    /**
     * Show the element
     */
    ipsHide() {
        this.setAttribute('hidden', 'true')
    },
    /**
     * Hide the element (analogous to display:none)
     */
    ipsShow() {
        this.removeAttribute('hidden')
        this.classList.remove('ipsHide');
        if (this.style.display === 'none') {
            this.style.display = ''
        }
    },

    /**
     * Remove the disabled filter and the disabled tooltip if there is one
     */
    ipsEnable() {
        this.style.filter = '';
        this.style.cursor = '';
        if (this.dataset.disabledOriginalStyles) {
            for (const [k, v] of Object.entries(JSON.parse(this.dataset.disabledOriginalStyles))) {
                if (v) {
                    this.style[k] = v;
                } else {
                    delete this.style[k];
                }
            }
        }
        delete this.dataset.disabledOriginalStyles;
        this.removeEventListener('click', eventSuppressor);
        this.removeEventListener('mousedown', eventSuppressor);
        this.removeEventListener('mouseup', eventSuppressor);
        this.removeEventListener('focus', eventSuppressor);


        if ('ipstooltip' in this.dataset && this.dataset.disableTitle && this.dataset.disableTitle === (this.getAttribute('title')||this.getAttribute('_title'))) {
            const originalTitle = this.dataset.originalTitle;
            delete this.dataset.disableTitle;
            if (!originalTitle) {
                this.removeAttribute('title');
                this.removeAttribute('_title');
                delete this.dataset.ipstooltip;
            } else {
                this.setAttribute('title', originalTitle);
                this.setAttribute('_title', originalTitle);
            }
        }
    },
    /**
     * Disable the button
     *
     * @param {Object}      [options]       The options for the disable region
     * @param {string|null}  [options.message]  A message to display in a tooltip explaining why this element was disabled
     * @param   {number}     [options.opacity]          The opacity of the disable effect, should be a number between 0 and 1
     */
    ipsDisable(options = {}) {
        let {message, opacity} = options;
        if (!this.dataset.disabledOriginalStyles) {
            const originals = {
                filter: this.style.filter,
                cursor: this.style.cursor
            };
            this.dataset.disabledOriginalStyles = JSON.stringify(originals);
        }
        opacity = Number(opacity);
        opacity = (opacity > 0 && opacity < 1) ? opacity : 0.6;
        this.style.filter = `grayscale(1) opacity(${opacity * 100}%)`;
        this.style.cursor = (message ? 'default' : 'not-allowed');
        this.addEventListener('click', eventSuppressor);
        this.addEventListener('mousedown', eventSuppressor);
        this.addEventListener('mouseup', eventSuppressor);
        this.addEventListener('focus', eventSuppressor);
        if (typeof message === 'string') {
            const originalMessage = ('ipstooltip' in this.dataset) ? (this.getAttribute('title') || this.getAttribute('_title')) : false;
            if (originalMessage) {
                this.dataset.originalTitle = originalMessage;
            }
            this.removeAttribute('_title');
            delete this.dataset.ipstooltip;
            this.setAttribute('title', message);
            this.dataset.disableTitle = message;
            this.setAttribute('data-ipstooltip', '')
        }
    }
};

for (const [name, func] of Object.entries(METHODS)) {
    Element.prototype[name] = function(...args) {
        func.bind(this)(...args);
        return this;
    }

    NodeList.prototype[name] = function(...args) {
        this.forEach(e => {
            if (e instanceof Element) {
                e[name](...args)
            }
        })
        return this;
    }
}

/**
 *
 * Wrapper for ips.getString() as a template tag (e.g. ilang`close` <=> 'Close')
 *
 * @param {string}      str         The lang key. This differs from ips.getString in that, if the lang key is undefined, it will return the raw lang key instead of an empty string
 * @param {*[]}         values      The rest of the values (e.g. every value<i> from `${value1}${value2}${value3}...${value<n>}`)
 *
 * @return {string}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates
 */
const ilang = (str, ...values) => {
    const raw = String.raw({raw:str}, ...values)
    return ips.getString(raw) || raw
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common" javascript_name="ips.controller.js" javascript_type="framework" javascript_version="5001403" javascript_position="250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.controller.js - Base controller handling
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.controller', function(){

		let _controllers = {},
			_autoMixins = {},
			_manualMixins = {},
			_mixins = {},
			_beingLoaded = [],
			_queue = {},
			_prototypes = {},
			instanceID = 1,
			_controllerCaseMap = {
				'core.front.core.autosizeiframe': 'core.front.core.autoSizeIframe'
			};

		/**
		 * Registers a controller
		 *
		 * @param	{string} 	id 			ID of this controller; used to auto-init on dom nodes
		 * @param	{object} 	definition 	Object containing the methods for the controller
		 * @returns {void}
		 */
		function register(id, definition) {
			_controllers[ id ] = definition;
			_checkQueue( id );
		}

		/**
		 * Returns boolean denoting whether a controller has been registered
		 *
		 * @param	{string} 	id 		ID of controller to check
		 * @returns 	{boolean}
		 */
		function isRegistered(id) {
			return _controllers[id] !== undefined;
		}

		/**
		 * Initializes controllers by looking at the dom tree for data-controller attributess
		 *
		 * @param	{element} 	node 		Root node to search in (defaults to document)
		 * @returns {void}
		 */
		function init() {
			// And also listen for the contentChange event
			$( document ).on('contentChange', function(e, newNode){
				initializeControllers( newNode );
			});

			// Do our initial search
			initializeControllers();
		}

		/**
		 * Registers a controller mixin
		 *
		 * @param 		{string} 	Controller ID this mixin works with
		 * @param 		{boolean} 	Automatically apply mixin to all instances of controller?
		 * @param 		{function} 	Function definition to apply
		 * @returns 	{void}
		 */
		function mixin(mixinName, controller, auto, mixinFunc) {
			if( _.isFunction( auto ) ){
				mixinFunc = auto;
				auto = false;
			}

			var obj = ( auto ) ? _autoMixins : _manualMixins;
			
			if( _.isUndefined( obj[ controller ] ) ){
				obj[ controller ] = {};
			}

			obj[ controller ][ mixinName ] = mixinFunc;
		}

		/**
		 * Given a node, will find all controllers on the node, initialize the ones that are
		 * available, and instruct the others to be loaded remotely
		 *
		 * @param 		{jQuery}  [node] to initialize on
		 * @returns 	{void}
		 */
		function initializeControllers(node) {
			var controllers = _findControllers( node );
			var needsLoading = {};

			for( var controller in controllers ){

				// If the controller is already registered, we'll init it immediately
				if( isRegistered( controller ) ){
					for( var i = 0; i < controllers[ controller ].length; i++ ){
						
						var elem = controllers[ controller ][i]['elem'];
						var mixins = controllers[ controller ][i]['mixins'];

						initControllerOnElem( elem, controller, mixins );
					}
				// If not, we'll load it then init
				} else {
					needsLoading[ controller ] = controllers[ controller ];
				}
			}
			
			if( _.size( needsLoading ) ){
				_loadControllers( needsLoading )
			}
		}

		/**
		 * Checks queued controllers to see if the given controller ID is needed
		 *
		 * @param 		{string} 	id 		Controller ID being checked
		 * @returns 	{void}
		 */
		function _checkQueue(id) {

			if( _queue[ id ] && _queue[ id ].length ){
				for( var i = 0; i < _queue[ id ].length; i++ ){
					initControllerOnElem( _queue[ id ][ i ]['elem'], id, _queue[ id ][ i ]['mixins'] );
				} 

				delete _queue[ id ];
			}

			if( _.indexOf( _beingLoaded, id ) ){
				delete _beingLoaded[ _.indexOf( _beingLoaded, id ) ];
			}
		}

		/**
		 * Loads the specified controllers, providing they aren't already being loaded
		 *
		 * @param 		{object} 	needsLoading 	Object of key/value pairs of controllers to load 
		 * @returns 	{void}
		 */
		function _loadControllers(needsLoading) {
			// Build include paths
			var filePaths = [];
			var deferred = $.Deferred();

			// CHeck whether our controllers are already being loaded
			for( var controller in needsLoading ){
				if( _.indexOf( _beingLoaded, controller ) !== -1 ){
					delete needsLoading[ controller ];
					continue;
				}

				_beingLoaded.push( controller );
				filePaths.push( _buildFilePath( controller ) );
			}

			if( !_.size( needsLoading ) ){
				// All are being loaded, so we're done here
				deferred.resolve();
				return deferred.promise();
			}

			// Add to the queue
			_.extend( _queue, needsLoading );

			ips.loader.get( filePaths ).then( function () {
				deferred.resolve();
			});

			return deferred.promise();
		}

		/**
		 * Builds a controller file path from the provided controller ID
		 *
		 * @param 		{string} 	controllerName 	 Controller ID
		 * @returns 	{string}	File path
		 */
		function _buildFilePath(controllerName) {
			const bits = controllerName.split('.');

			// Get the URL for this controller
			// The URL will vary depending on whether we're in_dev or not.
			if( ips.getSetting('useCompiledFiles') === false ){
				// If we're in_dev, we can build the URL simply by appending the pieces of the controller ID
				return bits[0] + '/' + bits[1] + '/controllers/' + bits[2] +
						'/ips.' + bits[2] + '.' + bits[3] + '.js';
			} else {
				// If we're not indev, we need to locate the bundle the controller exists in
				try {
					let url;
					// Load from static folders if ipsApps
					if( _.indexOf( ips.getSetting('ipsApps'), bits[0] ) !== -1 ) {
						url = ips.getSetting('baseURL') + 'static/js/' + bits[0] + '/' + bits[1] + '_' + bits[1] + '_' + bits[2] + '.js';
					} else {
						// Third party stuff
						url = ipsJsFileMap[bits[0]][bits[1] + '_' + bits[2]];
					}

					if (url.indexOf('?') != -1) {
						return url + '&v=' + ips.getSetting('jsAntiCache');
					} else {
						return url + '?v=' + ips.getSetting('jsAntiCache');
					}
				} catch (err) {
					Debug.log(err);
					return '';
				}
			}
		}

		/**
		 * Searches the provided node for any controllers specified on elements
		 *
		 * @param 		{element} 	node 	Optional node to search on. Defaults to document.
		 * @returns 	{object}	Found controllers, with the key being controller ID, value being array of elements
		 */
		function _findControllers(node) {
			// 02/03/16 - Allow either dom nodes or jquery objects here.
			// Previously only dom elements were allowed, which meant in most cases
			// we reverted to checking the whole document again, causing some odd behavior.
			if( !_.isElement( node ) && !( node instanceof jQuery ) ){
				node = document;
			}

			var controllersToLoad = {};
				
			$( node ).find('[data-controller]').addBack().each( function (idx, elem){

				if( !$( elem ).data('_controllers') ){
					$( elem ).data('_controllers', []);
				}

				var controllerString = $( elem ).data('controller'),
					controllerList = $( elem ).data('_controllers');

				if( controllerString )
				{
					_getControllersAndMixins( controllerString );

					var controllers = _getControllersAndMixins( controllerString );

					// Loop through each controller on this element
					if( _.size( controllers ) ){
						_.each( controllers, function (val, key) {

							if( controllerList.length && _.indexOf( controllerList, key ) !== -1 ){
								// Already initialized on this element
								return;
							}

							if( controllersToLoad[ key ] ){
								controllersToLoad[ key ].push( { elem: elem, mixins: val } );
							} else {
								controllersToLoad[ key ] = [ { elem: elem, mixins: val } ];
							}
						});
					}
				}
			});
			
			return controllersToLoad;
		}

		/**
		 * Returns controllers and mixins found in the string
		 * Given <pre>controllerOne( mixin1; mixin2 ), controllerTwo, controllerThree</pre>, returns:
		 * <pre>
		 * {
		 * 	controllerOne: [ mixin1, mixin2 ],
		 *	controllerTwo: [],
		 * 	controllerThree: []
		 * }
		 * </pre>
		 *
		 * @returns 	{string}
		 */
		function _getControllersAndMixins(controllerString) {
			var controllers = {};
			var pieces = controllerString.split(',');

			for( var i = 0; i < pieces.length; i++ ){
				
				pieces[i] = pieces[i].trim();

				// Fix case issues on user-submitted content
				if( !_.isUndefined( _controllerCaseMap[ pieces[i] ] ) ){
					pieces[i] = _controllerCaseMap[ pieces[i] ];
				}

				if( pieces[i].indexOf('(') === -1 ){
					controllers[ pieces[i] ] = [];
					continue;
				}

				var p = pieces[i].match( /([a-zA-Z0-9.]+)\((.+?)\)/i );
				var mixinPieces = [];

				_.each( p[2].split(';'), function (val) {
					mixinPieces.push( val.trim() );
				});

				controllers[ p[1] ] = mixinPieces;
			}

			return controllers;
		}

		/**
		 * Returns an incremental controller ID
		 * Controller IDs are used to enable controllers to identify events that they
		 * emitted themselves.
		 *
		 * @returns 	{string}
		 */
		function getInstanceID() {
			return 'ipscontroller' + (++instanceID);
		}

		/**
		 * Allows an element to be cleaned externally. If the element passed is not a controller scope,
		 * it'll search down one level of the DOM to find controllers.
		 *
		 * @param 	{element} 	elem 					The element to clean
		 * @param	{boolean}	[destroyWidgets]        Destroy the widgets along with the controllers?
		 *
		 * @returns {void}
		 */
		function cleanContentsOf(elem, destroyWidgets=true) {
			if (destroyWidgets) {
				ips.cleanContentsOf(elem)
				return;
			}

			Debug.log('Cleaning controllers from content');
			
			$( elem ).find('[data-controller]')
				.each( function () {
					var loopController = $( this );
					var controllers = loopController.data( '_controllerObjs' ) || [];

					if( controllers.length ){
						loopController.data('_controllerObjs', []);
						
						for( var i = 0; i < controllers.length; i++ ){
							controllers[i]._destroy.apply( controllers[i] );
							delete controllers[i];
						}
					}
				});
		}

		/**
		 * Initializes a controller instance by creating a new function, extending it with
		 * the controller methods then initializing it on the relevant dom node
		 *
		 * @param	{element} 	elem 			The element that will form the scope of this controller
		 * @param	{string} 	controllerID 	ID of this controller
		 * @returns {void}
		 */
		function initControllerOnElem(elem, controllerID, mixins) {

			if( !_controllers[ controllerID ] ){
				Debug.error("Controller '" + controllerID + "' has not been registered");
				return;
			}

			if( _.isUndefined( $( elem ).data('_controllers') )){
				$( elem ).data('_controllers', []);
			}

			$( elem ).data('_controllers').push( controllerID );

			if( _.isUndefined( _prototypes[ controllerID ] ) ){
				// Fetch our controller prototype
				_prototypes[ controllerID ] = getBaseController();
				// Extend with our specific controller methods
				$.extend( true, _prototypes[ controllerID ].prototype, _controllers[ controllerID ] );	
			}
			
			// And init
			if( _.isUndefined( $( elem ).data( '_controllerObjs' ) ) ){
				$( elem ).data( '_controllerObjs', [] );
			}

			var controllers = $( elem ).data( '_controllerObjs' );
			var obj = new _prototypes[ controllerID ](elem, controllerID);
			controllers.push( obj );

			// Any mixins?
			// Auto mixins first
			if( !_.isUndefined( _autoMixins[ controllerID ] ) && _.size( _autoMixins[ controllerID ] ) ){	
				_.each( _autoMixins[ controllerID ], function (val, key) {
					_autoMixins[ controllerID ][ key ].call( obj );
				});
			}

			// Then the manually-specified ones
			if( mixins.length ){
				for( var i = 0; i < mixins.length; i++ ){
					if( !_.isUndefined( _manualMixins[ controllerID ] ) && !_.isUndefined( _manualMixins[ controllerID ][ mixins[i] ] ) ){
						_manualMixins[ controllerID ][ mixins[i] ].call( obj );
					}
				}
			}

			if( _.isFunction( obj.initialize ) ){
				// Don't stop all other controllers from initializing because of one bad controller
				try {
					obj.initialize.call(obj);
				} catch (e) {
					Debug.error(`Failed to setup the controller '${controllerID}' on an element`);
					Debug.error(e);
					$(elem).data('_controllerObj', controllers.filter(inst => inst !== obj));
					return;
				}
			}

			$( elem ).removeData( '_controller' + controllerID );
			
			$( document ).trigger( 'controllerReady', {
				controllerID: obj.controllerID,
				controllerType: obj.controllerType,
				controllerElem: elem
			});
		}

		/**
		 * Finds controllers within a node that have an ID matching the provided name
		 * Wildcard character * supported at the front or end of the controller parameter
		 *
		 * @param 		{string} 		controller 		Controller name to find
		 * @param 		{element} 		node 			Optional node to search in (document by default)
		 * @returns 	{function}
		 */
		function _findSubControllers(controller, node) {
			var results = [];

			node = ( node && ( _.isElement( node ) || node.jquery ) ) ? node : document;

			if( controller.indexOf('*') === -1 ){
				results = $( node ).find('[data-controller*="' + controller + '"]');
			} else {
				var pieces = controller.split('.');

				if( pieces[0] === '*' ){
					pieces.shift();
					results = $( node ).find('[data-controller$="' + pieces.join('.') + '"]');
				} else if( pieces[ pieces.length - 1 ] === '*' ){
					pieces.pop();
					results = $( node ).find('[data-controller^="' + pieces.join('.') + '"]');
				}
			}

			return results;
		}

		class BaseController {
			/**
			 * @type {jQuery}
			 */
			scope;

			/**
			 * @type {Element}
			 */
			elem;

			constructor(scope, type) {
				this.controllerType = type;
				this.controllerID = getInstanceID();
				this.scope = $( scope );

				// In 2023 and later, we use a native HTMLElement rather than a jQuery selector
				this.elem = this.scope.get(0);
				this._eventListeners = [];

				// Advice methods - inspired by http://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/
				// and Twitter Flight
				const adviceFuncs = {
					before: function (baseFn, newFn) {
						return function () {
							newFn.apply(this, arguments);
							return baseFn.apply(this, arguments);
						};
					},
					after: function (baseFn, newFn) {
						return function () {
							const toReturn = baseFn.apply(this, arguments);
							newFn.apply(this, arguments);
							return toReturn;
						}
					},
					around: function (baseFn, newFn) {
						return function (...args) {
							args.unshift(baseFn.bind(this));
							return newFn.apply(this, args);
						}
					}
				};

				for (const [type, generator] of Object.entries(adviceFuncs)) {
					this[type] = (base, fn) => {
						if (!(this[base] instanceof Function)) {
							Debug.log( "Method '" + base + '" is not present in controller ' + this.controllerID );
						}

						this[base] = generator(this[base], fn)
					}
				}
			}

			/**
			 * Destroy this instance
			 * @private
			 */
			_destroy() {

				Debug.log( 'Destroyed instance ' + this.controllerID + ' of ' + this.controllerType );

				// Remove each event listener that was created in this controller
				if( this._eventListeners.length ){
					for( var i = 0; i < this._eventListeners.length; i++ ){
						var data = this._eventListeners[i];

						if( data['delegate'] ){
							data['elem'].off( data['ev'], data['delegate'], data['fn'] );
						} else {
							data['elem'].off( data['ev'], data['fn'] );
						}
					}
				}

				if( _.isFunction( this.destroy ) ){
					this.destroy.call( this );
				}

				// Remove reference to scope so that GC can do its thing
				this.scope = null;
			}

			/**
			 * Clean the contents of this controller
			 */
			cleanContents() {
				Debug.log('Cleaning contents of controller');

				this.scope.find('[data-controller]')
					.each( function () {
						var loopController = $( this );
						var controllers = loopController.data( '_controllerObjs' ) || [];

						if( controllers.length ){
							loopController.data('_controllerObjs', []);

							for( var i = 0; i < controllers.length; i++ ){
								controllers[i]._destroy.apply( controllers[i] );
								delete controllers[i];
							}
						}
					});

				// Remove any widgets that exist in this elem
				ips.ui.destructAllWidgets( this.scope );
			}

			/**
			 * trigger an event
			 *
			 * @param {mixed} 		elem
			 * @param {string}		ev
			 * @param {object}		[data]
			 */
			trigger(...args) {

				let elem = ( !_.isElement( args[0] ) && !args[0].jquery ) ? this.scope : $( args.shift() );
				let ev = args.shift();
				let data = args.shift() || {};

				// Add our origin to the event
				if( !data.stack ){
					data.stack = [];
				}

				data.stack.push( 'controllers.' + this.controllerType + '.' + this.controllerID );

				elem.trigger( ev, data );

			}

			/**
			 * Register an 'on' event
			 *
			 * @param elem
			 * @param ev
			 * @param delegate
			 * @param fn
			 */
			on(elem, ev, delegate, fn) {

				// Convert silly arguments object to an array
				var args = ips.utils.argsToArray( arguments );

				// Reconfigure our args as necessary
				elem = ( !_.isElement( elem ) && elem != document && elem != window ) ? this.scope : $( args.shift() );
				ev = args[0];
				fn = ( args.length == 3 ) ? args[2] : args[1];
				delegate = ( args.length == 3 ) ? args[1] : undefined;

				if( !_.isFunction( fn ) ){
					Debug.warn("Callback function for " + ev + " doesn't exist in " + this.controllerType
						+ " (" + this.controllerID + ")");
					return;
				}

				// Bind our callback to the controller
				fn = _.bind( fn, this );

				// Set up the event
				if( delegate ){
					elem.on( ev, delegate, fn );
					this._eventListeners.push({
						elem: elem,
						event: ev,
						delegate: delegate,
						fn: fn
					});
				} else {
					elem.on( ev, fn );
					this._eventListeners.push({
						elem: elem,
						event: ev,
						fn: fn
					});
				}
			}

			/**
			 * Trigger an 'on' event that is registered by a controller nested inside this one. For example, say controller ips.foo.bar is inside this one and registered `this.on('baz', this.doStuff)`. To trigger this method directly, you'd call this.triggerOn('ips.foo.bar', 'baz', {...allTheData});
			 * @param 	{string} 	controller	The controller that we're targeting
			 * @param 	{string}	ev			The 'on' event.
			 * @param	{Object}	[data]
			 *
			 * @memberOf baseController
			 */
			triggerOn (controller, ev, data) {
				const toTrigger = _findSubControllers(controller, this.scope);

				if( !toTrigger.length ){
					return;
				}

				data = data || {};

				// Add our origin to the event
				if( !data.stack ){
					data.stack = [];
				}

				data.stack.push( 'controllers.' + this.controllerType + '.' + this.controllerID );

				toTrigger.trigger( ev, data );
			}
		}

		/**
		 * Returns a mock subclass of the basecontroller. An instance of this subclass will serve as the base for each controller
		 *
		 * @returns 	{function}
		 */
		function getBaseController() {
			class BaseControllerClone extends BaseController {}
			return BaseControllerClone
		}

		return {
			initControllerOnElem,
			register,
			mixin,
			isRegistered,
			init,
			cleanContentsOf
		};
	});

}( jQuery, _ ));
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common" javascript_name="ips.loader.js" javascript_type="framework" javascript_version="5001403" javascript_position="250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.loader.js - Loader module
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.loader', function(){

		var _loadedScripts = [],
			_loadingScripts = [];

		const LOADER_STATES = {};

		/**
		 * Figures out the scripts that have already been inserted into the page
		 *
		 * @returns {void}
		 */
		var init = function () {
			var scripts = $('script[src][data-ips]');

			scripts.each( function () {
				var scriptInfo = ips.utils.url.getURIObject( $( this ).attr('src') );

				if ( scriptInfo.queryKey.src ){
					var paths = _getPathScripts( scriptInfo.queryKey.src );

					_.each( paths, function (value){
						_loadedScripts.push( value );
					});
				} else if( scriptInfo.path.indexOf('interface/') !== -1 ) {
					var interfaces = _getInterfaceScript( scriptInfo.path );

					if( interfaces ){
						_loadedScripts.push( interfaces );
					}	
				} else {
					var other = _getOtherScript( scriptInfo.source );

					if( other ){
						_loadedScripts.push( other );
					}
				}
			});
		},

		/**
		 * Parses a script URL. If the script is local, returns the path from /applications/, otherwise, the whole url.
		 *
		 * @returns {string} 
		 */
		_getOtherScript = function (path) {
			path = path.replace( ips.getSetting('baseURL'), '' );

			if( path.startsWith('/') ){
				path = path.substring(1);
			}

			if( path.startsWith('applications/') ){
				path = path.replace(/^applications\//i, '')
			}

			return path;
		},

		/**
		 * Parses a script URL for the relative path to an interface script
		 *
		 * @returns {mixed} 	Path as a string if an interface file, or false if not
		 */
		_getInterfaceScript = function (path) {
			// Split the path
			var pieces = _.compact( path.split('/').reverse() );
			var path = [];

			for( var i = 0; i < pieces.length; i++ ){
				if( pieces[i] == 'interface' ){
					path.push('interface');
					path.push( pieces[ i+1 ] );
					break;
				}

				path.push( pieces[i] );
			}

			if( _.indexOf( path, 'interface' ) !== -1 ){
				return path.reverse().join('/');
			}

			return false;
		},

		/**
		 * Splits a comma-separated list of paths into individual paths
		 *
		 * @returns {array}
		 */
		_getPathScripts = function (src) {
			return _.compact( src.split(',') );
		},

		/**
		 * Loads a script file. Calls the internal _doLoad method, wrapped in jQuery's when method for deferred
		 *
		 * @param 	{array} 	filePaths 	Array of relative file paths to load
		 * @returns {Promise}
		 */
		get = function (toLoad) {
			return $.when( _doLoad( _.compact( _.uniq( toLoad ) ) ) );
		},

		/**
		 * Loads a script file remotely
		 *
		 * @param 	{array} 	filePaths 	Array of relative file paths to load
		 * @returns {$.Deferred}
		 */
		_doLoad = function (filePaths) {
			const deferred = $.Deferred();

			if( !_.isArray( filePaths ) ){
				filePaths = [ filePaths ];
			}

			var done = [];
			var loading = [];
			var toLoad = [];

			// Step 1: Sort each file into done, loading or toLoad
			for( var i = 0; i < filePaths.length; i++ ){
				if( _.indexOf( _loadedScripts, filePaths[ i ] ) !== -1 ){
					done.push( filePaths[ i ] );
					continue;
				}

				if( _.indexOf( _loadingScripts, filePaths[ i ] ) !== -1 ){
					loading.push( filePaths[ i ] );
					continue;
				}

				toLoad.push( filePaths[ i ] );
			}

			// Step 2: If we've already loaded everything, short circuit and resolve the deferred
			if( done.length === filePaths.length ){
				deferred.resolve();
				return deferred.promise();
			}

			// Step 3: If we've got any files to watch (either loading, or toLoad), set an event handler
			if( loading.length || toLoad.length ){
				$( document ).on( 'scriptLoaded', function (e, files) {

					for( var i = 0; i < files.length; i++ ){
						if( _.indexOf( filePaths, files[ i ] ) === -1 ){
							continue;
						}

						done.push( files[ i ] );
					}

					if( done.length === filePaths.length ){
						setTimeout( function () {
							deferred.resolve();	
						}, 100);						
					}
				});
			}

			// Step 4: Load the files that haven't been loaded yet
			// Split them into local and global files and do separate requests for each
			if( toLoad.length ){
				var localFiles = [];
				var remoteFiles = []

				for( var i = 0; i < toLoad.length; i++ ){
					if( toLoad[ i ].match( /^(http|\/\/)/i ) ){
						remoteFiles.push( toLoad[ i ] );
					} else {
						localFiles.push( toLoad[ i ] );
					}
				}

				if( localFiles.length ){
					_insertScript( localFiles );	
				}

				if( remoteFiles.length ){
					for( var i = 0; i < remoteFiles.length; i++ ){
						_insertScript( [ remoteFiles[ i ] ] );
					}
				}				
			}

			return deferred.promise();
		},

		/**
		 * Loads a script file via ajax
		 *
		 * @param 	{array} 	filePaths 	Array of file paths to load
		 * @param 	{boolean} 	[cached]	Whether to allow the browser to use a cached file (default: true)
		 * @returns {void}
		 */
		_insertScript = function (toLoad, cached) {

			// Add URLs to the loading array
			for( var i = 0; i < toLoad.length; i++ ){
				_loadingScripts.push( toLoad[ i ] );
			}

			Debug.log( "Loading: " + toLoad.join(', ') );

			// Figure out the URL
			var url = '';

			if( toLoad[0].match( /^(http|\/\/)/i ) ){
				url = toLoad[0].match( /^http/ ) ? toLoad[0].replace( /^.+?\/\/(.*)$/, '//$1' ) : toLoad[0];
			} else {
				url = ips.getSetting('jsURL') + '?src=' + encodeURIComponent( toLoad.join(',') );
			}

			// Now fetch the script(s) by calling our JS url.
			// On success, we add the script(s) to the _loadedScripts array, and trigger an event so that other methods are aware
			// And we always remove it from the _loadingScripts array when the ajax finishes.
			// In a settimeout so that this happens on the next tick.
			setTimeout( function () {
				$.ajax( {
					dataType: 'script',
					cache: ( _.isUndefined( cached ) ) ? true : cached,
					url: url,
					data: {
						antiCache: ips.getSetting('jsAntiCache'),
						csrfKey: null, // Ensure the CSRF key is empty when fetching JS
					}
				})
					.fail( function (jqXHR, textStatus, errorThrown) {
						Debug.error( "Failed to load: " + toLoad.join(', ') );
						Debug.log( textStatus );
					})
					.always( function () {
						for( var i = 0; i < toLoad.length; i++ ){
							var index = _.indexOf( _loadingScripts, toLoad[ i ] );

							if( index !== -1 ){
								_loadingScripts.splice( index, 1 );
							}
						}
					})
					.done( function () {
						
						// Remove from loading, add to loaded
						for( var i = 0; i < toLoad.length; i++ ){
							_loadedScripts.push( toLoad[ i ] );
						}

						// Trigger event to let observers know
						$( document ).trigger( 'scriptLoaded', [ toLoad ] );
						Debug.log( "Loaded: " + toLoad.join(', ') );
					})
			}, 500);
			
		};

		return {
			init: init,
			get: get,
			/**
			 * Same as get, but loads the paths "statically".
			 *
			 * @param {string|string[]}	paths
			 * @return {Promise<Awaited<void>[]>}
			 */
			getStatic(paths) {
				if (!Array.isArray(paths)) {
					paths = [paths];
				}

				const uniquePaths = new Set();
				for (let path of paths) {
					if (path.startsWith('http://') || path.startsWith("https://")) {
						uniquePaths.add(path);
					} else {
						path = window.location.protocol + ips.getSetting('baseURL').replace(/\/+$/, '') + "/" + path.replace(/^\/+/, '');
						uniquePaths.add(path);
					}
				}

				return Promise.all([...uniquePaths].map(path => new Promise((resolve, reject) => {
					LOADER_STATES[path] = LOADER_STATES[path] || {
						state: 'unloaded',
						resolvers: new Set(),
						rejectors: new Set(),
						err: undefined,
					}

					const {state, resolvers,rejectors,err} = LOADER_STATES[path];
					if (state === 'loaded') {
						return resolve();
					}

					if (state === 'error') {
						return reject(err);
					}

					resolvers.add(resolve);
					rejectors.add(reject);

					if (state === 'unloaded') {
						LOADER_STATES[path].state = 'loading';
						const script = document.createElement('script');
						const url = new URL(path);
						url.updateSearchParams({
							param: 'antiCache',
							value: ips.getSetting('jsAntiCache')
						});
						script.src = url;
						script.addEventListener('load', () => {
							Debug.log(`Loaded static script ${path}`);
							LOADER_STATES[path].state = 'loaded';
							resolvers.forEach(resolver => resolver());
							resolvers.clear();
							rejectors.clear();
						}, {once: true});

						script.addEventListener('error', () => {
							LOADER_STATES[path].state = 'error';
							LOADER_STATES[path].err = new Error(`Failed to load ${path}`);
							Debug.error(LOADER_STATES[path].err);
							rejectors.forEach(rejector => rejector(LOADER_STATES[path].err));
							rejectors.clear();
							resolvers.clear();
						}, {once: true});

						document.body.appendChild(script);
					}
				})));
			}
		}
	});
}( jQuery, _ )); ]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common" javascript_name="ips.model.js" javascript_type="framework" javascript_version="5001403" javascript_position="250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.model.js - Base model handling
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.model', function(){

		var _models = {};

		/**
		 * Registers a model. Models are initialized immediately.
		 *
		 * @param	{string} 	id 			ID of this model
		 * @param	{object} 	definition 	Object containing the methods for the model
		 * @returns {void}
		 */
		var register = function (id, definition) {
			//_models[ id ] = definition;

			var Base = getBaseModel();

			// Extend with our specific controller methods
			$.extend( Base.prototype, definition );

			// And init
			var obj = new Base(id);

			if( _.isFunction( obj.initialize ) ){
				obj.initialize.call( obj );
			}
		},

		/**
		 * Returns a new function that will form our model prototype
		 *
		 * @returns 	{function}
		 */
		getBaseModel = function () {

			/*
			 * Base model definition
			 */
			var baseModel = function (id) {
				this.modelID = id;
				//Debug.info("Initialized model " + this.modelID);
			};

			baseModel.method('trigger', function (elem, ev, data) {

				// Convert silly arguments object to an array
				var args = ips.utils.argsToArray( arguments );

				elem = ( !_.isElement( elem ) ) ? $(document) : $( args.shift() );
				ev = args[0];
				data = args[1] || {};

				// Add our origin to the event
				if( !data.stack ){
					data.stack = [];
				} 

				data.stack.push( 'models.' + this.modelID );

				elem.trigger( ev, data );
			});

			baseModel.method('on', function (elem, ev, delegate, fn) {

				// Convert silly arguments object to an array
				var args = ips.utils.argsToArray( arguments );

				// Reconfigure our args as necessary
				elem = ( !_.isElement( elem ) && elem != document ) ? $(document) : $( args.shift() );
				ev = args[0];
				fn = ( args.length == 3 ) ? args[2] : args[1];
				delegate = ( args.length == 3 ) ? args[1] : undefined;

				if( !_.isFunction( fn ) ){
					Debug.warn("Callback function for " + ev + " doesn't exist in " + this.modelID);
					return;
				}

				// Bind our callback to the model
				fn = _.bind( fn, this );

				// Set up the event
				if( delegate ){
					elem.on( ev, delegate, fn );
				} else {
					elem.on( ev, fn );
				}
			});

			baseModel.method('getData', function (data, eventData) {
				var self = this;
				var ajaxObj = ips.getAjax();

				// If this appears to be a local URL, prefix with the baseURL
				if( !data.url.startsWith('http') ){
					data.url = ips.getSetting('baseURL') + 'index.php?' + data.url;
				}

				// See if we're specifying events manually
				// If not, build some event names to use
				if( data.events && _.isString( data.events ) ){
					data.events = {
						loading: data.events + 'Loading',
						done: data.events + 'Done',
						fail: data.events + 'Error',
						always: data.events + 'Finished'
					};
				}

				// Check if namespace exists, add a period if neessary
				if( data.namespace && !data.namespace.startsWith('.') ){
					data.namespace = '.' + data.namespace;
				}

				// Do the loading
				if( data.events.loading ){
					this.trigger( data.events.loading + ( data.namespace || '' ), eventData || {} );
				}

				ajaxObj( data.url, {
					data: data.data || {},
					dataType: data.dataType || 'html',
					type: data.type || 'get'
				})
					.done( function (response) {
						if( data.events.done ){
							if( data.dataType == 'json' ){
								var doneData = _.extend( eventData || {}, response );
							} else {
								var doneData = _.extend( eventData || {}, { response: response } );
							}

							self.trigger( data.events.done + ( data.namespace || '' ), doneData );
						}
					})
					.fail( function (jqXHR) {
						if( data.events.fail ){
							try {
								if( data.dataType == 'json' ){
									var doneData = _.extend( eventData || {}, $.parseJSON( jqXHR.responseText ) );
								} else {
									var doneData = _.extend( eventData || {}, { response: jqXHR.responseText } );
								}
							} catch (err) {}

							self.trigger( data.events.fail + ( data.namespace || '' ), doneData )
						}
					})
					.always( function () {
						if( data.events.always ){
							self.trigger( data.events.always + ( data.namespace || '' ) );
						}
					});
			});

			return baseModel;
		};

		return {
			register: register
		};
	});

}( jQuery, _ ));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="card.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[/*
	This custom element allows i-card to be swipe-dismissed on touch devices
*/
class iCard extends HTMLElement {

    constructor () {
        super();
        this.supportsPopover = CSS.supports("selector(:popover-open)");
        this.supportsAnimationTimeline = CSS.supports("(animation-timeline: scroll())");
        // Events
        this.addEventListener("beforetoggle", this);
        this.addEventListener("toggle", this);
    }

    // Handle events
    handleEvent(e){
        return this[`${e.type}Event`] && this[`${e.type}Event`](e);
    }

    // Before opening the popover, create extra elements if necessary
    beforetoggleEvent(e){
        if(e.newState === "open"){
            // Append menu to element (or body) to prevent external styles from leaking in
            if(this.hasAttribute("data-i-card-append")){
                const appendMenuTo = this.getAttribute("data-i-card-append") || "body";
                document.querySelector(appendMenuTo).append(this);
            }
            // Create the swipe elements, used in the mobile UI
            if(!this.swipeElement){
                this.createSwipeElement();
            }
        }
    }

    // Toggle the popover
    toggleEvent(e){
        // If the popover is being opened..
        if(e.newState === "open"){
            // Scroll to bottom of popover (for the mobile UI) since the swipe element is at the top
            this.scrollTop = this.scrollHeight;
            // Add "swipe to dismiss"
            this.swipeObserver.observe(this.swipeElement);
            // Scroll event is required for scroll animation (backdrop scroll)
            if(!this.supportsAnimationTimeline){
                this.addEventListener("scroll", this);
                this.addEventListener("transitionend", this);       
            }
        } else {
            // Remove IntersectionObserver and event listeners
            this.swipeObserver.disconnect();
            if(!this.supportsAnimationTimeline){
                this.removeEventListener("scroll", this);
                this.removeEventListener("transitionend", this);
            }
        }
    }

    transitionendEvent(e){
        // Only run this event once (otherwise it runs for each element that's transitioning)
        // Add scroll animation polyfill for backdrop transition
        if(e.target === this && !this.supportsAnimationTimeline){
            this.style.setProperty('--_card-backdrop-height', this.scrollHeight - this.clientHeight);
        }
    }

    scrollEvent(e){
        requestAnimationFrame(() => {
            // Scroll driven animation polyfill
            this.style.setProperty('--_card-backdrop-scroll', this.scrollTop);
        });
    }

    createSwipeElement(){
        // Create light-dismiss and swipe elements
        let addBackdropElements = ``;
        if(!this.querySelector(".iCardSwipe")){
            addBackdropElements += `<div class='iCardSwipe'></div>`;
        }
        if(!this.querySelector(".iCardDismiss")){
            addBackdropElements += `<button class="iCardDismiss" type="button" popovertarget="${this.id}" popovertargetaction="hide" aria-label="Close" tabindex="-1"></button>`;
        }
        // Prepend them to the popover
        this.insertAdjacentHTML("afterbegin", addBackdropElements);
        // An intersectionObserver is assigned to the swipeElement
        this.swipeElement = this.querySelector(".iCardSwipe");
    }

    // IntersectionObserver to close popover on swipe (mobile UI)
    swipeObserver = new IntersectionObserver(entries => {
        if (entries.some(entry => entry.isIntersecting)) {
            this.hidePopover();
        }
    }, {
        root: this,
        threshold: .1
    })

}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="dropdown.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[/*
	This custom element:
	1. Allows the menu to be swipe-dismissed on touch devices
	2. Adds aria-expanded="true" to the triggering element
	3. Positions dropdown menus
*/
class iDropdown extends HTMLElement {

    connectedCallback () {
        // Check support for anchor
        this.supportsAnchor = CSS.supports("(top: anchor(bottom)) and (not (-webkit-hyphens: auto))");
        this.supportsPopover = CSS.supports("selector(:popover-open)");
        this.supportsAnimationTimeline = CSS.supports("(animation-timeline: scroll())");
        // Events
        this.addEventListener("beforetoggle", this);
        this.addEventListener("toggle", this);
        // Add events and UX benefits if the menu is opened before the JS loads
        if(this.matches(":popover-open")){
            this.beforetoggleEvent({ newState: "open", oldState: "closed" });
            this.toggleEvent({ newState: "open", oldState: "closed" });
        }
    }

    // Handle events
    handleEvent(e){
        return this[`${e.type}Event`] && this[`${e.type}Event`](e);
    }

    clickEvent(e){

        // Get the clicked item in the menu
        let itemClicked = e.target.closest(".iDropdown__items a, .iDropdown__items button");

        // Dispatch the click event
        this.handleClick(e, itemClicked);

    }

    // Fired when <label> elements are clicked. Emits the same behavior as the click event, but lets labels natively handle inputs
    changeEvent(e){
        // Get the clicked item in the menu
        let itemClicked = e.target.closest(".iDropdown__items label");

        // Dispatch the click event
        this.handleClick(e, itemClicked);
    }

    // This controls clicks on a, button and label elements. We handle it here since we need to dispatch it either on "click" or "input" depending on the element type
    handleClick(e, itemClicked){
        
        // Return early if the item clicked is not a valid element (a, button, label)
        if(!itemClicked) return;

        // Close the menu after clicking an item, unless data-i-dropdown-persist exists
        if(!itemClicked.closest("[data-i-dropdown-persist]")){
            setTimeout(() => {
                // We have to use .closest() instead of this, otherwise all parent dropdowns (Eg. Edit tags > add prefix) will close too
                itemClicked.closest("i-dropdown")?.hidePopover();
            }, 150);
        }

        // Return early if the item should not be selectable
        if(itemClicked.closest("[data-i-dropdown-noselect]")) return;

        // Pinging is only used in ModCP and announcements. @todo Is this necessary or potentially redundant?
        const pingItems = itemClicked.closest('[data-action="ipsMenu_ping"]');
        if( pingItems ){
            e.preventDefault();
            ips.getAjax()( pingItems.getAttribute('href') ).done( () => {
                this.trigger.dispatchEvent(new CustomEvent('menuPingSuccessful', {}));
            });
        }

        // Optionally update the trigger label
        const selectedTextTrigger = this.trigger.closest('[data-role="ipsMenu_selectedText"]'),
              selectedTextMenu = e.target.closest('[data-role="ipsMenu_selectedText"]');
        if(selectedTextTrigger && selectedTextMenu){
            selectedTextTrigger.innerText = selectedTextMenu.innerText;
        }

        // Optionally update the trigger icon
        const selectedIconTrigger = this.trigger.closest('[data-role="ipsMenu_selectedIcon"]'),
              selectedIconMenu = e.target.closest('[data-role="ipsMenu_selectedIcon"]');
        if(selectedIconTrigger && selectedIconMenu){
            selectedIconTrigger.replaceWith(selectedIconMenu.cloneNode(true));
        }

        // Dispatch a CustomEvent
        let eventDetail = {
            triggerElem: this.trigger,
            triggerID: this.trigger.getAttribute("popovertarget"),
            menuElem: this,
            originalEvent: e
        };

        // We sometimes simulate radios/checkbox behavior using links
        // "radio" only allow a single link to be selected. "checkbox" allows multiple.
        let selectableList = itemClicked.closest("[data-i-dropdown-selectable]");
        if(selectableList && itemClicked.matches("a, button")){
            if(selectableList.getAttribute("data-i-dropdown-selectable") === "radio"){
                // If the selectable type is radio, remove all active options
                selectableList.querySelectorAll('[aria-selected="true"]').forEach(el => el.removeAttribute("aria-selected"));
                // And then assign the active attribute to the clicked item
                itemClicked.setAttribute("aria-selected", "true");
            } else {
                // If this is a "checkbox" version, toggle the attribute instead
                if(itemClicked.hasAttribute("aria-selected")){
                    itemClicked.removeAttribute("aria-selected")
                } else {
                    itemClicked.setAttribute("aria-selected", "true")
                }
            }
        }
        
        // Store selected value from data-ipsMenuValue
        if(itemClicked.hasAttribute("data-ipsMenuValue")){
            eventDetail.selectedItemID = itemClicked.getAttribute("data-ipsMenuValue");
        } else {
            // If the element doesn't have [data-ipsMenuValue], it might be a <label><input></label>
            // In this case, the inputs value should be used.
            let inputValue = itemClicked.querySelector("input[value]");
            if(inputValue){
                eventDetail.selectedItemID = inputValue.value;
            }
        }

        // Add the selected items to the event detail
        let selectedListItems = this.querySelectorAll("[aria-selected='true'], :checked"),
            selectedItemObj = {};

        if(selectedListItems.length){
            selectedListItems.forEach(el => {
                // If el is a :checked element, we need to reassign it to the label
                let input = el.closest("label");
                if(input){
                    el = input;
                }
                
                if( !el.id ) {
                    el.id = 'ips_uid_' + Math.floor(Math.random() * 9999) + 1;
                }

                selectedItemObj[el.getAttribute('id')] = el;
            })

            eventDetail.selectedItems = selectedItemObj;
        }

        // Dispatch custom event to the trigger, with details of the menu
        this.trigger.dispatchEvent(new CustomEvent("menuItemSelected", { 
            detail: eventDetail,
            bubbles: true
        }));
    }

    // Before opening the popover, create extra elements if necessary
    beforetoggleEvent(e){
        this.open = e.newState === 'open';
        if(e.newState === "open"){
            // If the popover was previously hidden by swipe, remove the attribute
            this.removeAttribute("hidden-via-swipe");
            // Find out which trigger was clicked. This is necessary incase there are multiple triggers for the same menu.
            if(e.source){
                this.trigger = e.source
            } else if(document.activeElement.matches("[popovertarget]")){
                // If the activeElement has [popovertarget], use it.
                this.trigger = document.activeElement;
            } else {
                // If that isn't defined for some reason, we'll just find a trigger ourselves.
                this.trigger = document.querySelector(`[popovertarget="${this.id}"]`);
            }
            // Append menu to element (or body) to prevent external styles from leaking in
            if(this.hasAttribute("data-i-dropdown-append")){
                const appendMenuTo = this.getAttribute("data-i-dropdown-append") || "body";
                document.querySelector(appendMenuTo)?.append(this);
            }

            // do we have to load remote content?
            if (!this._remoteContentLoaded) {
                this.resetRemoteContent()
                    .catch(err => Debug.error(err))
                    .finally(() => {
                        // still open? scroll into view again
                        if (this.open) {
                            this.scrollTop = this.scrollHeight;
                        }
                    });
            }

            // Position the dropdown menu
            this.positionAnchors(e);
            // Create the swipe elements, used in the mobile UI
            if(!this.swipeElement){
                this.createSwipeElement();
            }
        }
    }

    // Toggle the popover
    toggleEvent(e){
        // If the popover is being opened..
        if(e.newState === "open"){
            // Scroll to bottom of popover (for the mobile UI) since the swipe element is at the top
            this.scrollTop = this.scrollHeight;
            // Set active state on toggle
            this.trigger.ariaExpanded = "true";
            // Add "swipe to dismiss"
            this.swipeObserver.observe(this.swipeElement);
            // Add event listeners
            this.addEventListener("change", this);
            this.addEventListener("click", this);
            // The scroll event, required for the scroll-animation polyfill, is added in the transitionend event since the scrollTop (above) will otherwise prematurely change the backdrop opacity
            if(!this.supportsAnimationTimeline){
                this.addEventListener("transitionend", this);
            }
            // Scroll event on document positions the polyfilled popover polyfill elements (which use position: fixed)
            if(!this.supportsPopover){
                document.addEventListener("scroll", this, { passive: true });
            }
            // Dispatch custom event with details of the menu. The goal is to mimic the menuOpened event in ips.ui.menu.js
            this.trigger.dispatchEvent(new CustomEvent("menuOpened", { 
                detail: {
                    elemID: (this.trigger.id) ? this.trigger.id : this.trigger.getAttribute("popovertarget"),
                    menu: this
                },
                bubbles: true
            }));            
        } else {
            // Remove IntersectionObserver and event listeners
            this.swipeObserver.disconnect();
            // We cant't remove the click or change events here since external elements can sometimes dispatch click events to these links/buttons. If they don't have the listener, they fail.
            if(!this.supportsAnimationTimeline){
                this.removeEventListener("scroll", this, { passive: true });
                this.removeEventListener("transitionend", this);
            }
            if(!this.supportsPopover && !document.querySelector('i-dropdown[class*=":popover-open"]')){
                document.removeEventListener("scroll", this, { passive: true });
            }
            // Remove active state from trigger
            this.trigger.ariaExpanded = "false";

            // Dispatch custom event with details of the menu. The goal is to mimic the menuClosed event in ips.ui.menu.js
            this.trigger.dispatchEvent(new CustomEvent("menuClosed", { 
                detail: {
                    elemID: (this.trigger.id) ? this.trigger.id : this.trigger.getAttribute("popovertarget"),
                    menu: this
                },
                bubbles: true
            }));
        }
    }

    transitionendEvent(e){
        // Only run this event once (otherwise it runs for each element that's transitioning)
        if(e.target === this){
            // Add scroll event to the popover once it has finished transitioning. This applies the scroll-animations polyfill
            this.addEventListener("scroll", this, { passive: true });
        }
    }

    scrollEvent(e){
        requestAnimationFrame(() => {
            if(e.target === this){
                // Scroll driven animation polyfill
                this.style.setProperty('--i-dropdown--backdrop-scroll', Math.floor(this.scrollTop / (this.scrollHeight - this.clientHeight) * 100) + "%");
            } else {
                // Anchor polyfill. Update the position of dropdowns on scroll in unsupported browsers.
                this.style.setProperty("--_anchor-scroll", window.scrollY + "px");
            }
        });
    }

    /**
     * Create element to serve as the content root if there is not one
     */
    createContentElement() {
        this.contentElement = this.querySelector(':scope > :is(.iDropdown, [data-i-dropdown-wrapper]) > :is(.iDropdown__content, [data-i-dropdown-content])');
        if (this.contentElement instanceof HTMLElement) {
            return;
        }

        let contentWrapper = this.querySelector(`:scope > :is(.iDropdown, [data-i-dropdown-wrapper])`);
        if (!contentWrapper) {
            this.insertAdjacentHTML("beforeend", "<div class='iDropdown' data-i-dropdown-wrapper></div>");
            contentWrapper = this.querySelector(`:scope > :is(.iDropdown, [data-i-dropdown-wrapper])`);
        }

        contentWrapper.insertAdjacentHTML("beforeend", "<div class='iDropdown__content' data-i-dropdown-content=''></div>");
        this.contentElement = contentWrapper.querySelector(':scope > :is(.iDropdown__content, [data-i-dropdown-content])');
    }

    /**
     * If this dropdown is
     * @return {Promise<void>}
     */
    async resetRemoteContent() {
        if (this.dataset.iDropdownSource) {
            this._remoteContentLoaded = true;
            if (!this.contentElement) {
                this.createContentElement();
            }
            this.contentElement.classList.add('ipsLoading', 'ipsLoading--small');

            // wait until this is opened again if it's closed
            if (!this.open) {
                this._remoteContentLoaded = false;
                return;
            }

            try {
                let res = await ips.fetch(this.dataset.iDropdownSource);

                // just double check remote content is 'supposed' to be loaded
                if (!this._remoteContentLoaded) {
                    return;
                }

                if (typeof res === 'object') {
                    res = res.content;
                }

                if (typeof res !== 'string') {
                    throw new TypeError(`Expected a string as the content type`);
                }

                this.contentElement.classList.remove('ipsLoading', 'ipsLoading--small');
                this.contentElement.innerHTML = res;
                $(document).trigger('contentChange', [this.contentElement]);
            } catch (err) {
                this._remoteContentLoaded = false;
                throw err;
            }
        }
    }

    createSwipeElement(){
        // Create light-dismiss and swipe elements
        let addBackdropElements = ``;
        if(!this.querySelector(".iDropdownSwipe")){
            addBackdropElements += `<div class='iDropdownSwipe'></div>`;
        }
        if(!this.querySelector(".iDropdownDismiss")){
            addBackdropElements += `<button class="iDropdownDismiss" type="button" popovertarget="${this.id}" popovertargetaction="hide" aria-label="Close"></button>`;
        }
        // Prepend them to the popover
        this.insertAdjacentHTML("afterbegin", addBackdropElements);
        // An intersectionObserver is assigned to the swipeElement
        this.swipeElement = this.querySelector(".iDropdownSwipe");
    }

    // IntersectionObserver to close popover on swipe (mobile UI)
    swipeObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if(entry.isIntersecting){
                // This attribute removes the transition, allowing the popover to instantly hide once swiped. This fixes a bug in Safari 26.0 where the backdrop could flash during the closing transition after being swiped.
                this.setAttribute("hidden-via-swipe", true);
                // We remove the scroll position so it resets back to 0% if reopened
                this.style.removeProperty('--i-dropdown--backdrop-scroll');
                this.hidePopover();
            }
        });
    }, {
        root: this,
        threshold: .1
    })

    // Position the [popover] element using Anchor if supported, otherwise use position:fixed and variables
    positionAnchors(e){
        if(!this.supportsAnchor){
            // Get coordinates of trigger
            this.triggerPos = this.trigger.getBoundingClientRect();
            // Assign anchor and scroll variables
            this.style.setProperty("--_anchor-v", window.scrollY + this.triggerPos.bottom + "px");
            this.style.setProperty("--_anchor-h", this.triggerPos.left + (this.triggerPos.width / 2) + "px");
            this.style.setProperty("--_anchor-height", this.triggerPos.height + "px");
            this.style.setProperty("--_remaining-height", document.documentElement.scrollHeight - window.scrollY - this.triggerPos.bottom + "px");
            if(!this.supportsPopover){
                this.style.setProperty("--_anchor-scroll", window.scrollY + "px");
            }
        } else if(!e.source){
            // If the browser doesn't support implicit anchoring (Chrome 125 - 133), add a polyfill
            if (!this.anchorCounter) this.anchorCounter = 1;
            let anchorName = `--${this.id}-${this.anchorCounter++}`;
            this.trigger.style.setProperty("anchor-name", anchorName);
            this.style.setProperty("position-anchor", anchorName);
        }
    }
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="latex.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[class iLatex extends HTMLElement {
	/**
	 * The HTML (cached) for this element
	 * @type {string|null}
	 */
	_latexHTML = null;
	get latexHTML() { return this._latexHTML; }

	/**
	 * The text that was originally inside this element
	 * @type {string}
	 */
	_originalText = "";
	get originalText() { return this._originalText; }

	/**
	 * Initialize the katex object
	 */
	constructor() {
		super();
		this._originalText = this.textContent;
		this.addEventListener('fillLatex', this.fill);
		this.addEventListener('unfillLatex', this.unfill);
		this.fill().then(() => {});
	}

	/**
	 * Wait for katex to load
	 * @return {Promise<void>}
	 */
	async katexLoaded() {
		await ips.ui._codehighlighting.whenLoaded();
	}

	/**
	 * Fill with latex
	 *
	 * @param {string}		[text]		If specified, this text will be rendered as latex and then filled into the element
	 *
	 * @return {Promise<void>}
	 */
	async fill(text) {
		if (typeof text === 'string' && text !== this._originalText) {
			this._originalText = text;
			this._latexHTML = null;
		}

		if (!this._latexHTML) {
			await this.katexLoaded();
			this._latexHTML = await ips.ui.codehighlighting.renderKatexRaw(this._originalText);
		}
		this.innerHTML = this._latexHTML;
	}

	/**
	 * Clear the latex
	 */
	unfill() {
		this.textContent = this._originalText;
	}
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="latexNodeview.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[class iLatexNodeview extends HTMLElement {
	/**
	 * @type {iLatex|null}
	 * @private
	 */
	_preview = null;
	get preview() {return this._preview;}

	/**
	 * @type {HTMLElement|null}
	 * @private
	 */
	_source = null;
	get source() { return this._source; }

	/**
	 *
	 * @type {MutationObserver|null}
	 * @private
	 */
	_childObserver = null;

	/**
	 *
	 * @type {MutationObserver|null}
	 * @private
	 */
	_sourceObserver = null;

	constructor() {
		super();
		this._childObserver = new MutationObserver(_.throttle(entries => this._identifyComponentsInChildren(), 100));
		this._sourceObserver = new MutationObserver(_.debounce(entries => this._updateView(), 500));
		this._childObserver.observe(this, {childList: true, subtree: true});
		this._identifyComponentsInChildren();
		this.addEventListener('click', this);
	}

	/**
	 *
	 * @param {Event}	e
	 */
	handleEvent(e) {
		if (!(e instanceof Event)) {
			throw new TypeError(`A non-event object passed to handleEvent.`);
		}

		switch(e.type) {
			case 'click':
				if (e.target.closest('i-latex') === this.preview && this.source && this.preview) {
					this._focusSource()
				}
				break;
		}
	}

	/**
	 * Set the document's text selection to the source element of this node view. Will toggle the visibility of
	 * @private
	 */
	_focusSource() {
		if (!this.source) {
			return;
		}

		/** @see applications/cloud/dev/editor/latex.js. That handles the toggling on editor selection updates */
		this.source.classList.remove('ipsInvisible');
		this.preview.classList.add('iLatex--no-decoration');
		this.preview.querySelector(":scope > .latex")?.classList.add('ipsInvisible');
		const selection = document.getSelection();
		selection.removeAllRanges();
		const range = new Range();
		range.setStart(this.source.childNodes[0] || this.source, 1);
		range.setEnd(this.source.childNodes[0] || this.source, 0);
		selection.addRange(range);
	}

	/**
	 * Watch the contents to identify the source and the preview
	 * @private
	 */
	_identifyComponentsInChildren() {
		const preview = this.querySelector('i-latex');
		if (preview !== this._preview) {
			this._preview = preview;
		}

		const source = this.querySelector('[data-latex-source]');
		if (source !== this._source) {
			this._source = source;
			this._sourceObserver.disconnect();
			if (source) {
				this._sourceObserver.observe(this._source, {subtree: true, characterData: true});
				this._updateView();
			}
		}
	}

	/**
	 * Update the latex preview based on the source
	 * @private
	 */
	_updateView() {
		if (!this._source || !this._preview) {
			Debug.warn(`Cannot update view of i-latex-nodeview element because either its source or its preview is undefined`);
			return;
		}

		// It is possible, as a race condition such as when a draft loads, 
		customElements.whenDefined('i-latex')
			.then(() => this._preview.fill(this._source.textContent));
	}
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="pullToRefresh.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[class IPullToRefresh extends HTMLElement {

	constructor () {
		super();
	}

	connectedCallback(){
		this.dragDistance = 150;
		this.swipeObserver.observe(this);
	}

	// Handle scroll event
	handleEvent(e){
		requestAnimationFrame(() => {
			this.style.setProperty("--_scroll", (window.scrollY > 0) ? 0 : window.scrollY);
			if(window.scrollY < this.dragDistance * -1){
				document.removeEventListener("scroll", this);
				document.documentElement.setAttribute("data-ips-pwa-refreshing", "");
				// The timeout gives iOS a moment to smoothly apply the animation before reloading
				setTimeout(() => {
					location.reload();
				}, 16);
			}
		});
	}

	// Tweak the dragDistance value to ensure landscape iPhones can be refreshed
	setDragDistance(){
		this.dragDistance = Math.min(150, window.innerHeight * 0.25);
		this.style.setProperty("--_limit", this.dragDistance);
	}

	// IntersectionObserver removes the scroll event when the i-pull-to-refresh element isn't in the viewport
    swipeObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if(entry.isIntersecting){
                document.addEventListener("scroll", this);
				this.setDragDistance();
            } else {
				document.removeEventListener("scroll", this);
			}
        });
    }, {
        threshold: .1
    })
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="pushNotificationsPrompt.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[/*
	Display an "Enable push notifications" prompt
*/
class iPushNotificationsPrompt extends HTMLElement {

    constructor () {
        super();
    }

	connectedCallback(){
		// If push notifications aren't supported, return early
		if (!("Notification" in window)) return;
		// Add click events to message
		this.addEventListener("click", this);
		// If data-persistent is used, show the message even if notifications have been disabled (helpful for displaying enable instructions)
		// Otherwise, only show the message if a decision hasn't been made.
		if((this.hasAttribute("data-persistent")) || (Notification.permission === "default")){
			this.updateUI(Notification.permission);
			// Display message since it's hidden by default
			this.hidden = false;
		}
	}

    // Handle events
    handleEvent(e){
        return this[`${e.type}Event`] && this[`${e.type}Event`](e);
    }

	// Run a method when a data-click element is clicked
    clickEvent(e){
		const el = e.target.closest('[data-click]');
		if(!el) return;

		const method = el.getAttribute("data-click");
		if (method && typeof this[method] === "function") {
			return this[method](e);
		} else {
			console.warn(`No method named "${method}" found on`, this);
		}
    }

	// Hide banner if "Close" button is clicked
	hideMessage(e){
		this.hidden = true;
	}

	// Show browser prompt if "Enable" button is clicked
	async requestPermission(){
		try {
			const permission = await Notification.requestPermission();
			if ( permission === "granted" ) {
				$(document).trigger('permissionGranted.notifications');
			}
			else
			{
				$(document).trigger('permissionDenied.notifications');
			}
			// Notify all instances
			document.querySelectorAll("i-push-notifications-prompt").forEach(el => {
				el.updateUI(permission);
			});
		} catch (error) {
			console.error('Permission request failed:', error);
			// Notify all instances
			document.querySelectorAll("i-push-notifications-prompt").forEach(el => {
				el.updateUI('error');
			});
		}
	}

	updateUI(permission){

		// Style message based on permission
		this.setAttribute("data-permission", permission);

		// Get content area
		const contentEl = this.querySelector('[data-role="content"]');
		if (!contentEl) return;

		// Get template content
		const template = this.querySelector(`template[data-value="${permission}"]`);
		if (!template){
			console.warn(`Cannot update message. There is no template[data-value="${permission}"] element`);
			return;
		}

		// Append the message to the content area
		const clone = template.content.cloneNode(true);
		contentEl.innerHTML = '';
		contentEl.appendChild(clone);

	}
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="pwaInstall.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[class IPwaInstall extends HTMLElement {
	constructor() {
		super();
		this.deferredAndroidPrompt = null;
		this.dismissed = ips.utils.cookie.get('pwaInstallBanner');
	}

	// Handle events
    handleEvent(e){
        return this[e.type + "Event"] && this[e.type + "Event"](e);
    }

	connectedCallback() {
		this.addEventListener("click", this);
		window.addEventListener('appinstalled', this);
		window.addEventListener('beforeinstallprompt', this);
	}

	clickEvent(e){
		// Dismiss the banner if Dismiss button is clicked
        if(e.target.closest("#iPwaInstall__dismiss")){
			ips.utils.cookie.set('pwaInstallBanner', "dismissed", true);
			this.hideBanner();
		/*
		} else if(e.target.closest("#iPwaInstall__install") && (this.deferredAndroidPrompt)){
			// If the install button is clicked and if we're on Android, install the app and then hide the banner
			this.deferredAndroidPrompt.prompt();
			this.deferredAndroidPrompt.userChoice.then(choice => {
				if (choice.outcome === 'accepted') {
					ips.utils.cookie.set('pwaInstallBanner', "installed", true);
					this.hideBanner();
				}
				this.deferredAndroidPrompt = null;
			});
		*/
		}
    }

	// Chrome/Android: This event runs once per browsing session if Chrome determines the app hasn't been installed. We prevent this from running and replace it with our own UI
	// We store the event and display our own Install button, but the button will only be displayed when Chrome allows it
	beforeinstallpromptEvent(e){
		// If the banner has been dismissed, return early
		if(this.dismissed) return;
		// Prevent the default UI from showing
		e.preventDefault();
		// Store the event so we can reference it later
		this.deferredAndroidPrompt = e;
		// Show custom install button
		// this.querySelector("#iPwaInstall__install").hidden = false;
	}

	// Chrome/Android: Hide the banner when the app is installed using the .prompt() method
	appinstalledEvent(e){
		ips.utils.cookie.set('pwaInstallBanner', "installed", true);
		this.hideBanner();
	}

	hideBanner() {
		this.hidden = true;
	}
}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="pwaLoading.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[// PWAs don't have a loading indicator. This adds one when certain links are tapped
class iPwaLoading extends HTMLElement {

	constructor () {
		super();
	}

	connectedCallback(){
		document.addEventListener("click", this);
		window.addEventListener('pageshow', this);
	}

	// Handle events
    handleEvent(e){
        return this[`${e.type}Event`] && this[`${e.type}Event`](e);
    }

	pageshowEvent(e){
		if (e.persisted) {
			// Hide the loader if the page was loaded via the back button/swipe gesture
			this.hidden = true;
		}
	}

	// Handle events
	clickEvent(e){
		const link = e.target.closest("a[href]");
		// Not a link
		if (!link) return;
		// Wrapping in a setTimeout places this code at the end of the call stack. This ensures other click events have run, and we can more reliably check defaultPrevented.
		setTimeout(() => {
			// Link has preventDefault and likely doesn't navigate to a new page
			if (e.defaultPrevented) return;
			// Ignore certain links
			if (
				link.matches('[href^="#"], [href^="javascript:"], [target="_blank"]') ||
				e.ctrlKey || e.metaKey || e.shiftKey || e.altKey
			) return;
			// Show the loader
			this.hidden = false;
		});
	}

}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/components" javascript_name="themeEditor.js" javascript_type="component" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Theme Editor Web Component - registered as <i-theme-editor>
 */
class IThemeEditor extends HTMLElement {

    constructor(){
        super();

        // Start referencing required data/elements
        this.form = this.querySelector('form');
        this.inputs = this.form.elements;

        // Fetch panels and create an empty array to store panel navigation history
        this.panels = this.querySelectorAll('editor-panel');
        this.currentPanel = document.getElementById('panel__start');
        this.panelHistory = [];

        // Store modified settings in an object
        this.settings = {
            vars: {},
            text: {},
            layouts: {},
            images: {},
            headerPositions: {},
            dataAttributes: {}
        };

        // Fetch <iframe> and <style> tags, which we'll populate later with dynamic CSS
        this.iframe = document.getElementById('themeEditorIframe').contentWindow;
        this.iframeStyleTag = '';
        this.iframeTempStyleTag = '';
        this.styleTag = document.getElementById('themeEditorStyles');
        this.tempStyleTag = document.getElementById('themeEditorTempStyles');

        // Color picker text input
        this.colorPickerText = this.querySelector('[data-color-picker-text]');

        // Color preview block
        this.colorPreview = this.querySelector('#panel__colorSelector [data-color-preview]');

        // Custom CSS
        this.customCssDialog = this.querySelector("#dialog__customCSS");
        this.customCSSEditor = this.querySelector("#customCSS");

        this.customCssDialog.addEventListener('close', e => this.updateCustomCSS(e));

        // This determines what theme setting is being edited by the color/swatch pickers
        this.activeColor = '';

        // Run initial functions
        this.init();


        /*
            Events
        */

        // Events
        this.form.addEventListener('click', this);
        this.form.addEventListener('input', this);
        this.form.addEventListener('change', this);

        this.form.addEventListener('ips:codeboxAfterInit', e => {
            if (e?.detail?.instance) {
                this.cssEditorInstance = e.detail.instance;
                this.showOrHideCSSWarning();
            }
            this.showOrHideRevertButton();
        });

        this.debounceTimeout = undefined;
        this.form.addEventListener('ips:codebox#update', e => {
            if (e?.detail?.instance) {
                this.cssEditorInstance = e.detail.instance;
            }
            if (this.customCSSEditor instanceof Element && e?.detail?.elem?.closest('#customCSS') === this.customCSSEditor) {
                if (this.debounceTimeout !== undefined) {
                    clearTimeout(this.debounceTimeout);
                }
                this.debounceTimeout = setTimeout(() => {
                    this.showOrHideCSSWarning();
                    this.showOrHideRevertButton();
                }, 200);
            }
        })

        // Settings have been changed. Show dialog if quitting.
        this.form.addEventListener('change', e => this.unsavedChanges = true);      

        this.form.addEventListener('keydown', e => this.preventReturnKeySubmission(e));

        window.addEventListener("beforeunload", e => this.handleBeforeUnload(e));

        // iFrame Sync
        document.getElementById('themeEditorIframe').addEventListener('load', e => this.iframeSync());

        // Color scheme sync
        document.addEventListener("ips:colorScheme", this.closeColorPicker);

        // Update value of "color-scheme" button if system setting changes, and preference was set to auto
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (document.documentElement.getAttribute('data-ips-scheme-active') != 'system') return;

            let active = (window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark':'light';
            this.querySelector(`[data-workspace='color'] [value='${active}']`).click();
        });

    }

    init(){

        // Create color picker
        ips.utils.color.loadIro()
            .then(() => {
                this.colorPicker = new ips.utils.iro.ColorPicker(this.querySelector('color-picker'), {
                    width: 250,
                    color: "hsl(0 0% 0%)",
                    layout: [
                        {
                            component: ips.utils.iro.ui.Box,
                            options: {}
                        },
                        {
                            component: ips.utils.iro.ui.Slider,
                            options: {
                                sliderType: 'hue'
                            }
                        }
                    ]
                });

                // When the color picker value is changed..
                this.colorPicker.on('input:change', color => this.colorPickerChange(color));
                this.colorPicker.on('input:end', color => this.colorPickerDone(color));
            });

        // There are currently no unsaved changes
        this.unsavedChanges = false;

        // Change src of iframe to referrer, if one exists - unless it's an admin page
        if(document.referrer && !document.referrer.includes("/admin/")){
            document.getElementById('themeEditorIframe').src = document.referrer;
        }

        // Add loading icon
        this.setAttribute('data-loading', true);

        // Remove the loading animation after 3 seconds incase it hasn't already been removed from the load event.
        // This can sometimes happen if the iframe has trouble loading due to other errors.
        setTimeout(() => {
            this.removeAttribute('data-loading');
        }, 3000);

        // Add custom setting UIs (header drag, etc)
        this.customSettingUIs();


/*
        // Sync up max attributes for logo/header height settings. This is an object containing ID's of "responding" and "controlling" inputs
        this.syncMaxInputs = {
            'set__i-logo--he': 'set__i-header-primary--he',
            'set__i-sidebar-ui-logo--he': 'set__i-sidebar-ui-header--he',
            'set__i-mobile-logo--he': 'set__i-mobile-header--he'
        };

        // Add "data-sync-max-value-from" attributes to responding inputs which need to adjust their "max" value depending on the value of controlling inputs
        for (const [key, value] of Object.entries(this.syncMaxInputs)) {
            this.inputs[key].setAttribute("data-sync-max-value-from", value);
        }

        // Then update the controlling input of the "Logo height" setting
        this.updateLogoMaxHeightController();

        // Then run the syncMax method on each of these responding inputs
        this.querySelectorAll("[data-sync-max-value-from]").forEach(receiver => this.updateDynamicMaxValueFor(receiver));
*/

    }

    /*
        Add custom setting UIs, such as the drag/drop editor
    */
    customSettingUIs(){

        let headerDrag = `
			<div id="content__header__design">
				<p class="i-padding-block_2 i-text-align_center i-color_soft i-flex_11">
					<span class="i-display_hover">Click and drag to reorder header elements</span><span class="i-display_no-hover">Tap, hold and then drag to reorder header elements for the desktop header.</span>
				</p>
				<ul class="theme-editor__reorder" data-ips-reorder>
					<li draggable="true" style="view-transition-name: el-1" data-pos="1"></li>
					<li draggable="true" style="view-transition-name: el-2" data-pos="2"></li>
					<li draggable="true" style="view-transition-name: el-3" data-pos="3"></li>
					<li class="theme-editor__reorder-break"></li>
					<li draggable="true" style="view-transition-name: el-4" data-pos="4"></li>
					<li draggable="true" style="view-transition-name: el-5" data-pos="5"></li>
					<li draggable="true" style="view-transition-name: el-6" data-pos="6"></li>
					<li class="theme-editor__reorder-break"></li>
					<li draggable="true" style="view-transition-name: el-7" data-pos="7"></li>
					<li draggable="true" style="view-transition-name: el-8" data-pos="8"></li>
					<li draggable="true" style="view-transition-name: el-9" data-pos="9"></li>
					<li class="theme-editor__reorder-break"></li>
					<li draggable="true" style="view-transition-name: el-10" data-pos="10"></li>
					<li draggable="true" style="view-transition-name: el-11" data-pos="11"></li>
					<li draggable="true" style="view-transition-name: el-12" data-pos="12"></li>
				</ul>
			</div>`;

        // Insert draggable UI
        this.querySelector('[data-setting="set__i-position-search"]').insertAdjacentHTML('afterend', headerDrag);

        // Populate draggable list
        let positionInputs = this.form.querySelectorAll('[name^="set__i-position-"]');

        positionInputs.forEach(input => {
            let label = this.querySelector(`[for="${input.id}"]`),
                draggableEl = this.querySelector(`[data-ips-reorder] [data-pos='${input.value}']`);

            // Add data-label and data-name to the draggable element
            draggableEl.setAttribute('data-label', label.textContent);
            draggableEl.setAttribute('data-name', input.id);
        });

        this.dragLabels = document.querySelectorAll('[data-ips-reorder] [draggable]');

        // Drag to reorder header
        this.dragLabels.forEach(item => {
            item.addEventListener('dragstart', ev => this.handleDragStart(ev), false);
            item.addEventListener('dragenter', ev => this.handleDragEnter(ev), false);
            item.addEventListener('dragover', ev => this.handleDragOver(ev), false);
            item.addEventListener('dragleave', ev => this.handleDragLeave(ev), false);
            item.addEventListener('drop', ev => this.handleDrop(ev), false);
            item.addEventListener('dragend', ev => this.handleDragEnd(ev), false);
        });
    }

   /**
    * Change the iframe size, color scheme, etc
    * @param {Event} e 
    * @param {HTMLElement} target 
    */
    changeWorkspace(e, target){

        let type = target.parentElement.getAttribute('data-workspace');

        // If it's a solo element, then toggle its state
        if(target.matches(':only-child')){
            target.toggleAttribute('data-active');
            document.documentElement.setAttribute(`data-workspace-${type}`, target.hasAttribute('data-active'));
        } else {
            // ..otherwise it's part of a group, so remove the active state from all siblings, then activate the chosen option
            for(let el of target.parentElement.children){
                el.removeAttribute('data-active');
            }
            target.setAttribute('data-active', true);
            document.documentElement.setAttribute(`data-workspace-${type}`, target.value);
        }
    }

    /**
     * Navigate through panels, and store the history in an array so we can 'go back'
     * @param {Event} event 
     * @param {HTMLElement} target 
     */
    panelNavigation(event, target){

        // Hide all panels
        this.panels.forEach(p => {
            p.setAttribute('aria-hidden', 'true');
            p.inert = true;
        });

        if(target.getAttribute('data-panel-nav') === 'back'){

            // Get the previous panel and open it
            this.currentPanel = document.getElementById(this.panelHistory.pop());
            this.currentPanel.setAttribute('aria-hidden', 'false');
            this.currentPanel.inert = false;
            this.currentPanel.removeAttribute('data-panel-prev');
            this.currentPanel.querySelector("button")?.focus();

        } else {

            if(target.hasAttribute('data-color-tool')){
                // Open the color picker and assign active swatch
                this.toggleColorPanel(target);
            }

            let oldPanel = target.closest('editor-panel');
            this.currentPanel = document.getElementById(target.getAttribute('aria-controls'));

            // Open the new panel
            this.currentPanel.setAttribute('aria-hidden', 'false');
            this.currentPanel.inert = false;
            this.currentPanel.querySelector("button, input, select, textarea")?.focus();

            // Set the text for the Back button
            this.currentPanel.querySelector(`[data-panel-nav="back"]`).innerText = oldPanel.querySelector('[data-panel-name]')?.innerText ?? 'Back';

            // Add the old panel to the history array, so we can navigate back using data-panel-nav="back" buttons
            this.panelHistory.push(oldPanel.id);

            // Then animate the old panel to the left
            oldPanel.setAttribute('data-panel-prev', true);

        }
    }

    /**
     * Update <style id="themeVariables"> with variables
     */
    buildVariablesStyleTag(){

        // Empty the style elements
        this.styleContent = '';
        this.iframeTempStyleTag.textContent = '';

        // Loop through each input, then output its value as a css variable
        for (const [key, value] of Object.entries(this.settings.vars)){
            if(['set__i-logo-text', 'set__i-logo-slogan'].includes(key)) continue;
            if(this.settings.images[key]){
                if(this.settings.images[key].length){
                    this.styleContent += `--${key}: url("` + this.settings.images[key] + `");`;
                }
            } else {
                this.styleContent += `--${key}: ${value};`
            }
        }

        // Wrap the variables in a :root selector and apply it to the <style> tag
        this.styleTag.textContent = `:root{ ${this.styleContent} }`;
        this.iframeStyleTag.textContent = `:root{ ${this.styleContent} }`;

        // This is the generated CSS code
        window.Debug?.log(this.iframeStyleTag.textContent);

    }


    /**
     * Dynamically update live text elements. This runs when a text input is changed, or when the iframe is navigated to a new page
     * @param {String} setting  The name of the setting being changed
     * @param {String} value    The value of the setting being changed
     */
    updateLiveText(setting, value){
        this.iframe.document.querySelectorAll(`[data-ips-theme-text='${setting}']`).forEach(le => le.innerText = value);
    }

    /**
     * Display a preview of uploaded images in the editor panel
     * This runs when the [type="file"] input is changed
     * @param {Event} e 
     */
    updateImagePreview(e){

        const preview = e.target.parentElement.querySelector('[data-file-preview]');

        // Erase existing preview and delete from object
        preview.textContent = '';
        delete this.settings.images[e.target.name];

        // If an image has been uploaded, create the preview image and add to object
        if(e.target.files.length > 0){
            const src = URL.createObjectURL(e.target.files[0]);

            // Build preview thumbnail
            preview.innerHTML = `<img src="${src}" alt="">`;

            // Remove the "delete__" input, since an image has been uploaded
            preview.parentElement.querySelector('[data-delete-logo]')?.remove();

            // Add the uploaded image to object
            this.settings.images[e.target.name] = src;

            // Then apply the image to the iframe
            this.applyUploadedImageToIframe(e.target.name, src);
        }

    }

    /**
     * Apply uploaded image to iframe
     * @param {String} name     Name of image
     * @param {String} value    src of image
     */
    applyUploadedImageToIframe(name, value = null){

        let setting = name.replace("set__", ""),
            elements = this.iframe.document.querySelectorAll(`[data-ips-theme-image='${setting}']`);

        elements.forEach(el => {

            let picture = el.closest('picture');

            if(value){

                // The image has a URL, so apply it
                el.src = value;

                // Safari fix: Repaint image so it gets correct dimensions
                el.offsetHeight;

                el.hidden = false;
                if(picture) picture.hidden = false;

                // Remove width/height attributes which are applied to initial logo image
                el.removeAttribute('width');
                el.removeAttribute('height');

            } else {

                // Hide images since they've been deleted
                el.hidden = true;
                if(picture) picture.hidden = true;

            }
        });

    }

    /**
     * Live update: Delete image
     * @param {Event} event The click event
     * @param {HTMLElement} target  The delete button belonging to the image which we're deleting
     */
    deleteLogoImage(event, target){

        const fileInput = target.parentElement.querySelector('[type=file]');

        // Reset the file input
        fileInput.value = '';

        // Remove the image from the object
        delete this.settings.images[target.getAttribute('data-file-preview-delete')];

        // Programatically run this.updateImagePreview
        fileInput.dispatchEvent(new Event("change", {bubbles: true}));

        // Add an input so the image can be deleted from the backend
        if(!fileInput.parentElement.querySelector('[data-delete-logo]')){
            fileInput.insertAdjacentHTML('afterend', `<input type='hidden' name='delete__${fileInput.id}' value='1' data-delete-logo>`);
        }

        // Delete the image from the iframe
        this.applyUploadedImageToIframe(target.getAttribute('data-file-preview-delete'));
    }

    /**
     * Update the "max value" for the logo height depending on its location in the header
     * This runs on init, and when the header elements are repositioned
     */
    updateLogoMaxHeightController(){
        /*

        // Get the position of the logo
        let logoPosition = this.inputs['set__i-position-logo'].value,
            logoController = "";
        if (['1','2','3'].includes(logoPosition)){
            logoController = 'set__i-header-top--he';
        } else if (['7','8','9'].includes(logoPosition)){
            logoController = 'set__i-header-secondary--he';
        } else {
            logoController = 'set__i-header-primary--he';
        }

        // The max value of the logo height setting should be controlled by the header position which holds the logo
        this.inputs['set__i-logo--he'].setAttribute("data-sync-max-value-from", logoController);

        // Update the max value of logo setting
        this.updateDynamicMaxValueFor(this.inputs['set__i-logo--he']);
        */

    }

    /**
     * Sync up max values for logo and header heights
     * This provides a more friendly way of resizing the logo, since its max value is always in sync with the current header height (creating a dynamic 0% - 100% range)
     * @param {HTMLElement} receiver     The input whose max value will change based on its controlling input
     */
    updateDynamicMaxValueFor(receiver){
        /*

        let controllerValue = this.querySelector("#" + receiver.getAttribute("data-sync-max-value-from")).value;

        // Ensure the max value of the receiving input is the same as the controlling inputs value
        receiver.max = controllerValue;

        if(receiver.value > controllerValue){
            receiver.value = controllerValue;
        }

        // Update the max value of the receiving inputs "num output" if it exists
        let output = this.querySelector(`[data-range-output="${receiver.id}"]`);
        if(output){
            output.max = controllerValue;
            if(output.value > controllerValue){
                output.value = controllerValue;
            }
        }
        */

    }


    /**
     * When a "change color-scheme" button is clicked, close the color picker if it's open
     * @param {Event} event  The event
     */
    closeColorPicker(event){

        // If we're editing a color setting (such as Body Background), and if we change color scheme, we need to flick back to the "color settings" list otherwise we'll be editing the wrong color	
        if(document.querySelector("#panel__colorSelector[aria-hidden='false']")){
            document.querySelector('#panel__colorSelector [data-panel-nav="back"]').click();
        }

    }


    /**
     * Prevent the return key from submitting the form when a setting input is focused
     * @param {Event} e The submit event
     * @returns false
     */
    preventReturnKeySubmission(e){
        let input = e.target;
        if( input.matches('i-theme-editor input') && e.keyCode == 13 ) {
            e.preventDefault();

            // If a number outside of the min/max range is submitted, pull it back into the range
            if(input.min && input.min > Number(input.value)){
                input.value = input.min;
            } else if(input.max && input.max < Number(input.value)){
                input.value = input.max;
            }

            // Dispatch the 'change' event, so settingHasBeenChanged() runs and rebuilds the <style> element
            input.dispatchEvent(new Event("change", { bubbles: true }));

            return false;
        }
    }

    /**
     * When a range is being changed (via the 'input' eventListener), add its value to #themeEditorTempStyles
     * We should do as little as possible here for best performance.
     * Other updates are hanlded via settingHasBeenChanged()
     * @param {Event} e The 'input' event
     * @param {HTMLElement} e The target which triggered the event
     */
    changingRangeInput(e, target){

        cancelAnimationFrame(this.rebuildStyleDebounce);

        // Update the UI. The requestAnimationFrame ensures smoother framerates
        this.rebuildStyleDebounce = requestAnimationFrame(() => {

            // Add the new value into <style id='themeEditorTempStyles'>
            this.iframeTempStyleTag.textContent = `:root{ --${e.target.id}: ${e.target.value}; }`;

            // If this is an oklch range, update the theme editor styles so the color can be used in the other ranges
            if(e.target.matches("#panel__oklch input")){
                this.tempStyleTag.textContent = `:root{ --${e.target.id}: ${e.target.value}; }`;
            }

            // If the input is a range, update the "synced number input"
            let numInput = this.querySelector(`[data-range-output=${e.target.id}]`);
            if(numInput) numInput.value = e.target.value;

        });

    }

    /**
     * When a text input is being changed (via the 'input' eventListener), update the live text elements in the iframe
     * Other updates are hanlded via settingHasBeenChanged()
     * @param {Event} e The 'input' event
     * @param {HTMLElement} e The target which triggered the event
     */
    changingTextInput(e, target){

        // Run updateLiveText to update text in iframe
        this.updateLiveText(e.target.name, e.target.value);

        // Add the new value into <style id='themeEditorTempStyles'>
        //this.iframeTempStyleTag.textContent = `:root{ --${e.target.id}: ${e.target.value}; }`;

    }

    /**
     * Once a setting has been changed ('change' eventListener), add it to the settings.vars object, which tracks changed settings
     * The styles are then built into #themeEditorStyles via buildVariablesStyleTag()
     * @param {Event} e     'input' Event
     * @param {HTMLElement} target  The HTMLElement that triggered the event
     */
    settingHasBeenChanged(e, target){

        let setting = target.name,
            value = target.value;

        // Add the setting and value to the settings object, so we can reference/apply it during iframe navigation
        this.settings.vars[setting] = value;

        if (e.target.matches('[type="range"]')){

            let numInput = this.querySelector(`[data-range-output=${e.target.id}]`);
            if(numInput) numInput.value = value;

            // If an input with data-sync-max-value-from exists, with a value which matches the range that just changed, update the max value of that input
            /*
            let syncThisInput = this.querySelector(`[data-sync-max-value-from='${e.target.id}']`);
            if(syncThisInput){
                this.updateDynamicMaxValueFor(syncThisInput);
            }
            */

        } else if(target.matches('[type="text"]')){
            // If this is a text setting, add it to the settings.text object so updateLiveText can reference it on iframe navigation
            this.settings.text[setting] = value;
        }

        // If data-attributes on <html> exist for this setting, update them
        let attr = 'data-ips-theme-setting-' + setting.replace('set__i-', '');
        if(this.iframe.document.documentElement.hasAttribute(attr)){

            // Add attribute to object so we can reference it during iframe navigation
            this.settings.dataAttributes[attr] = value;

            // Set the attribute on the html element to the new value
            this.applyDataAttributes(attr, value);

        }

        // If this is <input type="file">, update the image prevent
        if(target.matches('[type="file"]')) this.updateImagePreview(e);       

        // Show the revert button
        this.toggleRevertButton(target);

        // Do we need to refresh the page?
        let container = document.querySelector( `theme-setting[data-setting='${setting}']` );
        if(container.matches('[data-setting-refresh]')) this.refreshIframe(e);

        // Rebuild <style id='themeEditorStyles'>
        this.buildVariablesStyleTag();

        // re-compile CSS
        this.updateCustomCSS();
    }

    /**
     * When manually editing <input type="number">, this updates the value of the corresponding <input type="range">
     * For checkboxes: Update the value of hidden inputs when checkboxes are changed. This allows us to submit 1/0 with the form, instead of the default "on" value
     * For ranges: Pull the value back into range if it exceeds it
     * @param {Event} e             The 'change' event
     * @param {HTMLElement} target  The element that triggered the event
     */
    syncInputsWithPseudo(e, target){

        let pseudoInput = e.target,
            input = document.getElementById(e.target.getAttribute('data-range-output'));

        if (pseudoInput.max) pseudoInput.value = Math.min(parseInt(pseudoInput.max), Math.max(parseInt(pseudoInput.min) || 0, parseInt(pseudoInput.value) || 0));

        if(e.target.type == 'checkbox'){
            input.value = (e.target.checked) ? 1 : 0;
        } else {
            input.value = e.target.value;
        }

        // Dispatch the 'change' event, so settingHasBeenChanged() runs and rebuilds the <style> element
        input.dispatchEvent(new Event("change", { bubbles: true }));

    }

    /**
     * Dynamically update the custom CSS code when the textarea changes
     * We check to see if </style> exists, and we remove it if so. Otherwise we keep the content unchanged so undo/redo can still function across dialog toggles
     */
    async updateCustomCSS(){

        let content = document.querySelector('#customCSS').textContent;//.replace(/<\/style>/g, ''); // in theory, we shouldn't need to strip the tag because the CSS is html-encoded anyway before ever being inserted into the DOM.
        this.customCSSEditor.value = content;

        if( content.length ){
            const {content: parsed} = await ips.fetch( '?app=core&module=system&controller=themeeditor', {method: 'post', data:{do: 'customCss', content:content}});

            // Apply new code to <style id="themeCustomCSS">
            this.iframeCustomCSS.textContent = parsed;
        } else {
            this.iframeCustomCSS.textContent = content;
        }
    }

    /**
     * Revert Custom CSS
     *
     * @param {Event} event
     * @param {HTMLElement} target
     */
    revertCustomCSS(event, target){
        
        if (confirm("This will revert your CSS back to its previously saved value. Any unsaved changes will be lost.")) {
            const originalContent = this.querySelector('#customCSS-saved').innerText;
            document.querySelector("#customCSS").value = originalContent;
            this.cssEditorInstance?.setValue(originalContent);
            this.updateCustomCSS();

            // Hide the revert button
            target.hidden = true;
        }
        
    }

    /**
     * Show or hide the warning about template tags
     */
    async showOrHideCSSWarning() {
        await ips.ui._codehighlighting.whenLoaded();
        const dialog = this.querySelector('#dialog__customCSS');
        const warning = dialog.querySelector('#customCSS-warning');
        if (!this.cssEditorInstance) {
            Debug.warn('No editor instance found!');
            warning.removeAttribute('hidden');
            return;
        }

        const preTag = document.createElement('pre');
        preTag.classList.add('language-ipscss');
        preTag.innerText = this.cssEditorInstance.getValue();
        const highlighted = await ips.ui.codehighlighting.highlight(this.cssEditorInstance.getValue(), 'ipscss');
        preTag.innerHTML = highlighted.value;

        const hasTemplateTag = !!preTag.querySelector('.language-ipscss :is(.ipsShortcut, .ipsVarTag, .ipsVarTagFilter, .ipsBlockTag)');
        if (hasTemplateTag) {
            warning.removeAttribute('hidden');
        } else {
            warning.setAttribute('hidden', '');
        }
        preTag.remove();
    }

    /**
     * Show or hide the revert button depending on whether or not the styles have changed
     */
    showOrHideRevertButton() {
        const originalContent = this.querySelector('#customCSS-saved').innerHTML;
        const currentContent = this.querySelector('#customCSS').innerHTML;

        this.querySelectorAll('[data-revert-custom-css]').forEach(revertButton => {
            if (currentContent === originalContent) {
                revertButton.setAttribute('hidden', '');
            } else {
                this.unsavedChanges = true;
                revertButton.removeAttribute('hidden');
            }
        });
    }

    /**
     * Update the color preview block
     */
    setColorPickerFromComputedStyle(){
        this.colorPreview.style.setProperty('--_background', this.activeColor.value);

        let color = window.getComputedStyle(this.colorPreview).getPropertyValue('background-color');

        if (color.startsWith("color(srgb")){
            // Convert color(srgb) to rgb so it can be applied to the color picker
            let values = color.replace(/color\(srgb |\)/g, '').split(" ");
            this.colorPicker.color.set(`rgb(${values[0] * 255} ${values[1] * 255} ${values[2] * 255})`);

        } else {
            // This is hopefully already rgb or hsl (thanks to relative colors in CSS)
            this.colorPicker.color.set(color);
        }
        
    }

    /**
     * This opens the swatch/color picker panel
     * @param {HTMLElement} target 
     */
    toggleColorPanel(target){

        let panel = document.getElementById('panel__colorSelector');

        // Set active values
        this.activeColor = this.inputs[target.getAttribute('data-controls')];

        // Update setting name in header
        this.querySelector('[data-active-name]').innerText = target.innerText;

        // Optionally only show certain swatches in the swatch picker
        if(target.hasAttribute('data-swatch-categories')){
            panel.setAttribute('data-show-swatches', target.getAttribute('data-swatch-categories'));
        } else {
            panel.removeAttribute('data-show-swatches');
        }

        // Always open the panel with the swatch picker visible
        let swatchTab = document.querySelector('[aria-controls="content__colorSelector__swatches_panel"]');
        if(swatchTab.getAttribute("aria-expanded") === "false"){
            swatchTab.click()
        }

        // Optionally hide swatches (ie. the Color Scheme creator)
        if(target.getAttribute('data-color-tool') != ''){
            panel.setAttribute('data-show-tool', target.getAttribute('data-color-tool'));
        }

        // Set aria-current on swatch if one exists
        this.querySelector('[data-swatch][aria-current]')?.removeAttribute('aria-current');
        this.querySelector(`[data-swatch][value='${this.activeColor.value}']`)?.setAttribute('aria-current', 'true');

        // Get the computed value of a CSS var (eg. if a swatch was previously selected) and apply it to the color picker
        this.setColorPickerFromComputedStyle();
        this.colorPickerText.value = `hsl(${this.colorPicker.color.hsl.h} ${this.colorPicker.color.hsl.s}% ${this.colorPicker.color.hsl.l}%)`;
    }

    /**
     * When the color picker is actively being dragged, only change <style id='themeEditorTempStyles'>
     * This improves performance, particularly in Safari.
     * The <style> tag is rebuilt via colorPickerDone() once dragging has finished.
     * @param {Object} color    The color object from the Color Picker
     */
    colorPickerChange(color){

        cancelAnimationFrame(this.rebuildStyleDebounce);

        // Update the UI. The requestAnimationFrame ensures smoother framerates
        this.rebuildStyleDebounce = requestAnimationFrame(() => {

            // We need to manually set this, so it uses the space separated syntax
            let newValue = `hsl(${color.hsl.h} ${color.hsl.s}% ${color.hsl.l}%)`,
                styleContent = `--${this.activeColor.name}: ${newValue};`;

            // Add the new color into <style id='themeEditorTempStyles'>
            this.iframeTempStyleTag.textContent = `:root{ ${styleContent} }`;

            // Update color picker text box and preview box
            this.colorPickerText.value = newValue;
            this.colorPreview.style.setProperty('--_background', newValue);

        });

    }

    /**
     * Contrast polyfill for primary-contrast and seconday-contrast variables in browsers which don't support relative colors: https://caniuse.com/css-relative-colors
     * This sets a value of 0-100 for approximate relative lightness
     * @param {Object} color The color object from the Color Picker
     * @returns {Number} The relative lightness of the color, from 0 - 100
     */
    colorPickerContrastPolyfill(color){
        let relativeLightness = ((color.red*299)+(color.green*587)+(color.blue*114)) / 1000 / 256 * 100;
        return Math.floor(relativeLightness);
    }

    /**
     * When the color picker is changed, update the value of the "input" which belongs to the setting
     * @param {Object} color The color object from the Color Picker
     */
    colorPickerDone(color){

        // Remove active swatch, if one exists
        this.querySelector('[data-swatch][aria-current]')?.removeAttribute('aria-current');

        // We need to manually set this, so it uses the space separated syntax
        let newValue = `hsl(${color.hsl.h} ${color.hsl.s}% ${color.hsl.l}%)`;

        // Dynamically update input value
        this.activeColor.value = newValue;
        this.settings.vars[this.activeColor.name] = this.activeColor.value;

        // Primary and secondary contrast polyfill for browsers which don't support relative color syntax: https://caniuse.com/css-relative-colors
        if(this.activeColor.matches('[name=light__i-primary], [name=light__i-secondary], [name=dark__i-primary], [name=dark__i-secondary]')){
            this.inputs[this.activeColor.name + '-relative-l'].value = this.colorPickerContrastPolyfill(color);
            this.settings.vars[this.activeColor.name + '-relative-l'] = this.colorPickerContrastPolyfill(color);
        }

        // Update color picker text box and preview box
        this.colorPickerText.value = newValue;
        this.colorPreview.style.setProperty('--_background', newValue);

        // Toggle revert button
        this.toggleRevertButton(this.activeColor);

        // Settings have been changed. Show dialog if quitting.
        this.unsavedChanges = true;

        // Apply styles
        this.buildVariablesStyleTag();
    }

    /**
     * When a color code (HEX, HSL, RGB, etc) is added to the text input, update the color picker
     * @param {Event} e The change event of the input
     * @param {HTMLElement} target
     * @returns 
     */
    colorPickerTextBlur(e, target){

        if (!e.target.value.startsWith('#') && !e.target.value.startsWith('hsl(') && !e.target.value.startsWith('rgb(')){
            window.Debug?.log('Not a supported color. Hex, RGB and HSL are supported.');
            return;
        }

        // Set these values for the setColorPickerFromComputedStyle() method can use them
        this.activeColor.value = e.target.value;
        this.settings.vars[this.activeColor.name] = this.activeColor.value;

        this.setColorPickerFromComputedStyle();
        this.colorPickerDone(this.colorPicker.color);

    }

    /**
     * When a swatch is clicked, grab its value and apply it to the active setting input
     * @param {Event} event The click event
     * @param {HTMLElement} target The swatch
     */
    swatchClick(event, target){

        // Set active swatch
        this.querySelector('[data-swatch][aria-current]')?.removeAttribute('aria-current');
        target.setAttribute('aria-current', 'true');

        // Update setting value
        this.activeColor.value = target.value;
        this.settings.vars[this.activeColor.name] = this.activeColor.value;

        // Update the preview swatch, style tag and revert button
        this.colorPreview.style.setProperty('--_background', target.value);
        this.buildVariablesStyleTag();
        this.toggleRevertButton(this.activeColor);

        // Set the value of the color picker to the same as the selected swatch
        this.setColorPickerFromComputedStyle();

        // Settings have been changed. Show dialog if quitting.
        this.unsavedChanges = true;
    }

   /**
    * Show or hide the revert button if the input value matches the data-default value
    * @param {HTMLInputElement} settingInput 
    */
    toggleRevertButton(settingInput){

        let revertButton = document.querySelector(`[data-revert="${settingInput.name}"]`),
            hasDefaultValue = settingInput.hasAttribute("data-default");

        if(revertButton && hasDefaultValue){
            revertButton.hidden = (settingInput.value == settingInput.getAttribute("data-default"));
        }

    }

    /**
     * Reverts a setting back to its data-default value
     * @param {Event} event The click event
     * @param {HTMLElement} target The Revert button
     */
    revertSetting(event, target){

        // Hide the revert button
        target.hidden = true;

        // Find out what setting this button reverts, and revert it to the data-default value
        let controls = target.getAttribute('data-revert'),
            defaultValue = this.inputs[controls].getAttribute('data-default'),
            fieldType = target.parentElement.getAttribute('data-type');

        // images need to be handled differently
        if (fieldType === 'image'){
            delete this.settings.images[controls];

            // load the default image, if we have one
            if (defaultValue.length) {
                const preview = target.parentElement.querySelector('[data-file-preview]');
                preview.textContent = '';
                preview.innerHTML = `<img src="${defaultValue}" alt="">`;
            }
            this.applyUploadedImageToIframe(controls,defaultValue);
        } else {
            this.inputs[controls].value = defaultValue;

            // If we're reverting a checkbox, we need to manually change its checked value. The actual setting field is a text input, so the checkbox is really just a pseudo input.
            let checkbox = document.getElementById(`${controls}__checkbox`);
            if (checkbox){
                checkbox.checked = (defaultValue === "1") ? true : false;
            }
        }

        // Ensure the reverted (default) value overwrites the saved value from CSS if it exists
        this.settings.vars[controls] = defaultValue;

        // Dispatch change event so we can update iframe preview
        // We skip this for images because that expects a file upload
        if (fieldType !== "image"){
            this.inputs[controls].dispatchEvent(new Event("change", {bubbles: true}));
        }

        // Rebuild <style> element
        this.buildVariablesStyleTag();

        // rebuild custom CSS in case anything depends on variables
        this.updateCustomCSS();
    }

    /**
     * Refresh the iframe if settings require it
     * @param {Event} e 
     */
    refreshIframe(e)  {
        // Add the new selection to the settings object
        this.settings.vars[e.target.name] = e.target.value;

        // store the latest session data
        ips.fetch( '?app=core&module=system&controller=themeeditor', {method: 'post', data:{do: 'store', data: this.settings }});

        // Add loading icon to iframe
        this.setAttribute('data-loading', true);

        // Remove the loading animation after 3 seconds incase it hasn't already been removed from the load event.
        // This can sometimes happen if the iframe has trouble loading due to other errors.
        setTimeout(() => {
            this.removeAttribute('data-loading');
        }, 3000);

        // ..then reload it so the new layout can be shown
        document.getElementById('themeEditorIframe').contentDocument.location.reload(true);
    }

    /**
     * Apply data-attributes to iframe
     * @param {String} attr The data-attribute
     * @param {String} value The value
     */
    applyDataAttributes(attr, value){
        this.iframe.document.documentElement.setAttribute(attr, value);
    }

    /**
     * iFrame navigation
     */
    iframeSync(){

        // Get <style> tag so we can fill it with our new values
        this.iframeStyleTag = this.iframe.document.getElementById('themeEditorStyles');
        this.iframeTempStyleTag = this.iframe.document.getElementById('themeEditorTempStyles');
        this.iframeCustomCSS = this.iframe.document.getElementById('themeCustomCSS');

        this.buildVariablesStyleTag();

        // Reapply uploaded images
        for(const [setting, value] of Object.entries(this.settings.images)){
            this.applyUploadedImageToIframe(setting, value);
        }

        // apply any unsaved custom CSS
        this.updateCustomCSS();

        // Reapply live text
        for(const [setting, value] of Object.entries(this.settings.text)){
            this.updateLiveText(setting, value);
        }

        // Reapply header positions
        for(const [setting, value] of Object.entries(this.settings.headerPositions)){
            this.repositionHeaderElement(setting, value);
        }
        this.repositionHeaderElementPolyfills();

        // Reapply data-attributes
        for(const [attr, value] of Object.entries(this.settings.dataAttributes)){
            this.applyDataAttributes(attr, value);
        }

        this.removeAttribute('data-loading');

    }

    /**
     * Handle all events (click, input, change, etc). When data-on-click="x", data-on-change="x", data-on-input="x", etc is assigned to an element, the method will run when the event fires.
     * @param {Event} event 
     * @returns Method from the custom element class
     */
    handleEvent(event){

        const target = event.target.closest(`[data-on-${event.type}]`);
        if(!target) return;
        const method = target.getAttribute(`data-on-${event.type}`);

        if(this[`${method}`]){
            return this[`${method}`](event, target)
        } else {
            (window.Debug || console).warn(`The ${method} method, triggered by [data-on-${event.type}="${method}"] was not found`);
        }

    }

    /* Handle drag/reorder elements */
    handleDragStart(e) {
        e.currentTarget.setAttribute('data-dragging', true);
        this.firstDrag = e.currentTarget;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', e.currentTarget.outerHTML); // Required for iOS
    }

    handleDragOver(e) {
        e?.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    handleDragEnter(e) {
        e.currentTarget.setAttribute('data-dropzone', true);
    }

    handleDragLeave(e) {
        e.currentTarget.removeAttribute('data-dropzone');
    }

    handleDrop(e) {
        e?.stopPropagation();

        if (this.firstDrag != e.currentTarget) {
            this.secondDrag = e.currentTarget;
            if (document.startViewTransition){
                document.startViewTransition(() => this.swapDraggables(this.firstDrag, this.secondDrag))
            } else {
                this.swapDraggables(this.firstDrag, this.secondDrag)
            }
        }
        // return false;
    }

    handleDragEnd(e) {
        e.currentTarget.removeAttribute('data-dragging');
        this.dragLabels.forEach(item => item.removeAttribute('data-dropzone'));
    }

    /**
     * Swap the position of header elements once they've been dragged
     * @param {HTMLElement} origin          The origin element
     * @param {HTMLElement} destination     The destination element
     */
    swapDraggables(origin, destination){

        let el = {
            fromName: origin.getAttribute('data-name'),
            fromPos: origin.getAttribute('data-pos'),
            fromDrag: origin.previousSibling,
            toName: destination.getAttribute('data-name'),
            toPos: destination.getAttribute('data-pos'),
            toDrag: destination.previousSibling
        }

        // Reposition draggables
        el.fromDrag.after(destination);
        el.toDrag.after(origin);

        // Swap data-pos
        origin.setAttribute('data-pos', el.toPos);
        destination.setAttribute('data-pos', el.fromPos);

        let input;

        if(input = this.form.querySelector(`[id='${el.fromName}']`)){
            input.value = el.toPos;
            this.settings.vars[input.name] = input.value;
            this.settings.headerPositions[input.name] = input.value;
            this.repositionHeaderElement(input.name, input.value);
        }
        if(input = this.form.querySelector(`[id='${el.toName}']`)){
            input.value = el.fromPos;
            this.settings.vars[input.name] = input.value;
            this.settings.headerPositions[input.name] = input.value;
            this.repositionHeaderElement(input.name, input.value);
        }

        // Reapply :has() selector for empty headers
        this.repositionHeaderElementPolyfills();

        // Update the setting which controls the max height of the logo
        this.updateLogoMaxHeightController();

        // Rebuild variable <style> element (future-proofing for @container style queries)
        this.buildVariablesStyleTag();

        // Setting has been changed. Show dialog if quitting.
        this.unsavedChanges = true;

    }

    repositionHeaderElement(settingName, settingValue){

        let name = settingName.replace(/(^set__i-position-)/gi, ""),
            elementOne = this.iframe.document.querySelector(`[data-ips-header-content='${name}']`),
            destination = this.iframe.document.querySelector(`[data-ips-header-position='${settingValue}']`);

        // If these elements don't exist (ie. when using the sidebar UI), or if this element is already in the right position, return early.
        if (!elementOne || !destination || destination.contains(elementOne)) return;

        // First, find the position where our content currently is..
        const parentOne = elementOne.closest(`[data-ips-header-position]`);

        // Next, append the content to the correct position..
        destination.append(elementOne);

        // If the destination previously contained a child which needs to be moved, move it.
        if(destination.firstElementChild != destination.lastElementChild){
            parentOne.append(destination.firstElementChild);
        }

    }

    /*
        Adjust the visibility of header elements via the [hidden] attribute
    */
    repositionHeaderElementPolyfills(){
        this.iframe.document.querySelectorAll('.ipsHeader__top, .ipsHeader__primary, .ipsHeader__secondary, .ipsHeaderExtra').forEach(h => {
            h.hidden = !h.querySelector('[data-ips-header-content]');
        })
    }

    /**
     * Save changes
     * @param {Event} event
     * @param {HTMLElement} target
     */
    saveChanges(event, target){
        // This disables the unload listener since we're saving the changes
        this.unsavedChanges = false;
        // window.removeEventListener("beforeunload", this.handleBeforeUnload);
    }

    /**
     * Close editor (and check for unsaved changes)
     * @param {Event} e 
     * @param {HTMLElement} target
     */
    closeEditor(e, target){
        ips.utils.cookie.set('themeEditorLocation', document.getElementById('themeEditorIframe').contentDocument.location );
        if(this.unsavedChanges){
            e.preventDefault();
            // Clicking the toggle instead of using showModal() ensures the hidden/aria attributes are updated correctly
            document.getElementById('toggleCloseConfirmationDialog').click();
        }
    }

    /**
     * If there are unsaved changes AND (the confirmation dialog is closed OR a submit button isn't pressed), prevent the page from unloading
     * @param {Event} e 
     */
    handleBeforeUnload(e){
 
        if(this.unsavedChanges && !(document.getElementById('closeConfirmationDialog').open)){
            e.preventDefault();
            e.returnValue = true;
        }
    }

}]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.accordion.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[;((($, _) => {
    "use strict";

    /**
     *
     * @type {Map<Element, Accordion>}
     */
    const accordionMap = new Map();

    /**
     *
     * @typedef {{defaultopen?: "open"|"closed"}} accordionOptions
     */

    /**
     * @type accordionOptions
     */
    const defaults = {
        defaultopen: 'open'
    }

    ips.createModule('ips.ui.accordion', function() {
        ips.ui.registerWidget('accordion', ips.ui.accordion, ['defaultopen', 'alwaysopen'])

        return {
            /**
             * Setup the accordion widget
             *
             * @param elem
             * @param options
             */
            respond(elem, options) {
                // While in the editor, don't do anything here
                if ($(elem).get(0).closest('.ipsEditor__tiptap-wrap')) {
                    return;
                }
                if (!accordionMap.has($(elem).get(0))) {
                    accordionMap.set($(elem).get(0), new Accordion($(elem).get(0), options))
                }
            },

            /**
             * Get the instance of an accordion
             * @param elem
             * @return {Accordion|null}
             */
            getInstance(elem) {
                if (accordionMap.has($(elem).get(0))) {
                    return accordionMap.get($(elem).get(0))
                }
                return null
            },

            /**
             * Clean the contents and destroy the instance
             * @param elem
             */
            destroy(elem) {
                if (this.getInstance(elem)) {
                    accordionMap.delete($(elem).get(0))
                }
            }
        }
    })

    class Accordion {
        /**
         * Create an accordion class; closes the adjacent accordions when this is opened and
         *
         * @param {HTMLDetailsElement}      elem        The element
         * @param {accordionOptions}        options     Options to use
         */
        constructor(elem, options={}) {
            this.options = {...defaults, ...options}
            this.elem = elem

            if (this.options.alwaysopen) {
                this.elem.open = true;
            }

            this.elem.addEventListener('toggle', () => {
                if (this.elem.open && !this.options.alwaysopen) {
                    this.accordionSiblings.forEach(sibling => {
                        sibling.open = false
                    })
                }
            })

            this.summary?.addEventListener('click', e => {
                e.preventDefault()
                this.open = !this.open
            })

            this.summary?.addEventListener('keyup', e => {
                if (['enter', 'space', 'return', ' '].includes(e.key.toLowerCase())) {
                    e.preventDefault()
                    this.open = !this.open
                }
            })
        }

        /**
         * Get the summary element if there is one
         *
         * @return {HTMLElement|null}
         */
        get summary() {
            return this.elem.querySelector(':scope > summary')
        }

        /**
         * @return {boolean}
         */
        get open() {
            return this.elem.open
        }

        /**
         *
         * @param {boolean}     open
         */
        set open(open) {
            open = !!open
            if (this.options.alwaysopen) {
                return
            }

            if (open === this.open) return
            const content = this.elem.querySelector(':scope > :not(summary)')
            if (!content) return;

            this.elem.open = true;
            content.animate([
                {
                    minHeight: 'revert',
                    maxHeight: 'revert',
                    // paddingTop: `${open ? 0 : 1.2}em`,
                    // paddingBottom: `${open ? 0 : 1.2}em`,
                    height: `${open ? 0 : content.getBoundingClientRect().height}px`
                },
                {
                    minHeight: 'revert',
                    maxHeight: 'revert',
                    // paddingTop: `${!open ? 0 : 1.2}em`,
                    // paddingBottom: `${!open ? 0 : 1.2}em`,
                    height: `${!open ? 0 : content.getBoundingClientRect().height}px`
                },
                // this third one is a duplicate of the second so that it's not shown for a split second before the subsequent timeout runs
                {
                    minHeight: 'revert',
                    maxHeight: 'revert',
                    // paddingTop: `${!open ? 0 : 1.2}em`,
                    // paddingBottom: `${!open ? 0 : 1.2}em`,
                    height: `${!open ? 0 : content.getBoundingClientRect().height}px`
                }
            ], {duration: 225})
            setTimeout(() => this.elem.open = open, 150)
        }

        /**
         *
         * @return {Accordion[]}
         */
        get accordionSiblings() {
            let element = this.elem.previousElementSibling
            let siblings = [];
            while (element?.dataset?.ipsaccordion !== undefined) {
                if (ips.ui.accordion.getInstance(element)) {
                    siblings.push(ips.ui.accordion.getInstance(element))
                }
                element = element.previousElementSibling
            }

            siblings = siblings.reverse();
            element = this.elem.nextElementSibling
            while (element?.dataset?.ipsaccordion !== undefined) {
                if (ips.ui.accordion.getInstance(element)) {
                    siblings.push(ips.ui.accordion.getInstance(element))
                }
                element = element.nextElementSibling
            }

            return siblings
        }
    }
})(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.addressForm.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.addressForm.js - Address form element widget
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.addressForm', function(){

		/**
		 * @typedef {{minimize?: boolean, country?: string, requireFullAddress?: boolean}} AddressFormOptions
		 */

		/**
		 *
		 * @type {AddressFormOptions}
		 */
		const defaults = {
			minimize: false,
			country: "",
			requireFullAddress: true
		};

		/**
		 *
		 * @param {jQuery}	elem
		 * @param {AddressFormOptions}	options
		 * @param {Event|undefined}		[e]
		 */
		function respond(elem, options, e) {
			// Don't reinitialize an existing address field
			if( !_.isUndefined( elem.data('initialized') ) ){
				return;
			}

			options = _.defaults( options, defaults );

			if( options.minimize ){
				minimizeAddress( elem, options );
			} else {
				init( elem, options, e );
			}

			elem.data('initialized', true);
		}

		/**
		 *
		 * @param elem
		 * @param options
		 * @param e
		 */
		function init(elem, options, e) {
			// Watch for country changes (so we can change state/region to a select box if appropriate
			elem.on( 'change', '[data-role="countrySelect"]', _.bind( countryChange, e, elem, options ) );
			$( elem ).find('[data-role="countrySelect"]').change();

			// Add a + button for address lines
			recalculateAddAddressLineButton( elem );
		}

		/**
		 * Setup an address form where all the fields are collapsed except for the address line 1. When clicking it, the other options appear and google maps is used to create suggestions
		 *
		 * @param {jQuery}				elem
		 * @param {AddressFormOptions}	options
		 */
		function minimizeAddress(elem, options) {
			const tempInput = $('<input/>')
				.attr('type', 'text')
				.attr('data-role', 'minimizedVersion')
				.addClass('ipsInput')
				.attr('placeholder', ips.getString('specifyLocation'))
				.on('focus', function (e) {
					// Hide the minimized version
					$(this).hide();

					// Set country if applicable
					if (options.country) {
						$(elem).find('[data-role="countrySelect"]').val(options.country);
					}

					// Init
					init(elem, options, e);

					// Show the main address fields
					elem.show().find('input').first().focus();
				});

			const value = [];

			// Build the existing value
			elem.find('input, select').each( function () {
				if( $( this ).val() ){
					if( $( this ).is('select') ){
						value.push( $( this ).find('option[value="' + $( this ).val() + '"]').text().trim() );
					} else {
						value.push( $( this ).val().trim() );
					}
				}

			});

			if (value.length) {
				tempInput.val(value.join(', '));
			}

			elem
				.hide()
				.after( tempInput );
		}

		/**
		 * Handle updates based on the country input being changed. This is also invoked when the module is first initialized to set it up
		 *
		 * @param {jQuery}				elem
		 * @param {AddressFormOptions}	options
		 * @param {Event}				e
		 */
		function countryChange(elem, options, e) {
			ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=ajax&do=states&country=' + $(e.target).val() )
				.done( function (response) {
					let regionSelect;
					let regionText;
					if (response.length) {
						if( !$( elem ).find('[data-role="regionSelect"]').length )
						{
							regionText = $( elem ).find('[data-role="regionText"]');
						}
						else
						{
							regionText = $(elem).find('[data-role="regionSelect"]');
						}

						regionSelect = $('<select class="ipsInput" data-role="regionSelect" />');

						regionSelect.attr( 'name', regionText.attr('name') );

						if ( !options.requireFullAddress ) {
							regionSelect.append( $('<option />').attr( 'value', '' ).html( $( elem ).find('[data-role="regionText"]').attr('placeholder') ) );
						}

						response.forEach?.(region => {
							regionSelect.append( $('<option />').attr('value', region).html(region) );

							if (region.toLowerCase() === regionText.val().toLowerCase() ){
								regionSelect.val(region);
							}
						})

						regionText.replaceWith(regionSelect);
					} else {
						if (!$( elem ).find('[data-role="regionText"]').length) {
							regionSelect = $(elem).find('[data-role="regionSelect"]');
							regionText = $('<input type="text" data-role="regionText" placeholder="' + ips.getString('address_region') + '" />');

							regionText.attr( 'name', regionSelect.attr('name') ).val( "" );
							regionSelect.replaceWith( regionText );
						}
					}
				} );

			if (typeof elem.attr('data-ipsAddressForm-googlePlaces') === 'string') {
				ips.ui.map.afterGoogleMapsLoaded(() => googlePlacesInit(elem))
			}
		}

		/**
		 * Adds an address line to an address form input
		 *
		 * @param {jQuery} elem
		 * @param {string}	value
		 */
		function addAddressLine(elem, value) {
			const lastLine = elem.find('[data-role="addressLine"]').closest('li').last();
			const newLine = lastLine.clone();

			if (value) {
				newLine.find('input').focus().val( value );
			}

			lastLine.after(newLine);
		}

		/**
		 * Setup the add address line button; sets up the click handler
		 * @param {jQuery}	elem
		 */
		function recalculateAddAddressLineButton(elem) {
			elem.find( '[data-role="addAddressLine"]' ).remove();
			const button = $('<i class="fa fa-plus" style="cursor:pointer; margin-left: 4px" data-role="addAddressLine">');

			button.click( function () {
				addAddressLine(elem, '');
				recalculateAddAddressLineButton(elem);
			});

			elem.find('[data-role="addressLine"]').last().after( button );
		}

		/**
		 * Initialize the autocomplete suggestions widget
		 *
		 * @param {jQuery}	elem
		 */
		function googlePlacesInit(elem) {
			const googlePlacesInput = $(elem).find('[data-role="addressLine"]').first();
			const options = {
				types: ['geocode'],
				componentRestrictions: {country: $(elem).find('[data-role="countrySelect"]').val()}
			};

			if (!options.componentRestrictions.country) {
				delete options.componentRestrictions
			}

			const autocomplete = new google.maps.places.Autocomplete(googlePlacesInput.get(0), options);

			googlePlacesInput.on( 'focus', function () {
				if( navigator.geolocation ){
					navigator.geolocation.getCurrentPosition( function (position) {
						const geolocation = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
						autocomplete.setBounds( new google.maps.LatLngBounds( geolocation, geolocation ) );
					});
				}
			} );
			googlePlacesInput.on( 'keypress', function(e) {
				if ((e.which && e.which == 13) || (e.keyCode && e.keyCode == 13)) {
					return false;
				}
			} );

			google.maps.event.addListener( autocomplete, 'place_changed', function () {
				const place = autocomplete.getPlace();

				for (let i = 0; i < $( elem ).find('[data-role="addressLine"]').length; i++) {
					$( elem ).find('[data-role="addressLine"]').val( '' );
				}
				const parsedAddress = $('<div>' + place.adr_address + '</div>');

				const addressLines = [];
				let existingAddressLines = $(elem).find('[data-role="addressLine"]').length;
				if ( parsedAddress.find('.post-office-box').length ) {
					addressLines.push( parsedAddress.find('.post-office-box').text() );
				}
				if ( parsedAddress.find('.street-address').length ) {
					addressLines.push( parsedAddress.find('.street-address').text() );
				}
				if ( parsedAddress.find('.extended-address').length ) {
					addressLines.push( parsedAddress.find('.extended-address').text() );
				}

				for (let i = 0; i < addressLines.length; i++) {
					if( existingAddressLines ){
						$( elem ).find('[data-role="addressLine"]').slice( i, 1 ).focus().val( addressLines[i] );
						existingAddressLines--;
					} else {
						addAddressLine(elem, addressLines[i]);
					}
				}

				if (parsedAddress.find('.locality') ) {
					elem.find('[data-role="city"]').focus().val( parsedAddress.find('.locality').text() );
				}

				if (parsedAddress.find('.region')) {
					elem.find('[data-role="regionText"]').focus().val( parsedAddress.find('.region').text() );

					if ( elem.find('[data-role="regionSelect"] option[value="' + parsedAddress.find('.region').text() + '"]').length ) {
						elem.find('[data-role="regionSelect"]').val( parsedAddress.find('.region').text() );
					} else {
						for (let i in place.address_components ) {
							if ( place.address_components[i].types[0] === 'administrative_area_level_1' || place.address_components[i].types[0] === 'administrative_area_level_2' ) {
								if ( elem.find('[data-role="regionSelect"] option[value="' + place.address_components[i].long_name + '"]').length ) {
									elem.find('[data-role="regionSelect"]').val( place.address_components[i].long_name );
									break;
								} else if ( elem.find('[data-role="regionSelect"] option[value="' + place.address_components[i].short_name + '"]').length ) {
									elem.find('[data-role="regionSelect"]').val( place.address_components[i].short_name );
									break;
								}
							}
						}
					}
				}

				if (parsedAddress.find('.postal-code')) {
					elem.find('[data-role="postalCode"]').focus().val( parsedAddress.find('.postal-code').text() );
				}
			});
		}

		// Register this module as a widget to enable the data API and
		// jQuery plugin functionality
		ips.ui.registerWidget( 'addressForm', ips.ui.addressForm, ['minimize','country','requireFullAddress'] );

		return {
			respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.alert.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.alert.js - Alert widget for alerts, prompts, confirms.
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.createModule('ips.ui.alert', function(){

		var respond = function (elem, options) {
			alertObj( options, elem );
		},

		show = function (options) {
			alertObj( options );
		};

		ips.ui.registerWidget('alert', ips.ui.alert, 
			[ 'message', 'type', 'icon', 'focus' ]
		);

		return {
			respond: respond,
			show: show
		};
	});

	/**
	 * Alert instance
	 *
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var alertObj = function (options) {

		var alert = null,
			modal = null;

		var _defaults = {
			type: 'alert', // alert, confirm, prompt, verify
			message: ips.getString('generic_confirm'),
			buttons: {
				ok: ips.getString('ok'),
				cancel: ips.getString('cancel'),
				yes: ips.getString('yes'),
				no: ips.getString('no')
			},
			icon: 'info',
			showIcon: true,
			callbacks: {}
		};

		var _icons = {
			warn: 'fa-solid fa-triangle-exclamation',
			success: 'fa-solid fa-check-circle',
			info: 'fa-solid fa-circle-info',
			ok: 'fa-solid fa-check-circle',
			question: 'fa-solid fa-circle-question'
		};

		options = _.defaults( options || {}, _defaults );

		/**
		 * Initialization
		 *
		 * @returns {void}
		 */
		var init = function () {
			// Build alert
			_buildAlert();
			_setUpEvents();
		},

		/**
		 * Set up events for the alert - button clicks, and document events for keyboard accessibility
		 *
		 * @returns {void}
		 */
		_setUpEvents = function () {
			alert.on( 'click', '[data-action]', _clickButton );
			$( document ).on('keydown', _keyPress);
		},

		/**
		 *
		 * @param {KeyboardEvent}	e
		 * @private
		 */
		_keyPress = function(e) {
			if (!alert.get(0) || !document.documentElement.contains(alert.get(0))) {
				$(document).off('click', _keyPress);
			}
			let toClick;
			switch (e.key) {
				case 'Escape':
					toClick = alert.find(options.type === 'alert' ? '[data-action=&quot;ok&quot;]' : '[data-action=&quot;cancel&quot;], [data-action=&quot;no&quot;]').get(0);
					break;
				case 'Enter':
					toClick = alert.find('[data-action=&quot;ok&quot;], [data-action=&quot;yes&quot;]').get(0);
					break;
			}

			if (toClick) {
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation?.();
				toClick.click();
			}
		},

		/**
		 * Event handler for clicking a button in the alert
		 * Looks for a callback to execute, then removes the alert from the dom
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		_clickButton = function (e) {
			var button = $( e.currentTarget );
			var action = button.attr('data-action');
			var value = null;

			if( options.type == 'prompt' ){
				value = alert.find('[data-role=&quot;promptValue&quot;]').val();
			}

			if( _.isFunction( options.callbacks[ action ] ) ){
				options.callbacks[ action ]( value );
			}

			_remove();
		},

		/**
		 * Removes the alert from the dom and unsets the events
		 *
		 * @returns {void}
		 */
		_remove = function () {
			$(document).off('keydown', _keyPress);
			modal.remove();

			ips.utils.anim.go( 'fadeOutDown fast', alert ).done( function () {
				alert.remove();
			});
		},

		/**
		 * Builds the alert element based on options
		 *
		 * @returns {void}
		 */
		_buildAlert = function () {

			var parts = {},
				buttons = [];

			// Icon
			if( options.showIcon ){
				parts.icon = ips.templates.render( 'core.alert.icon', {
					icon: _icons[ options.icon ] || options.icon
				});
			}

			parts.id = 'alert_' + ( Math.round( Math.random() * 10000000 ) );
			parts.text = options.message;

			if( options.subText ){
				parts.subtext = ips.templates.render( 'core.alert.subText', {
					text: options.subText
				});
			}

			if( options.subTextHtml ){
				parts.subtext = ips.templates.render( 'core.alert.subTextHtml', {
					text: options.subTextHtml
				});
			}

			// Build buttons
			switch( options.type ){
				case 'alert':
					buttons.push( ips.templates.render( 'core.alert.button', {
						action: 'ok',
						title: options.buttons.ok,
						extra: 'ipsButton--primary'
					}));
				break;
				case 'confirm':
				case 'prompt':
					buttons.push( ips.templates.render( 'core.alert.button', {
						action: 'ok',
						title: options.buttons.ok,
						extra: 'ipsButton--primary'
					}));
					buttons.push( ips.templates.render( 'core.alert.button', {
						action: 'cancel',
						title: options.buttons.cancel,
						extra: 'ipsButton--inherit'
					}));
				break;
				case 'verify':
					buttons.push( ips.templates.render( 'core.alert.button', {
						action: 'yes',
						title: options.buttons.yes,
						extra: 'ipsButton--primary'
					}));
					if( options.buttons.no ){
						buttons.push( ips.templates.render( 'core.alert.button', {
							action: 'no',
							title: options.buttons.no,
							extra: 'ipsButton--inherit'
						}));
					}
					if( options.buttons.cancel ){
						buttons.push( ips.templates.render( 'core.alert.button', {
							action: 'cancel',
							title: options.buttons.cancel,
							extra: 'ipsButton--inherit'
						}));
					}
				break;
			}

			parts.buttons = buttons.join('');

			// Prompt?
			if( options.type == 'prompt' ){
				parts.text += ips.templates.render( 'core.alert.prompt');
			}

			// Build box
			var tmpAlert = $.parseHTML( ips.templates.render( 'core.alert.box', parts ).trim() );
			alert = $( tmpAlert[0] );
			$('body').append( alert );

			// Build modal
			modal = ips.ui.getModal();
			modal.css({ zIndex: ips.ui.zIndex() }).show();

			alert.css( { zIndex: ips.ui.zIndex() } );
			ips.utils.anim.go('zoomIn fast', alert );

			// Focus the appropriate element
			if( options.focus ){
				alert
					.find('[data-action=&quot;' + options.focus + '&quot;]')
						.focus();
			} else {
				if( options.type == 'prompt' ){
					alert
						.find('[data-role=&quot;promptValue&quot;]')
							.val( options.value || '' )
							.focus();
				} else {
					alert
						.find('[data-action=&quot;ok&quot;], [data-action=&quot;yes&quot;]')
							.focus();
				}
			}
		};

		init();

	};
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.alertMessage.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.alertMessage.js - Handle an alert message created in the ModeratorCP
 *
 * Author: Matt Finger
 */
;(function($,_) {
    "use strict";

    ips.createModule('ips.ui.alertMessage', () => {
        class AlertMessage extends ips.ui.BaseWidget {
            constructor(...args) {
                super(...args);
                this.form?.addEventListener('submit', this.remoteSubmit.bind(this), {capture: true});
                this.element.addEventListener('click', this.remoteSubmit.bind(this), {capture: true});
                this.element.addEventListener('ips:editorUpdated', () => {
                    this.element.querySelector('[data-role="reply"]').removeAttribute('disabled')
                }, {once: true})
            }

            /**
             * The form element
             * @return {HTMLFormElement|undefined}
             */
            get form() {
                return this.element?.querySelector('form') || (this.element instanceof HTMLFormElement ? this.element : undefined);
            }

            /**
             * @return {string|undefined}
             */
            get url() {
                return this.element?.querySelector('[data-role="reply"]')?.getAttribute('href') || this.form?.getAttribute('action');
            }

            /**
             * Handle the remote submission of this element
             *
             * @param {SubmitEvent|MouseEvent|Event} e
             */
            async remoteSubmit(e) {
                if (e.type === 'submit' || e.target.closest('input[type="submit"],form button:not([type="button"]), a:is([data-role="dismiss"], [data-role="reply"])')) {
                    e.preventDefault();

                    if (e.target.closest('[disabled]')) {
                        return;
                    }

                    if (e.type === 'submit' || e.target.closest('[data-role="reply"]')) {
                        const url = this.url;
                        const form = this.form;
                        if (url && form) {
                            const data = Object.fromEntries((new FormData(form)).entries());
                            try {
                                const response = await ips.fetch(url, {
                                    method: form.method || 'post',
                                    data,
                                    bypassRedirect: true,
                                });

                                if (typeof response?.redirect === 'string') {
                                    setTimeout(() => {
                                        ips.ui.alert.show({
                                            message: ips.getString('moderator_alert_reply_ready'),
                                            type: 'confirm',
                                            buttons: {
                                                ok: ips.getString('moderator_alert_reply_view'),
                                                cancel: ips.getString('ok')
                                            },
                                            callbacks: {
                                                ok() {
                                                    window.location = response.redirect;
                                                }
                                            }
                                        });
                                    });
                                }
                            } catch (e) {
                                Debug.warn(e);
                            }
                        }
                    } else {
                        // in this case, we're closing the form
                        const url = e.target.closest('a[data-role="dismiss"]')?.getAttribute('href');
                        try {
                            if (url) {
                                await ips.fetch(url, {
                                    method: 'get',
                                    bypassRedirect: true,
                                });
                            } else {
                                throw new Error(`Failed to get the dismiss ajax url of a notification`);
                            }
                        } catch (e) {
                            e.message = `Failed to set the status as dismissed.\n${e.message}`;
                            Debug.warn(e)
                        }
                    }

                    this.destruct();
                    this.element.remove();
                }
            }
        }

        return AlertMessage.buildModuleAndRegisterWidget('alertMessage');
    })
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.autoCheck.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.autoCheck.js -Enables easy 'filtering' of checkboxes in tables
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.autoCheck', function(){

		var defaults = {};

		var respond = function (elem, options) {
			if( !$( elem ).data('_autoCheck') ){
				$( elem ).data('_autoCheck', autoCheckObj(elem, _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Destruct the autoCheck widgets in elem
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		},

		/**
		 * Retrieve the autoCheck instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The autocheck instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_autoCheck') ){
				return $( elem ).data('_autoCheck');
			}

			return undefined;
		};

		ips.ui.registerWidget('autoCheck', ips.ui.autoCheck, 
			[ 'context' ]
		);

		return {
			respond: respond,
			getObj: getObj,
			destruct: destruct
		};
	});

	/**
	 * autoCheck instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var autoCheckObj = function (elem, options) {
		/**
		 * Store a count of items from other pages
		 */
		var initialCount = 0;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			if( options.context && $( options.context ).length ){
				elem.on('menuItemSelected', clickedMenu); // Watch for the menu event
				$( options.context ).on( 'change', 'input[type="checkbox"][data-state]', _updateCount);
			}

			elem.on('refresh.autoCheck', refresh);
			elem.on('setInitialCount.autoCheck', setInitialCount);
			elem.find('[data-role="autoCheckCount"]').hide();
		},

		/**
		 * Destruct
		 * Removes event handlers assosciated with this instance
		 *
		 * @returns {void}
		 */
		destruct = function () {
			if( options.context ){
				$( options.context ).off( 'change', 'input[type="checkbox"][data-state]', _updateCount );
			}
		},

		/**
		 * Refreshes the autocheck
		 *
		 * @returns {void}
		 */
		refresh = function () {
			_updateCount();
		},

		/**
		 * Set the initial count
		 *
		 * @returns {void}
		 */
		setInitialCount = function ( e, data ) {
			initialCount = data.count;
			_updateCount();
		},

		/**
		 * One of the selection options has been chosen from the menu
		 *
		 * @param	{event} 	e 			The event object
		 * @param	{object} 	data 		The event data object from the menu widget
		 * @returns {void}
		 */
		clickedMenu = function (e, data = e.detail) {
			
			if( !_.isUndefined( data.originalEvent ) ){
				data.originalEvent.preventDefault();
			}

			// Make sure we have a value
			if( !data.selectedItemID ){
				return;
			}

			var checkboxes = $( options.context ).find(':checkbox[data-state]');

			if( data.selectedItemID == 'all' ){
				checkboxes.prop( 'checked', true );
			} else if( data.selectedItemID == 'none' ){
				checkboxes.prop( 'checked', false );
			} else {
				checkboxes
					.prop( 'checked', false )
					.filter( '[data-state~="' + data.selectedItemID + '"]' )
						.prop( 'checked', true );
			}

			// Trigger an event
			checkboxes.trigger('change');

			var count = _updateCount();

			// Trigger an event
			elem.trigger('autoChecked', {
				menu: elem,
				currentFilter: data.selectedItemID,
				count: count
			});
		},

		/**
		 * Updates the count of selected items
		 *
		 * @returns {number}	Count of selected items
		 */
		_updateCount = function () {
			var checkboxes = $( options.context ).find(':checkbox[data-state]');

			// Now get an up to date count
			var count = $( options.context ).find(':checkbox[data-state]:checked');

			if( count.length == checkboxes.length && checkboxes.length !== 0 ){
				elem.find('.cAutoCheckIcon').html('<i class="fa-solid fa-check-square"></i>');
			} else if( count.length === 0 ){
				elem.find('.cAutoCheckIcon').html('<i class="fa-regular fa-square"></i>');
			} else {
				elem.find('.cAutoCheckIcon').html('<i class="fa-solid fa-minus-square"></i>');
			}

			var countToDisplay = count.length + initialCount;

			if( countToDisplay ){
				elem.find('[data-role="autoCheckCount"]').text( countToDisplay ).show();
			} else if( elem.find('[data-role="autoCheckCount"]').is(':visible') ) {
				// We use a timeout because more than one setInitialCount call can be sent, so if a 0 comes in and then a 1, the fadeout will take
				// too long and a hide() call will occur after the show() call above since the fadeOut takes time.
				setTimeout( function(){
					if( !initialCount )
					{
						ips.utils.anim.go( 'fadeOut', elem.find('[data-role="autoCheckCount"]') );
					}
				}, 300 );
			}

			return count.length;
		};

		init();

		return {
			destruct: destruct,
			refresh: refresh
		};
	};

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.autocomplete.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.autocomplete.js - Autocomplete widget for text fields
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.autocomplete', function(){

		const defaults = {
			multiValues: true,
			freeChoice: true,
			itemSep: { chr: ',', keycode: 188, charcode: 44 },
			disallowedCharacters: JSON.stringify( [ "<", ">", "'", "\"" ] ),
			unique: false,
			customValues: true,
			fieldTemplate: 'core.autocomplete.field',
			resultsTemplate: 'core.autocomplete.resultWrapper',
			resultItemTemplate: 'core.autocomplete.resultItem',
			tokenTemplate: 'core.autocomplete.token',
			addTokenTemplate: 'core.autocomplete.addToken',
			addTokenText: ips.getString( 'add_tag' ),
			queryParam: 'q',
			forceLower: false,
			minLength: 1,
			minAjaxLength: 1,
			commaTrigger: true,
			searchFieldThreshold: 10,
			suggestionsOnly: false
		};

		function respond (elem, options) {
			if( !$( elem ).data('_autocomplete') ){
				$( elem ).data('_autocomplete', autocompleteObj(elem, _.defaults( options, defaults ) ) );
			}
		}

		/**
		 * Destruct the autocomplete widget on this elem
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		function destruct (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		}

		/**
		 * Retrieve the autocomplete instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The dialog instance or undefined
		 */
		function getObj (elem) {
			elem = $( elem );

			if( elem.data('_autocomplete') ){
				return elem.data('_autocomplete');
			} else if(  $( '[name="' + elem.attr('name') + '_original' + '"]' ).length &&  $( '[name="' + elem.attr('name') + '_original' + '"]' ).data('_autocomplete') ){
				return  $( '[name="' + elem.attr('name') + '_original' + '"]' ).data('_autocomplete');
			}

			return undefined;
		}

		ips.ui.registerWidget('autocomplete', ips.ui.autocomplete, [
			'multiValues',
			'freeChoice',
			'dataSource',
			'maxItems',
			'itemSep',
			'resultsElem',
			'unique',
			'commaTrigger',
			'fieldTemplate',
			'resultsTemplate',
			'resultItemTemplate',
			'tokenTemplate',
			'addTokenTemplate',
			'addTokenText',
			'queryParam',
			'minLength',
			'maxLength',
			'forceLower',
			'disallowedCharacters',
			'minAjaxLength',
			'suggestionsOnly'
		]);

		return {
			respond: respond,
			destruct: destruct,
			getObj: getObj
		};
	});

	/**
	 * autocomplete instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	function autocompleteObj(elem, options, e) {

		let timer,
			blurTimer,
			lastValue = '',
			originalTextField,
			valueField,
			textField,
			dataSource,
			elemID = $( elem ).identify().attr('id'),
			wrapper,
			inputItem,
			resultsElem,
			selectedToken,
			disabled = false,
			required = false,
			tooltip = null,
			tooltipTimer = null,
			mouseOverResults = false,
			hasError = false;

		let _visible=false;
		let cleanupQueue = [];

		/**
		 * Resize observer that watches for
		 * @type {ResizeObserver}
		 * @private
		 */
		const _resizeObserver = new ResizeObserver(entries => {
			for (const entry of [...entries].reverse()) {
				if (entry.target instanceof HTMLElement && resultsElem && resultsElem.get(0) === entry.target) {
					_visible = !!(entry.borderBoxSize?.[0]?.blockSize && entry.borderBoxSize?.[0]?.inlineSize);
					break;
				}
			}
		});

		cleanupQueue.push(() => _resizeObserver.disconnect());

		/**
		 * Sets up this instance. The datasource object is chosen depending on what options and/or
		 * attributes are provided. We can fetch results from a local <datalist>, remotely via ajax
		 * or not look up results from a data source at all.
		 *
		 * @returns 	{void}
		 */
		function init() {
			if( $( elem ).is('textarea, input[type="text"], input[type="search"]') ){
				originalTextField = $( elem );
			} else {
				originalTextField = $( elem ).find('textarea, input[type="text"], input[type="search"]').first();
			}

			try {
				options.disallowedCharacters = $.parseJSON( options.disallowedCharacters );
			} catch (err) {
				Debug.error("Couldn't parse disallowed characters option");
			}

			// Add our autocomplete wrapper to the page, and move the element into it
			_buildWrapper();

			// Set up the data source for this control
			_getDataSource();

			// Remove list from original field
			originalTextField.removeAttr('list');

			// Build the list
			if( dataSource.type != 'none' ){
				_buildResultsList();

				if( dataSource.type == 'local' )
				{
					_initAutocomplete();
				}

				// Set up events
				$([...resultsElem.find('input[type="search"]'), ...textField]).each(function() {
					this.addEventListener('input', _keyupAutocomplete);
					cleanupQueue.push(() => this.removeEventListener('input', _keyupAutocomplete));
				});
			}

			// Not sure why this is here, but it breaks toggles when the field is disabled by default
			// if( originalTextField.is(':disabled') ){
			// 	disabled = true;
			// }

			if( originalTextField.is('[required]') ){
				required = true;
				originalTextField
					.removeProp('required')
					.removeAttr('aria-required');
			}

			// Turn off autocomplete and spellcheck so the browser menu doesn't get in the way
			textField
				.prop( 'autocomplete', 'off' )
				.prop( 'spellcheck', false )
				.prop( 'disabled', disabled )
				.attr( 'aria-autocomplete', 'list' )
				.attr( 'aria-haspopup', 'true' )
				.attr( 'tabindex', originalTextField.attr('tabindex') || '' );

			if( options.maxLength ){
				textField.attr( 'maxlength', options.maxLength + 1 );
			}

            wrapper.click(function(e) {
				e.stopPropagation();
				return false;
			});

			// Set up events
			textField
				.on( 'focus', _focusField )
				.on( 'blur', _blurField )
				.on( 'keydown', _keydownField )
				.on( 'keyup', _keyupField )
				.on( 'keypress', _keypressField );

			wrapper
				.on( 'click', '[data-action="addToken"]', _clickAddToken )
				.on( 'keydown', _keydownWrapper )
				.on( 'propChanged', _propChanged )
				.toggleClass( 'ipsField_autocompleteDisabled', disabled );

			cleanupQueue.push(() => {
				// Clean up events
				textField
					.off( 'focus', _focusField )
					.off( 'blur', _blurField )
					.off( 'keydown', _keydownField )
					.off( 'keyup', _keyupField )
					.off( 'keypress', _keypressField );

				wrapper
					.off( 'click', '[data-action="addToken"]', _clickAddToken )
					.off( 'keydown', _keydownWrapper )
					.off( 'propChanged', _propChanged )
			})

			_buildInitialTokens();

			const onBlur = () => {
				// For closed tagging, our text field is the same element as the autocomplete widget
				// In that case, we don't want to blur otherwise we go into a death loop.
				if( textField !== elem ){
					textField.trigger('blur');
				}
			}

			elem
				.on( 'blur', onBlur)
				.trigger( 'autoCompleteReady', {
					elemID: elemID,
					elem: elem,
					currentValues: tokens.getValues()
				});

			// Some widgets like prefixedAutocomplete may not set up until after this UI module runs, so make sure we trigger the 'ready' event when needed
			elem.on( 'reissueReady', function() {
				elem.trigger( 'autoCompleteReady', {
					elemID: elemID,
					elem: elem,
					currentValues: tokens.getValues()
				});
			});

			cleanupQueue.push(() => {
				elem.off('blur', onBlur);
				elem.off('reissueReady');
			});
		}
		
		/**
		 * Destruct
		 * Removes event handlers assosciated with this instance
		 *
		 * @returns {void}
		 */
		function destruct() {
			cleanupQueue.forEach(cb => cb());
			cleanupQueue = [];
			$( document ).off( 'click', _documentClick );
		}

		/**
 		 * Determines whether any errors are present in the autocomplete widget (e.g. duplicates)
		 *
		 * @returns {void}
		 */
		function hasErrors() {
			return hasError;
		}

		/**
 		 * Responds to the propChange event, which we use to determine whether the original field has been toggled
		 *
		 * @returns {void}
		 */
		function _propChanged(e) {
			disabled = originalTextField.is(':disabled');

			wrapper.toggleClass( 'ipsField_autocompleteDisabled', disabled );
		}

		/**
 		 * Builds tokens from whatever values exist in the original text field
		 *
		 * @returns {void}
		 */
		function _buildInitialTokens () {
			var value = _getOriginalValue();
			
			if( !value ){
				return;
			}

			// Get individual values
			var splitValues = _.without( value.split( "\n" ), '' );
			var itemCount = 0;
			itemCount = splitValues.length;
			
			// Clear field, as tokens.add() will re-add value
			originalTextField.val('');

			if( splitValues.length ){
				for( var i = 0; i < itemCount; i++ ){
					_addToken( splitValues[i] );
				}
			}
		}

		/**
 		 * Returns the value from the original text field (i.e. the value provided by the backend on pag load)
		 *
		 * @returns {string}
		 */
		function _getOriginalValue () {
			return originalTextField.val();
			//return _.unescape( originalTextField.val() ).replace("&#039;", "'").replace("&apos;", "'");
		}

		/**
 		 * Builds the element that results will appear in
		 *
		 * @returns {void}
		 */
		function _buildResultsList () {
			if( options.resultsElem && $( options.resultsElem ).length ){
				resultsElem = $( options.resultsElem );
				_resizeObserver.observe(resultsElem.get(0), {box: 'border-box'});
				return;
			}

			var resultsList = ips.templates.render( options.resultsTemplate, {
				id: elemID
			});

			wrapper.append( resultsList );

			resultsElem = $('#' + elemID + '_results');

			resultsElem
				.on('mouseover', '[data-value]', function (e) {
					results.select( $( e.currentTarget ) );
				})
				.on('mouseenter', function () {
					mouseOverResults = true;
				})
				.on('mouseleave', function () {
					mouseOverResults = false;
				})
				.on('click', '[data-value]', function (e) {
					_addToken( $( e.currentTarget ).attr('data-value') );
					textField.focus();
				})
				.attr( 'aria-busy', 'false' );
			_resizeObserver.observe(resultsElem.get(0), {box: "border-box"});
		}

		/**
		 * Builds an autocomplete search field for the list of tokens
		 *
		 * @returns {void}
		 */
		function _initAutocomplete () {
			if( dataSource.totalItems() > options.searchFieldThreshold && !options.freeChoice ){
				var searchField = ips.templates.render( 'core.autocomplete.searchTypeAhead', {} );

				$(resultsElem).prepend( searchField );
			}
		}

		/**
		 * Character entered in the autocomplete field - update our results
		 *
		 * @param {InputEvent}	e
		 *
		 * @returns {void}
		 */
		const _keyupAutocomplete = _.throttle(function(e) {
			_loadResults(e.target.value);
			return true;
		}, 200);

		/**
 		 * Builds the wrapper element that looks like a text input, but allows us to insert
 		 * items as tokens
		 *
		 * @returns {void}
		 */
		function _buildWrapper () {
			var existingClasses = elem[0].className;
			
			$( elem )
				.after( ips.templates.render( options.fieldTemplate, {
					id: elemID
				}))
				.removeClass( existingClasses );

			wrapper = $(elem).parent().find( '#' + elemID + '_wrapper' );
			inputItem = $(wrapper).find( '#' + elemID + '_inputItem' );

			// If users have to choose from a predefined list, we'll hide the text field
			// and build a link which will show the results panel
			if( !options.freeChoice ){
				var insertElem = ips.templates.render(options.addTokenTemplate, {
					text: options.addTokenText
				});

				textField = elem;
			} else {
				var insertElem = $('<input/>').attr( {
					type: 'text',
					id: elemID + '_dummyInput'
				})
				.prop( 'autocomplete', 'off' );

				textField = insertElem;
			}

			// prevent the submission when the input is invalid
			if (options.suggestionsOnly) {
				const form = $(elem).closest('form').get(0)
				if (form) {
					const onSubmit = e => {
						// If there is a result that is not a token from autocomplete, prevent the submission
						if (_getCurrentValue() && !( $(elem).get(0).closest('.ipsFieldRow[hidden]') )) {
							e.preventDefault()
							e.stopPropagation()
							const warning = $(elem).get(0).closest('.ipsFieldRow__content')?.querySelector(".ipsFieldRow__warning")
							if (warning) {
								warning.innerHTML = ips.getString('form_autocomplete_bad')
							}
						}
					};
					form.addEventListener('submit', onSubmit);
					cleanupQueue.push(() => form.removeEventListener("submit", onSubmit));
				}
			}

			// Make a copy of the original text field using its name. This is because it's difficult to set
			// arbitrary values in the original text field later if it's associated with a datalist.
			var name = originalTextField.attr('name');

			originalTextField.attr( 'name', originalTextField.attr('name') + '_original' );
			valueField = $('<textarea/>').attr( 'name', name ).hide();

			originalTextField.hide();

			// Move any classnames on the original element onto our new wrapper to maintain styling,
			// then move the original element into our reserved list element
			wrapper
				.addClass( existingClasses )
				.append( elem )
				.append( valueField );

			inputItem
				.append( insertElem );

			wrapper.on('click', handleWrapperClick);
			cleanupQueue.push(() => wrapper.off('click', handleWrapperClick));
		}

		/**
		 * Handle a click on the wrapper
		 *
		 * @param {Event} e		The jquery click event
		 */
		function handleWrapperClick(e) {
			if (e.target instanceof HTMLElement && e.target.dataset.action === 'delete') {
				_deleteToken($(e.target.closest(`[data-value]`)));
			} else if (e.target instanceof HTMLElement && e.target.dataset.value !== undefined && !disabled) {
				tokens.select($(e.target));
			}
		}

		/**
 		 * Gets the apprioriate data source for this control
		 *
		 * @returns {void}
		 */
		function _getDataSource () {
			if( ( options.dataSource && options.dataSource.indexOf('#') === 0 && $( options.dataSource ).length ) ||
					originalTextField.is('[list]') ){
				dataSource = localData( 
					originalTextField.is('[list]') ? $('#' + originalTextField.attr('list') ) : options.dataSource,
					options
				);
			} else if( ips.utils.validate.isUrl( options.dataSource ) ){
				dataSource = remoteData( options.dataSource, options );
			} else {
				dataSource = noData();
			}
		}

		/**
 		 * When the wrapper is clicked, we see if a token was clicked. If it was, select it. If not, focus the textbox.
		 *
		 * @returns {void}
		 */
		function _clickWrapper (e) {
			if( $( e.target ).is('[data-token]') || $( e.target ).parents('li[data-token]').length ){
				var token = ( $( e.target )  );
			} else {				
				if( !$( e.target ).is( textField ) && ( !resultsElem || !$.contains( resultsElem.get(0), e.target ) ) ){
					textField.focus();
				}
			}
		}

		/**
 		 * Event handler for focusing on the text field
		 *
		 * @returns {void}
		 */
		function _clickAddToken (e) {
			e.preventDefault();

			if (_visible) {
				_closeResults();
			} else {
				_loadResults('');
			}
		}

		/**
 		 * Focus the autocomplete field
		 *
		 * @returns {void}
		 */
		function focus (e) {
			textField.focus();
		}

		/**
 		 * Event handler for focusing on the text field
		 *
		 * @returns {void}
		 */
		function _focusField (e) {
			// If there are no results, or the result panel is already visible, don't show it on focus
			if (dataSource.type === 'none' || _visible) {
				return;
			}

			_timerFocusField();
			// we don't need this; we use a debounced keypress event
			// timer = setInterval( _timerFocusField, 400 );
		}

		/**
 		 * Event handler for blurring on the text field
		 *
		 * @returns {void}
		 */
		function _blurField (e) {
			if( mouseOverResults ){
				return;
			}
			
			clearInterval( timer );

			_.delay( _timerBlurField, 300 );
		}

		/**
 		 * Timed event hides the results list
		 *
		 * @returns {void}
		 */
		function _timerBlurField () {
			// See #47772
			/*if( dataSource.type == 'none' ){
				return;
			}*/

			if( textField.val() ){
				_addTokenFromCurrentInput();
			}

			_closeResults();
		}

		/**
 		 * Timed event, checks whether the value has changed, and fetches the results
		 *
		 * @returns {void}
		 */
		function _timerFocusField () {
			if( dataSource.type == 'none' ){
				return;
			}

			// Fetch the current item value
			var currentValue = _getCurrentValue();

			// If the value hasn't changed, we can leave
			if( currentValue == lastValue ){
				return;
			}

			lastValue = currentValue;

			_loadResults( currentValue );
		}

		/**
		 * Show the results list
		 * @template T
		 * @param {function:T}		[cb]		Callback to urn after showing/hiding the element. Only called if the element is actually shown
		 * @return {T}
		 * @private
		 */
		function _show(cb) {
			if (!_visible) {
				_visible = true;
				resultsElem?.show();
				return cb?.();
			}
		}

		/**
		 * Hide the results list
		 * @template T
		 * @param {function:T}        [cb]        Callback to urn after showing/hiding the element. Only called if the element is actually hidden
		 * @return {T}
		 * @private
		 */
		function _hide(cb) {
			if (_visible) {
				_visible = false;
				resultsElem?.hide();
				return cb?.();
			}
		}

		/**
 		 * Requests results from the data source, and shows/hides the loading widget
 		 * while that is happening.
		 *
		 * @returns {Promise<void>}
		 */
		async function _loadResults (value) {
			// is the value long enough
			if (dataSource.type === 'remote' && typeof options.minAjaxLength === "number" && value.length < options.minAjaxLength) {
				_hide(() => {
					resultsElem.attr( 'aria-busy', 'false' );
					_toggleLoading('hide');
				});

				return;
			}

			_show(() => {
				_toggleLoading('show');

				// Set elem to busy
				resultsElem.attr( 'aria-busy', 'true' );
			});

			// Get the results
			try {
				let results = (await dataSource.getResults(value));
				if (dataSource.type === 'local') {
					results = results?.slice(0,100);
				}
				_showResults(_processResults(results, value));
			} catch (e) {
				Debug.warn(e)
			}

			resultsElem.attr( 'aria-busy', 'false' );
			_toggleLoading('hide');
		}

		/**
 		 * Toggles the loading thingy in the control to signify data is loading
		 *
		 * @param 	{string} 	doWhat 	 Acceptable values: 'show' or 'hide'
		 * @returns {void}
		 */
		function _toggleLoading (doWhat) {
			if( doWhat == 'show' ){
				wrapper.addClass('ipsField_loading');
			} else {
				wrapper.removeClass('ipsField_loading');
			}
		}

		/**
 		 * Closes the suggestions menu, sets the aria attrib, and tells the data source
 		 * to stop loading new results
		 *
		 * @param {Event}		[e]
		 *
		 * @returns {void}
		 */
		function _closeResults (e) {
			e?.preventDefault();

			if( resultsElem && resultsElem.length ){
				_hide(() => {
					resultsElem.attr('aria-expanded', 'false');
				});

				if( resultsElem.find('input[type="search"]').length ){
					resultsElem.find('input[type="search"]').val('');
				}
			}

			dataSource.stop();
			$(document).off('click', _documentClick)
		}

		/**
 		 * Handles a click on the document, closing the results dropdown
		 *
		 * @param {{originalEvent: PointerEvent|MouseEvent}}	event		The jQuery event
		 *
		 * @returns {void}
		 */
		function _documentClick ({originalEvent: e}) {
			if (!resultsElem && !textField) {
				return;
			}

			if (!_visible) {
				return;
			}
			let target = e.target;
			const _resultElem = resultsElem ? $(resultsElem).get(0) : undefined;
			const _textField = textField ? $(textField).get(0) : undefined;
			while(target instanceof HTMLElement) {
				if (target === _resultElem || target === _textField) {

					return;
				}
				target = target.parentElement;
			}
			_closeResults();
		}

		/**
 		 * Processes the results that are returned by the data source
		 *
		 * @param {AutocompleteResult[]|undefined|null}	results
		 * @param {string}		text
		 *
		 * @returns {AutocompleteResult[]|Object.<string, AutocompleteResult>}
		 */
		function _processResults (results, text) {
			const existingTokens = tokens.getValues(),
				newResults = {};

			if( options.unique ){
				$.each( results, function (key, data) {
					let processedValue = _.escape(data.value).trim();
					if( options.forceLower ){
						processedValue = processedValue.toLowerCase();
					}
					if( !data.value || (_.indexOf( existingTokens, data.value ) === -1 && _.indexOf( existingTokens, processedValue ) === -1 ) ){
						newResults[ key ] = data;
					}
				});

				return newResults;
			}

			return results;
		}

		/**
 		 * Gets the current item value from the text field
		 *
		 * @param {(string|*)[]}	results		The results
		 *
		 * @returns {string}
		 */
		function _showResults (results) {

			var output = '';

			$.each( results, function (idx, value) {
				output += ips.templates.render( options.resultItemTemplate, value );
			});
			
			if( resultsElem.attr('id') == ( elemID + '_results' ) ){
				_positionResults();
			}

			// no need for the following because we just set the inner html
			// We need to clear out the results element, but without removing our search field if it's present
			// resultsElem.find('[data-role="items"] li').remove();

			resultsElem
				.show()
				.attr('aria-expanded', 'true')
				.find('[data-role="items"]')
					.html( output );

			// Toggle the No results message
			resultsElem.find('[data-role="noresults"]').prop('hidden', Boolean(Object.keys(results).length));

			if( resultsElem.find('input[type="search"]').length ){
				resultsElem.find('input[type="search"]').focus();
			}

			// Allow the results to hide after they are visible; remove then add the listener prevents the listener from being added multiple times
			$( document ).off( 'click', _documentClick )
			let timeout = setTimeout(() => $( document ).on( 'click', _documentClick ));
			cleanupQueue.push(() => clearTimeout(timeout));
		}

		/**
 		 * Sizes and positions the results menu to match the wrapper
		 *
		 * @returns {void}
		 */
		function _positionResults () {
			ips.ui.zIndex();
		}

		/**
 		 * Gets the current item value from the text field
		 *
		 * @returns {string}
		 */
		function _getCurrentValue () {
			var value = textField.val();

			if( options.multiValues ){
				if( value.indexOf( options.itemSep.chr ) === -1 || !options.commaTrigger ){
					// Multi items, but only one entered so far
					return value.trim();
				} else {
					// Get the last-entered item
					var pieces = value.split( options.itemSep.chr );
					return pieces[ pieces.length - 1 ].trim();
				}
			} else {
				return value;
			}
		}

		/**
 		 * Event handler for keydown event in wrapper.
 		 * We check for esape here, because if options.freeChoice is disabled, there's no textbox to
 		 * watch for events. By watching for escape on the wrapper, we can still close the menu.
		 *
		 * @returns {void}
		 */
		function _keydownWrapper (e) {
			if( e.which == ips.ui.key.ESCAPE ){
				keyEvents.escape(e);
			}
		}

		/**
 		 * Event handler for keydown event in text field
		 *
		 * @returns {void}
		 */
		function _keydownField (e) {
			var ignoreKey = false;

			// Ignore irrelevant keycodes
			if( !_( [ ips.ui.key.UP, ips.ui.key.DOWN, ips.ui.key.LEFT, ips.ui.key.RIGHT,
						 ips.ui.key.ENTER, ips.ui.key.TAB, ips.ui.key.BACKSPACE, ips.ui.key.ESCAPE
					 ] ).contains( e.which ) ){
				ignoreKey = true;
			}
			
			var value = textField.val().trim();

			// If this is empty, remove errors
			if( !value.length ){
				hasError = false;
			}

			// If this is a normal key press and we're at our max length, prevent the keypress
			if( options.maxLength && value.length == options.maxLength && ignoreKey ){
				e.preventDefault();
				return;
			}

			// Check for duplicates if we're potentially adding a new tag
			if( _( [ ips.ui.key.ENTER, ips.ui.key.TAB ] ).contains( e.which ) && options.unique && _duplicateValue( value ) ){
				e.preventDefault();
				_showTooltip( ips.getString( 'ac_dupes' ) );
				return;
			}
			
			if( ignoreKey ){
				return;
			}

			switch(e.which){
				// Token keys
				case ips.ui.key.BACKSPACE:
					keyEvents.backspace(e);
				break;
				case ips.ui.key.TAB:
				case ips.ui.key.ENTER:
					keyEvents.enter(e);
				break;

				// Suggestions keys
				case ips.ui.key.UP:
					keyEvents.up(e);
				break;
				case ips.ui.key.DOWN:
					keyEvents.down(e);
				break;
				case ips.ui.key.ESCAPE:
					keyEvents.escape(e);
				break;
			}
		}

		/**
 		 * Event handler for keyup in the text field.
		 *
		 * @param {KeyboardEvent|Event}	e		The event
		 *
		 * @returns {void}
		 */
		function _keyupField (e) {
			// Check for prohibited characters
			var i;
			for( i in options.disallowedCharacters ){
				if ( textField.val().indexOf( options.disallowedCharacters[i] ) !== -1 ) {
					textField.val( textField.val().replace( options.disallowedCharacters[i], '' ) );
					_showTooltip( ips.getString( 'ac_prohibit_special', {
						chars: options.disallowedCharacters.join(' ')
					} ) );
					e.preventDefault();
					return;
				}
			}

			// 229 is the 'input waiting' keycode. We need to check for it here because on IME keyboards,
			// we won't necessarily get a real keycode. e.g. Chrome on android. Instead we need to see if
			// the comma character is in the input, and process it that way.
			var lastCharIsComma = ( textField.val().substr( textField.val().length - 1 ) === ',' );

			if( e.which === 229 && lastCharIsComma ){
				_addTokenFromCurrentInput();
				e.preventDefault();
			}
		}

		/**
 		 * Event handler for keypress in the text field.
		 *
		 * @returns {void}
		 */
		function _keypressField (e) {

			// If we aren't concerned about commas, we can stop here
			if( !options.commaTrigger ){
				return;
			}

			// Get rid of the comma
			textField.val( textField.val().replace(',', '') );

			// Check for duplicates if we're potentially adding a new tag by pressing comma
			if( e.charCode == options.itemSep.charcode && options.unique && _duplicateValue( textField.val() ) ){
				e.preventDefault();
				_showTooltip( ips.getString( 'ac_dupes' ) );
				return;
			}

			if( e.charCode == options.itemSep.charcode ){
				_addTokenFromCurrentInput();
				e.preventDefault();
			}
		}

		/**
 		 * A wrapper method for tokens.add which also clears the text field
 		 * and hides it if options.maxItems is reached
		 *
		 * @returns {void}
		 */
		function _addToken (value) {
			tokens.add( value );
			textField.val('');
			lastValue = '';

			if( options.maxItems && tokens.total() >= options.maxItems ){
				inputItem.hide();
			}

			if( options.unique && options.freeChoice == false && 
				dataSource.totalItems() !== -1 && dataSource.totalItems() <= tokens.total() ){
				wrapper.find('[data-action="addToken"]').hide();
			}

			// If we're here, remove any errors
			hasError = false;
		}

		/**
 		 * A wrapper method for tokens.remove which shows the text field if we're under
 		 * our options.maxItems limit
		 *
		 * @returns {void}
		 */
		function _deleteToken (token) {
			if( disabled ){
				return;
			}
			
			tokens.remove( token );
		}

		/**
 		 * Imperative event handler for handling individual key presses
 		 */
		const keyEvents = {

			/**
	 		 * Backspace handler. If the textfield is empty, we highlight the previous token.
	 		 * If a token is selected, hitting backspace deletes it.
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			backspace(e) {
				if( !textField.val() ){
					if( tokens.selected ){
						tokens.remove( tokens.selected );
					} else {
						if( inputItem.prev().length ){
							tokens.select( inputItem.prev() );
						}
					}
				}
			},

			/**
	 		 * Enter/tab handler. If text has been entered, we add it as a token, otherwise pass through
	 		 * to the browser to handle.
			 *
			 * @param 	{Event} 	e 		Event object
			 * @returns {void|boolean}
			 */
			enter(e) {
				if( e.which == ips.ui.key.TAB && textField.val() == '' ){
					return false;
				}

				e.preventDefault();

				const currentResult = results.getCurrent();
				let value = '';

				if( currentResult ){
					value = currentResult.attr('data-value');
				} else {
					if( options.commaTrigger ){
						value = _stripHTML( textField.val().replace( options.itemSep.chr, '' ) );
					} else {
						value = _stripHTML( textField.val() );
					}
				}

				if( !value ){
					return false;
				}

				_addToken( value );
			},

			/**
	 		 * Handler for 'up' key press. Selects previous item in the results list.
			 *
			 * @param {Event}	e
			 *
			 * @returns {void}
			 */
			up(e) {
				if (!resultsElem || !_visible) {
					return;
				}

				e.preventDefault();

				const selected = results.getCurrent();

				if( !selected ){
					results.selectLast();
				} else {
					const prev = results.getPrevious(selected);
					if (prev) {
						results.select( prev );
					} else {
						results.selectLast();
					}
				}
			},

			/**
	 		 * Handler for 'down' key press. Selects next item in the results list.
			 *
			 * @returns {void}
			 */
			down(e) {
				if (!_visible) {
					return;
				}

				e.preventDefault();

				const selected = results.getCurrent();

				if( !selected ){
					results.selectFirst();
				} else {
					const next = results.getNext(selected);
					if( next ){
						results.select( next );
					} else {
						results.selectFirst();
					}
				}

			},

			/**
	 		 * Handler for 'escape' key press. Closes the suggestions menu, if it's open.
			 *
			 * @param {Event}		e
			 *
			 * @returns {void}
			 */
			escape(e) {
				if (_visible) {
					e.stopPropagation?.();
					_closeResults();
				}
			}

		}

		/**
 		 * Object containing methods for dealing with the results list.
 		 */
		const results = {

			/**
	 		 * Deselects any selected results
			 *
			 * @returns {void}
			 */
			deselectAll() {
				resultsElem
					.find('[data-selected]')
					.removeAttr('data-selected');
			},

			/**
	 		 * Returns the currently selected result
			 *
			 * @returns {jQuery|$|void|boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getCurrent() {
				if( dataSource.type === 'none' ){
					return;
				}

				const cur = resultsElem.find('[data-selected]');

				if (cur.length && _visible) {
					return cur;
				} 

				return false;
			},

			/**
	 		 * Gets the result preceding the provided result
			 *
			 * @returns {element|boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getPrevious(result) {
				const prev = $(result).prev('[data-value]');

				if( prev.length ){
					return prev;
				}

				return false;
			},

			/**
	 		 * Gets the result following the provided result
			 *
			 * @returns {element|boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getNext(result) {
				const next = $(result).next('[data-value]');

				if( next.length ){
					return next;
				}

				return false;
			},

			/**
	 		 * Selects the first result
			 *
			 * @returns {void}
			 */
			selectFirst() {
				results.select( resultsElem.find('[data-value]').first() );
			},

			/**
	 		 * Selects the last result
			 *
			 * @returns {void}
			 */
			selectLast() {
				results.select( resultsElem.find('[data-value]').last() );
			},

			/**
	 		 * Selects the provided item
			 *
			 * @returns {void}
			 */
			select(result) {
				results.deselectAll();
				result.attr('data-selected', true);
			}
		}

		/**
 		 * Object containing token methods
 		 */
		const tokens = {

			selected: null,

			/**
	 		 * Adds a token to the control
			 *
			 * @param 	{string} 	value 	The value of this token
			 *
			 * @returns {boolean}
			 */
			add(value) {
				let html = '';

				value = _.escape( value ).trim();

				if( options.minLength && value.length < options.minLength ){
					return false;
				}

				if( options.maxLength && value.length > options.maxLength ){
					return false;
				}

				if( options.forceLower ){
					value = value.toLowerCase();
				}

				tokens.deselectAll();

				inputItem.before( ips.templates.render( options.tokenTemplate, {
					id: elemID,
					value: value,
					title: value
				}));

				if( resultsElem ){
					_closeResults();
				}

				// Update hidden textbox
				valueField.val( tokens.getValues().join( "\n" ) );

				if( dataSource.type !== 'none' ){
					html = resultsElem.find('[data-value="' + value.replace("\\", "\\\\") + '"]').html();
				} else {
					html = value;
				}

				$(elem).trigger('tokenAdded', {
					token: value,
					html: html,
					tokenList: tokens.getValues(),
					totalTokens: tokens.total()
				});

				return true;
			},

			/**
	 		 * Deletes the given token
			 *
			 * @param 	{element} 	token 	The token element to select
			 * @returns {void}
			 */
			remove(token) {
				if( tokens.selected === token ){
					tokens.selected = null;
				}

				const value = $(token).attr('data-value');
				$( token ).remove();

				if( options.maxItems && tokens.total() < options.maxItems ){
					inputItem.show();
				}

				if (options.unique && !options.freeChoice &&
					( dataSource.totalItems() === -1 || dataSource.totalItems() > tokens.total() ) ) {
					wrapper.find('[data-action="addToken"]').show();
				}
				
				// Update text field
				valueField.val( tokens.getValues().join( "\n" ) );

				$(elem).trigger('tokenDeleted', {
					token: value,
					tokenList: tokens.getValues(),
					totalTokens: tokens.total()
				});
			},

			/**
	 		 * Removes all tokens
			 *
			 * @returns {void}
			 */
			removeAll() {
				const allTokens = inputItem.siblings().filter('[data-value]');

				allTokens.each( function () {
					tokens.remove( $( this ) );
				});
			},

			/**
	 		 * Selects a given token
			 *
			 * @param 	{element} 	token 	The token element to select
			 * @returns {void}
			 */
			select(token) {
				tokens.deselectAll();
				tokens.selected = $( token ).addClass('cToken_selected');
			},

			/**
	 		 * Returns total number of tokens entered
			 *
			 * @returns {number}
			 */
			total() {
				return inputItem.siblings().filter('[data-value]').length;
			},

			/**
	 		 * Returns all the values
			 *
			 * @returns {(string|null)[]}
			 */
			getValues() {
				let values = [];
				const allTokens = inputItem.siblings().filter('[data-value]');

				if( allTokens.length ){
					values = _.map( allTokens, function( item ){
						return $( item ).attr('data-value');
					});
				}

				return values;
			},

			/**
	 		 * Returns selected token value
			 *
			 * @returns {string|null} 	Value or null if no token selected
			 */
			getSelected() {
				return tokens.selected.attr('data-value');
			},

			/**
	 		 * Deselects all tokens
			 *
			 * @returns {void}
			 */
			deselectAll() {
				wrapper.find('[data-value]').removeClass('cToken_selected');
				tokens.selected = null;
			}
		}

		/**
 		 * Creates a token out of the current value in the text field
		 *
		 * @returns {void}
		 */
		function _addTokenFromCurrentInput () {
			let value = '';

			if( options.commaTrigger ){
				value = _stripHTML( textField.val().replace( options.itemSep.chr, '' ) );
			} else {
				value = _stripHTML( textField.val() );
			}

			if( options.minLength && value.length < options.minLength || options.maxLength && value.length > options.maxLength ){
				if( options.commaTrigger ){
					textField.val( textField.val().replace( options.itemSep.chr, '' ) );
				}
				return;
			}

			if (options.suggestionsOnly) {
				if (!resultsElem) {
					return
				}

				const results = [...resultsElem.find('[data-value]')]
				let valueInResults = false;
				for (const result of results) {
					if (result.dataset.value?.toLowerCase().trim() === value.toLowerCase().trim()) {
						valueInResults = true;
						value = result.dataset.value
						break;
					}
				}

				if (!valueInResults) {
					for (const result of results) {
						if (!options.unique || !_duplicateValue(result.dataset.value)) {
							value = result.dataset.value
							valueInResults = true;
							break;
						}
					}
				}

				// still here?
				if (!valueInResults) {
					return
				}
			}

			if( options.unique && _duplicateValue( value ) ){
				_showTooltip( ips.getString( 'ac_dupes' ) );
				return;
			}

			_addToken( value );
		}

		/**
 		 * Determines whether the value would be a duplicate
		 *
		 * @param 	{string} 	value 	Value to check
		 * @returns {boolean}
		 */
		function _duplicateValue (value) {
			return tokens.getValues().indexOf(value) !== -1;
		}

		/**
 		 * Removes special characters from text
		 *
		 * @returns {string}
		 */
		function _stripHTML (text) {
			return text.replace(/<|>|"|'/g, '');
		}

		/**
 		 * Shows a tooltip on the autocomplete with the provided message
		 *
		 * @param 	{string} 	msg 	Message to show
		 * @returns {void}
		 */
		function _showTooltip (msg) {
			if( !tooltip ){
				_buildTooltip();
			}

			// Set errors to true
			hasError = true;

			// If we're already showing a tooltip, remove the timeout before
			// showing this one.
			if( tooltipTimer ){
				clearTimeout( tooltipTimer );
			}

			tooltip[0].hidePopover();
			tooltip.text( msg );

			_positionTooltip();

			// Hide it automatically in a few seconds
			tooltipTimer = setTimeout( function () {
				_hideTooltip();
			}, 2500);
		}

		/**
 		 * Hides the tooltip
		 *
		 * @returns {void}
		 */
		function _hideTooltip () {
			if( tooltip && tooltip.is(':visible') ){
				tooltip[0].hidePopover();
			}
		}

		/**
 		 * Positions the tooltip over the autocomplete
		 *
		 * @returns {void}
		 */
		function _positionTooltip () {
			const positionInfo = {
				trigger: wrapper,
				target: tooltip,
				center: true,
				above: true
			};

			const tooltipPosition = ips.utils.position.positionElem( positionInfo );

			$( tooltip ).css({
				left: tooltipPosition.left + 'px',
				top: tooltipPosition.top + 'px'
			});

			if( tooltipPosition.location.vertical === 'top' ){
				tooltip.addClass('ipsTooltip_top');
			} else {
				tooltip.addClass('ipsTooltip_bottom');
			}

			tooltip[0].showPopover();
		}

		/**
 		 * Builds the tooltip element
		 *
		 * @returns {void}
		 */
		function _buildTooltip () {
			// Build it from a template
			const tooltipHTML = ips.templates.render( 'core.tooltip', {
				id: 'elAutoCompleteTooltip'
			});

			// Append to body
			ips.getContainer().append( tooltipHTML );

			tooltip = $('#elAutoCompleteTooltip');
		}

		init();

		return {
			init: init,
			destruct: destruct,
			hasErrors: hasErrors,
			addToken: tokens.add,
			getTokens: tokens.getValues,
			removeToken: tokens.remove,
			removeAll: tokens.removeAll,
			focus: focus
		};
	}

	/**
	 * @typedef AutocompleteResult
	 * @property {*}	id
	 * @property {*} 	value
	 * @property {string}	html
	 */

	/**
	 * Handler for local data retrieval
	 */
	function localData(source) {
		const valueOrderMap = new Map();
		const searchInterface = {
			type: 'local',

			_items:  $(source).get(0).querySelectorAll('option'),

			/**
			 * Searches through the source element, matching option values to our search string
			 *
			 * @param 	{string} text The text to search for
			 * @returns {Promise<AutocompleteResult[]>}
			 */
			async getResults(text) {
				return [...ips.utils.search.search(this, text)].sort((val1, val2) => valueOrderMap.get(val1) - valueOrderMap.get(val2))
			},

			/**
			 * Returns the number of items in the result set
			 *
			 * @returns {number}
			 */
			totalItems() {
				return ips.utils.search.getSize(this);
			},

			stop: $.noop,
		};

		const secondaryTerms = []
		let i = 0;
		for (const item of $(source).get(0).querySelectorAll('option')) {
			const value = {
				id: item.value,
				value: item.value,
				html: item.innerHTML
			}
			const searchTerms = item
				.innerText
				.trim()
				.replaceAll(/(\p{L}|\p{N})((?:\p{Upper}|_|-)[\p{Lower}\p{N}])/ug, "$1 $2")
				.replaceAll(/(\P{N})(\p{N}{3,})/ug, "$1 $2") // get "numeric" words... e.g. some_content_13435_rest
				.trim()
				.toLowerCase()
				.split(/\s+/)
				.map(term => ips.utils.search.fixTerm(term))
				.filter(term => !!term);

			ips.utils.search.addTerm(searchInterface, searchTerms.join(''), [value])
			valueOrderMap.set(value, i++);
			searchTerms.shift();
			// now, when there are split names, let's add them but AFTER the results where the first word matches. For example, "joe rogan" should always come after "ronald mcdonald" for the search "ro". To do this, "joe rogan" is added twice, once as "joe" then later as "rogan"
			while (searchTerms.length) {
				secondaryTerms.push([searchTerms.join(''), value])
				searchTerms.shift()
			}
		}

		for (const [searchTerm, item] of secondaryTerms) {
			ips.utils.search.addTerm(searchInterface, searchTerm, [item])
		}

		return searchInterface;
	}

	/**
	 * Handler for remote data retrieval
	 */
	function remoteData(source, options) {
		/**
		 * @type {Map<string, AutocompleteResult>}
		 */
		const results = new Map();

		/** @type {Map<string, string[]>} Map of the search string to the results */
		const responseItemCache = new Map();

		return {
			type: 'remote',

			/**
			 * Initiates either a remote search or a remote fetch
			 *
			 * @returns {Promise<AutocompleteResult[]>}
			 */
			async getResults(text) {
				if (!responseItemCache.has(text)) {
					const data = {dataType: 'json', data: {}}
					if (options.freeChoice) {
						if (options.minAjaxLength > text.length) {
							throw new RangeError(`Expected the text to be less than ${options.minAjaxLength} characters, got a string containing ${text.length} characters`);
						}

						data.data[options.queryParam] = text
					}

					/**
					 * @type {AutocompleteResult[]}
					 */
					const response = await ips.fetch(source, data)
					if (!Array.isArray(response) || response.some(item => !(typeof item === 'object' && 'value' in item))) {
						throw new TypeError(`Could not get autocomplete results from response.`);
					}

					response.forEach(item => {
						results.set(item.value, item);
					})

					responseItemCache.set(text, response.map(item => item.value));
				}

				return responseItemCache
					.get(text)
					.map(value => results.get(value));
			},

			/**
			 * Returns the number of items in the result set
			 *
			 * @returns {number}
			 */
			totalItems() {
				if (!options.freeChoice) {
					return results.size;
				}

				return -1;
			},

			stop: $.noop
		};
	}

	function noData() {
		return {
			type: 'none',
			getResults: $.noop,
			totalItems: -1,
			stop: $.noop
		};
	}

}(jQuery, _));

]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.captcha.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.captcha.js - Recaptcha widget. Allows for dynamic loading of recpatcha, so it works in popups
 *
 * Author: Rikki Tissier
 */

/* A global function breaks our coding standards, but it's the only way Google will allow it */
function recaptcha2Callback(){
	jQuery( window ).trigger( 'recaptcha2Loaded' );
};
// Turnstile is set up very similar to recaptcha.
window.turnstileCallback = function () {
    console.log('CF callback triggered');
    jQuery( window ).trigger( 'turnstileLoaded' );
};

;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.captcha', function(){

		var defaults = {
			lang: 'en-US',
			theme: 'white'
		};

		var recaptchaLoaded = false;
        var turnstileLoaded = false;

		var respond = function (elem, options) {
			options = _.defaults( options, defaults );
			
			if( options.service == 'recaptcha' ){
				_recaptcha( elem, options );
			} else if( options.service == 'recaptcha2' ){
				_recaptcha2( elem, options );
			} else if ( options.service == 'keycaptcha' ) {
				_keycaptcha(elem);
			} else if ( options.service == 'recaptcha_invisible' ) {
				_recaptcha_invisible( elem );
			} else if ( options.service == 'turnstile' ) {
                _turnstile( elem );
            }
		},

		/**
		 * Recaptcha
		 * Handles a recaptcha captcha, loading the JS file from google.com before setup
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		_recaptcha = function (elem, options) {
			ips.loader.get( [ document.location.protocol + '//www.google.com/recaptcha/api/js/recaptcha_ajax.js'] ).done( function () {
				var container = $('<div/>');
				var id = container.identify().attr('id');

				elem.append( container );

				Recaptcha.create( options.key, id, {
					theme: options.theme,
					lang: options.lang,
					callback: function () { Debug.log('done') }
				});
			});
		},

		/**
		 * Recaptcha2
		 * Handles a new recaptcha captcha, loading the JS file from google.com before setup
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		_recaptcha2 = function (elem, options) {
			ips.loader.get( [ 'https://www.google.com/recaptcha/api.js?hl=' + $(elem).attr('data-ipsCaptcha-lang') + '&onload=recaptcha2Callback&render=explicit' ] );

			var initRecaptcha2 = function () {
				elem.children('[data-captchaContainer]').remove();
				
				var container = $('<div data-captchaContainer/>');
				var id = container.identify().attr('id');

				elem.append( container );
				
				grecaptcha.render( id, {
					sitekey: $(elem).attr('data-ipsCaptcha-key'),
					theme: $(elem).attr('data-ipsCaptcha-theme')
				} );
			};

			if( recaptchaLoaded ){
				initRecaptcha2();
			} else {
				$( window ).on( 'recaptcha2Loaded', function() {
					recaptchaLoaded = true;
					initRecaptcha2();
				});	
			}
		},
		
		/**
		 * Invisible Recaptcha
		 * Handles a new recaptcha captcha, loading the JS file from google.com before setup
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		_recaptcha_invisible = function (elem, options) {
			ips.loader.get( [ 'https://www.google.com/recaptcha/api.js?hl=' + $(elem).attr('data-ipsCaptcha-lang') + '&onload=recaptcha2Callback&render=explicit' ] );

			var initRecaptchaInvisible = function () {
				elem.children('[data-captchaContainer]').remove();
				var container = $('<div data-captchaContainer/>');
				var id = container.identify().attr('id');
				elem.append( container );
				
				var form = elem.closest('form');
				var recaptchaId = grecaptcha.render( id, {
					sitekey: $(elem).attr('data-ipsCaptcha-key'),
					size: 'invisible',
					callback: function () {
						form.attr( 'data-recaptcha-done', 'true' );
						form.submit();
					}
				} );
				
				form.on( 'submit', function( e ) {
					if ( !form.attr( 'data-recaptcha-done') ) {
						e.stopPropagation();
						e.preventDefault();
						grecaptcha.execute(recaptchaId);
					}
				});
			};

			if( recaptchaLoaded ){
				initRecaptchaInvisible();
			} else {
				$( window ).on( 'recaptcha2Loaded', function() {
					recaptchaLoaded = true;
					initRecaptchaInvisible();
				});	
			}
		},

		/**
		 * Keycaptcha captcha
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @returns {void}
		 */
		_keycaptcha = function (elem) {
			ips.loader.get( [ document.location.protocol + '//backs.keycaptcha.com/swfs/cap.js' ] );
		},

        /**
         * Cloudflare Turnstile
         * Handles a new turnstile captcha, loading the JS file from cloudflare.com before setup
         *
         * @param	{element} 	elem 		The element this widget is being created on
         * @param	{object} 	options 	The options passed into this instance
         * @returns {void}
         */
        _turnstile = function (elem, options) {
            ips.loader.get( [ 'https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit&onload=turnstileCallback' ] )

            const initTurnstile = function () {
                elem.children('[data-captchaContainer]').remove();
                var container = $('<div data-captchaContainer/>');
                var id = container.identify().attr('id');
                elem.append(container);

                turnstile.render('#' + id, {
                    sitekey: $(elem).attr('data-ipsCaptcha-key'),
                    language: $(elem).attr('data-ipsCaptcha-lang'),
                    theme: $(elem).attr('data-ipsCaptcha-theme')
                });
            };

            if( turnstileLoaded ){
                initTurnstile();
            } else {
                $( window ).on( 'turnstileLoaded', function() {
                    turnstileLoaded = true;
                    initTurnstile();
                });
            }
        };

		ips.ui.registerWidget( 'captcha', ips.ui.captcha, [
			'service', 'key', 'lang', 'theme'
		]);

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.carousel.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.carousel.js - Carousel
 *
 * Author: Ehren Harber
 */
;( function($, _){
	"use strict";

	ips.createModule('ips.ui.carousel', function() {
		const buttonHandlerMap = new WeakMap();
		/**
		 * @type {WeakMap<HTMLElement, function>}
		 */
		const cleanupCallbacks = new WeakMap();

		/**
		 * @type {WeakSet<HTMLElement>}
		 */
		const visibleCarousels = new WeakSet();
		const visibleCarouselObserver = new IntersectionObserver(entries => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					visibleCarousels.add(entry.target);
				} else {
					visibleCarousels.delete(entry.target);
				}
			});
		}, {threshold: 0});


		// Register this widget with ips.ui
		ips.ui.registerWidget( 'carousel', ips.ui.carousel );

		return {
			/**
			 * Cleanup existing elements
			 * @param elem
			 */
			destruct(elem) {
				$(elem).each(function() {
					if (cleanupCallbacks.has(this)) {
						try {
							cleanupCallbacks.get(this)();
						} catch (e) {
							Debug.error(e);
						}
						cleanupCallbacks.delete(this);
					}
				});
			},
			/**
			 * Responder for carousel widget
			 *
			 * @param    {element}    elem        The element this widget is being created on
			 *
			 * @returns {void}
			 */
			respond(elem) {

				let controls = elem[0],
					scroller = document.getElementById(controls.dataset.ipscarousel);

				// If no carousel exists, bail here
				if(!scroller) {
					Debug.warn({
						warning: `Carousel nav was not setup because its scroller (#${controls.dataset.ipscarousel}) cannot be identified`,
						controls
					});
					return;
				}

				let buttons = controls.querySelectorAll('[data-carousel-arrow]'),
					interval = controls.dataset.ipscarouselInterval,
					int,
					scrollerWidth,
					scrollerScrollWidth,
					scrollerGap = 0,
					itemWidths = new WeakMap(),
					visibleElements = new WeakSet();


				/**
				 * @type {function[]}
				 */
				const callbacks = [];
				cleanupCallbacks.set(controls, () => callbacks.forEach(cb => cb()));

				if (interval === undefined && controls.closest('.cWidgetContainer--isWidget[data-widget-interval]:not([data-ipscarousel] *)')) {
					interval = parseInt(controls.closest('.cWidgetContainer--isWidget[data-widget-interval]:not([data-ipscarousel] *)').dataset.widgetInterval)
					interval = Number.isNaN(interval) || !Number.isInteger(interval) || !interval ? undefined : interval * 1000;
				}

				const _ro = new ResizeObserver(entries => {
					for (const entry of entries) {
						if (entry.target === scroller) {
							scrollerWidth = entry.borderBoxSize[0]?.inlineSize || scrollerWidth;
							scrollerScrollWidth = scroller.scrollWidth;
							const gap = getComputedStyle(scroller).columnGap?.trim?.().match(/^(\d+|\d+\.\d*|\.\d+)px$/)?.[1];
							if (gap) {
								scrollerGap = parseFloat(gap);
							}
						} else if (entry.target?.parentElement === scroller) {
							if (entry.borderBoxSize.length) {
								itemWidths.set(entry.target, entry.borderBoxSize[0].inlineSize);
							}
						} else {
							_ro.unobserve(entry.target);
						}
					}
				});
				_ro.observe(scroller);
				callbacks.push(() => _ro.disconnect());
				buttons.forEach(carouselButton => {
					if (buttonHandlerMap.has(carouselButton)) {
						carouselButton.removeEventListener('click', buttonHandlerMap.get(carouselButton))
					}

					buttonHandlerMap.set(carouselButton, () => {
						// when they click manually, we stop the auto carousel
						if (int) {
							clearInterval(int)
						}
						scrollPanels(carouselButton.dataset.carouselArrow);
					});
					const cb = buttonHandlerMap.get(carouselButton);
					carouselButton.addEventListener('click', cb);
					callbacks.push(() => carouselButton.removeEventListener('click', cb));
				});

				visibleCarouselObserver.observe(scroller);
				callbacks.push(() => visibleCarouselObserver.unobserve(scroller));

				// If either the first or last element is hidden, we need to show the carousel navigation
				let firstVisible, lastVisible;

				const scrollerObserver = new IntersectionObserver(
					(entries) => {
						entries
							.forEach((entry) => {
								if (entry.isIntersecting) {
									visibleElements.add(entry.target);
								} else {
									visibleElements.delete(entry.target);
								}
								if(entry.target === scroller.firstElementChild){
									firstVisible = entry.isIntersecting;
								}
								if (entry.target === scroller.lastElementChild) {
									lastVisible = entry.isIntersecting;
								}
							});

						// Hide the controls if both the first and last children are visible
						requestAnimationFrame(() => {
							controls.hidden = firstVisible && lastVisible;
						});
					},
					{
						root: scroller,
						threshold: 0.99
					}
				);

				// Attach intersection observer to first and last tab
				const mutationObserver = new MutationObserver(_.throttle(() => {
					scrollerObserver.disconnect();
					[...scroller.children].forEach(child => {
						scrollerObserver.observe(child);
						_ro.observe(child, {box: "border-box"});
					});
				}, 10, {leading: true}));

				[...scroller.children].forEach(child => {
					scrollerObserver.observe(child);
					_ro.observe(child, {box: 'border-box'});
				});
				mutationObserver.observe(scroller, {childList: true});

				callbacks.push(() => {
					mutationObserver.disconnect();
					scrollerObserver.disconnect();
				});

				// Add a scroll event
				const scrollListener = (e, direction, loop=true) => {
					loop = 'loop' in e.detail || {} ? e.detail.loop : loop;
					direction = e.detail?.direction || direction;
					scrollPanels(direction, loop)
				};
				$(scroller).on('scrollPanels', scrollListener)
				callbacks.push(() => $(scroller).off('scrollPanels', scrollListener));

				let removeCB;
				const scrollEnd = () => {
					scroller.classList.remove('ipsScrolling');
				};

				const scrollStart = () => {
					scroller.classList.add('ipsScrolling');
					clearTimeout(removeCB);
					removeCB = setTimeout(() => scrollEnd(), 300);
				};
				scroller.addEventListener('scroll', scrollStart);
				callbacks.push(() => {
					scroller.removeEventListener('scroll', scrollStart);
					clearTimeout(removeCB)
				});

				if (scroller.onscrollend instanceof Function) {
					scroller.addEventListener('scrollend', scrollEnd);
					callbacks.push(() => scroller.removeEventListener('scrollend', scrollEnd));
				}

				if (interval && !Number.isNaN(parseInt(interval))) {
					int = setInterval(() => {
						if (scroller?.closest('body') !== document.body || controls?.closest('body') !== document.body) {
							clearInterval(int)
							return;
						}

						// Don't scroll if the window isn't focused
						if (document.visibilityState !== 'visible') {
							Debug.log(`Not auto-playing carousel "${scroller.id}" because the document isn't focused`);
							return;
						}

						// make sure it's visible
						if (!visibleCarousels.has(scroller)) {
							Debug.log(`Not auto-playing carousel "#${scroller.id}" because it is off-screen.`);
							return;
						}
						Debug.log(`Auto-playing carousel "#${scroller.id}".`);
						scrollPanels()
					}, parseInt(interval))
					callbacks.push(() => clearInterval(int));
				}


				/**
				 * Scroll the carousel in the correct direction when buttons are clicked
				 *
				 * @param {"prev"|"next"}        [direction="next"]        The direction of the scroll effect
				 * @param {boolean}	[loop=true]		Whether to loop to the beginning/end if the user is moving before the start or after the end
				 *
				 * @return void
				 */
				const scrollPanels = async (direction = "next", loop=true) => {
					const currentlyVisibleElements = [];
					let precedingElement = false;
					let succeedingElement = false;
					for (const child of [...scroller.children]) {
						if (visibleElements.has(child)) {
							currentlyVisibleElements.push(child);
						} else if (!itemWidths.get(child)) { // no size? don't really care about this one
							continue;
						} else if (currentlyVisibleElements.length) {
							succeedingElement = child;
							break;
						} else {
							precedingElement = child;
						}
					}

					const rtl = this.isRTL(scroller);
					if ((direction === 'next' && !succeedingElement) || (direction === 'prev' && !precedingElement)) {
						const amount = (rtl && direction === 'prev') || (!rtl && direction === 'next') ? -scrollerScrollWidth : scrollerScrollWidth;
						scroller.scrollBy({left: amount, behavior: 'smooth'});
					} else if (currentlyVisibleElements.length) {
						let el = currentlyVisibleElements[0];
						let amount;
						// the only case where scrolling the width of the first visible element will not work is if the scroll is snapped to the last el; this is because the last element uses scroll-snap-align:end, so we actually need to scroll to the preceding element directly
						if (!succeedingElement && precedingElement instanceof Element && direction === 'prev') {
							const padding = this.getScrollPadding(scroller);
							// get the width of all visible elements plus the element that is about to become visible, then subtract the scroll width. This is the amount by which the first not-visible element precedes the scroll area
							amount = (itemWidths.get(precedingElement) + currentlyVisibleElements.map(el => itemWidths.get(el)).reduce((prev,cur) => prev + scrollerGap + cur, 0)) - (scrollerWidth - padding.left - padding.right);

							// are we moving to the right?
							if (!rtl) {
								amount = -amount;
							}
						} else {
							amount = (rtl && direction === 'prev') || (!rtl && direction === 'next') ? itemWidths.get(el) + scrollerGap : -(itemWidths.get(el) + scrollerGap);
						}

						scroller.scrollBy({left: amount, behavior: 'smooth'});
					}
				}
			},

			/**
			 * See if the container is already scrolled to the end based on its direction. Used for widget carousel groups
			 *
			 * @param {HTMLElement}		scroller
			 * @param {'prev'|'next'}	[direction='prev']
			 * @return {boolean}
			 */
			containerAtEnd(scroller, direction='prev') {
				const _containerBox = scroller.getBoundingClientRect();
				// can't scroll? Then no
				if (Math.ceil(_containerBox.width) >= Math.floor(scroller.scrollWidth)) {
					return true;
				}

				const scrollPadding = this.getScrollPadding(scroller);
				const containerBox = new DOMRect(
					_containerBox.x + scrollPadding.left,
					_containerBox.y,
					_containerBox.width - (scrollPadding.left + scrollPadding.right),
					_containerBox.height
				);

				const rtl = this.isRTL(scroller);
				for (const child of scroller.querySelectorAll(':scope > *')) {
					const box = child.getBoundingClientRect();
					const computed = getComputedStyle(child);
					if (['absolute','fixed'].includes(computed.position?.toLowerCase())) {
						continue;
					}

					if (rtl && ((direction === 'prev' && Math.floor(box.right) >= Math.ceil(containerBox.right)) || (direction === 'next' && Math.ceil(box.left) <= Math.floor(containerBox.left)))) {
						return false;
					}

					if (!rtl && ((direction === 'prev' && Math.ceil(box.left) <= Math.floor(containerBox.left)) || (direction === 'next' && Math.floor(box.right) >= Math.ceil(containerBox.right)))) {
						return false
					}
				}

				return true;
			},

			/**
			 * Get the scroll padding
			 * @param elem
			 * @return {{left: number, right: number}}
			 */
			getScrollPadding(elem) {
				const style = getComputedStyle(elem);
				const padding = {left: 0, right: 0};
				for (const dir of ['Left','Right']) {
					if (style[`scrollPadding${dir}`]?.match(/^(\d+|\d+\.\d*|\.\d+)px$/)) {
						padding[dir.toLowerCase()] = parseFloat(style[`scrollPadding${dir}`].match(/^(\d+|\d+\.\d*|\.\d+)px$/)[1]);
					}
				}


				return padding;
			},

			/**
			 * Determine if the context for a given element causes RTL scrolling
			 *
			 * @param	{HTMLElement|undefined|jQuery} 	[elem]
			 *
			 * @return {boolean}
			 */
			isRTL(elem) {
				elem = $(elem || document.body).get(0);
				while (elem instanceof HTMLElement) {
					if (elem.dir && elem.dir.toLowerCase() === 'rtl') {
						return true;
					}
					elem = elem.parentElement;
				}

				return document.dir.toLowerCase() === 'rtl';
			}
		}
	});
}(window.jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.chart.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.chart.js - Converts a table into a Google Graph
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.createModule('ips.ui.chart', function(){
		
		var defaults = {};

		/**
 		 * Widget respond method
 		 * Simply sets a callback that will execute when the google visualization JS has loaded
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed
		 * @returns {void}
		 */
		var respond = function (elem, options) {

			var doInit = function () {
				if( !$( elem ).data('_chart') ){
					$( elem ).data('_chart', chartObj(elem, _.defaults( options, defaults ) ) );
				}
			};

			try {
				doInit();
			} catch (err) {
				ips.loader.get( ['https://www.gstatic.com/charts/loader.js'] ).then( function () {
					google.charts.load( '47', {'packages':['corechart', 'gauge', 'table'], 'callback': doInit } );
				});
			}
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		},

		/**
		 * Retrieve the carousel instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The carousel instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_chart') ){
				return $( elem ).data('_chart');
			}

			return undefined;
		};

		/**
		 * Chart instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		var chartObj = function (elem, options) {
						
			var data = new google.visualization.DataTable();
			var headerTypes = {};
			var extraOptions = {};
			var chartElem = $(elem).next();
			//chartElem.css( 'height', Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - chartElem.offset().top );
			var chart = null;
			const table = $(elem).is('table') ? $(elem) : $(elem).find('table');

			/**
	 		 * Initialize this chart
			 *
			 * @returns {void}
			 */
			var init = function () {
				$(elem).addClass('ipsLoading');
				// Add headers
				table.find('thead th').each( function (idx) {
					headerTypes[ idx ] = $( this ).attr('data-colType');										
					data.addColumn( $( this ).attr('data-colType'), $( this ).text() );
				});
								
				// Add rows
				table.find('tbody tr').each( function () {
					var row = [];

					$( this ).find('td').each( function( idx ) {
						
						if( headerTypes[ idx ] == 'number' ){
							var val;
							if ( val = $( this ).text() ) {
								val = Number( val );
							} else {
								val = null;
							}
						} else if ( headerTypes[ idx ] == 'date' || headerTypes[ idx ] == 'datetime' || headerTypes[ idx ] == 'timeofday'  ) {
							var val = new Date( $( this ).text() );
						} else {
							var val = $( this ).text();
						}

						if( !_.isNaN( val ) ){
							if ( $(this).attr('data-key') ) {
								val = { v: $(this).attr('data-key'), f: val };
							}
							row.push( val );	
						}
					});
					
					data.addRow(row);
				});
				
				if ( options.format ) {
					var formatter = new google.visualization.NumberFormat({pattern:'# ' + options.format} );
					formatter.format( data, 1 );
				}
				
				// Set options
				extraOptions = $.parseJSON( options.extraOptions );

				if( !_.isUndefined( extraOptions.height ) ){
					chartElem.css({
						height: extraOptions.height + 'px'
					});
				} else {
					chartElem.css({
						minHeight: '250px'
					});
				}
				
				// Add Chart wrapper
				$(elem)
					.hide()
					.removeClass('ipsLoading')
					.after(chartElem);
				
				// We need to redraw the chart when the window resizes
				$( window ).on( 'resize', drawChart );

				drawChart();

				// Callback to let the page know
				google.visualization.events.addListener( chart, 'ready', function () {
					$( elem ).trigger( 'chartInitialized');
				});

				// If this chart is in a tab, we need to re-initialize it after the tab is shown so that
				// it sizes properly
				$( document ).on( 'tabShown', tabShown );
			},

			/**
	 		 * Draws a Google graph using the data in a table
			 *
			 * @returns {void}
			 */
			drawChart = function (e) {
				chart = new google.visualization[ options.type ]( chartElem.get(0) );
				chart.draw( data, extraOptions );
			},

			/**
	 		 * Destruct the graph widget on this instance
			 *
			 * @returns {void}
			 */
			destruct = function () {
				$( window ).off( 'resize', drawChart );
				$( document ).off( 'tabShown', tabShown );
			},

			/**
	 		 * Event handler for a tab showing
			 *
			 * @param 	{event} 	e 		Event object
			 * @param 	{object} 	data 	Event data object
			 * @returns {void}
			 */
			tabShown = function (e, data) {
				if( $.contains( data.panel.get(0), elem.get(0) ) ){
					drawChart();
				}
			};

			if( _.isUndefined( google.visualization ) ){
				google.setOnLoadCallback( init );	
			} else {
				init();
			} 

			return {
				init: init,
				drawChart: drawChart
			};
		};

		// Register this module as a widget to enable the data API and
		// jQuery plugin functionality
		ips.ui.registerWidget( 'chart', ips.ui.chart, [
			'type', 'extraOptions', 'format'
		] );

		return {
			respond: respond,
			destruct: destruct,
			getObj: getObj
		};
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.codebox.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.codebox.js - Codebox widget (like the editor but dumbed down and only has a code box)
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
    "use strict";

    ips.createModule('ips.ui.codebox', function() {


        ips.ui.registerWidget(
            'codebox',
            ips.ui.codebox,
            [
                'allowed-languages',
                'autosave-key'
            ]
        );

        return {

            /**
             * Respond method, sets up the editor widget.
             * Loads the Tiptap libraries, then boots the editor
             *
             * @param	{element} 	elem 		The element this widget is being created on
             * @param	{object} 	options 	The options passed into this instance
             * @returns {void}
             */
            respond(elem, options) {

                if ($(elem).data('_editor')) {
                    return;
                }

                const instance = editorObj(elem, options)
                $(elem).data('_editor', instance)
                instance.init()
            },

            /**
             * Retrieve the editor instance (if any) on the given element
             *
             * @param	{element} 	elem 		The element to check
             *
             * @returns {editorObj|undefined} 	The editor instance or undefined
             */
            getObj(elem) {
                if( $( elem ).data('_editor') ){
                    return $( elem ).data('_editor');
                }

                return undefined;
            },

            /**
             * Retrieve the editor instance (if any) on the given element, initiating it if it isn't already. The instance is passed to a callback
             *
             * @param	{element} 	                        elem 		The element to check
             * @param   {function(editorObj|undefined)}     callback    If the instance exists, it will be passed to this callback
             *
             * @returns {void}
             */
            getObjWithInit( elem, callback ) {
                let obj = this.getObj( elem );
                if ( obj ) {
                    callback( obj );
                } else {
                    let initFunction = $( elem ).data('_editorInit');
                    if ( initFunction ) {
                        initFunction( callback );
                    }
                }
            },

            /**
             * Destruct the editor
             *
             * @param	{element} 	elem 		The element to check
             * @returns {void}
             */
            destruct(elem) {
                this.getObj( elem )?.destruct();
            }
        };
    });


    function editorObj(elem, options) {
        let instance;
        let reactRoot
        let allowedLanguages;
        async function init() {
            await ips.ui.editorv5.whenLoaded()

            const config = {'codeMode' : true}
            if (options['allowed-languages']) {
                allowedLanguages = [...new Set(JSON.parse(options['allowed-languages']))]
                config.allowedLanguages = allowedLanguages
                config.defaultLanguage = allowedLanguages.includes('plaintext') ? 'plaintext' : allowedLanguages[0]
            }

            /**@var {HTMLElement|HTMLTextAreaElement}*/
            const textArea = $(elem).get(0);
            config.textArea = textArea;

            if (options['autosave-key']) {
                config.autosaveKey = options['autosave-key'];
            } else if (!textArea.closest('i-theme-editor') && textArea.closest('form[action]') && (textArea.hasAttribute('name') || textArea.closest('.ipsFieldRow[id], .ipsFieldRow [id]'))) {
                config.autosaveKey = ips.utils.crypto.md5(
                    JSON.stringify([
                        textArea.closest('form[action]').getAttribute('action'),
                        textArea.getAttribute('name') || textArea.closest('.ipsFieldRow[id], .ipsFieldRow [id]').id
                    ])
                );
            }

            const editorLocation = document.createElement('div')
            editorLocation.dataset.role = 'reactRoot'
            textArea.parentElement.insertBefore(editorLocation, textArea)
            config.content = textArea.innerHTML
            config.onUpdate = (editor) => {
                const value = editor.getValue();
                textArea.innerHTML = "";
                textArea.appendChild(document.createTextNode(value));
                textArea.value = value;
                textArea.dispatchEvent(new CustomEvent('ips:codebox#update', {detail: {instance, elem: textArea}, bubbles: true}));
            }

            config.hasTags = !!textArea.closest('[data-controller="core.global.editor.customtags"]');

            textArea.ipsHide()
            let result = await ips.utils.tiptap.editorInstance(editorLocation, config);
            instance = result[0] // this is a MONACO instance
            textArea.dispatchEvent(new CustomEvent('ips:codeboxAfterInit', {
                bubbles: true,
                cancelable: true,
                detail: {
                    instance,
                    config
                }
            }))

            textArea.addEventListener('insertCode', e => {
                if (e?.detail?.content) {
                    let content = e.detail.content;

                    // if this is a string, it could very well contain HTML, in which case we need to insert it as a text node, not raw HTML
                    if (typeof content === 'string') {
                        instance.executeEdits("insertCode", [
                            {
                                text: content,
                                range: instance.getSelection()
                            }
                        ]);
                        instance.focus();
                    } else {
                        throw new TypeError(`The content property of the event insertCode is expected to be a string`);
                    }
                }
            })

            reactRoot = result[1]
        }

        function destruct() {
            instance?.dispose()
            reactRoot.unmount();
        }

        return {instance, destruct, init}
    }

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.codehighlighting.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[((($, _) => {
    "use strict";

    ips.createModule('ips.ui._codehighlighting', function() {

        const LOADER_RESOLVERS = new Set();
        const LOADER_REJECTS = new Set();
        /**
         *
         * @type {'loaded'|'error'|"loading"}
         */
        let STATE = 'loading';

        document.addEventListener('ipsCodehighlightingLoaded', () => {
            STATE = 'loaded';
            LOADER_RESOLVERS.forEach(resolve => resolve());
            LOADER_RESOLVERS.clear();
            LOADER_REJECTS.clear();
        });

        // The actual ips.ui.codehighlighting module is bundled and lazily loads the language support.
        // We are NOT using ips.loader here because that ruins the browsers ability to track the URL of the script
        let timeout;
        let attempts = 0;
        function inject() {
            clearTimeout(timeout);
            window.removeEventListener('load', inject);
            if (typeof ips.ui?.codehighlighting === 'object') {
                STATE = 'loaded';
                LOADER_REJECTS.clear();
                LOADER_RESOLVERS.forEach(resolve => resolve());;
                LOADER_RESOLVERS.clear();
                return;
            }

            if (!document?.body) {
                if (attempts++ < 5) {
                    timeout = setTimeout(inject, 100);
                    Debug.log(`Attempting to load the codehighlighting module. Attempt: ${attempts}`);
                } else {
                    STATE = 'error';
                    LOADER_RESOLVERS.clear();
                    LOADER_REJECTS.forEach(reject => reject(new Error(`The codehighlighting module could not be loaded`)));
                    LOADER_RESOLVERS.clear();
                    Debug.warn(`Couldn't load the codehighlighting module after 5 attempts because document.body isn't present!`);
                }
                return;
            }

            const script = document.createElement('script')
            document.body.appendChild(script)
            script.src = ips.getSetting('baseURL').replace(/\/+$/, "") + "/applications/core/interface/static/codehighlighting/codehighlighting.js?antiCache=" + encodeURIComponent(ips.getSetting('jsAntiCache'));
        }

        try {
            if (!document?.body) {
                throw new Error();
            }
            inject();
        } catch (e) {
            window.addEventListener('load', inject, {once: true});
            timeout = setTimeout(() => {
                if (typeof ips.ui?.codehighlighting === "object") {
                    STATE = 'loaded';
                    LOADER_REJECTS.clear();
                    LOADER_RESOLVERS.forEach(resolve => resolve());
                    LOADER_RESOLVERS.clear();
                    return;
                }
                Debug.warn(`The codehighlighting module was not appended to document.body because the window's \`load\` event didn't fire within 2 seconds after ips.ui._codehighlighting was initialized.`);
                inject()
            }, 2000);
        }

        return {
            whenLoaded() {
                return new Promise((resolve, reject) => {
                    if (STATE === 'loaded') {
                        return resolve();
                    } else if (STATE === 'error') {
                        return reject();
                    }

                    LOADER_REJECTS.add(reject);
                    LOADER_RESOLVERS.add(resolve);
                })
            }
        }
    })
})(jQuery, _))]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.contentItem.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _, Debug */
/**
 * IPS 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.contentItem.js - Autocomplete widget for text fields
 *
 * Author: MTM and Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.contentItem', function(){

		var defaults = {
			multiValues: true,
			unique: false,
			fieldTemplate: 'core.contentItem.field',
			resultsTemplate: 'core.contentItem.resultWrapper',
			resultItemTemplate: 'core.contentItem.resultItem',
			itemTemplate: 'core.contentItem.item',
			queryParam: 'q',
			minAjaxLength: 1
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_contentItem') ){
				$( elem ).data('_contentItem', contentItemObj(elem, _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Destruct the autocomplete widget on this elem
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		},

		/**
		 * Retrieve the  instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The dialog instance or undefined
		 */
		getObj = function (elem) {
			elem = $( elem );

			if( elem.data('_contentItem') ){
				return elem.data('_contentItem');
			} else if(  $( '[name="' + elem.attr('name') + '_original' + '"]' ).length &&  $( '[name="' + elem.attr('name') + '_original' + '"]' ).data('_contentItem') ){
				return  $( '[name="' + elem.attr('name') + '_original' + '"]' ).data('_contentItem');
			}

			return undefined;
		};

		ips.ui.registerWidget('contentItem', ips.ui.contentItem, 
			[ 'resultsTemplate', 'resultItemTemplate', 'itemTemplate', 'queryParam', 'dataSource', 'maxItems', 'minAjaxLength' ]
		);

		return {
			respond: respond,
			destruct: destruct,
			getObj: getObj
		};
	});

	/**
	 * Content item instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var contentItemObj = function (elem, options, e) {

		var timer,
			blurTimer,
			lastValue = '',
			originalTextField,
			valueField,
			hiddenValueField,
			itemListWrapper,
			textField,
			dataSource,
			elemID = $( elem ).identify().attr('id'),
			wrapper,
			inputItem,
			resultsElem,
			disabled = false,
			required = false,
			tooltip = null,
			tooltipTimer = null;

		/**
		 * Sets up this instance. The datasource object is chosen depending on what options and/or
		 * attributes are provided.
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			if( $( elem ).is('input[type="text"], input[type="search"]') ){
				originalTextField = $( elem );
			} else {
				originalTextField = $( elem ).find('input[type="text"], input[type="search"]').first();
			}

			// Add our autocomplete wrapper to the page, and move the element into it
			_buildWrapper();

			// Set up the data source for this control
			_getDataSource();

			// Remove list from original field
			originalTextField.removeAttr('list');

			// Build the list
			_buildResultsList();

			if( originalTextField.is(':disabled') ){
				disabled = true;
			}

			if( originalTextField.is('[required]') ){
				required = true;
				originalTextField
					.removeProp('required')
					.removeAttr('aria-required');
			}

			// Turn off autocomplete and spellcheck so the browser menu doesn't get in the way
			textField
				.prop( 'autocomplete', 'off' )
				.prop( 'spellcheck', false )
				.prop( 'disabled', disabled )
				.attr( 'aria-autocomplete', 'list' )
				.attr( 'aria-haspopup', 'true' )
				.attr( 'tabindex', originalTextField.attr('tabindex') || '' );

            $( document ).on( 'click', _documentClick );

            wrapper.click(function(e) {
                e.stopPropagation();
                return false;
            });

			// Set up events
			textField
				.on( 'focus', _focusField )
				.on( 'blur', _blurField )
				.on( 'keydown', _keydownField )

			wrapper
				.on( 'click', _clickWrapper )
				.on( 'keydown', _keydownWrapper )
				.on( 'propChanged', _propChanged )
				.toggleClass( 'ipsField_autocompleteDisabled', disabled );
			
			elem.trigger( 'autoCompleteReady', {
				elemID: elemID,
				elem: elem,
				currentValues: contentItems.getValues()
			});
		},
		
		/**
		 * Destruct
		 * Removes event handlers assosciated with this instance
		 *
		 * @returns {void}
		 */
		destruct = function () {
			$( document ).off( 'click', _documentClick );
		},

		/**
 		 * Responds to the propChange event, which we use to determine whether the original field has been toggled
		 *
		 * @returns {void}
		 */
		_propChanged = function (e) {
			disabled = originalTextField.is(':disabled');

			wrapper.toggleClass( 'ipsField_autocompleteDisabled', disabled );
		},

		/**
 		 * Builds the element that results will appear in
		 *
		 * @returns {void}
		 */
		_buildResultsList = function () {

			if( options.resultsElem && $( options.resultsElem ).length ){
				resultsElem = $( options.resultsElem );
				return;
			}

			var resultsList = ips.templates.render( options.resultsTemplate, {
				id: elemID
			});

			wrapper.append( resultsList );

			resultsElem = $('#' + elemID + '_results');

			resultsElem
				.on('mouseover', '[data-id]', function (e) {
					results.select( $( e.currentTarget ) );
				})
				.on('click', '[data-id]', function (e) {
					_addContentItem( $( e.currentTarget ) );
					textField.focus();
				})
				.attr( 'aria-busy', 'false' );
		},

		/**
 		 * Builds the wrapper element that looks like a text input, but allows us to search for items
		 * @returns {void}
		 */
		_buildWrapper = function () {
			var existingClasses = elem[0].className;
			
			$( elem )
				.after( ips.templates.render( options.fieldTemplate, {
					id: elemID
				}))
				.removeClass( existingClasses );

			wrapper = $( '#' + elemID + '_wrapper' );
			inputItem = $( '#' + elemID + '_inputItem' );

			var insertElem = $('<input/>').attr( {
				type: 'text',
				id: elemID + '_dummyInput'
			})
			.prop( 'autocomplete', 'off' );

			textField = insertElem;
			
			// Make a copy of the original text field using its name. This is because it's difficult to set
			// arbitrary values in the original text field later if it's associated with a datalist.
			var name = originalTextField.attr('name');

			originalTextField.attr( 'name', originalTextField.attr('name') + '_original' );
			valueField = $('<input/>').attr( 'name', name ).hide();
			hiddenValueField = $('input[name=' + name + '_values]');
			itemListWrapper = $('[data-contentitem-results=' + name + ']');
			
			originalTextField.hide();

			// Move any classnames on the original element onto our new wrapper to maintain styling,
			// then move the original element into our reserved list element
			wrapper
				.addClass( existingClasses )
				.append( elem )
				.append( valueField )
				.find('#' + elemID + '_inputItem')
					.append( insertElem );
			
			if ( options.maxItems && contentItems.total() >= options.maxItems )
			{
				wrapper.hide();
			}
				
			// Set events for clicking on item
			itemListWrapper
				.on('click', '[data-action="delete"]', function (e) {
					_deleteContentItem( $( e.currentTarget ).parent('[data-id]') );
				});
		},

		/**
 		 * Gets the apprioriate data source for this control
		 *
		 * @returns {void}
		 */
		_getDataSource = function () {
			if( ips.utils.validate.isUrl( options.dataSource ) ){
				dataSource = remoteData( options.dataSource, options );
			} else {
				dataSource = noData();
			}
		},

		/**
 		 * When the wrapper is clicked, we see if a item was clicked. If it was, select it. If not, focus the textbox.
		 *
		 * @returns {void}
		 */
		_clickWrapper = function (e) {
			if( !$( e.target ).is( textField ) && ( !resultsElem || !$.contains( resultsElem.get(0), e.target ) ) ){
				textField.focus();
			}
		},

		/**
 		 * Event handler for focusing on the text field
		 *
		 * @returns {void}
		 */
		_focusField = function (e) {
			if( dataSource.type == 'none' ){
				return;
			}

			timer = setInterval( _timerFocusField, 400 );
		},

		/**
 		 * Event handler for blurring on the text field
		 *
		 * @returns {void}
		 */
		_blurField = function (e) {
			clearInterval( timer );

			_.delay( _timerBlurField, 300 );
		},

		/**
 		 * Timed event hides the results list
		 *
		 * @returns {void}
		 */
		_timerBlurField = function () {
			
			_closeResults();
		},

		/**
 		 * Timed event, checks whether the value has changed, and fetches the results
		 *
		 * @returns {void}
		 */
		_timerFocusField = function () {
			if( dataSource.type == 'none' ){
				return;
			}

			// Fetch the current item value
			var currentValue = _getCurrentValue();

			// If the value hasn't changed, we can leave
			if( currentValue == lastValue ){
				return;
			}

			lastValue = currentValue;

			_loadResults( currentValue );
		},

		/**
 		 * Requests results from the data source, and shows/hides the loading widget
 		 * while that is happening.
		 *
		 * @returns {void}
		 */
		_loadResults = function (value) {
			_toggleLoading('show');

			// Set elem to busy
			resultsElem.attr( 'aria-busy', 'true' );

			// Get the results
			dataSource.getResults( value )
				.done( function (results) {
					// Show the results after processing them
					_showResults( _processResults( results, value ) );
				})
				.fail( function () {

				})
				.always( function () {
					resultsElem.attr( 'aria-busy', 'false' );
					_toggleLoading('hide');
				});
		},

		/**
 		 * Toggles the loading thingy in the control to signify data is loading
		 *
		 * @param 	{string} 	doWhat 	 Acceptable values: 'show' or 'hide'
		 * @returns {void}
		 */
		_toggleLoading = function (doWhat) {
			if( doWhat == 'show' ){
				wrapper.addClass('ipsField_loading');
			} else {
				wrapper.removeClass('ipsField_loading');
			}
		},

		/**
 		 * Closes the suggestions menu, sets the aria attrib, and tells the data source
 		 * to stop loading new results
		 *
		 * @returns {void}
		 */
		_closeResults = function (e) {
			if( e ){
				e.preventDefault();
			}

			if( resultsElem && resultsElem.length ){
				resultsElem
					.hide()
					.attr('aria-expanded', 'false');	
			}		

			dataSource.stop();
		},

		/**
 		 * Handles a click on the document, closing the results dropdown
		 *
		 * @returns {void}
		 */
		_documentClick = function () {
			_closeResults();
		},

		/**
 		 * Processes the results that are returned by the data source
		 *
		 * @returns {void}
		 */
		_processResults = function (results, text) {
			var existingItems = contentItems.getValues(),
				newResults = {};

			$.each( results, function (key, data) {
				if( !data.id || _.indexOf( existingItems, data.id ) === -1 ){
					newResults[ key ] = data;
				}
			});

			return newResults;
		},

		/**
 		 * Gets the current item value from the text field
		 *
		 * @returns {string}
		 */
		_showResults = function (results) {

			var output = '';

			$.each( results, function (idx, value) {
				output += ips.templates.render( options.resultItemTemplate, value );
			});
		
			if( resultsElem.attr('id') == ( elemID + '_results' ) ){
				_positionResults();
			}

			resultsElem
				.show()
				.html( output )
				.attr('aria-expanded', 'true');
		},

		/**
 		 * Sizes and positions the results menu to match the wrapper
		 *
		 * @returns {void}
		 */
		_positionResults = function () {

			resultsElem.css( {
				width: wrapper.outerWidth() + 'px'
			});

			var positionInfo = {
				trigger: wrapper,
				targetContainer: wrapper,
				target: resultsElem,
				center: false
			};

			var resultsPosition = ips.utils.position.positionElem( positionInfo );

			$( resultsElem ).css({
				left: '0px',
				top: resultsPosition.top + 'px',
				position: ( resultsPosition.fixed ) ? 'fixed' : 'absolute',
				zIndex: ips.ui.zIndex()
			});
		},

		/**
 		 * Gets the current item value from the text field
		 *
		 * @returns {string}
		 */
		_getCurrentValue = function () {
			var value = textField.val();
			return value;
		},

		/**
 		 * Event handler for keydown event in wrapper.
 		 * We check for esape here, because if options.freeChoice is disabled, there's no textbox to
 		 * watch for events. By watching for escape on the wrapper, we can still close the menu.
		 *
		 * @returns {void}
		 */
		_keydownWrapper = function (e) {
			if( e.keyCode == ips.ui.key.ESCAPE ){
				keyEvents.escape(e);
			}
		},

		/**
 		 * Event handler for keydown event in text field
		 *
		 * @returns {void}
		 */
		_keydownField = function (e) {
			_expandField();
			var ignoreKey = false;

			// Ignore irrelevant keycodes
			if( !_( [ ips.ui.key.UP, ips.ui.key.DOWN, ips.ui.key.ESCAPE, ips.ui.key.ENTER
					 ] ).contains( e.keyCode ) ){
				ignoreKey = true;
			}
			
			var value = textField.val().trim();
			
			if( ignoreKey ){
				return;
			}
			
			switch(e.keyCode){
				// Suggestions keys
				case ips.ui.key.UP:
					keyEvents.up(e);
				break;
				case ips.ui.key.DOWN:
					keyEvents.down(e);
				break;
				case ips.ui.key.ESCAPE:
					keyEvents.escape(e);
				break;
				case ips.ui.key.ENTER:
					keyEvents.enter(e);
				break;
			}
		},

		/**
 		 * A wrapper method for contentItems.add which also clears the text field
 		 * and hides it if options.maxItems is reached
		 *
		 * @returns {void}
		 */
		_addContentItem = function (elem) {
			contentItems.add( elem );
			textField.val('');
			lastValue = '';
			_resetField();

			if( options.maxItems && contentItems.total() >= options.maxItems ){
				wrapper.hide();
			}
		},

		/**
 		 * A wrapper method for contentItems.remove which shows the text field if we're under
 		 * our options.maxItems limit
		 *
		 * @returns {void}
		 */
		_deleteContentItem = function (item) {
			if( disabled ){
				return;
			}
			
			contentItems.remove( item );
		},

		/**
 		 * Object containing event handlers bound to individual keys
 		 */
		keyEvents = {

			/**
	 		 * Handler for 'up' key press. Selects previous item in the results list.
			 *
			 * @returns {void}
			 */
			up: function (e) {
				if( !resultsElem || !resultsElem.is(':visible') ){
					return;
				}

				e.preventDefault();

				var selected = results.getCurrent();				

				if( !selected ){
					results.selectLast();
				} else {
					var prev = results.getPrevious( selected );

					if( prev ){
						results.select( prev );
					} else {
						results.selectLast();
					}
				}
			},

			/**
	 		 * Handler for 'down' key press. Selects next item in the results list.
			 *
			 * @returns {void}
			 */
			down: function (e) {
				if( !resultsElem || !resultsElem.is(':visible') ){
					return;
				}

				e.preventDefault();

				var selected = results.getCurrent();
				
				if( !selected ){
					results.selectFirst();
				} else {
					var next = results.getNext( selected );

					if( next ){
						results.select( next );
					} else {
						results.selectFirst();
					}
				}

			},
			
			/**
	 		 * Enter/tab handler. If text has been entered, we add it as a item, otherwise pass through
	 		 * to the browser to handle.
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void,boolean} 		
			 */
			enter: function (e) {
				e.preventDefault();

				var currentResult = results.getCurrent();
				var value = '';

				if( currentResult ){
					value = currentResult.attr('data-id');
				}
				
				if( !value ){
					return false;
				}

				_addContentItem( currentResult );
			},

			/**
	 		 * Handler for 'escape' key press. Closes the suggestions menu, if it's open.
			 *
			 * @returns {void}
			 */
			escape: function (e) {
				if( resultsElem && resultsElem.is(':visible') ){
					_closeResults();
				}
			}

		},

		/**
 		 * Object containing methods for dealing with the results list.
 		 */
		results = {

			/**
	 		 * Deselects any selected results
			 *
			 * @returns {void}
			 */
			deselectAll: function () {
				resultsElem
					.find('[data-selected]')
					.removeAttr('data-selected');
			},

			/**
	 		 * Returns the currently selected result
			 *
			 * @returns {element,boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getCurrent: function () {
				if( dataSource.type == 'none' ){
					return;
				}

				var cur = resultsElem.find('[data-selected]');

				if( cur.length && resultsElem.is(':visible') ){
					return cur;
				} 

				return false;
			},

			/**
	 		 * Gets the result preceding the provided result
			 *
			 * @returns {element,boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getPrevious: function (result) {
				var prev = $( result ).prev('[data-id]');

				if( prev.length ){
					return prev;
				}

				return false;
			},

			/**
	 		 * Gets the result following the provided result
			 *
			 * @returns {element,boolean} 	Returns the jQuery object containing the selected result, or false
			 */
			getNext: function (result) {
				var next = $( result ).next('[data-id]');

				if( next.length ){
					return next;
				}

				return false;
			},

			/**
	 		 * Selects the first result
			 *
			 * @returns {void}
			 */
			selectFirst: function () {
				results.select( resultsElem.find('[data-id]').first() );
			},

			/**
	 		 * Selects the last result
			 *
			 * @returns {void}
			 */
			selectLast: function () {
				results.select( resultsElem.find('[data-id]').last() );
			},

			/**
	 		 * Selects the provided item
			 *
			 * @returns {void}
			 */
			select: function (result) {
				results.deselectAll();
				
				result.attr('data-selected', true);
			}
		},

		/* ! Content Items */
		/**
 		 * Object containing item methods
 		 */
		contentItems = {

			selected: null,

			/**
	 		 * Adds an item to the control
			 *
			 * @param 	{object} 	elem 	Element from result list to add
			 * @returns {void}
			 */
			add: function (elem) {
				var html = '';
				var obj  = $(elem).find('[data-role=contentItemRow]');
				html = obj.html();

				itemListWrapper.append( ips.templates.render( options.itemTemplate, {
					id: obj.attr('data-itemid'),
					html: html
				}));

				if( resultsElem ){
					_closeResults();
				}

				// Update hidden field
				hiddenValueField.val( contentItems.getValues().join( ',' ) );
				
				if ( options.maxItems && contentItems.total() >= options.maxItems )
				{
					wrapper.hide();
				}
				
				elem.trigger('contentItemAdded', {
					html: html,
					itemList: contentItems.getValues(),
					totalItems: contentItems.total()
				});

				return true;
			},

			/**
	 		 * Deletes the given item
			 *
			 * @param 	{element} 	item 	The item element to select
			 * @returns {void}
			 */
			remove: function (item) {
				if( contentItems.selected == item ){
					contentItems.selected = null;
				}

				var value = $( item ).attr('data-value');
				$( item ).remove();

				if( options.maxItems && contentItems.total() < options.maxItems ){
					wrapper.show();
				}

				// Update text field
				hiddenValueField.val( contentItems.getValues().join( ',' ) );

				elem.trigger('contentItemDeleted', {
					item: item,
					itemList: contentItems.getValues(),
					totalItems: contentItems.total()
				});
			},

			/**
	 		 * Returns total number of items entered
			 *
			 * @returns {number}
			 */
			total: function () {
				return itemListWrapper.find('[data-id]').length;
			},

			/**
	 		 * Returns all of the values
			 *
			 * @param 	{element} 	item 	The item element to select
			 * @returns {void}
			 */
			getValues: function () {
				var values = [];
				var allContentItems = itemListWrapper.find('[data-id]');
				if( allContentItems.length ){
					values = _.map( allContentItems, function( item ){
						return $( item ).attr('data-id');
					});
				}

				return values;
			}
		},

		/**
 		 * Determines whether the value would be a duplicate
		 *
		 * @param 	{string} 	value 	Value to check
		 * @returns {void}
		 */
		_duplicateValue = function (value) {
			var values = contentItems.getValues();

			if( values.indexOf( value ) !== -1 ){
				return true;
			}

			return false;
		},
		
		/**
 		 * Expands the text field to fit the given text
		 *
		 * @returns {void}
		 */
		_expandField = function () {
			var text = textField.val();
			var widthOfElem = wrapper.width();

			widthOfElem -= ( parseInt( wrapper.css('padding-left') ) + parseInt( wrapper.css('padding-right') ) );

			// Create temporary span
			var span = $('<span/>').text( text ).css({
				'font-size': textField.css('font-size'),
				'letter-spacing': textField.css('letter-spacing'),
				'position': 'absolute',
				'top': '-100px',
				'left': '-300px',
				'opacity': "0.1"
			});

			ips.getContainer().append( span );

			// Get the width
			var width = span.width() + 20;

			// Remove it
			span.remove();

			textField.css({
				width: ( ( width >= widthOfElem ) ? widthOfElem : width ) + 'px'
			});
		},

		/**
 		 * Resets the width of the text input
		 *
		 * @returns {void}
		 */
		_resetField = function () {
			textField.css({
				width: '15px'
			});
		};

		init();

		return {
			init: init,
			destruct: destruct,
			addContentItem: contentItems.add,
			getContentItem: contentItems.getValues,
			removeContentItem: contentItems.remove
		};
	};

	/**
	 * Handler for remote data retrieval
	 */
	var remoteData = function (source, options) {

		var ajaxObj,
			loadedCache = false,
			cache = {};

		/**
 		 * Initiates either a remote search or a remote fetch
		 *
		 * @returns {promise}
		 */
		var getResults = function (text) {
			return _remoteSearch( text );
		},

		/**
 		 * Returns the number of items in the result set
		 *
		 * @returns {number}
		 */
		totalItems = function () {
			return -1;
		},

		/**
 		 * Does a remote search (i.e. passing search string to backend, and returning results)
		 *
		 * @param 	{string}	String to search for
		 * @returns {promise}
		 */
		_remoteSearch = function (text) {
			var deferred = $.Deferred();

			if( ajaxObj ){
				ajaxObj.abort();
			}

			if( options.minAjaxLength > text.length ){
				deferred.reject();
				return deferred.promise();
			}

			if( cache[ text ] ){
				deferred.resolve( cache[ text ] );
			} else {				
				ajaxObj = ips.getAjax()( source + '&' + options.queryParam + '=' + encodeURIComponent( text ), { dataType: 'json' } )
					.done( function (response) {
						deferred.resolve( response );
						cache[ text ] = response;
					})
					.fail( function (jqXHR, status, errorThrown) {
						if( status != 'abort' ){
							Debug.log('aborting');
						}
						deferred.reject();
					});
			}

			return deferred.promise();
		},

		/**
 		 * Fetches remote data, and then performs a local search on the data to find results
		 *
		 * @param 	{string}	String to search for
		 * @returns {promise}
		 */
		_remoteFetch = function (text) {
			var deferred = $.Deferred();

			if( !loadedCache ){
				if( ajaxObj ){
					return;
				}

				if( options.minAjaxLength > text.length ){
					return;
				}

				ajaxObj = ips.getAjax()( source, { dataType: 'json' } )
					.done( function (response) {
						loadedCache = true;
						cache = response;
						_remoteFetch( text );
					})
					.fail( function (jqXHR, status, errorThrown) {
						if( status != 'abort' ){
							Debug.log('aborting');
						}
						deferred.reject();
					});
			}

			// Search through the cache for results
			cache.each( function (idx, item) {
				if( item.value.toLowerCase().startsWith( text ) ){
					output.push( item );
				}
			});

			return deferred.promise();
		},

		/**
 		 * Aborts the ajax request
		 *
		 * @param 	{string}	String to search for
		 * @returns {void}
		 */
		stop = function () {
			if( ajaxObj ){
				ajaxObj.abort();
			}
		};

		return {
			type: 'remote',
			getResults: getResults,
			totalItems: totalItems,
			stop: stop
		};
	};

	var noData = function () {
		return {
			type: 'none',
			getResults: $.noop,
			totalItems: -1,
			stop: $.noop
		};
	};

}(jQuery, _));

]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.controls.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.controls.js
 * This powers element visibility using aria-controls/aria-expanded (on a toggle button), and an id on the content/target element.
 * Animations are powered by CSS using either data-ips-hidden-animation="slide | slide-fade | fade", or --i-animation-name on the hidden element.
 *
 * Author: Ehren Harber
 */
;( function($, _){
	"use strict";

	const CACHED_REMOTE_RESPONSES = new Map();

	/**
	 * @typedef {CustomEvent<{controls:boolean, toggle:Element}>} ipsUiControlsToggleEvent
	 */
	ips.createModule('ips.ui.controls', function(){

		// Add event listener to document, which handles all opening/closing of hidden elements
		// This event listener is only added to the document once, regardless of how many data-ipscontrols elements exist
		document.addEventListener('click', handleEvent);

		/**
		 * Responder for controls widget
		 *
		 * @param	{jQuery} 	elem 		The element this widget is being created on
		 */
		function respond(elem) {
		}

		function handleEvent(e){

			// Return early if any editor toolbars are clicked
			if (e.target.closest('.ipsEditor__toolbar-item, .ipsEditor__toolbar-panel')) {
				return;
			}

			// Find out if the target is an aria-controls element
			let toggle = e.target.closest('[data-ipscontrols][aria-controls]');

			// Find out if any light dismiss elements are open. This fetches open dialogs, and non-dialog light-dismiss elements which are [hidden]. We fetch them like this since dialogs don't use [hidden]
			const lightDismiss = document.querySelectorAll("[data-ips-hidden-light-dismiss][open], [data-ips-hidden-light-dismiss]:not(dialog):not([hidden])");

			// If a toggle button wasn't clicked and if there are no active light-dismiss elements, stop here
			if (!toggle && !lightDismiss.length) return;

			if(toggle){

				// Get elements IDs (aria-controls supports multiple elements separated by a space)
				const name = toggle.getAttribute("aria-controls"),
					contentElementIds = name.split(" "),
					isExpanded = toggle.getAttribute("aria-expanded");

				// If [aria-expanded] doesn't exist, log to the console and return early
				if(!isExpanded){
					Debug.log("The clicked element has [aria-controls] but no [aria-expanded] value.")
					return
				}

				// If a 'multi id' value was clicked, toggle its aria-expanded attribute
				if(contentElementIds.length > 1){
					document.querySelectorAll(`[aria-controls="${name}"]`).forEach(t => t.setAttribute("aria-expanded", (isExpanded === "true") ? "false" : "true"));
				}

				// Loop through each of the content areas and adjust their visibility
				for(const id of contentElementIds){

					// Get content, but return early if it doesn't exist
					const content = document.querySelector(`#${id}`);
					if(!content){
						Debug.log(`An element with #${id} was not found and therefore can't be toggled.`);
						continue;
					}

					// Update visibility of element
					showOrHide(content, toggle, !(isExpanded === "true"));

					// If this content is part of a group, only show a single element at a time. Useful for tabs, off-canvas menus, etc
					const isInGroup = content.getAttribute("data-ips-hidden-group");
					if(isInGroup){
						const groupElements = document.querySelectorAll(`[data-ips-hidden-group="${isInGroup}"]:not([hidden])`);

						for (const groupElement of groupElements){
							// Hide other group elements, except for the one being triggered
							if (groupElement != content){
								showOrHide(groupElement, toggle, false);
							}
						}
					}

				}

			}

			// Hide light-dismiss element(s) when they aren't clicked
			for(const lightDismissEl of lightDismiss){
				// Close the element unless the click event occurred inside the light-dismiss element or if the clicked element was a light-dismiss dialog (ie. ::backdrop)
				if (lightDismissEl.contains(e.target) && e.target.tagName.toLowerCase() !== "dialog") continue;
				showOrHide(lightDismissEl, e.target, false);
			}
		}

		/**
		 * Hide or show an element. aria-expanded toggles are also updated
		 * @param 	{HTMLElement}		content
		 * @param 	{Element}			trigger
		 * @param 	{boolean}			show
		 */
		async function showOrHide(content, trigger, show = true){

			// Move element to end of body if it's being opened and has data-ips-hidden-top-layer, or if it's a dialog
			if(show && (content.hasAttribute("data-ips-hidden-top-layer") || content.tagName === "DIALOG")){
				document.getElementById('ipsLayout')?.appendChild(content);
			}

			// Determine what element this is (div, dialog, etc) so we can handle appropriately
			const contentTag = (content.tagName);

			// Toggle aria-expanded attribute on trigger element
			document.querySelectorAll(`[data-ipscontrols][aria-controls="${content.id}"]`).forEach(t => t.setAttribute("aria-expanded", show));
			
			if (show) {
				if (contentTag === "DIALOG") {
					content.showModal();
					content.addEventListener("close", _closeEvent);
				} else {
					content.hidden = false;
				}

				const src = trigger.dataset.ipscontrolsSrc;
				if (typeof src === 'string' && !content.dataset.ipscontrolsLoaded) {
					/** if we know the content, just use it */
					if (CACHED_REMOTE_RESPONSES.has(src) && typeof CACHED_REMOTE_RESPONSES.get(src).html === 'string' && !(typeof CACHED_REMOTE_RESPONSES.get(src).expiresAt === 'number' && CACHED_REMOTE_RESPONSES.get(src).expiresAt < Date.now() / 1000)) {
						Debug.log(`ips.ui.controls: Using cached response for ${src}`);
						content.innerHTML = CACHED_REMOTE_RESPONSES.get(src).html;
						for (const cls of [...content.classList]) {
							if (cls.startsWith('ipsLoading')) {
								content.classList.remove('ipsLoading');
							}
						}
						$(document).trigger('contentChange', [$(content)]);
						content.ipsHide();
						content.dataset.ipscontrolsLoaded = '1';
						content.querySelector("[data-autofocus]")?.focus();
						// on the first time, we wait a split second for the browser to execute a reflow
						await new Promise(resolve => setTimeout(resolve, 50));
						content.ipsShow();
					} else {
						content.classList.add('ipsLoading');
						const start = Date.now();
						loadContent(src)
							.then(html => new Promise(
								/**
								 *
								 * @param {function(string)} resolve
								 */
								resolve => {
									// first, make sure the animation completed
									if (Date.now() - start < 700) {
										setTimeout(() => resolve(html), 700 - (Date.now() - start))
									} else {
										resolve(html)
									}
								}
							))
							.then(html => {
								content.innerHTML = html;

								for (const cls of [...content.classList]) {
									if (cls.startsWith('ipsLoading')) {
										content.classList.remove('ipsLoading');
									}
								}
								$(document).trigger('contentChange', [$(content)]);
								content.dataset.ipscontrolsLoaded = '1';
								content.querySelector("[data-autofocus]")?.focus();
							})
					}
				} else {

					// Apply autofocus to inputs
					content.querySelector("[data-autofocus]")?.focus();
				}
			}

			// Ensure the above has painted before the height is calculated
			requestAnimationFrame(() => {
				content.style.setProperty('--i-animating-height', content.scrollHeight + 'px');
			})

			content.setAttribute("data-ips-animating", (show) ? 'opening' : 'closing');

			// Once animations are done, remove animation
			await Promise.allSettled(
				content.getAnimations().map((a) => a.finished)
			);

			if (!show) {
				(contentTag === "DIALOG") ? content.close() : content.hidden = true;
			}
			content.removeAttribute("data-ips-animating");

			// Dispatch event so other elements can respond to the changed state; always dispatch `ips:toggleComplete`, then optionally another event if the dataset specifies an event property
			const eventNames = ['ips:toggleComplete']
			if (content.dataset.ipsHiddenEvent) {
				eventNames.push(content.dataset.ipsHiddenEvent)
			}

			eventNames.forEach(eventName => content.dispatchEvent(new CustomEvent(eventName, {
				bubbles: true,
				detail: { hidden: content.hidden, trigger: trigger }
			})));
		}

		/**
		 * Ensure the necessary data-attributes are updated when the close event is fired on dialogs (eg, via ESC)
		 * @param 	{Event}			e
		 */
		function _closeEvent(e) {
			if(!e.target.getAttribute("open")){
				showOrHide(e.target, e.target, false);
			}
		}

		/**
		 * Load the content at a given url, contained to this module
		 *
		 * @param {string|URL}		src								Where to load content from
		 * @param {boolean}			[forceRequest=false]			Force an xhr request
		 *
		 * @return {Promise<string>}
		 */
		async function loadContent(src, forceRequest=false) {
			src = (new URL(src)).toString();
			const cachedContents = CACHED_REMOTE_RESPONSES.get(src);
			if (!forceRequest && cachedContents && typeof cachedContents.html === 'string') {
				if (!(typeof cachedContents.expiresAt === 'number' && cachedContents.expiresAt < Date.now() / 1000)) {
					Debug.log(`ips.ui.controls: Using cached response for ${src}`);
					return cachedContents.html;
				}
				CACHED_REMOTE_RESPONSES.delete(src);
			}

			try {
				const response = await ips.fetch(src);
				if (typeof response !== 'object' || typeof response.html !== 'string') {
					throw new TypeError(`Expected an object with an html:string property`);
				}

				if (!response.noCache) {
					response.expiresAt = response.expiresAt || Math.round(Date.now() / 1000 + 3600);
					if (typeof response.expiresAt === 'string') {
						response.expiresAt = parseInt(response.expiresAt);
					}
					if (typeof response.expiresAt !== 'number' || Number.isNaN(response.expiresAt)) {
						response.expiresAt = Math.round(Date.now() / 1000 + 3600);
					}
					if (!Number.isInteger(response.expiresAt)) {
						response.expiresAt = Math.round(response.expiresAt);
					}

					if (response.expiresAt * 1000 > Date.now()) {
						CACHED_REMOTE_RESPONSES.set(src, response);
					}
				}
				return response.html;
			} catch (e) {
				return ips.templates.render("ips.ui.controls.cannot_load", {message: typeof e.responseJSON?.errorMessage === 'string' ? e.responseJSON.errorMessage : undefined});
			}
		}
		
		// Register this widget with ips.ui
		ips.ui.registerWidget( 'controls', ips.ui.controls, ['src'] );

		return {
			respond
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.copy.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.copy.js - Widget that has something that can be copied to clipboard
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.createModule('ips.ui.copy', function(){

		var respond = function (elem, options, e) {
			ips.loader.getStatic(&quot;/applications/core/interface/static/clipboard/clipboard.min.js&quot;).then( function()
	        {
		        if ( ClipboardJS.isSupported() ) {
			        elem.find('[data-role=&quot;copyButton&quot;]').show();

					if ( elem.find('[data-role=&quot;copyButton&quot;]').attr('href') ) {
						/* Don't allow the link to be followed */
						elem.find('[data-role=&quot;copyButton&quot;]').on('click', function (e) {
							e.preventDefault();
							e.stopPropagation();
						});
					}

					var clipboard = new ClipboardJS( elem.find('[data-role=&quot;copyButton&quot;]').get(0) );

					clipboard.on('success', function(e) {
						if ( elem.attr('data-ipsCopy-flashmessage') !== undefined ) {
							ips.ui.flashMsg.show(ips.getString('copied'))
						} else {
							elem.find('[data-role=&quot;copyButton&quot;]').text( ips.getString('copied') );
						}
					});
				}
			} );
		};
		
		ips.ui.registerWidget( 'copy', ips.ui.copy, [] );

		return {
			respond
		};
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.details.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.details.js
 * This adds animations to details/summary elements
 *
 * Author: Ehren Harber
 */
;( function(){
	"use strict";

	ips.createModule('ips.ui.details', function(){

		/**
		 * Responder for details widget
		 *
		 * @param	{jQuery} 	elem 		The element this widget is being created on
		 */
		var respond = function (elem) {
			document.addEventListener('click', toggleDetails);
		},

		toggleDetails = function(e){

			const summary = e.target.closest('[data-ipsdetails] summary');

			if(!summary) return;

			const details = summary.closest('details'),
				content = details.querySelector('i-details-content'),
				isOpen = details.open;

			if(!details || !content) return;

			e.preventDefault();

			if(!isOpen) details.open = true;

			// Calculate height of content
			content.style.setProperty('--i-animating-height', content.scrollHeight + 'px');

			// Start animating
			content.setAttribute('data-ips-animating', (isOpen) ? 'closing' : 'opening');

			// Once animations are done, remove animation
			Promise.all(
				content.getAnimations().map((a) => a.finished)
			).then(() => {
				if(isOpen) details.open = false;
				content.removeAttribute('data-ips-animating');
			});

		};
		
		// Register this widget with ips.ui
		ips.ui.registerWidget( 'details', ips.ui.details );

		return {
			respond: respond
		}
	});
}());]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.dialog.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.dialog.js - Popup dialog UI component
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.dialog', function(){

		var defaults = {
			modal: true,
			draggable: false,
			className: 'ipsDialog',
			extraClass: '',
			close: true,
			fixed: false,
			narrow: false,
			callback: null,
			forceReload: false,
			flashMessage: '',
			flashMessageTimeout: 2,
			flashMessageEscape: true,
			remoteVerify: true,
			remoteSubmit: false,
			destructOnClose: false,
			ajax: { type: 'get', data: {} }
		};

		var showStack = [];

		/**
 		 * Respond to a dialog trigger
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed
		 * @returns {void}
		 */
		var respond = function (elem, options, e) {
			e.preventDefault();

			// If no option URL and no local content is specified, see if we can use
			// the href of the source element
			if( !options.url && !options.content && $( elem ).attr('href') ){
				options.url = $( elem ).attr('href');
			}

			if( !$( elem ).data('_dialog') ){
				$( elem ).data('_dialog', dialogObj(elem, _.defaults( options, defaults ) ) );
			}

			$( elem ).data('_dialog').show();
		},

		/**
		 * Retrieve the dialog instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The dialog instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_dialog') ){
				return $( elem ).data('_dialog');
			}

			return undefined;
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
				$( elem ).removeData('_dialog');
			}
		},

		/**
		 * Creates a dialog that is not attached to a specific element
		 *
		 * @param	{object} 	options 		Options passed to the dialog
		 * @returns {object} 	The dialog instance
		 */
		create = function (options) {
			return dialogObj( null, _.defaults( options, defaults ) );
		},

		/**
		 * Determine if there are any open dialogs
		 *
		 * @returns	{bool}
		 */
		hasOpenDialogs = function() {
			return ( showStack.length > 0 );
		},

		/**
		 * Init
		 * Sets up events used to manage multiple dialog instances, primarily
		 * the escape key to hide the forefront dialog
		 *
		 * @returns {void}
		 */
		_init = function () {
			// Set up event checking for ESC
			$( document )
				.on( 'keydown', function (e) {
					if( e.keyCode == ips.ui.key.ESCAPE ){
						$( document ).trigger( 'closeDialog', {
							dialogID: showStack[ showStack.length - 1 ]
						});
					}
				})
				.on( 'openDialog', function (e, data) {
					showStack.push( data.dialogID );
				})
				.on( 'hideDialog', function (e, data) {
					showStack = _.without( showStack, data.dialogID );
				});
		};

		ips.ui.registerWidget('dialog', ips.ui.dialog, [ 
			'url', 'modal', 'draggable', 'size', 'title', 'close', 'fixed', 'destructOnClose', 'extraClass',
			'callback', 'content', 'forceReload' , 'flashMessage', 'flashMessageTimeout', 'flashMessageEscape', 'remoteVerify', 'remoteSubmit'
		], { lazyLoad: true, lazyEvents: 'click' } );

		_init();

		return {
			respond: respond,
			destruct: destruct,
			getObj: getObj,
			create: create,
			hasOpenDialogs: hasOpenDialogs
		};
	});

	/**
	 * Dialog instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var dialogObj = function (elem, options) {

		var modal, // The modal background
			dialog, // The dialog element itself
			ajaxObj,
			dialogID = '',
			elemID = '',
			dialogBuilt = false,
			contentLoaded = false,
			modalEvent = { up: false, down: false },
			contentProcessors = []
		;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			
			if( elem === null ){
				elemID = 'elem_' + ( Math.round( Math.random() * 10000000 ) );
			} else {
				elemID = $(elem).identify().attr('id');
			}

			dialogID = elemID + '_dialog';

			// If we're fullscreen, make sure we're fixed too
			if( options.size == 'fullscreen' ){
				options.fixed = true;
			}

			// We watch for this on the document, to give our pages a chance
			// to intercept the event and cancel it (e.g. an unsaved form)
			$( document ).on( 'closeDialog', closeDialog );
		},

		/**
		 * Destruct the dialog for this instance
		 *
		 * @returns 	{void}
		 */
		destruct = function () {
			clearTimeout(anchorClickTimeout);
			$( document ).off( 'closeDialog', closeDialog );

			if( modal ){
				modal.remove();
			}

			if( dialog ){
				dialog.remove();
			}
		},

		anchorClickTimeout,

		/**
		 * Check if an anchor tag was clicked
		 * @param	{PointerEvent} e
		 */
		checkForAnchorClicks = e => {
			clearTimeout(anchorClickTimeout);
			// if the browser behavior of focusing the anchor is prevented, no need to close
			if (e.defaultPrevented) {
				return;
			}

			const link = e.target?.closest?.(`a[href*="#"]`);
			if (!link) {
				return;
			}

			const pageURL = new URL(window.location.href);
			pageURL.hash = "";

			const linkURL = new URL(link.href, window.location.href);
			const hash = linkURL.hash;
			linkURL.hash = "";

			// Does this link go to an anchor on this page?
			if (!hash || pageURL.toString() !== linkURL.toString()) {
				return;
			}

			// Do we know what the dialog is?
			const dialogEl = dialog.get(0);
			if (!dialogEl) {
				return;
			}

			// focusing somewhere inside the dialog? leave it open
			try {
				if (hash.startsWith('#') && dialogEl.querySelector(hash)) {
					return;
				}
			} catch (e) {} // possible the hash is not a valid ID, but this is more or less expected

			// Wait for any other click listeners to do their thing before closing the dialog
			anchorClickTimeout = setTimeout(() => {
				if (!e.defaultPrevented) {
					closeDialog(undefined, {dialogID});
				}
			}, 0);
		},

		/**
		 * Event handler for the closeDialog event
		 *
		 * @param 		{Event} 	[e] 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		closeDialog = function (e, data) {
			if( data && data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			if( data && data.dialogID == dialogID ){
				hide();
				modalEvent = { up: false, down: false };
			}
		},

		/**
		 * Hides this dialog
		 *
		 * @returns 	{Promise<void>}
		 */
		hide = function () {
			return new Promise(resolve => {
				try {
					clearTimeout(anchorClickTimeout);
					dialog.get(0)?.removeEventListener('click', checkForAnchorClicks);
					dialog.animationComplete(function () {
						if (options.forceReload || options.destructOnClose) {
							ips.controller.cleanContentsOf(dialog);
							dialog.find('.' + options.className + '_content').html('');
						}

						$(elem || document).trigger('hideDialog', {
							elemID: elemID,
							dialogID: dialogID,
							dialog: dialog
						});

						if (options.destructOnClose) {
							ips.ui.dialog.destruct(elem);
						}

						resolve()
					});

					ips.utils.anim.go('fadeOutDown fast', dialog);

					if (options.modal) {
						ips.utils.anim.go('fadeOut fast', modal);
					}

					if (options.fixed) {
						$('html').removeClass('ipsNoScroll');
					}
				} catch (e) {}
			});
		},

		/**
		 * Public method for showing the dialog
		 * Builds local or remote dialog if necessary, then shows it
		 *
		 * @param		{bool}		[initOnly]	If TRUE, will create dialog but not show it
		 * @returns 	{void}
		 */
		show = function ( initOnly ) {
			if( options.url && !contentLoaded ){
				_remoteDialog( initOnly );
			} else if( !contentLoaded ) {
				_localDialog( initOnly );
			} else {
				if ( initOnly ) {
					return;
				}
				
				// Dialog already exists, so reset the zIndex and show it
				if( modal ){
                    modal.css( { zIndex: ips.ui.zIndex() } );
				}

				dialog.css( { zIndex: ips.ui.zIndex() } );
				_positionDialog();
				if (dialog.find( '.' + options.className + '_content').length) {
					for (const processor of contentProcessors) {
						processor($(dialog.find( '.' + options.className + '_content')).get(0))
					}
				}
				_showDialog();				
			}
		},

		/**
		 * Remove the dialog
		 *
		 * @returns 	{void}
		 */
		remove = function (hideFirst) {

			var doRemove = function () {
				if( ajaxObj && _.isFunction( ajaxObj.abort ) ){
					ajaxObj.abort();
				}

				// Remove the elements
				dialog.remove();

				if( modal ){
					modal.remove();
				}

				// Not built
				dialog = null;
				modal = null;
				dialogBuilt = false;
				contentLoaded = false;
				ajaxObj = null;
			};

			// If we're hiding first, we'll do it after the animation has finished
			if( hideFirst && dialog.is(':visible') ){
				hide().done( function () {
					doRemove();
				});
			} else {
				doRemove();
			}
		},

		/**
		 * Sets the dialog to 'loading' state.
		 * Hides the content, and adds a loading thingy.
		 *
		 * @returns 	{void}
		 */
		setLoading = function (loading) {
			if( loading ){
				dialog
					.find( '.' + options.className + '_loading')
						.show()
					.end()
					.find( '.' + options.className + '_content' )
						.hide();

				_positionDialog();
			} else {
				dialog
					.find( '.' + options.className + '_loading')
						.hide()
					.end()
					.find( '.' + options.className + '_content' )
						.show();
			}
		},

		/**
		 * Updates the contents of the dialog
		 *
		 * @returns 	{void}
		 */
		updateContent = function (newContent) {
			dialog.find( '.' + options.className + '_content' ).html( newContent );
			for (const processor of contentProcessors) {
				if (processor instanceof Function) {
					processor(dialog.get(0))
				}
			}
			
			$( document ).trigger('contentChange', [ dialog ]);
		},

		/**
		 * Add a content processor that accepts the HTML Element of the dialog and runs after the content is set but before the contentChange event fires
		 * This is useful to change the html before controllers and widgets initialize
		 *
		 * @param {function(Element)}		processor
		 */
		addContentProcessor = function(processor) {
			if (!(processor instanceof Function)) {
				throw new TypeError(`A non-function value was passed as a processor`);
			}
			contentProcessors.push(processor)
		},

		/**
		 * Internal method to actually show the dialog
		 * Triggers the openDialog event to let the document know
		 *
		 * @returns 	{void}
		 */
		_showDialog = function () {
			if( options.fixed ){
				$('html').addClass('ipsNoScroll');
			}

			if( options.modal ){
				ips.utils.anim.go('fadeIn', modal);
			}

			ips.utils.anim.go('fadeInDown', dialog)
				.done( function () {
					dialog.find( '.' + options.className + '_loading');
				});

			$( elem || document ).trigger('openDialog', {
				elemID: elemID,
				dialogID: dialogID,
				dialog: dialog,
				contentLoaded: contentLoaded
			});

			// check for clicks on [a] tags where the href is an anchor elsewhere on the page
			dialog.get(0)?.addEventListener('click', checkForAnchorClicks);
		},

		/**
		 * Builds a dialog from remote content
		 *
		 * @param		{bool}	initOnly	If TRUE, will create dialog but not show it
		 * @returns 	{void}
		 */
		_remoteDialog = function ( initOnly ) {

			// Build dialog wrapper
			if( !dialogBuilt ){
				if( options.modal ){
					_buildModal();
				}

				_buildDialog();
			}
			
			if ( initOnly ) {
				_fetchContent();
			} else {
				setLoading( true );
				_showDialog();			
				_fetchContent();
			}
			
			if( !options.forceReload ){
				contentLoaded = true;
			}
		},

		/**
		 * Builds a dialog from a local element
		 *
		 * @param		{bool}	initOnly	If TRUE, will create dialog but not show it
		 * @returns 	{void}
		 */
		_localDialog = function ( initOnly ) {

			if( !options.content && !$( options.content ).length ){
				Debug.warn("'content' option not specified for dialog, or element doesn't exist");
				return;
			}

			if( !dialogBuilt ){
				if( options.modal ){
					_buildModal();
				}

				_buildDialog();
			}
			
			if ( initOnly ) {
				return;
			}

			dialog.find( '.' + options.className + '_content').html( $( options.content ).first().show() );
			for (const processor of contentProcessors) {
				processor(dialog.find( '.' + options.className + '_content').get(0))
			}

			_showDialog();

			if( !options.forceReload ){
				contentLoaded = true;
			}
		},

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		_fetchContent = function () {

			var deferred = $.Deferred();

			// Set content to loading
			setLoading( true );

			// Get the content
			ajaxObj = ips.getAjax()( options.url, {
				type: options.ajax.type,
				data: options.ajax.data
				} )
				.done( function (response) {

					// Set our content
					setLoading( false );
					updateContent( response );
					deferred.resolve();
					
					// Run callback
					if ( options.callback !== null ) {
						options.callback( dialog );
					}
										
					// Send trigger
					$( elem || document ).trigger('dialogContentLoaded', {
						elemID: elemID,
						dialogID: dialogID,
						dialog: dialog,
						contentLoaded: true
					});
				})
				.fail( function (jqXHR, status, errorThrown) {
					if( jqXHR.responseJSON ){
						ips.ui.alert.show({
							message: jqXHR.responseJSON,
						});
						setLoading(false);
						contentLoaded = false;
						hide();
					} else if( Debug.isEnabled() ){
						Debug.error( "Ajax request failed (" + status + "): " + errorThrown );
					} else if ( elem ) {
						window.location = elem.href;
					} else {
						ips.ui.alert.show({
							message: ips.getString('errorLoadingContent'),
						});
						setLoading(false);
						contentLoaded = false;
						hide();
					}

					deferred.reject();
				})
				.always( function () {
					//_removeLoadingWidget();
				});

			return deferred.promise();
		},

		/**
		 * Builds the dialog frame
		 *
		 * @returns 	{void}
		 */
		_buildDialog = function () {

			if( dialogBuilt ){
				return;
			}

			var offset = 0;

			// Build dialog
			$('body').append(
				 ips.templates.render( 'core.dialog.main', {
					'class': options.className,
					title: options.title || '',
					id: dialogID,
					fixed: options.fixed,
					size: options.size,
					close: options.close,
					extraClass: options.extraClass
				})
			);

			dialog = $( '#' + dialogID );

			// Add to body
			dialog.css( {
				zIndex: ips.ui.zIndex(),
			});

			_positionDialog();
			
			// Add events
			dialog.on('click', '[data-action="dialogClose"]', function (e) {
				// We trigger on the dialog, but watch on the document
				$( dialog ).trigger('closeDialog', { 
					dialogID: dialogID,
					originalEvent: e
				});
			});

			$( dialog ).on('closeDialog', function (e, data) {
				hide();
			});

			if( options.close ){
				dialog.on( 'mouseup', function (e) {
					// This check is necessary so that if you click in the dialog then drag your mouse out and release over
					// the modal, we don't detect it as a full click on the modal. 
					if( e.target == dialog.get(0) ){
						modalEvent.up = true;
					}					
				});

				dialog.on( 'mousedown', function (e) {
					if( e.target == dialog.get(0) ){
						modalEvent.down = true;
					}					
				});

				dialog.on( 'click', function (e) {
					// If target still exists and isn't a child of the dialog, trigger closeDialog
					if( ( !modalEvent.up || ( dialog.get(0) == e.target && modalEvent.down ) ) && // Mouse up didn't happen on the modal, or it did but we clicked the modal completely
							dialog.find('> div').get(0) != e.target &&
							!$.contains( dialog.find('> div').get(0), e.target ) && 
							$.contains( document, e.target ) 
					){
						$( dialog ).trigger('closeDialog', { 
							dialogID: dialogID,
							originalEvent: e
						});
					}

					modalEvent = { up: false, down: false };
				});
			}

			/* Add this listener for any dialog submission of a form that is intended to return a file. This listener also handles the updating of datalayer events */
			dialog.get(0)?.addEventListener('submit', async (e) => {
				let target = e.target;
				while (target instanceof HTMLElement && target !== dialog.get(0)) {
					if (target instanceof HTMLFormElement && target.matches('form[data-form-is-download]')) {
						e.preventDefault();
						e.stopPropagation();
						e.stopImmediatePropagation();

						const formData = new FormData(target);
						try {
							await ips.utils.fileDownload.download({
								url: target.action,
								formData,
								blobName: target.dataset.formDownloadName || dialog.find('.ipsDialog_title').text() || 'blob'
							});
							await hide();
							_fetchDataLayerEventsAfterSubmit();
						} catch (e) {
							try {
								Debug.log(e);
								if (e && e.xhr instanceof XMLHttpRequest) {
									let content;
									if (e.xhr.responseType === 'arraybuffer') {
										content = await (new Blob([e.xhr.response])).text()
									} else if (e.xhr.responseType === 'document') {
										content = e.xhr.responseXML;
									} else if (e.xhr.responseType === 'text') {
										content = e.xhr.responseText;
									}

									if (content && e.xhr.getResponseHeader('content-type').match(/^text\/html/)) {
										updateContent(content);
										return;
									} else if (e.xhr.getResponseHeader('content-type').match(/^(?:text|application)\/json/)) {
										if (content) {
											content = JSON.parse(content)
										} else if (e.xhr.responseType === 'json') {
											content = e.xhr.response;
										}

										if (typeof content === 'object' && content.message) {
											ips.ui.alert.show({message: content.message, callbacks: {ok() {hide()}}})
											return;
										}
									}

									throw e;
								}
							} catch (e) {
								ips.ui.alert.show({message: ips.getString('unexpected_error'), callbacks: {ok() {hide()}}})
								Debug.error(e)
							}
						}
						break;
					}
					target = target.parentElement;
				}
			}, {capture: true});

			if( options.remoteVerify || options.remoteSubmit ){
				dialog.find( '.' + options.className + '_content' ).on('submit', function(e) {
					_ajaxFormSubmit(e, $( this ) );
				});
			}

			dialogBuilt = true;
		},

		/**
		 *
		 * @private
		 */
		_fetchDataLayerEventsAfterSubmit = function() {
			if (ips.getSetting('memberID')) {
				let redirected = false;
				const listener = () => {
					redirected = true;
				};
				window.addEventListener('popstate', listener, {once: true});
				setTimeout(() => {
					window.removeEventListener('popstate', listener);
					if (!redirected) {
						document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles: true}));
					}
				}, 1000); // wait a sec to make sure that the page wasn't redirected
			}
		},

		/**
		 * Positions the dialog window
		 *
		 * @returns 	{void}
		 */
		_positionDialog = function () {
			// Get the body scroll position
			if( dialog && !options.fixed ){
				var win = $( window );
				var offset = win.scrollTop();

				dialog.css({
					top: offset + 'px'
				});
			}
		},

		/**
		 * Fetches a modal element from ips.ui and sets the zindex on it
		 *
		 * @returns 	{void}
		 */
		_buildModal = function () {
			modal = ips.ui.getModal();
			modal.css( { zIndex: ips.ui.zIndex() } );
		},
		
		/**
		 * Submit a form within the dialog using AJAX
		 *
		 * @param		{Event}		e			The submit event
		 * @param		{element} 	form 		The element this widget is being created on
		 * @returns		{void}
		 */
		_ajaxFormSubmit = function(e, form) {
			if (!($(form)?.get?.(0) instanceof HTMLFormElement)) {
				form = $(e.target)
			}
			if (!($(form).get(0) instanceof HTMLFormElement)) {
				return;
			}

			if( form.attr('data-bypassValidation') && !options.remoteSubmit ){
				return;
			}

			e.preventDefault();
			setLoading( true );

			var url = form.attr('action');
			var ajaxUrl = url;

			if( options.remoteVerify ){
				var joinWith = '?';
				
				if ( ajaxUrl.indexOf('?') != -1 ){
					joinWith = '&';
				}
				
				ajaxUrl	= ajaxUrl + joinWith + 'ajaxValidate=1';
			}

			ips.getAjax()( ajaxUrl, {
				data: form.serialize(),
				type: 'post'
			} )
				.done( function (response, status, jqXHR) {

					// If we are verifying remotely, and we haven't already checked everything is fine...
					if( options.remoteVerify && !form.attr('data-bypassValidation') ){
						if( jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormError: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormNoSubmit: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formerror: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formnosubmit: true') !== -1 ){
							Debug.log('Validation failed');
							setLoading( false );
							updateContent( response );
							return;
						}
					}
					
					if( options.remoteSubmit ){

						var doneAfterSubmit = function (submitResponse) {

							// If we're submitting via ajax, then we've already done that; just need to trigger an event and hide the dialog
							$( elem || document ).trigger('submitDialog', {
								elemID: elemID,
								dialogID: dialogID,
								dialog: dialog,
								contentLoaded: contentLoaded,
								response: submitResponse
							});

							// and here we dispatch a native event in the push towards a native JS approach
							$(elem || document).get(0)?.dispatchEvent(new DialogSubmissionEvent(elemID, dialogID, dialog, contentLoaded, submitResponse))

							setLoading( false );
							contentLoaded = false; // This will cause the dialog to be reloaded again if we open it again, which we want so our previous values aren't still inputted
							hide();
							_fetchDataLayerEventsAfterSubmit();
							
							if( options.flashMessage ){
								ips.ui.flashMsg.show( options.flashMessage, { timeout: options.flashMessageTimeout, escape: options.flashMessageEscape } );
							}
						};

						// If we verified this submission first, we actually need to submit again, without the verification this time
						if( options.remoteVerify ) {
							ips.getAjax()( url, {
								data: form.serialize(),
								type: 'post',
								bypassRedirect: true
							})
								.done( function (response, status, jqXHR) {
									if( jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormError: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormNoSubmit: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formerror: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formnosubmit: true') !== -1 ){
										form.attr( 'data-bypassValidation', true ).submit();
									} else {
										doneAfterSubmit( response );
									}
								})
								.fail( function (jqXHR, status, errorThrown) {
									form.attr( 'data-bypassValidation', true ).submit();
								});
						} else {
							doneAfterSubmit( response );
						}
						
					} else if( jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormNoSubmit: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formnosubmit: true') !== -1 ) {
						// If the response from the verification told us not to submit the form, we'll update the dialog
						setLoading( false );
						updateContent( response );
					} else {
						// Otherwise, we've passed verification and we can submit the form as normal
						form.attr( 'data-bypassValidation', true ).submit();
						setTimeout(() => _fetchDataLayerEventsAfterSubmit(), 30000); // Do this 30 seconds later in case the content took a long time to load but redirects the page. If the redirect ocurrs after teh datalayer event was loaded but before it's dispatched to GTM, it can cause event loss so we'll just wait until the next page load
					}
				})
				.fail( function () {
					form.attr( 'data-bypassValidation', true ).submit();
				});
		};

		init();

		return {
			init: init,
			show: show,
			hide: hide,
			remove: remove,
			setLoading: setLoading,
			updateContent: updateContent,
			dialogID: dialogID,
			destruct: destruct,
			addContentProcessor
		};
	};

	class DialogSubmissionEvent extends Event {
		/**
		 * Create a new Native Dialog submission event. The event's key is 'dialogSubmission'
		 *
		 * @param elemID
		 * @param dialogID
		 * @param dialog
		 * @param contentLoaded
		 * @param response
		 */
		constructor(elemID, dialogID, dialog, contentLoaded, response) {
			super('dialogSubmission')
			this.elemID = elemID;
			this.dialogID = dialogID;
			this.dialog = dialog;
			this.contentLoaded = contentLoaded;
			this.response = response;
		}
	}
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.drawer.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.drawer.js - A drawer (e.g. iOS-style sidebar) widget
 *
 * Author: Rikki Tissier
 * This component is now deprecated in 5.0.10 in favour of .ipsOffCanvas menus
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.drawer', function(){

		var defaults = {};

		/**
		 * Respond to a menu trigger being clicked
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object
		 * @returns {void}
		 */
		var respond = function (elem, options, e) {
			e.preventDefault();

			if( !$( elem ).data('_drawer') ){
				$( elem ).data('_drawer', drawerObj(elem, _.defaults( options, defaults ) ) );
			}

			$( elem ).data('_drawer').show();
		};

		ips.ui.registerWidget('drawer', ips.ui.drawer, 
			[ 'drawerElem' ],	
			{ lazyLoad: true, lazyEvents: 'click' } 
		);

		return {
			respond: respond
		};
	});

	/**
	 * Drawer instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var drawerObj = function (elem, options) {

		var modal, // The modal background
			drawerElem,
			drawerContent;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			modal = ips.ui.getModal().addClass('ipsDrawer_modal');
			drawerElem = $( options.drawerElem ),
			drawerContent = drawerElem.find('.ipsDrawer_menu');

			drawerElem.on('click', '[data-action="close"]', function (e) {
				e.preventDefault();
				hide();
			});

			drawerElem.on('click', function (e) {
				if( !$.contains( drawerContent.get(0), e.target ) ){
					hide();
				}
			});

			// set up sub-menus
			drawerElem
				.on( 'click', '.ipsDrawer_itemParent > h4', _showSubMenu )
				.on( 'click', '[data-action="back"]', _subMenuBack )
				.find('.ipsDrawer_itemParent > ul')
					.addClass('ipsDrawer_subMenu')
					.hide();
		},

		_showSubMenu = function (e) {
			e.preventDefault();

			var item = $( e.currentTarget );
						
			item
				.parents('.ipsDrawer_list')
					.animate( ( $('html').attr('dir') === 'rtl' ) ? { marginRight: '-100%' } : { marginLeft: '-100%' } )
				.end()
				.siblings('.ipsDrawer_list')
					.show();

			drawerElem.find('.ipsDrawer_content').animate({
				scrollTop: "0px"
			});
		},

		_subMenuBack = function (e) {
			e.preventDefault();
			
			var item = $( e.currentTarget ),
				thisMenu = item.parent('.ipsDrawer_list');
						
			thisMenu	
				.parents('.ipsDrawer_list')
				.first()
					.animate( ( $('html').attr('dir') === 'rtl' ) ? { marginRight: '0' } : { marginLeft: '0' }, function () {
						thisMenu.hide();
					});

		},

		show = function () {
			window.scrollTo(0,-1);

			// Show modal
			modal.css( { zIndex: ips.ui.zIndex() } );
			
			// Hide close elem
			drawerElem.find('.ipsDrawer_close').hide();
			ips.utils.anim.go( 'fadeIn fast', modal );

			// Show drawer
			drawerElem
				.css( { zIndex: ips.ui.zIndex() } )
				.show();
				
			if( $('html').attr('dir') === 'rtl' ) {
				ips.utils.anim.go( 'slideRight fast', drawerElem );
			} else {
				ips.utils.anim.go( 'slideLeft fast', drawerElem );
			}

			drawerElem.find('.ipsDrawer_close').delay(500).fadeIn();

			// Make body non-scrolly
			$('body')[0].style.setProperty("overflow", "hidden");
		},

		hide = function () {
			ips.utils.anim.go( 'fadeOut fast', modal );

			drawerElem.hide();

			$('body')[0].style.setProperty("overflow", "");
		};

		init();

		return {
			init: init,
			show: show,
			hide: hide
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.editorv5.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.editorv5.js - Editor widget
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
    "use strict";


    /**
     * @type {"unloaded"|"loaded"|"loading"}
     */
    let state = 'unloaded'

    /**
     * @type {"unloaded"|"loaded"|"loading"|"error"}
     */
    let pluginsState = 'unloaded'
    const pluginsCallbacks = new Set()
    const resolveCallbacks = new Set()

    const _thirdPartyExtensions = {};
    const _thirdPartyNodes = {};
    const _thirdPartyMarks = {};
    const pluginTimeouts = new Set();

    document.addEventListener('ips:editorPluginsReady', () => {
        pluginsState = 'loaded'
        pluginsCallbacks.forEach(cb => cb())
        pluginsCallbacks.clear()

        pluginTimeouts.forEach(clearTimeout)
        pluginTimeouts.clear()
    });

    document.addEventListener('ips:editorPluginsError', () => {
        pluginsState = 'error'
        pluginsCallbacks.forEach(cb => cb())
        pluginsCallbacks.clear()

        pluginTimeouts.forEach(clearTimeout)
        pluginTimeouts.clear()
    });


    document.addEventListener('ipsTiptapLoaded', () => {
        resolveCallbacks.forEach(cb => cb())
        resolveCallbacks.clear()
    })

    /**
     * Load 3rd party tiptap plugin files
     */
    function loadTiptapPlugins() {
        pluginsState = 'loading'
        const pluginURL = ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/editor/index.php'
        const script = document.createElement('script');
        script.setAttribute("src", pluginURL)
        document.body.appendChild(script)
        script.dataset.ipsEditorPlugins = ''

        // We quit after 5 seconds
        pluginTimeouts.add(setTimeout(() => document.dispatchEvent(new CustomEvent('ips:editorPluginsError')), 5000))
    }

    /**
     * Load the core tiptap files
     */
    function loadTiptap() {
        state = "loading";
        Debug.log("Loading the editor from the interface");

        const manifestURL = ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/tiptap/manifest.json?antiCache=' + encodeURIComponent(ips.getSetting('jsAntiCache'))

        ips.fetch(manifestURL).then(response => {
            if (typeof response === 'object') {
                for (const details of Object.values(response)) {
                    if (details.isEntry) {
                        const src = ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/tiptap/' + details.file + `?antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`
                        const scriptElem = document.createElement('script')
                        scriptElem.type = 'module'
                        document.head.appendChild(scriptElem)
                        scriptElem.src = src
                        if (Array.isArray(details.css)) {
                            for (const css of details.css) {
                                const src = ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/tiptap/' + css
                                const styleElem = document.createElement('link')
                                styleElem.rel = 'stylesheet'
                                styleElem.setAttribute('href', src)
                                document.head.appendChild(styleElem)
                            }
                        }
                    }
                }
            }
        })
    }

    /**
     * Async function that resolves as soon as the tiptap modules are loaded
     *
     * @param {boolean}     [skipPlugins=true]     Whether to skip the loading of 3rd party customizations
     *
     * @return {Promise<void>}
     */
    function whenLoaded(skipPlugins=true) {
        return new Promise((resolve) => {

            // before anything, if we are not skipping the plugins, start loading them now so this is done in parallel
            if (pluginsState === 'unloaded' && !skipPlugins) {
                loadTiptapPlugins()
            }

            const done = () => {
                if (skipPlugins || ['loaded', 'error'].includes(pluginsState)) {
                    resolve()
                } else {
                    pluginsCallbacks.add(resolve)
                }
            }

            if (state === 'loaded' || ips.utils.tiptap) {
                state = 'loaded'
                done()
            } else {
                resolveCallbacks.add(done)
            }

            if (state === 'unloaded') {
                loadTiptap()
            }
        })
    }

    const defaults = {
        postkey: '',
        minimized: false,
        autoSaveKey: null,
        hidebuttons: [],
        autosubmit: true,
        giphyenabled: false,
        stockrepliesenabled: false,
        minimizeAfterReset: false,
        name: undefined,
        restrictions: [],
        restrictionLevel: 0,
        commenteditor: false,
    };

    ips.createModule('ips.ui.editorv5', function() {
        ips.ui.registerWidget(
            'editorv5',
            ips.ui.editorv5,
            [
                'postkey',
                'minimized',
                'autoSaveKey',
                'giphyenabled',
                'stockrepliesenabled',
                'hidebuttons',
                'name',
                'loadplugins', // When this is true, we load extra plugins from the backend
                'restrictions',
                "restrictionLevel",
                'commenteditor'
            ]
        );

        return {

            /**
             * Respond method, sets up the editor widget.
             * Loads the Tiptap libraries, then boots the editor
             *
             * @param	{element} 	elem 		The element this widget is being created on
             * @param	{object} 	options 	The options passed into this instance
             * @returns {void}
             */
            respond(elem, options) {
                if ($(elem).data('_editor') !== undefined) {
                    return;
                }
                $(elem).data('_editor', null)

                if (!('loadplugins' in options)) {
                    pluginsState = 'loaded';
                    document.dispatchEvent(new CustomEvent('ips:editorPluginsReady'))
                }
                delete options.loadplugins;

                const instance = editorObj(elem, options)
                $(elem).data('_editor', instance)
                instance.init()
            },

            /**
             * Retrieve the editor instance (if any) on the given element
             *
             * @param	{element} 	elem 		The element to check
             *
             * @returns {editorObj|undefined} 	The editor instance or undefined
             */
            getObj(elem) {
                if( $( elem ).data('_editor') ){
                    return $( elem ).data('_editor');
                }

                return undefined;
            },

            /**
             * Retrieve the editor instance (if any) on the given element, initiating it if it isn't already. The instance is passed to a callback
             *
             * @param	{element} 	                        elem 		The element to check
             * @param   {function(editorObj|undefined)}     callback    If the instance exists, it will be passed to this callback. Leave callback null to return a promise which resolves to the instance
             *
             * @returns {Promise<editorObj|undefined>|void}
             */
            getObjWithInit( elem, callback ) {
                let obj = this.getObj( elem );
                if ( obj ) {
                    if (callback) {
                        callback(obj);
                    } else {
                        return new Promise(resolve => resolve(obj));
                    }
                } else {
                    let initFunction = $( elem ).data('_editorInit');
                    if ( initFunction ) {
                        if (callback) {
                            initFunction( callback );
                        } else {
                            return new Promise(resolve => initFunction(resolve))
                        }
                    }
                }

                // still here in async mode? return a void promise
                if (!callback) {
                    return new Promise(resolve => resolve(undefined))
                }
            },

            /**
             * Destruct the editor
             *
             * @param	{element} 	elem 		The element to check
             * @returns {void}
             */
            destruct(elem) {
                this.getObj( elem )?.destruct();
                $(elem).data('_editor', undefined)
            },

            whenLoaded,

            registerExtension(name, definition) {
                definition.name = `ipsCustomExtension__${name}`;
                if (name in _thirdPartyExtensions) {
                    Debug.log(`Replacing tiptap third party extension: ${name}`);
                }

                _thirdPartyExtensions[name] = definition;
            },

            registerNode(name, definition) {
                definition.name = `ipsCustomNode__${name}`;
                if (name in _thirdPartyNodes) {
                    Debug.log(`Replacing tiptap third party node: ${name}`);
                }

                _thirdPartyNodes[name] = definition;
            },

            registerMark(name, definition) {
                definition.name = `ipsCustomMark__${name}`;
                if (name in _thirdPartyMarks) {
                    Debug.log(`Replacing tiptap third party mark: ${name}`);
                }

                _thirdPartyMarks[name] = definition;
            },

            /**
             * Get all registered extension restrictions
             *
             * @param {boolean}     includeDefaults=false       Whether to include defaults. When set to true, this method will return a 2d array of restriction key/default pairs
             *
             * @return {Promise<string[]|([string, number])[]>}
             */
            async getExtensionRestrictions(includeDefaults=false) {
                await whenLoaded(false);
                const restrictions = {};
                for (const collection of [_thirdPartyMarks, _thirdPartyExtensions, _thirdPartyNodes]) {
                    for (const name in collection) {
                        const definition = {...collection[name]};
                        if (Array.isArray(definition.restrictions)) {
                            const restrictions = {};
                            for (const restriction of definition.restrictions) {
                                restrictions[restriction] = -1;
                            }
                            definition.restrictions = restrictions;
                        }

                        if (typeof definition.restrictions !== 'object' || !Object.keys(definition.restrictions).length) {
                            continue;
                        }

                        const [_, type] = definition.name.match(/^ipsCustom(Node|Mark|Extension)__/);
                        if (!type) {
                            continue;
                        }

                        for (const [restriction, defaultValue] of Object.entries(definition.restrictions)) {
                            if (![-1,0,1,2].includes(defaultValue)) {
                                Debug.warn(`The restriction ${JSON.stringify(restriction)} from the extension ${definition.name} has an invalid default value (got ${defaultValue}, expected one of -1,0,1,2), so the restriction is being skipped!`);
                                continue;
                            }

                            const langString = definition.name + '__' + restriction;

                            if (!langString?.match(/^[a-zA-Z_\-0-9]+$/)) {
                                Debug.warn(`Skipping the restriction "${restriction}" because it doesn't match the pattern "/^[a-zA-Z0-9_\\-]+$/. (It consists of one or more characters that are not alphanumeric, an underscore, or a dash)"`);
                                continue;
                            }

                            if (!ips.haveString(langString)) {
                                Debug.warn(`The restriction "${restriction}" of the ${type} "${name}" doesn't have a lang string registered (expected a lang string registered as ${langString})!`);
                                ips.setString(langString, langString);
                            }
                            restrictions[langString] = defaultValue;
                        }
                    }
                }

                return Array.from(includeDefaults ? Object.entries(restrictions) : Object.keys(restrictions));
            },

            /**
             * Build the config based on the passed options
             * @return {Object}
             */
            buildConfig(options) {
                let config = {}
                for (const k in defaults) {
                    config[k] = options[k] !== undefined ? options[k] : defaults[k];
                }
                config.giphyenabled = !!(config.giphyenabled || config.giphyenabled === '');
                config.stockrepliesenabled = !!(config.stockrepliesenabled || config.stockrepliesenabled === "");
                config.commenteditor = !!(config.commenteditor || config.commenteditor === "");

                if (typeof config.hidebuttons === 'string') {
                    config.hidebuttons = config.hidebuttons
                        .split(',')
                        .map(key => key.trim())
                        .filter(key => !!key);
                }



                if (typeof options.restrictions === 'string') {
                    config.restrictions = options.restrictions.split(',')
                } else {
                    config.restrictions = [];
                }

                return config
            }
        };
    });

    /**
     * Editor instance
     *
     * @param	{element} 	elem 		The element this widget is being created on
     * @param	{object} 	options 	The options passed into this instance
     *
     * @returns {{
            init: init,
            focus: focus,
            unminimize: unminimize,
            minimize: minimize,
            insertQuotes: insertQuotes,
            insertHtml: insertHtml,
            reset: reset,
            destruct: destruct,
            saveAndClearAutosave: saveAndClearAutosave,
            getInstance: getInstance,
            getInstanceHTML: getInstanceHTML,
            scrollIntoView: (function(*):void)
      }}
     */
    function editorObj(elem, options) {
        /**
         * @type {Editor|null}
         */
        let instance = null;
        let hiddenAtStart = false;
        let minimized = !!options.minimized;
        let editorLocation;
        let originalContent = '';

        let name = options.name || '';
        let _reactRoot;

        const config = ips.ui.editorv5.buildConfig(options)
        options = {...options, ...config}

        /**
         * This is what actually loads tiptap and creates an instance
         *
         * @return {Promise<void>}
         */
        async function fillTiptapInstance() {
            if (!instance) {
                await whenLoaded(false);


                const throttledComposeEvent = _.throttle(() => {
                    try {
                        $(elem).trigger('editor.composing', {elem})
                    } catch (e) {
                        Debug.error(e)
                    }
                }, 1000)

                const textArea = getTextarea();
                editorLocation = editorLocation || $(elem).get(0).querySelector('[data-role="reactRoot"]') || document.createElement('div')
                editorLocation.dataset.role = 'reactRoot'
                editorLocation.classList.add('ipsEditor__react-root')
                textArea.parentElement.insertBefore(editorLocation, textArea)
                originalContent = textArea.textContent
                try {
                    const detail = {
                        elem: $(elem).get(0),
                        textArea,
                        content: textArea.textContent,
                        options: config
                    };

                    document.dispatchEvent(new CustomEvent("ips:editorBeforeInit", {
                        bubbles: true,
                        cancelable: false,
                        detail
                    }));
                    textArea.textContent = detail.content;

                } catch (e) {
                    e.message = "An event listener on `ips:editorBeforeInit` failed to run\n\n" + e.message
                    Debug.warn(e)
                }

                // it is possible restrictions were left in for apps that don't exist. Remove those
                if (Array.isArray(config.restrictions)) {
                    const allRestrictions = new Set(await ips.ui.editorv5.getExtensionRestrictions());
                    config.restrictions = config.restrictions.filter(restriction => allRestrictions.has(restriction) || !restriction.match(/^ipsCustom(Node|Mark|Extension)__/))
                } else {
                    config.restrictions = [];
                }

                const currentOnCreate = config.onCreate;
                const self = this;
                config.onCreate = function(...args) {
                    instance = instance || args[0]?.editor;
                    if (currentOnCreate instanceof Function) {
                        (self === this ? currentOnCreate : currentOnCreate.bind(this))(...args);
                    }

                    // After everything else has run on create, we need to sync the contents
                    setTimeout(() => fillTextarea())
                    setTimeout(() => {
                        try {
                            $(elem).get(0).dispatchEvent(new CustomEvent("ips:editorAfterInit", {
                                bubbles: true,
                                cancelable: false,
                                detail: {
                                    elem: $(elem).get(0),
                                    textArea,
                                    content: textArea.innerText,
                                    options: config,
                                    instance
                                }
                            }));
                        } catch (e) {
                            e.meessage = "Something went wrong dispatching ips:editorAfterInit event on the page:\n" + e.message;
                            Debug.error(e);
                        }

                        // One more fillTextarea call for good measure
                        fillTextarea();
                    }, 100)
                }

                // Debounced onTransaction callback because onUpdate doesn't dispatch when the editor is updated programmatically (e.g. via editor.commands.setContent). However, onTransaction is called many times per keystroke so this is why we debounce a bit
                const onTransaction = config.onTransaction;
                config.onTransaction = _.debounce(function(...args) {
                    instance = instance || args[0]?.editor;
                    fillTextarea();
                    try {
                        onTransaction?.call?.(this, ...args);
                    } catch (e) {
                        e.message = "Something went wrong in an onTransaction call to the editor" + e.message;
                        Debug.error(e);
                    }
                }, 200, {leading: false, trailing: true});

                const onUpdate = config.onUpdate;
                config.onUpdate = function (...args) {
                    try {
                        onUpdate?.call?.(this, ...args);
                    } catch (e) {
                        e.message = "Failed to run the onUpdate event listener:\n" + e.message;
                        Debug.error(e);
                    }
                    instance = instance || args[0]?.editor;
                    // console.log(instance, instance.getJSON()) // leaving this in as it's real handy for debug
                    config.onTransaction?.cancel();
                    setTimeout(() => {
                        let canceled = false;
                        const event = new CustomEvent('ips:editorUpdated', {
                            bubbles: true,
                            cancelable: true,
                            detail: {
                                elem: $(elem).get(0),
                                textArea,
                                instance,
                            }
                        });

                        throttledComposeEvent();

                        const origStopProp = event.stopPropagation;
                        const origStopImmProp = event.stopImmediatePropagation;
                        event.stopPropagation = (function() {
                            canceled = true;
                            origStopProp();
                        }).bind(event)

                        event.stopImmediatePropagation = (function () {
                            canceled = true;
                            origStopImmProp();
                        }).bind(event);

                        $(elem).get(0).dispatchEvent(event)

                        if (canceled) {
                            return;
                        }

                        fillTextarea()
                    })
                }

                const customizedRestrictions = {...(ips.getSetting('editor_restrictions') || {})};
                const filterAndPrepPlugins = extensions => [...Object.values(extensions)]
                    .filter(extension => !config.restrictions.includes(`${extension.name}__`))
                    .filter(extension => {
                        if (typeof extension.restrictions !== 'object') {
                            extension.restrictions = {};
                        } else if (Array.isArray(extension.restrictions)) {
                            extension.restrictions = Object.fromEntries(extension.restrictions.map(r => [r, -1]))
                        }

                        for (const customizedRestriction in customizedRestrictions) {
                            if (customizedRestriction.startsWith(extension.name + "__")) {

                                extension.restrictions[customizedRestriction.replace(new RegExp(`^${extension.name}__`), '')] = customizedRestrictions[customizedRestriction];
                                // don't process again
                                delete customizedRestrictions[customizedRestriction];
                            }
                        }

                        for (const restriction in extension.restrictions) {
                            if (typeof extension.restrictions[restriction] === 'number' && extension.restrictions[restriction] >= (config.restrictionLevel||0) && !config.restrictions.includes(`${extension.name}__${restriction}`)) {
                                config.restrictions.push(`${extension.name}__${restriction}`)
                            }
                        }

                        return typeof extension.restrictions[""] !== "number" || extension.restrictions[""] < (config.restrictionLevel || 0);
                    })
                    .map(extensionDef => ({...extensionDef}));

                const res = await ips.utils.tiptap.editorInstance(
                    editorLocation,
                    {
                        ...config,
                        content: textArea.innerText,
                        jQuery: $,
                        ipsPlugins: {
                            // If, in the definition of the extension, there is the restriction "", it refers to the extension itself
                            extensions: filterAndPrepPlugins(_thirdPartyExtensions),
                            nodes: filterAndPrepPlugins(_thirdPartyNodes),
                            marks: filterAndPrepPlugins(_thirdPartyMarks),
                        },
                    }
                );
                instance = res[0]
                _reactRoot = res[1]

                throttledComposeEvent();

                instance.on('create', () => {
                    fillTextarea();
                })

                instance.on('selectionUpdate', () => {
                    throttledComposeEvent()
                })

                const time = config.autoSaveKey ? ips.utils.db.get('editorSave', config.autoSaveKey)?.time : false;
                if (Number.isInteger(time) && time > (Date.now() / 1000 - 86400 * 3)) {
                    fillTextarea()
                }

                // Focus event handling
                instance.on('focus', () => $(elem).trigger('editor.focused', {elem}));
                instance.on('blur', () => $(elem).trigger('editor.blurred', { elem }));

                if (Debug.isEnabled()) {
                    instance.on('contentError', (...args) => {
                        const err = new Error("Failed to insert content using current editor schema");
                        console.warn(err);
                        console.log(args);
                    })
                }
            }
        }

        /**
         * Get the textarea for this editor instance
         *
         * @return {HTMLTextAreaElement|null|undefined}
         */
        function getTextarea() {
            return $(elem).find('textarea:not(.tiptap *)').get(0);
        }

        /**
         * Get the html of the editor. Accounts for the fact that empty editors are <p></p>
         * @return {string}
         */
        function getInstanceHTML() {
            if (!instance) return "";

            const html = instance.getHTML?.();
            if (typeof html !== 'string' || html === '<p></p>') {
                return "";
            }

            // now let's strip out the box contents wrappers. We wrap the raw HTML in an actual HTML5 document juuust in case
            const parserDoc = (new DOMParser()).parseFromString(`<!DOCTYPE html><html><head><meta charset="utf-8"/></head><body>${html}</body></html>`, 'text/html');
            let boxContentElement;
            while ((boxContentElement = parserDoc.querySelector('i-richtext-box-content')) && boxContentElement instanceof Element) {
                boxContentElement.before(...boxContentElement.childNodes);
                boxContentElement.remove();
            }

            return parserDoc.body.innerHTML.trim();
        }

        /**
         * Fill the textarea so that its value matches the value of the current tiptap instance
         */
        const fillTextarea = _.debounce(function() {
            const textarea = getTextarea();
            if (textarea && instance) {
                textarea.innerHTML = "";
                textarea.appendChild(document.createTextNode(getInstanceHTML())) // we use text node because they will preserve new lines and all non-breaking characters instead of replacing with <br>
            }
        }, 10);

        /**
         * Clear the textarea input for the form
         */
        function clearTextarea() {
            const textarea = getTextarea();
            if (textarea) {
                textarea.innerHTML = '';
                textarea.append(document.createTextNode(originalContent))
            }
        }

        /**
         * @callback init
         * Initializes tiptap, or if it is minimized sets up the minimized view to initialize on unminimize
         *
         * @param {Function|undefined}    [callback]
         * @returns void
         */
        async function init(callback) {
            if (options.minimized) {
                $(elem)
                    .find('.ipsComposeArea_dummy')
                    .show()
                    .on('focus click', function() {
                        $(this).off('focus click'); // Ensure these events only fire once

                        unminimize( function() {
                            focus();
                        });
                    })
                    .end()
                    .find('[data-role="mainEditorArea"]')
                    .hide()
                    .closest('.ipsComposeArea')
                    .addClass('ipsComposeArea_minimized')
                    .find('[data-ipsEditor-toolList]')
                    .attr('hidden', true);

                // Let other controllers initialize us
                $( document ).on( 'initializeEditor', _initializeEditor );
                hiddenAtStart = true;
                minimized = true;
                setTimeout(() => whenLoaded(false), 3000);
            } else {
                const mainEditorArea = $(elem).get(0).querySelector('[data-role="mainEditorArea"]')
                mainEditorArea?.classList.add('ipsLoading');
                await fillTiptapInstance();
                mainEditorArea?.classList.remove('ipsLoading');
                instance.commands.fireVisibilityChange(true)
            }

            // Any other callback?
            if (callback instanceof Function) {
                callback(this);
            }

            // When we delete a file from the uploader, we need to remove it from the editor
            $( document ).on( 'fileDeleted', _deleteFile );

            _cleanUpStaleAutoSaves();
        }


        /**
         * Remove old auto saves if they've been there for more than 3 days
         *
         * @returns void
         */
        function _cleanUpStaleAutoSaves() {
            for (let [k, v] of  Object.entries(ips.utils.db.getByType('editorSave')))
            {
                try{
                    let time = v?.time || v?.[1] // the old v4 version used an array. We still have to clean those up if they exist still
                    if (!time) {
                        continue;
                    }
                    // Older than 3 days, remove.
                    if ( time < Math.round( new Date().getTime() / 1000 ) - ( 86400 * 3 ) ) {
                        ips.utils.db.remove( 'editorSave', k );
                    }
                } catch( err ) {
                    Debug.error("Trying to remove editorSave keys:");
                    Debug.error( err );
                }
            }
        }

        let destroyed = false;

        /**
         * @callback destruct
         * Destructs this object
         *
         * @param {boolean}     [clearAutoSave=true]       Whether to clear the autosave during this process
         *
         * @returns void
         */
        function destruct(clearAutoSave=false) {
            if (destroyed) {
                return;
            }
            destroyed = true;

            try {
                _reactRoot?.unmount()
            } catch (e) { // every once in a blue moon, this throws an error. not 100% sure why; could be a tooltip in the wrong place, or some other thing interrupting react so we try 100ms later
                const r = _reactRoot;
                setTimeout(() => r.unmount(), 100);
            }
            // Tell editor we are resetting
            if (clearAutoSave) {
                instance?.commands?.clearAutosave?.();
            }
            instance?.destroy()
            clearTextarea()
            _reactRoot = undefined;

            _offEvents();
            instance = undefined;
            editorLocation?.remove();
            editorLocation = null;
        }

        /**
         * @callback getInstance
         * Returns this instance of Tiptap
         *
         * @returns {import('@tiptap/core').Editor|null}
         */
        function getInstance() {
            if( instance ){
                return instance;
            }

            return null;
        }

        /**
         * Stop listening to events for this editor
         *
         * @returns void
         */
        function _offEvents() {
            $( document ).off( 'fileDeleted', _deleteFile );
            $( document ).off( 'initializeEditor', _initializeEditor );
        }

        /**
         * @callback focus
         * Focus
         *
         * @returns void
         */
        function focus() {
            scrollIntoView();
            instance.commands.focus();
        }

        /**
         * Scroll the editor into view
         */
        function scrollIntoView(options) {
            const element = $(elem).get(0);
            const container = element.closest('#replyForm,.cTopicPostArea') || element.closest('.ipsComposeArea') || element;
            const rect = container.getBoundingClientRect();
            if (rect.top < 0 || rect.left < 0 || rect.right > window.innerWidth || rect.bottom > window.innerHeight || rect.left > window.innerWidth) {
                const defaults = {
                    behavior: 'instant',
                    block: rect.top < 0 ? 'start' : 'end',
                    inline: rect.left < 0 ? "start" : "end"
                };

                if (options === true) {
                    Object.assign(defaults, {
                        behavior: 'auto',
                        block: "start",
                        inline: "nearest"
                    });
                } else if (options === false) {
                    Object.assign(defaults, {
                        behavior: 'auto',
                        block: "end",
                        inline: "nearest"
                    });
                } else if (typeof options === 'object') {
                    Object.assign(defaults, options);
                }

                container.scrollIntoView(defaults);
            }
        }

        /**
         * @callback unminimize
         * Unminimize
         *
         * @param	{Function}	callback	Function to run after unminimized
         * @returns void
         */
        function unminimize( callback ) {
            if( !_.isFunction(callback) ){
                callback = $.noop;
            }

            if (minimized) {

                // this is not async/await because there are 2 requests: one for the editor and one for the uploader. These can process in parallel by using .then() style promise handling
                function _unminimize() {
                    // Hide the dummy area and show the actual editor
                    const element = $(elem).get(0)
                    element.querySelector('.ipsComposeArea_dummy')?.setAttribute('hidden', '')
                    element.closest('.ipsComposeArea')?.classList.remove('ipsComposeArea_minimized')
                    element.closest('.ipsComposeArea')?.querySelectorAll('[data-ipseditor-toollist]').forEach(toolList => toolList.ipsShow())

                    const mainEditorArea = $(elem).get(0).querySelector('[data-role="mainEditorArea"]')
                    mainEditorArea?.ipsShow()
                    mainEditorArea?.classList.add('ipsLoading')

                    fillTiptapInstance()
                        .then(() => {
                            mainEditorArea?.classList.remove('ipsLoading')
                            instance?.commands.fireVisibilityChange(true)
                            // element.querySelector();

                            if (hiddenAtStart) {
                                setTimeout(() => focus(), 1);
                                hiddenAtStart = false;
                            }
                            callback();
                        })

                    minimized = false;

                    // Load the upload area
                    const minimizedUploader = element.querySelector('[data-ipsEditor-toolListMinimized]');

                    if (minimizedUploader) {
                        minimizedUploader.ipsShow();
                        ips.fetch(element.closest('form[action]').getAttribute('action'), {
                            'data': {
                                'getUploader': minimizedUploader.dataset.name
                            }
                        })
                            .then(response => {
                                const responseElement = (new DOMParser()).parseFromString(`${response}`, 'text/html').body
                                for (const el of responseElement.childNodes) {
                                    minimizedUploader.parentElement.insertBefore(el, minimizedUploader)
                                }
                                minimizedUploader.remove();
                                $(document).trigger('contentChange', [elem]);
                            })
                            .catch(e => {
                                e.message = `Failed to unminimize uploader. \n${e.message}`
                                Debug.error(e)
                            })
                    }
                }
                _unminimize();
            } else {
                callback();
            }
        }

        /**
         * @callback minimize
         * Minimize
         *
         * @returns void
         */
        function minimize() {
            if( !minimized ){
                const element = $(elem).get(0)
                element.querySelectorAll('.ipsComposeArea_dummy').ipsShow();
                element.querySelectorAll('[data-role="mainEditorArea"]').ipsHide();
                element.closest('.ipsComposeArea')?.classList.add('ipsComposeArea_minimized')
                element.closest('.ipsComposeArea')?.querySelectorAll('[data-ipseditor-toollist]').ipsHide()

                $(elem).find('.ipsComposeArea_dummy').on('focus click', function() {
                    $( this ).off('focus click'); // Ensure these events only fire once

                    unminimize( function() {
                        focus();
                    });
                })
                instance?.commands.fireVisibilityChange(false)
                minimized = true;
            }
        }

        /**
         * @callback insertQuotes
         * Insert quotes into editor
         *
         * @param 		{array} 	quotes 	Array of data objects (which should contain all of the properties necessary for a quote)
         * @returns void
         */
        function insertQuotes(quotes) {
            let isAutoSave = false, draftContent = '', _minimized = minimized;

            // Wrapper method for inserting quotes into the editor
            const _doInsert = function () {
                /* Now insert the posts. If the instance is empty return now */
                if (!instance) return;
                let toInsert = "";
                for (const data of quotes) {
                    // Remove any lightboxes on the content (they'll be reapplied when viewing the quote)
                    const html = data.quoteHtml.replace(/data-ipsLightbox(-group)?="([\w]+)?"/ig, '').trim();

                    /* Build quote */
                    const quote = $(ips.templates.render('core.editor.quote', {
                        citeurl: data.citeurl || '',
                        citation: ips.utils.getCitation(data),
                        contents: html
                    }));

                    for (let attr of ['timestamp', 'userid', 'username', 'contentapp', 'contenttype', 'contentclass', 'contentid', 'contentcommentid']) {
                        if (data[attr]) {
                            quote.attr('data-ipsQuote-' + attr, data[attr]);
                        }
                    }
                    toInsert += quote.get(0).outerHTML
                }

                if (!toInsert) {
                    return;
                }

                if (isAutoSave && draftContent) {
                    instance
                        .chain()
                        .setContent(draftContent, false)
                        .focus()
                        .run();

                    setTimeout(() => {
                        let pos
                        instance
                            .chain()
                            .command(({tr}) => pos = tr.doc.resolve(0).end())
                            .insertContentAt(pos, toInsert + "<p></p>", {parseOptions: {preserveWhitespace: false}})
                            .setMeta('preventUpdate', true)
                            .showMessage('autosave')
                            .focus()
                            .command(({chain, tr}) => chain().setTextSelection(tr.doc.resolve(0).end() - 1))
                            .run();
                    }, 10);
                    return;
                } else if (_minimized) {
                    // It's odd, but if we insert a new line and move the cursor inside it, then the quote before the new line in a second transaction it works.
                    let to, from;
                    instance
                        .chain()
                        .command(({tr}) => {
                            to = tr.doc.resolve(0).end();
                            from = to;
                            if (tr.doc.lastChild?.inlineContent && ![...tr.doc.lastChild.children].some(desc => desc.nodeSize)) {
                                from = tr.doc.resolve(0).posAtIndex(tr.doc.childCount - 1);
                            }
                            return true;
                        })
                        .insertContentAt(to, "<p></p>")
                        .setTextSelection(to + 1)
                        .focus()
                        .run();

                    instance
                        .chain()
                        .insertContentAt({from,to}, toInsert, {parseOptions: {preserveWhitespace: false}, updateSelection:false})
                        .focus()
                        .run();
                    return;
                }

                instance
                    .chain()
                    .insertContent(toInsert + (instance.state.selection.empty && instance.state.selection.$from.nodeAfter ? "" : "<p></p>"), {parseOptions: {preserveWhitespace: false}})
                    .focus()
                    .run();
            };

            // If we are minimized, we will unminimize, then empty the editor contents, and then insert the quotes
            // If we aren't minimized, keep the existing content.
            if (minimized) {
                const draft = options.autoSaveKey && ips.utils.db.get('editorSave', options.autoSaveKey);
                if (typeof draft?.content === 'string' && draft.time && (Date.now() / 1000 - 86400 * 3) < parseInt(draft.time) && !instance) {
                    draftContent = draft.content;
                    isAutoSave = true;
                }
                unminimize(function() {
                    _doInsert();
                });
            } else {
                _doInsert();
            }
        }

        /**
         * @callback insertHtml
         *
         * Insert arbitrary HTML into editor at the current selection
         *
         * @param 		{string|object} 	html 	HTML to insert; This can alternatively be a JS Object meeting the Tiptap/Prosemirror document schema
         * @see https://tiptap.dev/docs/editor/api/commands/insert-content
         *
         * @returns void
         */
        function insertHtml(html) {
            instance
                .chain()
                .insertContent(html, {parseOptions: {preserveWhitespace: false}})
                .focus()
                .run();
        }

        /**
         * @callback reset
         * Reset the editor
         *
         * @returns void
         */
        function reset() {
            // Tell editor we are resetting
            instance
                .chain()
                .setContent(originalContent || '<p></p>', {emitUpdate: true})
                .clearAutosave()
                .run();

            $(elem).find('[data-ipsUploader]').trigger('resetUploader');

            if (options.minimized && options.minimizeAfterReset) {
                minimize();
            }
            clearTextarea();
        }

        /**
         * @callback saveAndClearAutosave
         *
         * Save and clear autosave
         *
         * @returns void
         */
        function saveAndClearAutosave() {
            if (instance) {
                instance?.commands.clearAutoSave?.()
            } else {
                ips.utils.db.remove('editorSave', options.autoSaveKey);
            }
        }

        /**
         * Determines whether the provided editor ID matches this widget
         *
         * @param 		{object} 	 data   A generic data object requires editorID key which is the editor name to check
         * @returns 	boolean
         */
        function _belongsToThisEditor(data) {
            return data.editorID !== undefined && data.editorID === name;
        }

        /**
         * Allows other JS to initialize the editor
         *
         * @returns void
         */
        function _initializeEditor(e, data) {
            if( !_belongsToThisEditor( data ) ){
                return;
            }

            unminimize(	function () {
                focus();
            });
        }

        /**
         * Remove a file from the editor
         *
         * @param	{event} 	e 		Event object
         * @param	{object} 	data 	Data object from the event
         * @returns {void}
         */
        function _deleteFile(e, data) {
            // This runs from a listener on the document itself, so make sure the event is for this editor
            if (options.postkey && options.postkey !== data.postkey) {
                return;
            }

            // If this isn't unminimized, don't do anything
            if (!instance) {
                Debug.warn(new Error(`An attachment was deleted for an editor that has not been initialized. This will cause the editor's content to retain the attachment if it is unminimized or initialized`));
                return;
            }

            const fileId = parseInt(data?.fileElem?.attr?.('data-fileid'));
            if (!fileId || Number.isNaN(fileId)) {
                Debug.log(`Could not delete a file in the editor because no file id was passed`);
                return;
            }

            // Wrap in try catch so as to not block the rest of the event listeners
            try {
                instance
                    .chain()
                    .removeAttachment(fileId)
                    .focus()
                    .run();
            } catch (e) {
                Debug.warn(e);
            }
        }

        return {
            init,
            focus,
            unminimize,
            minimize,
            insertQuotes,
            insertHtml,
            reset,
            destruct,
            saveAndClearAutosave,
            getInstance,
            getInstanceHTML,
            scrollIntoView
        };

    }
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.filterBar.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.filterBar.js - Filter bar widget
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.filterBar', function(){

		var defaults = {
			on: 'phone,tablet',
			viewDefault: 'filterContent'
		};

		/**
		 * Respond to a menu trigger being clicked
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object
		 * @returns {void}
		 */
		var respond = function (elem, options) {
			if( !$( elem ).data('_filterBar') ){
				$( elem ).data('_filterBar', filterBarObj(elem, _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Retrieve the filterBar instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The filterBar instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_filterBar') ){
				return $( elem ).data('_filterBar');
			}

			return undefined;
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		};

		ips.ui.registerWidget( 'filterBar', ips.ui.filterBar, [ 'on', 'viewDefault' ] );

		return {
			respond: respond,
			destruct: destruct,
			getObj: getObj
		};
	});

	/**
	 * Filter bar instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var filterBarObj = function (elem, options) {

		var filterBar = null;
		var filterContent = null;
		var currentlyShowing = null;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			
			filterBar = elem.find('[data-role="filterBar"]');
			filterContent = elem.find('[data-role="filterContent"]');

			// Widget events
			elem
				.on( 'switchTo.filterBar', function (e, data) {				
					_switchView( data.switchTo );
				})
				.on( 'click', '[data-action="filterBarSwitch"]', _switchToggle );


			_setUpBar();
		},

		/**
		 * Destruct the instance
		 *
		 * @returns {void}
		 */
		destruct = function () {
			
		},

		/**
		 * Sets up the filter bar on widget initialization
		 *
		 * @returns 	{void}
		 */
		_setUpBar = function () {
			if( options.viewDefault == 'filterBar' ){
				currentlyShowing = 'filterBar';
			} else {
				currentlyShowing = 'filterContent';
			}
		},

		/**
		 * A manual toggle by the user (e.g. clicking a link)
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		_switchToggle = function (e) {
			_switchView( $( e.currentTarget ).attr('data-switchTo') == 'filterBar' ? 'filterBar' : 'filterContent' );
		},

		/**
		 * Toggles the current view from filters to content or vice-versa
		 *
		 * @param 		{string} 	switchTo 	The view to switch to (filterBar or filterContent)
		 * @returns 	{void}
		 */
		_switchView = function (switchTo) {
			if( switchTo == currentlyShowing ){
				return;
			}

			// View transition
			if (document.startViewTransition) {
				document.startViewTransition(() => {
					elem.attr('data-ipsfilterbar-viewing', switchTo);
				});
			} else {
				// Fallback
				elem.attr('data-ipsfilterbar-viewing', switchTo);
			}

			currentlyShowing = switchTo;
		};

		init();

		return {
			init: init,
			destruct: destruct
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.flashMsg.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.flashMsg.js - Flash message widget
 * Creates a flash message - a box used for communicating quick messages to the user such as 'success' text.
 *
 * Although this widget can be initialized on an element with the data api, it will primarily be
 * called programatically:
 *
 * ips.ui.flashMsg.show('text');
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.flashMsg', function(){

		var _queue = [],
			_doneInit = false,
			_box,
			_content,
			_isShowing = false,
			_currentDismissHandler = null;

		var defaults = {
			timeout: 2,
			extraClasses: '',
			location: 'top',
			sticky: false,
			escape: true
		};

		/**
		 * Responder for flash card widget
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object passed through
		 * @returns {void}
		 */
		var respond = function (elem, options) {
			if( options.text ){
				show( options.text, options );
			}
		},

		/**
		 * Check the URL and cookie for any flash card we might need to show
		 *
		 * @returns {void}
		 */
		init = function () {
			$( document ).ready( function () {
				if( $('body').attr('data-message') ){
					show( $('body').attr('data-message') );
				}
								
				if( ips.utils.url.getParam('flmsg') ){
					show( _.escape( decodeURIComponent( ips.utils.url.getParam('flmsg') ) ) );
				}

				if( ips.utils.cookie.get('flmsg') ){
					show( _.escape( ips.utils.cookie.get('flmsg') ) );
					ips.utils.cookie.unset('flmsg');
				}
			});

			$( document ).on( 'closeFlashMsg.flashMsg', hide );
		},

		/**
		 * Shows the flash message
		 *
		 * @param	{string} 	message 	The flash message
		 * @param	{object} 	options 	Options for showing this flash message
		 * @returns {void}
		 */
		show = function (message, options, update) {
			if( !_doneInit ){
				_initElement();
			}

			options = _.defaults( options || {}, defaults );
			
			if ( options.escape ) {
				message = _.escape( message );
			}

			// If there's already a message showing, add to the queue
			if( _isShowing && !update ){
				_queue.push( [ message, options ] );
				return;
			}

			// If we're updating the current flash message and already showing...
			if( update && _isShowing ){
				_content.html( message );
				ips.utils.anim.go( 'pulseOnce', _box );

				if( !options.sticky ){
					setTimeout( hide, options.timeout * 1000 );
				}

				return;
			}

			_currentDismissHandler = null;
			_isShowing = true;
			_content.html( message );

			_box
				.attr( 'class', '' ) // Reset classes
				.addClass( options.extraClasses )
				.addClass( options.dismissable ? 'ipsFlashMsg_dismissable' : '' )
				.addClass( options.position == 'bottom' ? 'ipsFlashMsg--bottom' : 'ipsFlashMsg--top' )
				.on( 'click', 'a:not( [data-action="dismissFlashMessage"] )', function () {
					hide();
				})
				.animationComplete( function () {
					if ( !options.sticky ) {
						setTimeout( hide, options.timeout * 1000 );
					}
				});

			// Any close handlers?
			if( _.isFunction( options.dismissable ) ){
				_currentDismissHandler = options.dismissable;
			}

			ips.utils.anim.go( 'fadeInDown', _box );
		},

		/**
		 * Hides the flash message
		 *
		 * @param	{string} 	message 	The flash message
		 * @param	{object} 	options 	Options for showing this flash message
		 * @returns {void}
		 */
		hide = function () {
			if( _queue.length ){
				var next = _queue.shift();
				show( next[0], next[1], true );
			} else {
				_box
					.animationComplete( function () {
						_isShowing = false;
						_box.hide();

						if( _queue.length ){
							var next = _queue.shift();
							show( next[0], next[1] );
						}
					});

				ips.utils.anim.go('fadeOutDown', _box);
			}
		},

		dismiss = function (e) {
			e.preventDefault();
			hide();

			if( _.isFunction( _currentDismissHandler ) ){
				_currentDismissHandler();
				_currentDismissHandler = null;
			}
		},

		/**
		 * Initialize the element used for the flash message
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object passed through
		 * @returns {void}
		 */
		_initElement = function () {
			// Create element
			$('body').append( ips.templates.render("core.general.flashMsg") );

			// Find the box, then find the content element (which might be the same one)
			_box = $('#elFlashMessage').hide();
			_content = ( _box.is('[data-role="flashMessage"]') ) ? _box : _box.find('[data-role="flashMessage"]');

			// Dismiss event
			_box.on( 'click', 'a[data-action="dismissFlashMessage"]', dismiss );

			_doneInit = true;
		};

		// Register this widget with ips.ui
		ips.ui.registerWidget('flashMsg', ips.ui.flashMsg,
			['text', 'extraClasses', 'timeout', 'position', 'sticky', 'dismissable' ]
		);

		init();

		return {
			respond,
			show
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.form.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.forms.js - Form handling in the AdminCP
 * Sets up basic form elements and behaviors used throughout the acp. More complex form controls (e.g.
 * uploading or autocomplete) are handled in their own widgets.
 *
 * Author: Matt Finger. Originally Mark Wade & Rikki Tissier, but they didn't do a great job :)
 */
;( function($, _){
	"use strict";

	/**
	 * @typedef {CustomEvent<ToggleCollection>} ToggleEvent
	 */

	/**
	 * @typedef {{togglesOn: Set<Element>, togglesOff: Set<Element>}} ToggleCollection
	 */

	ips.createModule('ips.ui.form', function(){

		const _cmInstances = {};
		const _support = {};

		const formTypes = {
			// Toggles to allow 'unlimited' values
			'unlimited': '[data-control~="unlimited"]',
			// Polyfills dates
			'date': 'input[type="date"], [data-control~="date"]',
			// Makes range inputs a bit nicer
			'range': 'input[type="range"], [data-control~="range"]',
			// Polyfills colors
			'color': 'input[type="color"], [data-control~="color"]',
			// Width/height changers
			'dimensions': '[data-control~="dimensions"]',
			// Width/height unlimited toggles
			'dimensionsUnlimited': '[data-control~="dimensionsUnlimited"]',
			// Disables fields if JS is enabled
			'jsDisable': 'input[data-control~="jsdisable"]',
			// Codemirror
			'codemirror': '[data-control~="codemirror"]',
			// CheckboxSets with Unimited toggles
			'granularCheckboxset': '[data-control~="granularCheckboxset"]',
		};

		const _controlMethods = {
			/**
			 * Handles codemirror fields
			 *
			 * @param	{element}	elem		The textarea element
			 * @returns {void}
			 */
			codemirror(elem) {
				ips.loader.getStatic( ['applications/core/interface/static/codemirror/diff_match_patch.js','applications/core/interface/static/codemirror/codemirror.js'] ).then( function () {
					const elemId = $(elem).attr('id');

					// If there's already an instance here, we need to remove it and reinitialize
					// This happens when, for example, a form is validated in a modal, meaning the same element
					// ID is used again
					if( !_.isUndefined( _cmInstances[ elemId ] ) ) {
						// 10/23/15 we were still losing the contents of codemirror when switching tabs. To fix this, we need to save
						// the contents to the textarea *before* removing the CM instance.
						_cmInstances[ elemId ].save();
						//-----

						$( _cmInstances[ elemId ].getWrapperElement() ).remove();
						delete _cmInstances[ elemId ];
					}

					_cmInstances[ elemId ]	= CodeMirror.fromTextArea( document.getElementById(elemId), {
						mode: $(elem).attr('data-mode'),
						lineWrapping: true,
						lineNumbers: false,
						leaveSubmitMethodAlone: true
					} );

					if ( $(elem).attr('data-height') ){
						_cmInstances[ elemId ].setSize( null, $(elem).attr('data-height') );
						$('div[data-codemirrorid=' + elemId + '] ul[data-role=tagsList]').css('max-height', $(elem).attr('data-height') );
					}

					$( '#' + elemId ).data('CodeMirrorInstance', _cmInstances[ elemId ] );

					// Support custom tags
					$('[data-codemirrorcustomtag]').on( 'click', function( e ){
						_cmInstances[ elemId ].replaceRange( $( e.currentTarget ).attr('data-codemirrorcustomtag'), _cmInstances[ elemId ].getCursor( "end" ) );
					});
				});
			},

			/**
			 * Makes range inputs a little nicer to use
			 *
			 * @param	{element}	elem		The range element
			 * @returns {void}
			 */
			range(elem) {
				if( _.isUndefined( _support['range'] ) ){
					const i = document.createElement("input");
					i.setAttribute("type", "range");

					_support['range'] = !( i.type === 'text' );
				}

				if( !_support['range'] ){
					elem.siblings('[data-role="rangeBoundary"]').hide();
				} else {
					const valueElem = $('#' + elem.attr('name') + '_rangeValue');
					valueElem.text( elem.val() );

					elem.on( 'change', function () {
						valueElem.text( elem.val() );
					});
				}
			},

			/**
			 * Enables functionality for 'unlimited' toggles
			 *
			 * @param	{HTMLInputElement}	elem		The checkbox element
			 * @returns {void}
			 */
			unlimited(elem) {
				elem = $(elem).get(0);
				elem.addEventListener('change', () =>_unlimitedCheck());

				if (!elem.dataset.initialized) {
					elem.dataset.initializd = '1';
					_unlimitedCheck();
				}

				/**
				 * 'Unlimited' checkbox implementation
				 * Disables inputs if the element is checked
				 *
				 * @returns {void}
				 */
				function _unlimitedCheck() {
					const checkbox = elem;
					if (checkbox.disabled) {
						return;
					}

					checkbox
						.closest('.ipsFieldRow__content,[data-role="unlimitedCatch"]')
						?.querySelectorAll('input:not([type="checkbox"],[type="hidden"]),select,textarea')
						.forEach(input => {
							if (input.dataset.control !== 'color') {
								if (checkbox.checked) {
									if (input.value) {
										input.dataset.previousvalue = input.value;
									}

									input.value = "";
									input.setAttribute('disabled', '');
								} else {
									input.removeAttribute('disabled');
									if (input.dataset.previousvalue) {
										input.value = input.dataset.previousvalue;
									}
								}
							}

							input
								.querySelectorAll('[data-role="rangeBoundary"]')
								.forEach(
									boundary => boundary.style.opacity = checkbox.checked ? '0.5' : '1'
								);
						});
				}
			},

			/**
			 * Handles color fields by adding a jquery plugin if the browser doesn't natively support type='color'
			 *
			 * @param	{element}	elem		The color control
			 * @returns {void}
			 */
			color(elem) {
				if( elem.attr('data-ipsFormData')) {
					return;
				}

				/** @type {HTMLInputElement<{tagName: "COLOR"}>} */
				const input = elem.get(0);
				input.setAttribute("data-ipsFormData", "1");
				const initialColor = input.style.getPropertyValue('--i-co--inverse') || "var(--i-color_root)"
				const unlimited = input.closest('.ipsFieldRow__content')?.querySelector(`input[data-control=unlimited]`);
				const wrap = input.closest('.ipsInput__color-wrap-inner');
				const iroWrap = wrap.querySelector('[data-role="iro-container"]');
				const label = input.closest('.ipsInput__color-wrap')?.querySelector('.ipsInput__color-label');
				let controller = 'label'; // this lets us keep track of what input the user last used
				let iro;
				ips.utils.color.loadIro().then(() => {
					function buildIro() {
						iroWrap.innerHTML = '';
						iro = new ips.utils.iro.ColorPicker(iroWrap, {
							color: input.value,
							layout: [
								{
									component: ips.utils.iro.ui.Box,
									options: {}
								},
								{
									component: ips.utils.iro.ui.Slider,
									options: {
										sliderType: 'hue'
									}
								}
							]
						});

						iro.on('input:change', (e) => {
							controller = 'picker';
							input.value = e.hexString;
							updateColor({target: input});
						});
					}

					buildIro();

					wrap?.addEventListener('pointerdown', e => {
						if (e.target.closest('[data-role="iro-container"]')) {
							return;
						}

						e.stopPropagation();
						if (unlimited) {
							const sel = document.getSelection();
							const activeElement = document.activeElement;
							const wasFocused = controller === 'label' && ((activeElement === label) || (activeElement.parentElement?.closest?.('.ipsInput__color-label') === label));
							const ranges = [];
							for (let i = 0; i < sel.rangeCount; i++) {
								ranges.push(sel.getRangeAt(i));
							}
							let currentText = label.innerText;
							unlimited.checked = false;
							updateColor(e);
							if (label.innerText !== currentText) {
								e.preventDefault();
								let sel = document.getSelection();
								if (!wasFocused || (e instanceof PointerEvent && e.detail >= 2)) {
									sel.removeAllRanges();
									const range = document.createRange();
									range.selectNodeContents(label);
									if (!(e instanceof PointerEvent && e.detail > 2) && label.innerText.startsWith('#')) {
										const st = document.createTextNode('#');
										const textNode = document.createTextNode(label.innerText.slice(1));

										label.innerHTML = "";
										label.appendChild(st);
										label.appendChild(textNode);
										range.selectNodeContents(textNode);
									} else {
										const text = document.createTextNode(label.innerText);
										label.innerHTML = "";
										label.append(text);
										range.selectNodeContents(text);
									}
									sel.addRange(range);
								} else if (wasFocused) {
									sel.removeAllRanges();
									ranges.forEach(range => {
										sel.addRange(range);
									})
								}
							}
						}

						iroWrap.classList.add('ipsInput__color-iro-container--open');
					});

					label.addEventListener('input', e => {
						controller = 'label';
						const text = label.innerText;
						try {
							input.value = (new ips.utils.iro.Color(text)).hexString;
							buildIro();
							updateColor({target: input}, true);
						} catch (e) {
							// This is an expected error; If the user enters an invalid color, such as "rgb(ba ba black sheep)", IRO will throw an error because it cannot determine the color. Simply exiting the flow is fine in this case
							// Debug.error(e);
						}
					});

					/**
					 * Handle data transfer from dropping or pasting content
					 *
					 * @param {DragEvent|ClipboardEvent} e
					 */
					function handleDataTransfer(e) {
						const dt = e instanceof ClipboardEvent ? e.clipboardData : e.dataTransfer;
						if (dt instanceof DataTransfer) {
							e.preventDefault();
							e.stopPropagation();
							const allTypes = [...dt.types];
							let textFound;
							if (allTypes.includes('text/plain')) {
								Debug.log("Using plain text from paste or drop event");
								textFound = dt.getData('text/plain');
							} else if (allTypes.includes('text/html')) {
								Debug.log("Using html from paste or drop event");
								const cleanText = (new DOMParser()).parseFromString(dt.getData('text/html'), 'text/html').body.innerText;
								if (cleanText) {
									textFound = cleanText;
								}
							}

							// now actually insert. This looks weird because we have to emulate native paste events with selection fixing
							if (textFound) {
								textFound = textFound.replaceAll(/\s+/g, ' ').trim().slice(0, 30).trim(); // make sure we don't have a 500kb webpage pasted in here. Won't break anything but could be problematic
								const selection = document.getSelection();
								const text = document.createTextNode(textFound);
								let usingExistingRange = false;

								for (let i = 0; i < selection.rangeCount; i++) {
									const existingRange = selection.getRangeAt(i);
									if (existingRange.intersectsNode(label)) {
										const isDescendant = (descendant, ancestor) => {
											while (descendant) {
												if (descendant === ancestor) {
													return true;
												}
												descendant = descendant.parentNode;
											}
											return false;
										}

										if (!isDescendant(existingRange.startContainer, label)) {
											existingRange.setStart(label, 0);
										}

										if (!isDescendant(existingRange.endContainer, label)) {
											existingRange.setEnd(label, label.childNodes.length);
										}

										usingExistingRange = true;
										existingRange.deleteContents();
										existingRange.insertNode(text);
										existingRange.collapse(false);
										break;
									}
								}

								selection.removeAllRanges();
								const newRange = document.createRange();
								if (!usingExistingRange) {
									label.innerHTML = "";
									label.appendChild(text);
								}
								newRange.setStartAfter(text);
								newRange.setEndAfter(text);
								selection.addRange(newRange);

								// now see if we need to truncate
								if (label.innerText.trim().length > 30) {
									let precedingTextLength = 0;
									for (let node of label.childNodes) {
										if (node === text) {
											break;
										}
										if (node instanceof Text) {
											precedingTextLength += node.wholeText.length;
										} else if (node instanceof Element) {
											precedingTextLength += node.innerText.length;
										}
									}
									const replacementTextNode = document.createTextNode(label.innerText.trim().slice(0, 30));
									label.innerHTML = "";
									label.appendChild(replacementTextNode);
									if (precedingTextLength) {
										const correctedRange = document.createRange();
										correctedRange.setStart(replacementTextNode, Math.min(30, precedingTextLength));
										correctedRange.setEnd(replacementTextNode, Math.min(30, precedingTextLength));
										selection.removeAllRanges();
										selection.addRange(correctedRange);
									}
								}

								controller = 'label';
								try {
									input.value = (new ips.utils.iro.Color(label.innerText)).hexString;
									buildIro();
									updateColor({target: input}, true);
								} catch (e) {
									Debug.error(e);
									// todo: possibly show a warning icon, but that may be overkill
								}
								return;
							}

							// still here? show a message
							ips.ui.flashMsg.show(ips.getString('form_color_datatransfer_fail'));
						}
					}

					label.addEventListener('drop', handleDataTransfer);
					label.addEventListener('paste', handleDataTransfer);

					document.addEventListener('pointerdown', e => {
						if (e.target.closest('.ipsInput__color-wrap-inner') !== wrap && iroWrap.classList.contains('ipsInput__color-iro-container--open')) {
							iroWrap.classList.remove('ipsInput__color-iro-container--open');
						}
					});
				});

				/**
				 *
				 * @param [e]
				 * @param [skipLabel]
				 */
				const updateColor = (e, skipLabel=false) => {
					if (unlimited && e?.target === input) {
						unlimited.checked=false;
					}

					if (unlimited?.checked) {
						wrap?.classList.add('ipsInput--color-disabled');
						if (label) {
							label.innerHTML = "";
						}
						return;
					}


					wrap?.classList.remove('ipsInput--color-disabled');
					let textColor;
					if (ips.utils.iro?.colorPackage) {
						// utilize oklab to determine perceived lightness rather than physical values
						const color = new ips.utils.iro.colorPackage(input.value);
						if (color.to('oklab').toGamut().l < 0.71) {
							textColor = "#fff";
						} else {
							textColor = "#000";
						}
					} else {
						const [_, __, l] = input.value.match(/#[0-9a-f]{3,8}/i) ? ips.utils.color.RGBtoHSL(...ips.utils.color.hexToRGB(input.value.match(/#([0-9a-f]{3,8})/i)[1])) : [null,null,null];
						textColor = typeof l === "number" ? (l < 0.6 ? "#fff" : "#000") : initialColor;
					}

					input.closest('.ipsInput__color-wrap')?.style.setProperty("--i-co-inverse", textColor);
					input.closest('.ipsInput__color-wrap')?.style.setProperty("--i-co", `${input.value}`);
					if (!skipLabel && label && label.innerText !== input.value) {
						// set the label's inner text to the selection; We don't want to select the # for hex codes though
						label.innerHTML = "";
						let textNodes = input.value.match(/^(#)?(.*)/i)
							.slice(1)
							.map(match => document.createTextNode(match || ''));

						textNodes.forEach(node => label.append(node));
						const sel = document.getSelection();
						sel.removeAllRanges();
						const range = document.createRange();
						range.selectNodeContents(textNodes[textNodes.length - 1]);
						sel.addRange(range);
					}

					input.setAttribute('value', input.value);
				};

				input.addEventListener("input", updateColor);
				unlimited?.addEventListener('input', updateColor);
				updateColor();
			},

			/**
			 * Handles dimension controls, which have dragging functionality to choose a size
			 *
			 * @param	{element}	elem	The dimensions element
			 * @returns {void}
			 */
			dimensions(elem) {
				const container = elem.closest('.ipsWidthHeight_container');

				elem.resizable( {
					resize: function (event, ui) {
						container.find('input.ipsWidthHeight_width').val( elem.width() );
						container.find('input.ipsWidthHeight_height').val( elem.height() );
					}
				});

				container.find('input.ipsWidthHeight_width').on( 'change', function () {
					elem.width( $( this ).val() );
				});

				container.find('input.ipsWidthHeight_height').on( 'change', function () {
					elem.height( $( this ).val() );
				});
			},

			/**
			 * Sets up events for unlimited checkbox for dimension controls
			 *
			 * @param	{Element}	elem	THe checkbox element
			 * @returns {void}
			 */
			dimensionsUnlimited(elem) {
				$(elem).get(0).addEventListener( 'change', () => _dimensionsUnlimitedCheck());
				_dimensionsUnlimitedCheck();

				/**
				 * Handles the 'unlimited' checkbox for dimension controls
				 *
				 * @returns {void}
				 */
				function _dimensionsUnlimitedCheck () {
					elem = $(elem).get(0);
					const container = elem.closest('.ipsWidthHeight_container');

					if( elem.matches(':checked') ){
						container
							.querySelectorAll('[data-control="dimensions"]')
							.ipsHide();

						container
							.querySelectorAll('input.ipsWidthHeight_width, input.ipsWidthHeight_height')
							.forEach(el => {
								if (el.value !== '' && !Number.isNaN(parseFloat(el.value))) {
									el.dataset.lastvalue = el.value;
								}
								el.value = '';
								el.setAttribute('disabled', '');
							});
					} else {
						container
							.querySelectorAll('[data-control="dimensions"]')
							.ipsShow();

						container
							.querySelectorAll('input.ipsWidthHeight_width, input.ipsWidthHeight_height')
							.forEach(el => {
								if (el.dataset.lastvalue !== undefined) {
									el.value = el.dataset.lastvalue;
								}
								// $(el).change(); // todo find a native js way to polyfill this jquery change event
								el.removeAttribute('disabled');
							});
					}
				}
			},

			/**
			 * Disables fields if JS is enabled
			 *
			 * @param	{element}	elem		The element this widget is being created on
			 * @returns {void}
			 */
			jsDisable(elem) {
				elem.prop('disabled', true);
			},

			/**
			 * CheckboxSet with Unlimited checkbox
			 *
			 * @param	{jQuery|element}	elem		The element this widget is being created on
			 * @returns {void}
			 */
			granularCheckboxset(elem) {
				elem.find('[data-role="checkboxsetUnlimitedToggle"]').on( 'change', function () {
					// We don't want to check disabled boxes, but we do want to uncheck them
					if( $(this).is(':checked') ){
						elem.find('[data-role="checkboxsetGranular"] input:enabled[type="checkbox"]').prop( 'checked', $(this).is(':checked') );
					} else {
						elem.find('[data-role="checkboxsetGranular"] input[type="checkbox"]').prop( 'checked', $(this).is(':checked') );
					}
				});

				elem.find('[data-action="checkboxsetCustomize"]').on( 'click', function () {
					elem.find('[data-role="checkboxsetUnlimited"]').hide();
					elem.find('[data-role="checkboxsetUnlimitedToggle"]').prop( 'checked', false );

					if( elem.find('[data-role="checkboxsetUnlimitedToggle"]').length > 0 ) {
						elem.find('[data-role="checkboxsetGranular"]').slideDown();
					}
				});

				elem.find('[data-action="checkboxsetAll"]').on( 'click', function () {
					elem.find('[data-role="checkboxsetGranular"] input:enabled[type="checkbox"]').prop( 'checked', true );

					if( elem.find('[data-role="checkboxsetUnlimitedToggle"]').length > 0 ) {
						elem.find('[data-role="checkboxsetUnlimited"]').slideDown();
						elem.find('[data-role="checkboxsetGranular"]').slideUp();
						elem.find('[data-role="checkboxsetUnlimitedToggle"]').prop( 'checked', true );
					}

					$(elem)[0]?.dispatchEvent(new CustomEvent('ips:formChange', {bubbles: true}));
				});
				elem.find('[data-action="checkboxsetNone"]').on( 'click', function () {
					elem.find('[data-role="checkboxsetGranular"] input:enabled[type="checkbox"]').prop( 'checked', false );

					if( elem.find('[data-role="checkboxsetUnlimitedToggle"]').length > 0 ) {
						elem.find('[data-role="checkboxsetUnlimited"]').slideDown();
						elem.find('[data-role="checkboxsetGranular"]').slideUp();
						elem.find('[data-role="checkboxsetUnlimitedToggle"]').prop( 'checked', false ).change();
					}

					$(elem)[0]?.dispatchEvent(new CustomEvent('ips:formChange', {bubbles: true}));
				});

				elem.find('[data-role="search"]').on( 'keydown', function(e){
					if ( e.keyCode == 13 || e.keyCode == 38 || e.keyCode == 40 ) {
						e.preventDefault();
					}
				});
				// We call .off() first in case this function is hit more than once - we don't want the event handler set more than once
				// or it will cause items to be skipped when navigating via arrows, and checkboxes not to check when hitting enter
				elem.find('[data-role="search"]').off('keyup').on( 'keyup', function(e){
					const focussedCheckbox = elem.find('[data-role="result"].ipsField__checkboxOverflow__focused');

					switch ( e.keyCode ) {
						case 13: // Return
							focussedCheckbox.find('input').prop( 'checked', !focussedCheckbox.find('input').prop('checked') );
							break;

						case 38: // Up
							var prev = focussedCheckbox.prevAll(':visible').first();
							if ( prev.length ) {
								focussedCheckbox.removeClass('ipsField__checkboxOverflow__focused')
								prev.addClass('ipsField__checkboxOverflow__focused');
							}
							break;

						case 40: // Down
							var next = focussedCheckbox.nextAll(':visible').first();
							if ( next.length ) {
								focussedCheckbox.removeClass('ipsField__checkboxOverflow__focused')
								next.addClass('ipsField__checkboxOverflow__focused');
							}
							break;

						default:
							focussedCheckbox.removeClass('ipsField__checkboxOverflow__focused');

							var val = $(this).val().toLowerCase();
							if ( val ) {
								elem.find('[data-role="massToggles"]').hide();
								elem.find('[data-role="result"]').each(function(){
									const labelText = this.querySelector('label svg[data-ipstooltip]')?.getAttribute('title') || this.querySelector('label svg[data-ipstooltip]')?.getAttribute('_title') || this.querySelector('label')?.innerText
									if (labelText?.toLowerCase().includes(val)) {
										$(this).show();
									} else {
										$(this).hide();
									}
								});
								elem.find('[data-role="result"]:visible').first().addClass('ipsField__checkboxOverflow__focused');
							} else {
								elem.find('[data-role="result"]:hidden').show();
								elem.find('[data-role="massToggles"]').show();
							}
					}
				});

				elem.find('[data-role="search"]').on( 'clear blur', function(e){
					// Did we want to select/un select an input first?
					if( $( e.relatedTarget ).closest('[data-role="checkboxsetGranular"]').find('[data-role="search"]').is( this ) ){
						e.preventDefault();
						$( this ).focus();
						return;
					}

					$(this).val('');
					elem.find('[data-role="result"].ipsField__checkboxOverflow__focused').removeClass('ipsField__checkboxOverflow__focused');
					elem.find('[data-role="result"]:hidden').show();
					elem.find('[data-role="massToggles"]').show();
				});

				const count = parseInt( elem.attr('data-count') );

				// If we have more than 10 items, then make this a scrolling selection box with search
				// v5 todo: This can be done with CSS: .ipsField__checkboxOverflow:has(li:nth-child(10))
				if( count > 10 ){
					elem.find('.ipsField__checkboxOverflow').addClass('ipsField__checkboxOverflow--scroll');
				}
			},

			/**
			 * Dialling code select box
			 *
			 * @param	{element}	elem		The element this widget is being created on
			 * @returns {void}
			 */
			diallingCode(elem) {

				const selected = elem.find('option:selected');
				if ( selected.length ) {
					selected.html( selected.attr('data-code') );
				}

				elem.on('change mouseleave', function(){
					elem.find('option').each(function(){
						$(this).html( $(this).attr('data-text') );
					});
					elem.find('option:selected').html( elem.find('option:selected').attr('data-code')  );
					$(this).blur();
				});
				elem.on('focus', function(){
					elem.find('option').each(function(){
						$(this).html( $(this).attr('data-text') );
					});
				});
			}
		}
		
		/**
		 * Locale sort
		 */
		function localeSort(a, b) {
			let bValue;
			let aValue;
			if ( $(a).prop("tagName") == 'OPTGROUP' ) {
				aValue = $(a).attr('label');
			} else {
				if (!a.value) {
			        return -1;   
			    }
				aValue = a.innerHTML;
			}
			if ( $(b).prop("tagName") == 'OPTGROUP' ) {
				bValue = $(b).attr('label');
			} else {
				if (!b.value) {
			        return 1;   
			    }
				bValue = b.innerHTML;
			}
									 
		    try {
		    	return aValue.localeCompare( bValue );
		    } catch ( err ) {
			    return ( aValue > bValue ) ? 1 : -1;
		    }
		}

		/**
		 * Refresh a form's toggles by firing an event.
		 *
		 * @note Third party code can listen to the `ips:calculateToggles` event, and add items to the `togglesOn` or `togglesOff` Set to modify what's toggled. Anything in togglesOn will be visible, everything in togglesOff that is NOT in togglesOn will be hidden
		 *
		 * @param {HTMLElement}	form
		 */
		function refreshFormToggles(form) {
			// do this twice so that toggles are accurately applied to elements which were just hidden
			if (!form) {
				return;
			}

			for (let i = 0; i < 1; i++) {
				/** @type ToggleEvent */
				const event = new CustomEvent('ips:calculateToggles', {
					cancelable: false,
					bubbles: false,
					detail: {
						togglesOn: new Set(),
						togglesOff: new Set(),
					}
				});

				// Dispatch an event so third party stuff can modify as needed
				try {
					form.dispatchEvent(event)
				} catch (e) {
					e.message = 'Failed to evaluate form toggles on an element:\n' + e.message;
					Debug.warn(e);
				}

				const forceStates = {
					togglesOn: new Set([...event.detail.togglesOn]),
					togglesOff: new Set([...event.detail.togglesOff])
				}

				parseToggleControls(event);

				// now we override system defaults with the custom values
				forceStates.togglesOn.forEach(el => {
					event.detail.togglesOn.add(el);
					event.detail.togglesOff.delete(el);
					forceStates.togglesOff.delete(el);
				})

				forceStates.togglesOff.forEach(el => {
					event.detail.togglesOff.add(el);
					event.detail.togglesOn.delete(el);
				})

				const allToggled = new Set([...event.detail.togglesOn, ...event.detail.togglesOff]);
				for (const toggle of allToggled) {
					if (event.detail.togglesOn.has(toggle)) {
						toggle.removeAttribute('hidden');
					} else {
						toggle.setAttribute('hidden', '');
					}
				}

				// These have to be updated when the form updates
				for (const widgetType of ['uploader', 'matrix']) {
					form
						.querySelectorAll(`[data-ips${widgetType}]`)
						.forEach(elem => ips.ui[widgetType].refresh($(elem)));
				}

				form.dispatchEvent(new CustomEvent('ips:refreshTogglesDone', {bubbles: true, cancelable: true}));
			}
		}

		/**
		 * Get a mapping of every toggled element to the things that toggle it
		 * @param {HTMLFormElement|Element}	form
		 * @param {Array<Element>}	togglers
		 * @param {Map<Element, ToggleCollection>}	toggledCollection
		 * @return {{inputMap: Map<Element, {parents: Set<Element>, ancestors: Set<Element>}>, toggleInputMap: Map<Element, Element>}}
		 */
		function buildToggleMap(form, togglers, toggledCollection) {
			togglers = [...togglers];
			const allToggledElementsForForm = new Set();
			for (const {togglesOn, togglesOff} of toggledCollection.values()) {
				togglesOn.forEach(elem => allToggledElementsForForm.add(elem));
				togglesOff.forEach(elem => allToggledElementsForForm.add(elem));
			}
			/**
			 * @type {Map<Element, {parents: Set<Element>, ancestors: Set<Element>}>}
			 */
			const map = new Map();
			const toggleInputMap = new Map();
			for (let toggler of togglers) {
				const toggleCollection = toggledCollection.get(toggler);
				const allToggled = new Set([...toggleCollection.togglesOn, ...toggleCollection.togglesOff]);
				let possibleToggled = toggler;
				while (possibleToggled && !allToggledElementsForForm.has(possibleToggled)) {
					possibleToggled = possibleToggled.parentElement;
				}
				toggleInputMap.set(toggler, possibleToggled || toggler);
				for (let toggled of allToggled) {
					if (!map.has(toggled)) {
						map.set(toggled, {parents: new Set(), ancestors: new Set()});
					}
					map.get(toggled).parents.add(toggler);
				}
			}

			/**
			 * @type {Map<Element, Set<Element>>}
			 */
			const allAncestorsMemo = new Map();

			/**
			 * @param {Element}	el
			 * @param {Set<Element>} [path]
			 * @return {Set<Element>}
			 */
			function getAllAncestors(el, path) {
				if (!allAncestorsMemo.has(el)) {
					path = path || new Set();
					path.add(el);
					const ancestors = new Set();
					if (map.has(el)) {
						for (let parent of map.get(el).parents) {
							if (path.has(parent)) {
								Debug.warn(`Cyclical form toggle detected. #${parent.getAttribute('id')} ultimately toggles itself.`);
								continue;
							}
							ancestors.add(parent);
							ancestors.add(toggleInputMap.get(parent))
							for (const ancestor of getAllAncestors(parent, new Set(path))) {
								ancestors.add(ancestor);
							}
						}
					}

					if (map.has(toggleInputMap.get(el))) {
						for (let parent of map.get(toggleInputMap.get(el)).parents) {
							if (path.has(parent)) {
								Debug.warn(`Cyclical form toggle detected. #${parent.getAttribute('id')} ultimately toggles itself.`);
								continue;
							}
							ancestors.add(parent);
							for (const ancestor of getAllAncestors(parent, new Set(path))) {
								ancestors.add(ancestor);
							}
						}
					}
					allAncestorsMemo.set(el, ancestors);
				}
				return allAncestorsMemo.get(el);
			}

			for (const toggled of map.keys()) {
				// we add all the ancestors of the parent to the ancestors array. The ancestors array doesn't contain direct parents
				for (const parent of [...map.get(toggled).parents]) {
					for (const ancestor of getAllAncestors(parent)) {
						map.get(toggled).ancestors.add(ancestor);
					}
				}
			}

			return {inputMap: map, toggleInputMap};
		}

		/**
		 *
		 * @param {ToggleEvent}	e
		 */
		function parseToggleControls(e) {
			/**@type {HTMLElement}*/
			const form = e.target;
			if (!form) {
				return;
			}
			const toggleCollectionMap = new Map();
			const allTogglers = [...form.querySelectorAll('[data-control~="toggle"], [data-action="nodeSelect"][data-toggles]')];
			allTogglers.forEach(toggler => toggleCollectionMap.set(toggler, getToggleCollection(toggler, form)));
			const {inputMap:toggleMap, toggleInputMap} = buildToggleMap(form, allTogglers, toggleCollectionMap);
			const toggleMapReverse = new Map();
			for (const toggled of toggleMap.keys()) {
				for (const parent of toggleMap.get(toggled).parents) {
					if (!toggleMap.get(toggled).ancestors.has(parent)) {
						if (!toggleMapReverse.has(parent)) {
							toggleMapReverse.set(parent, new Set())
						}
						toggleMapReverse.get(parent).add(toggled);
					}
				}
			}
			const roots = new Set();
			for (const toggler of toggleMapReverse.keys()) {
				// if the toggler is not toggled by something else, it is a root
				if (!toggleMap.has(toggler)) {
					roots.add(toggler);
				}
			}

			const toggleStates = new Map();

			// First, we need to compute the states depending on the elements themselves
			for (const toggle of allTogglers) {
				let eventType;
				let state;
				const toggleElements = toggleCollectionMap.get(toggle);
				if (!toggleElements.togglesOn.size && !toggleElements.togglesOff.size) {
					continue;
				}

				if (toggle.matches('option')) {
					state = toggleIsOn.select(toggle);
				} else if (toggle.matches('input[type="checkbox"], input[type="radio"]')) {
					state = toggleIsOn.checkbox(toggle);
				} else if (toggle.matches('.ipsSelectTree_item')) {
					state = toggleIsOn.node(toggle);
					eventType = 'nodeSelectedChanged';
				} else {
					state = toggleIsOn.generic(toggle);
				}
				toggleStates.set(toggle, state);
			}

			const checkAncestorMemo = new Map();

			/**
			 * Return whether this input has a disabled ancestor
			 * @param input
			 * @param path
			 */
			function checkAncestors(input, path) {
				if (checkAncestorMemo.has(input)) {
					return checkAncestorMemo.get(input);
				}

				path = path || new Set();
				const toggledEl = toggleInputMap.get(input) || input;
				path.add(input);
				if (!toggleMap.has(toggledEl)) {
					checkAncestorMemo.set(toggledEl, false);
					return false;
				}

				//now check all the immediate parents
				let allDisabled = true;
				for (const parent of toggleMap.get(toggledEl).parents) {
					if (toggleMap.get(toggledEl).ancestors.has(parent)) {
						continue;
					}

					if (!path.has(parent) && !checkAncestors(parent, new Set(path))) {
						let relationship = 'togglesOn';
						if (toggleCollectionMap.get(parent) && (toggleCollectionMap.get(parent).togglesOff.has(toggledEl) || toggleCollectionMap.get(parent).togglesOff.has(input))) {
							relationship = 'togglesOff';
						}

						if (toggleStates.has(parent) && !(relationship === 'togglesOn' ? toggleStates.get(parent) : !toggleStates.get(parent))) {
							continue;
						}
						allDisabled = false;
						break;

					}
				}

				if (allDisabled) {
					checkAncestorMemo.set(input, true);
					return true;
				}

				checkAncestorMemo.set(input, false);
				return false;
			}

			for (const toggle of [...toggleStates.keys()]) {
				const disabled = checkAncestors(toggle);
				const state = disabled ? false : toggleStates.get(toggle);
				const toggleElements = toggleCollectionMap.get(toggle);
				toggleElements.togglesOn.forEach(elem => {
					// if this toggler is also a "grandparent" toggler, don't consider it
					if (!toggleMap.get(elem).ancestors.has(toggle)) {
						if (state && !disabled) {
							e.detail.togglesOn.add(elem);
						} else {
							e.detail.togglesOff.add(elem);
						}
					}
				});

				toggleElements.togglesOff.forEach(elem => {
					if (!toggleMap.get(elem).ancestors.has(toggle)) {
						if (state || disabled) {
							e.detail.togglesOff.add(elem);
						} else {
							e.detail.togglesOn.add(elem);
						}
					}
				});
			}
		}

		/**
		 * Get all the toggled elements for a given toggler
		 *
		 * @param {HTMLElement}	elem
		 * @param {HTMLElement}	form
		 *
		 * @returns {ToggleCollection}
		 */
		function getToggleCollection(elem, form) {
			const getElements = s => new Set(form.querySelectorAll(s.split(',').map(c => "[id='" + c.trim() + "']").join(', ')));
			return {
				togglesOn: (elem.dataset.toggles || elem.dataset.toggleson) ? getElements(elem.dataset.toggles || elem.dataset.toggleson) : new Set(),
				togglesOff: elem.dataset.togglesoff ? getElements(elem.dataset.togglesoff) : new Set(),
			}
		}

		/**
		 * Methods to determine if the element is toggled to an "on" state
		 *
		 * @type {{[key: "select"|"checkbox"|"node"|"generic"]: function(HTMLOptionElement|HTMLInputElement|HTMLTextAreaElement|Element):boolean}}
		 */
		const toggleIsOn = {
			select: elem => !!elem.selected || elem.closest('select')?.value === elem.value,
			checkbox: elem => !!elem.checked,
			node: elem => elem.matches('[data-action="nodeSelect"][data-toggles].ipsSelectTree_selected'),
			generic: elem => elem.dataset && 'togglereverse' in elem.dataset ? !elem.value : !!elem.value,
		};

		ips.ui.registerWidget( 'form', ips.ui.form );

		return {

			/**
			 * Respond method
			 * Loops through each form type, finds elements that match, then initializes them
			 *
			 * @returns {void}
			 */
			respond(elem) {
				const form = $(elem).get(0).closest('form, [data-ipsform]');
				if (form && !('listenersSetup' in form.dataset)) {
					form.dataset.listenersSetup = '';
					form.addEventListener('nodeSelectedChanged', () => form.dispatchEvent(new CustomEvent('ips:formChange')));
					form.addEventListener('change', () => form.dispatchEvent(new CustomEvent('ips:formChange')));
					form.addEventListener(
						'ips:formChange',
						_.debounce(() => refreshFormToggles(form), 20)
					);

					// Timeout because we want other stuff to have a chance to initialize synchronously, and we don't want to block rendering
					setTimeout(() => refreshFormToggles(form));
				}

				// Loop through each type of control we'll work with
				for (const type in formTypes) {
				 	$( elem ).find( formTypes[ type ] ).each(function() {
				 		_controlMethods[type]?.($(this), elem);
				 	});
				}

				/* Sort any select boxes that need it */
				$(elem).find('select[data-sort]').each(function(){
					var value = $(this).val();
					$(this).children('optgroup').each(function(){
						$(this).append( $(this).children('option').remove().sort(localeSort) );
					});
					$(this).append( $(this).children('optgroup').remove().sort(localeSort) );
					$(this).append( $(this).children('option').remove().sort(localeSort) );
					$(this).val( value );
				});
			},
			/**
			 * Called when module is initialized.
			 * Observes the content change event, and calls our respond method. This allows us to initialize new form controls
			 * that might be added inside the form.
			 *
			 * @returns {void}
			 */
			init() {
				$( document ).on( 'contentChange', (e, data) => {
					if( !_.isUndefined( data ) && $( data[0] ).closest('[data-ipsForm]').length ){
						this.respond( $( data[0] ).closest('[data-ipsform]') );
					}
				});

				$( document ).on( 'menuOpened', (e, data = e.detail) => {
					if( data.menu.closest('[data-ipsForm]') && data.menu.closest('[data-ipsForm]').length ){
						this.respond( data.menu );
					}
				});

				/* This listens for codeMirrorInsert which is triggered from ips.editor.customtags.js and then inserts into code mirror instances */
				$( document ).on( 'codeMirrorInsert', function (e, data) {
					if( !_.isUndefined( _cmInstances[ data.elemID ] ) ) {
						_cmInstances[ data.elemID ].replaceRange( data.tag, _cmInstances[ data.elemID ].getCursor( "end" ) );
					}
				});

				$( document ).on( 'tabChanged', function (e, data) {
					var form = $( '#' + data['barID'] ).closest('[data-ipsForm]');
					if ( $('input[name=' + form.attr('data-formId' ) + '_activeTab]' ).length ) {
						$('input[name=' + form.attr('data-formId' ) + '_activeTab]' ).val( data['tabID'].replace( form.attr('data-formId' ) + '_tab_', '' ) );
					}
				});
			}
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.formSubmit.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.formSubmit.js - Disables form submit button when form is submitted to help prevent duplicated submissions
 *
 * Author: Mark Wade & Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.formSubmit', function(){

		/**
		 * Respond
		 *
		 * @returns {void}
		 */
		var respond = function (elem, options) {
			var formElement = $(elem).is('form') ? $(elem) : $(elem).closest('form');

			// Disable submit button when form is submitted to prevent duplicate submissions
			formElement.on( 'submit', function( e ){
				formElement.find('input[type="submit"],button[type="submit"]').prop( 'disabled', true );
			});

			// If attachment is still uploading, form submission is stopped. If that happens, re-enable submit button so user can try again
			formElement.on( 'fileStillUploading', function( e ){
				formElement.find('input[type="submit"],button[type="submit"]').prop( 'disabled', false );
			});
		};

		ips.ui.registerWidget( 'formSubmit', ips.ui.formSubmit );

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.hovercard.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[ /* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.hovercard.js - Hovercard UI component
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.hovercard', function(){

		var defaults = {
			timeout: 0.75, // Hovercard timeout, in seconds
			showLoading: true, // Show the loading widget for ajax requests?
			width: 450, // Default width of hovercards
			className: 'ipsHovercard',
			onClick: false,
			target: null,
			cache: true
		};

		// Cache object for URLs
		var cache = {};

		var respond = function (elem, options) {

			if( !$( elem ).data('_hover') ){
				$( elem ).data('_hover', hoverCardObj(elem, _.defaults( options, defaults ) ) );
			}

			if( options.onClick ){
				// We have to remove the click event before reapplying, or multiple events
				// will be trying to open the hovercard
				$( elem ).off('.hovercard').on( 'click.hovercard', function (e) {
					e.preventDefault();
					$( elem ).data('_hover').start();
				});
			} else {
				// Don't show hovercards on small touch devices
				if( ips.utils.events.isTouchDevice() && ( ips.utils.responsive.currentIs('phone') || ips.utils.responsive.currentIs('tablet') ) ){
					return;
				}

				$( elem ).data('_hover').start();
			}			
		},

		/**
		 * Retrieve the hovercard instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The hovercard instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_hover') ){
				return $( elem ).data('_hover');
			}

			return undefined;
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		},

		setCache = function (url, content) {
			cache[ url ] = content;
		},

		unCache = function (url) {
			delete cache[ url ];
		},

		getCache = function (url) {
			return cache[ url ];
		};

		ips.ui.registerWidget('hover', ips.ui.hovercard, 
			[ 'timeout', 'attach', 'content', 'width', 'onClick', 'target', 'cache' ],
			{ lazyLoad: true, lazyEvents: 'mouseover' } 
		);

		return {
			respond: respond,
			destruct: destruct,
			setCache: setCache,
			getCache: getCache
		};
	});


	/**
	 * Hovercard instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var hoverCardObj = function (elem, options) {

		var onTimeout = null, // Reference to our show timeout
			offTimeout = null, // Reference to hide timeout
			ajaxObj, // Ajax object reference
			content, // Content of the hovercard
			target, // The actual element the hovercard is attached to (usually elem)
			loading, // Our loading element
			card, // The hovercard itself
			working = false, // Are we in the middle of setup?
			elemID = '';

		/**
 		 * Sets up this instance
		 * This method does not start showing a hovercard. Call 'start' to do that.
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			elemID = $( elem ).identify().attr('id');
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @returns {void}
		 */
		destruct = function () {
			// Clear mouseout timeouts
			clearTimeout( offTimeout );
			// Remove document click event for hiding
			$( document ).off( 'click.' + elemID );
			// Remove loading widget in case it's there
			_removeLoadingWidget();
			// Delete the card element
			if( card ){
				card.remove();
			}
		},

		/**
		 * Starts the process of building and showing a hovercard
		 * Sets up events and starts a timeout to make sure we should really show it
		 *
		 * @returns 	{void}
		 */
		start = function () {

			// Check we aren't already in setup - prevents double-clicks
			if( working !== false && options.onClick ){
				return;
			}

			working = true;

			// Get the target
			target = ( $( options.attach ).length ) ? $( options.attach ) : $( elem );

			// Clear the timeout for our mouse off event
			clearTimeout( offTimeout );

			if( !options.onClick ){
				// We set a timeout before we do anything, which means we can cancel the event
				// if the user moves a mouse off the target
				onTimeout = setTimeout( _startShow, ( options.timeout * 1000 ) );

				// Set the event handler for when the mouse stops hoving
				$( elem ).off('mouseout.hovercard', _mouseOut).on('mouseout.hovercard', _mouseOut);
				$( elem ).off('mousedown.hovercard', _elemClick).on( 'mousedown.hovercard', _elemClick );
			} else {
				$( document ).off( 'click.' + elemID ).on( 'click.' + elemID, _documentClick );
				_startShow();
			}
		},

		/**
		 * The trigger element was clicked, so we cancel the hovercard showing
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		_elemClick = function (e) {
			if( onTimeout ){
				clearTimeout( onTimeout );
			}

			if( offTimeout ){
				clearTimeout( offTimeout );
			}

			if( ajaxObj && _.isFunction( ajaxObj.abort ) ){
				ajaxObj.abort();
			}
			
			_removeLoadingWidget();
			_hideCard();
		},

		/**
		 * Reacts to a click on the document (used for an onclick hovercard)
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		_documentClick = function (e) {
			if( !$( card ).is(':visible') ){
				return;
			}

			if( e.target != elem && !$.contains( elem, e.target ) && e.target != card.get(0) && !$.contains( card.get(0), e.target ) ){
				_hideCard();
				$( document ).off( 'click.' + elemID );
			}
		},

		/**
		 * Internal call to fetch content, build, position and show a hovercard
		 *
		 * @returns 	{void}
		 */
		_startShow = function () {

			if( card && card.length && _.isElement( card.get(0) ) ){
				_positionCard();
				working = false;
				return;
			}

			// Determine where content is coming from
			if( options.content && $( options.content ).length ) {
				_buildLocalContent();
				_buildCard();
				_positionCard();

				working = false;
			} else {
				_buildRemoteContent()
					.done( function () {
						_buildCard();
						_positionCard();
					})
					.fail( function () {})
					.always( function () {
						working = false;
					});
			}
		},

		/**
		 * Hides the hovercard
		 *
		 * @returns 	{void}
		 */
		_hideCard = function () {
			card[0].hidePopover();
		},

		/**
		 * Positions a hovercard relative to the target
		 *
		 * @returns {void}
		 */
		_positionCard = function () {

			if( !card.length ){
				Debug.warn("_positionCard called before a card element exists");
				return;
			}

			if( !target.is(':visible') ){
				Debug.info("Can't show hovercard when target isn't visible");
				return;
			}

			// Reset menu positioning
			card.css({
				left: 'auto',
				top: 'auto'
			});

			if( card.attr('data-originalWidth') ){
				card.css({
					width: card.attr('data-originalWidth') + 'px'
				});
			}

			// Figure out where we'll place it
			var elemPos = ips.utils.position.getElemPosition( target );
			var tooWide = false;
			var elemHeight = $( target ).height();
			var elemWidth = $( target ).width();
			var actualWidth = $( card ).width();
			var actualHeight = $( card ).height();
			var win = $( window );
			
			// Set up the data we'll use to position it
			var positionInfo = {
				trigger: elem,
				target: card,
				above: true,
				stemOffset: { left: 20, top: 0 }
			};

			var location = ips.utils.position.positionElem( positionInfo );

			// Position the hovercard with the resulting styles
			card.css({
				left: location.left + 'px',
				top: location.top + 'px'
			});

			var newElemPosition = ips.utils.position.getElemPosition( card );

			// If the menu is wider than the window, reset some styles
			if( ( actualWidth > $( document ).width() ) || newElemPosition.viewportOffset.left < -20 ){
				options.noStem = true;
				
				card
					.attr( 'data-originalWidth', actualWidth )
					.css({
						left: '10px',
						width: ( $( document ).width() - 20 ) + 'px'
					});

				var newLocation = ips.utils.position.positionElem( positionInfo );

				card.css({
					top: newLocation.top + 'px'
				});
			}

			// Remove old stems
			card.find('.ipsHovercard_stem').remove();

			_.each( ['Top', 'Bottom', 'Left', 'Right'], function (type) {
				card.removeClass( 'ipsHovercard_stem' + type );
			});

			// Build stem
			var stem = $('<span/>').addClass('ipsHovercard_stem');
			card
				.append( stem )
				.addClass( options.className + '_stem' + ( location.location.vertical.charAt(0).toUpperCase() + location.location.vertical.slice(1) ) );

			// If the card is a full-width size, we position the stem to the trigger.
			// Otherwise we just apply a classname
			if( tooWide ){
				stem.css({
					left: ( elemPos.viewportOffset.left - 10 ) + 'px'
				});
			} else {
				card.addClass( options.className + '_stem' + ( location.location.horizontal.charAt(0).toUpperCase() + location.location.horizontal.slice(1) ) );
			}		

			// And now animate in
			card[0].showPopover();
		},

		/**
		 * Builds the hovercard
		 *
		 * @returns 	{void}
		 */
		_buildCard = function () {

			var cardId = $( elem ).identify().attr('id') + '_hovercard',
				actualWidth = options.width || 300;

			// Build the card wrapper
			card = $('<div/>');

			card
				.attr("popover", "manual")
				.attr( { id: cardId } )
				.addClass( options.className )
				.css( {
					width: actualWidth + 'px'
				});

			if( _.isString( content ) ){
				card.append( $('<div/>').html( content ) );
			} else {
				card.append( content.show() );
			}

			// Append to container
			ips.getContainer().append( card );	

			// Watch event handlers
			if( !options.onClick ){
				card
					.on('mouseenter', _cardMouseOver)
					.on('mouseleave', _cardMouseOut);	
			}			

			// Let everyone know
			$( document ).trigger('contentChange', [ card ]);		
		},

		/**
		 * If this card is using local content, we build it here
		 *
		 * @returns 	{void}
		 */
		_buildLocalContent = function () {
			content = $( options.content );
		},

		/**
		 * Fetch remote content based on the target href
		 *
		 * @returns 	{promise}
		 */
		_buildRemoteContent = function () {

			var deferred = $.Deferred();

			if( !elem.href ){
				deferred.reject();
				return deferred.promise();
			}

			if( options.cache && ips.ui.hovercard.getCache( elem.href ) ){
				content = ips.ui.hovercard.getCache( elem.href );
				deferred.resolve();
				return deferred.promise();
			}

			// Show temporary loading thingy
			_buildLoadingWidget();

			// Get our ajax handler
			if ( options.target ) {
				var target = options.target;
			} else {
				var target = elem.href;
			}
			ajaxObj = ips.getAjax()( target )
				.done( function (response) {
					// Set our content
					content = response;
					// Let everyone know
					deferred.resolve();
					// Set a cache for this URL
					if( options.cache ){
						ips.ui.hovercard.setCache( target, content );
					}
				})
				.fail( function (jqXHR, status, errorThrown) {

					if( Debug.isEnabled() ){
						if( status != 'abort' ){
							Debug.error( "Ajax request failed (" + status + "): " + errorThrown );
						} else {
							Debug.warn("Ajax request aborted");
						}

						_removeLoadingWidget();
						deferred.reject();
					} else {
						if( status != 'abort' ){
							content = $('<div/>').addClass('i-padding_2 i-color_soft').html( ips.getString('errorLoadingContent') );
							deferred.resolve();
						} else {
							deferred.reject();
						}						
					}					
				})
				.always( function () {
					_removeLoadingWidget();
				});

			return deferred.promise();
		},

		/**
		 * Builds a little loading hovercard, before we replace it with the full card
		 *
		 * @returns 	{void}
		 */
		_buildLoadingWidget = function () {

			if( !options.showLoading ){
				return;
			}

			// Create loading dom node
			loading = $('<div/>').addClass('ipsHovercard_loading').html( ips.templates.render('core.hovercard.loading') );

			// Add it to our main container
			ips.getContainer().append( loading );

			// Get the dimensions of it
			var loadingDims = { width: loading.width(), height: loading.height() };

			// And hide it
			loading.hide();

			// Get the real position of our target
			var elemPos = ips.utils.position.getElemPosition( target ),
				dimsToUse = ( elemPos.fixed ) ? 'fixedPos' : 'absPos';

			loading.css( {
				left: elemPos[ dimsToUse ].left + 'px',
				top: ( elemPos[ dimsToUse ].top - loadingDims.height - 10 ) + 'px',
				position: ( elemPos.fixed ) ? 'fixed' : 'absolute',
				zIndex: "50000"
			});

			ips.utils.anim.go( 'fadeIn', loading );
		},

		/**
		 * Removes the loading hovercard
		 *
		 * @returns 	{promise}
		 */
		_removeLoadingWidget = function () {
			if( loading && loading.length ){
				loading.remove();
			}
		},

		/**
		 * Event handler for mouseout of the target
		 *
		 * @param 	{event} 	e 	The event object
		 * @returns {void}
		 */
		_mouseOut = function () {

			// Stop waiting for this
			clearTimeout( onTimeout );

			// Abort the Ajax request if necessary
			if( ajaxObj ){
				ajaxObj.abort();
			}

			// Remove the loading thingy if it exists
			_removeLoadingWidget();

			if( card && card.is(':visible') ){
				offTimeout = setTimeout( _hideCard, options.timeout * 1000 );
			}

			// Remove mouseout event
			$( elem ).off('.hovercard', _mouseOut);
		},

		/**
		 * Event handler for mouseover of the hovercard
		 *
		 * @param 	{event} 	e 	The event object
		 * @returns {void}
		 */
		_cardMouseOver = function () {
			clearTimeout( offTimeout );
		},

		/**
		 * Event handler for mouseout of the hovercard
		 *
		 * @returns 	{event} 	e 	The event object
		 * @returns 	{void}
		 */
		_cardMouseOut = function () {
			clearTimeout( offTimeout );
			offTimeout = setTimeout( _hideCard, options.timeout * 1000 );
		};

		init();

		return {
			init: init,
			destruct: destruct,
			start: start
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.iframelySizing.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Module to load iframely's embed.js script when there are iframely embeds on the page
 * @see https://iframely.com/docs/omit-script#load-when-required
 */
;(function($, _) {
	"use strict";

	ips.createModule('ips.ui.iframelySizing', function() {
		let loaded = false;
		/**
		 *
		 * @param {Element|undefined} [root]		The root to check for iframely embeds
		 */
		function loadIframelyAdHoc(root) {
			if (loaded) {
				return;
			}

			// Iframely allows custom CDNs for high tier packages. For now, I'm just making this a JS setting (e.g. can be set in the theme) but if it comes up we may want to add another setting to the ACP integrations page
			const iframelyCDN = ips.getSetting('iframely_custom_cdn') || "iframe.ly";
			if (!(root || document).querySelector(`[data-iframely-url], iframe[src*='${iframelyCDN}']`)) {
				return;
			}

			let iframely = window.iframely = window.iframely || {};
			loaded = true;

			if (iframely.load) {
				iframely.load();
			} else {
				ips.loader.get(["//cdn.iframe.ly/embed.js"])
					.then(() => {
						Debug.log('Iframely embed.js loaded.');
					});
			}
		}

		return {
			loadIframelyAdHoc,
			init() {
				loadIframelyAdHoc(document.body);
				if (!loaded) {
					const contentChange = (elem) => {
						$(elem).each(function() {
							if (this instanceof Element) {
								loadIframelyAdHoc(this);
							}
						});

						if (loaded) {
							$(document).off('contentChange', contentChange);
						}
					};
					$(document).on('contentChange', contentChange);
				}
			}
		}
	})
})(jQuery, _);]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.infiniteScroll.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.infiniteScroll.js - Infinite scrolling widget
 * Loads new content into the bottom of the container when the user approaches the bottom
 * Infinite scrolling can be a real usability problem if used in the wrong place. Please use responsibly ;)
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.infiniteScroll', function(){

		var defaults = {
			distance: 50,
			loadingTpl: 'core.infScroll.loading',
			scrollScope: window,
			pageParam: 'page',
			pageBreakTpl: 'core.infScroll.pageBreak',
			totalPages: null,
			disableIn: 'phone'
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_infinite') ){
				$( elem ).data('_infinite', infiniteScrollObj(elem, _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Retrieve the infinite scroll instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The dialog instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_infinite') ){
				return $( elem ).data('_infinite');
			}

			return undefined;
		};

		ips.ui.registerWidget( 'infScroll', ips.ui.infiniteScroll, [
			'container', 'scrollScope', 'distance', 'url', 'pageParam', 'loadingTpl',
			'pageBreakTpl', 'disableIn'
		] );

		/**
		 * Infinite scroll instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		var infiniteScrollObj = function (elem, options) {

			var state = 'ready',
				scrollScope = null,
				container = null,
				ajaxObj = null,
				currentPage = 1;

			/**
			 * Initializes this Infinite Scroll instance
			 *
			 * @returns 	{void}
			 */
			var init = function () {
				container = $( options.container );
				scrollScope = $( options.scrollScope );				
				scrollScope.on( 'scroll', _scrollEvent );

				options.disableIn = options.disableIn.split(',');

				if( _.isString( options.distance ) && options.distance.indexOf('%') !== -1 ){
					var percent = parseInt( options.distance );
					options.distance = ( scrollScope.height() / 100 ) * percent;
				}
				
				if ( options.totalPages == null ) {
					options.totalPages = _getTotalPages();
				}

				currentPage = _getStartPage();

				elem.on( 'refresh.infScroll', _refresh );
			},

			/**
			 * Refreshes the data the infScroll widget uses
			 *
			 * @returns 	{void}
			 */
			_refresh = function () {
				options.totalPages = _getTotalPages();
				currentPage = _getStartPage();

				try {
					ajaxObj.abort();
				} catch (err) {}
			},

			/**
			 * Event handler for scrolling in the scroll scope element
			 * If we're within the 'distance' value from the bottom, load more results into the container
			 * Won't do anything if we're finished or loading, though
			 * 
			 * @param 		{event}	 	e 		Event object
			 * @returns 	{void}
			 */
			_scrollEvent = function (e) {
					
				// Only be concerned if we are working in this device
				if( ips.utils.responsive.enabled() && _.indexOf( options.disableIn, ips.utils.responsive.getCurrentKey() ) !== -1 ){
					return;
				}

				if( state == 'loading' || state == 'done' ){
					return;
				}

				if( currentPage >= _getTotalPages() ){
					return;
				}

				var distanceFromBottom = _getDistance();
				
				if( distanceFromBottom <= options.distance ){
					state = 'loading';
					_loadMoreResults();
				}
			},

			/**
			 * Fetches more results to display 
			 *
			 * @returns 	{void}
			 */
			_loadMoreResults = function () {
							
				_showLoadingElem();

				if( ajaxObj && ajaxObj.abort ){
					ajaxObj.abort();
				}
				
				ajaxObj = ips.getAjax()( _getPageURL( currentPage + 1 ) )
					.done( function (response) {
						currentPage++;
						_insertNewResults( response );
						state = 'ready';
						$( elem ).trigger( 'infScrollPageLoaded', {
							page: currentPage
						});
					})
					.fail( function () {

					})
					.always( function () {
						_removeLoadingElem();
					});
			},

			/**
			 * Inserts new results into the container
			 * 
			 * @param 		{string}	 	response 		Response from ajax request
			 * @returns 	{void}
			 */
			_insertNewResults = function (response) {
				var output = '';

				if( options.pageBreakTpl ){
					output += ips.templates.render( options.pageBreakTpl, {
						page: currentPage
					});
				}

				output += response;

				// count how many children container *currently* has
				var oldChildLength = container.children().length;

				// append new results
				container.append( output );

				// Now trigger content change on only the new items
				container.children().slice( oldChildLength ).each( function (child) {
					$( document ).trigger( 'contentChange', [ $( this ) ] );
				});				
			},

			/**
			 * Appends the loading row to the container
			 *
			 * @returns 	{void}
			 */
			_showLoadingElem = function () {
				container.append( ips.templates.render( options.loadingTpl ) );
			},

			/**
			 * Removes the loading row from the container
			 *
			 * @returns 	{void}
			 */
			_removeLoadingElem = function () {
				container.find('[data-role="infScroll_loading"]').remove();
			},

			/**
			 * Works out the distance remaining in the scroll scope, in pixels
			 * Different logic is used depending on whether the scope is the body, or an overflow'd element
			 *
			 * @returns 	{void}
			 */
			_getDistance = function () {

				if( options.scrollScope == window ){
					var scrollHeight = $( document ).height();
					var distanceFromBottom = scrollHeight - $( window ).height() - $( window ).scrollTop();
				} else {
					var scrollHeight = scrollScope[0].scrollHeight;
					var distanceFromBottom = scrollHeight - scrollScope.height() - scrollScope.scrollTop();
				}

				return distanceFromBottom;
			},

			/**
			 * Builds a page url with the given page number
			 * 
			 * @param 		{number}	pageNo 		Page number
			 * @returns 	{string}	Query string
			 */
			_getPageURL = function (pageNo) {
				var url = elem.attr('data-ipsInfScroll-url');
				return url + ( url.match(/\?/) ? '&' : '?' ) + options.pageParam + '=' + parseInt( pageNo );
			},

			/**
			 * Returns the current/starting page number based on the currently-active item from pagination
			 * 
			 * @returns 	{number}
			 */
			_getStartPage = function () {
				var paginationElem = elem.find('.ipsPagination').first();

				if( !paginationElem.length ){
					return 1;
				}

				var activePage = paginationElem.find('.ipsPagination__active').attr('data-page');

				if( !activePage ){
					return 1;
				} else {
					return parseInt( activePage );
				}
			},

			/**
			 * Returns the total number of pages based on the value provided in the pagination HTML
			 * 
			 * @returns 	{number}
			 */
			_getTotalPages = function () {				
				var paginationElem = elem.find('.ipsPagination').first();

				if( !paginationElem.length ){
					return 1;
				}

				var totalPages = paginationElem.attr('data-pages');

				if( !totalPages ){
					return 1;
				} else {
					return parseInt( totalPages );
				}
			};

			init();

			return {
				init: init
			};
		};

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000349"><![CDATA[/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.js - UI widget parent
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui', function(){

		let widgets = {}, // Registry for our widgets
			doneInitialInit = false, // Have we done the initial DOM setup on page load yet?
			ziCounter = ips.getSetting('zindex_start') || 5000, // Counter for zIndex incrementing
			ziIncrement = ips.getSetting('zindex_inc') || 50; // Increment for zindex

		/**
		 * Symbol to represent a widget that has yet to be loaded
		 * @type {symbol}
		 */
		const COMPONENT_LAZY_LOAD_SYMBOL = Symbol('i-component-unloaded');

		/**
		 * Symbol to represent a widget that is a web component but should only load on a certain event
		 * @type {symbol}
		 */
		const COMPONENT_LAZY_LOAD_ON_EVENT_SYMBOL = Symbol('i-component-load-on-event');

		// Set some keycodes as 'constants'
		// Todo this is deprecated. If code is found referencing these, it should be replaced to just use e.key instead of e.keyCode. See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
		const key = {
			BACKSPACE: 8,
			ESCAPE: 27,
			TAB: 9,
			LEFT: 37,
			RIGHT: 39,
			UP: 38,
			DOWN: 40,
			ENTER: 13,
			COMMA: 188,
			SPACE: 32
		};

		const LOADING_COMPONENTS = new Set();
		/**
		 * Map of the widgetID to the web component name
		 * @type {Object<string, string|function():RangeError>}
		 */
		const WEB_COMPONENT_NAMES = {};
		/**
		 * @type {Object<string, string|function():RangeError>}
		 */
		const WEB_COMPONENT_NAMES_REVERSE = {};

		/**
		 * Register a widget module. Widget modules are for interface items, and work with
		 * a dataAPI that looks for data- options in HTML.
		 *
		 * @param	{string} 	widgetID 		The ID of this widget, which also forms its dataAPI key
		 * @param	{boolean|string[]|FunctionConstructor<HTMLElement>|(function():(Object|{respond:(function(elem:jQuery,options:array|null))}))}	handler				A handler that returns the widget constructor. If a boolean is provided, it indicates this widget is a Web Component, and will lazy-load then register the custom element as `i-${widgetID}`. Alternatively, if a class that extends HTMLElement is provided, it will be immediately registered as the custom element `i-${widgetID}`. Lastly, an array of strings can be passed as the events that should trigger the loading of the web component
		 * @param 	{array} 	[acceptedOptions]	Array of option keys that will be accepted by this widget
		 * @param 	{object}	[widgetOptions] 	Options to change the way this widget is registered/executed
		 * @param 	{function} 	[fnCallback]		The callback function when a widget is found on the page
		 * @returns {void}
		 */
		var	registerWidget = function (widgetID, handler, acceptedOptions, widgetOptions, fnCallback) {

			if( widgets[ widgetID ] ){
				Debug.warn( "'" + widgetID + "' is already registered as a widget. Skipping..."); // todo investigate whether this log really matters. It says "skipping" but then does not skip the process
			}

			if (typeof handler === 'boolean' || isElementConstructor(handler) || Array.isArray(handler)) {
				const name = webComponentName(widgetID);
				if (widgetID in widgets) {
					Debug.warn(new RangeError(`Cannot define a web component, <${name}/>, from the UI widget system because the widget ID ${widgetID} is already in use.`));
				} else {
					widgets[widgetID] = COMPONENT_LAZY_LOAD_SYMBOL;
					if (isElementConstructor(handler)) {
						if (customElements.get(name)) {
							Debug.warn(new RangeError(`Cannot define the web component <${name}/> because it is already registered.`));
							return;
						}
						customElements.define(name, handler);
						widgets[widgetID] = handler;
					} else if (Array.isArray(handler)) {
						widgets[widgetID] = COMPONENT_LAZY_LOAD_ON_EVENT_SYMBOL;
						const listener = e => {
							if (e.target instanceof HTMLElement && e.target.tagName?.toLowerCase() === name) {
								handler.forEach(eventType => document.removeEventListener(eventType, listener, {capture: true}));
								setTimeout(() => loadWebComponent(name));
							}
						}
						handler.forEach(eventType => document.addEventListener(eventType, listener, {capture: true}));
					} else if (handler) { // if handler === true, we register right away
						setTimeout(() => loadWebComponent(name))
					} else if (handler === false) { // add the ability to instantly load this component
						document.addEventListener(`ips:loadComponent#${widgetID}`, () => {
							if (widgets[widgetID] === COMPONENT_LAZY_LOAD_SYMBOL) {
								setTimeout(() => loadWebComponent(name));
							}
						}, {once: true, capture: true});
					}

					customElements.whenDefined(name)
						.then(() => {
							widgets[widgetID] = customElements.get(name);
							document.querySelectorAll(name).forEach(el => customElements.upgrade(el));
							Debug.log(`Registered the web component <${name}/>`)
						});
				}
				return;
			}

			widgetOptions = _.defaults( widgetOptions || {}, {
				'lazyLoad': false, // Whether to only init this widget when necessary
				'lazyEvents': '', // The event to watch for to trigger lazy init
				'makejQueryPlugin': true
			});

			widgets[ widgetID ] = { handler: handler, callback: fnCallback,
				acceptedOptions: acceptedOptions || [], widgetOptions: widgetOptions || {} };

			if( widgetOptions.makejQueryPlugin !== false ){
				buildjQueryPlugin( widgetID, handler, acceptedOptions, widgetOptions, fnCallback );
			}

			//Debug.info("Registered widget " + widgetID);
		},

		/**
		 * Returns an array of the options accepted for the given widget
		 *
		 * @param	{string} 	widgetId 		The ID of this widget, which also forms its dataAPI key
		 * @returns {array}
		 */
		getAcceptedOptions = function (widgetID) {
			return widgets[ widgetID ]['acceptedOptions'] || [];
		},

		/**
		 * Adds the provided widget as a jQuery plugin, enabling it to be instantiated programatically
		 * e.g. $('selector').ipsMenu({ options });
		 *
		 * @param	{string} 	widgetId 		The ID of this widget, which also forms its dataAPI key
		 * @param 	{array} 	acceptedOptions	Array of option keys that will be accepted by this widget
		 * @param 	{object}	widgetOptions 	Options to change the way this widget is registered/executed
		 * @param 	{function} 	fnCallback		The callback function when a widget is found on the page
		 * @returns {void}
		 */
		buildjQueryPlugin = function ( widgetID, handler, acceptedOptions, widgetOptions ) {

			const jQueryKey = widgetOptions.jQueryKey || 'ips' + widgetID.charAt(0).toUpperCase() + widgetID.slice(1),
				dataID = 'ips' + widgetID;

			if( $.fn[ jQueryKey ] ){
				Debug.warn("jQuery plugin '" + jQueryKey + "' already exists.");
				return;
			}

			$.fn[ jQueryKey ] = function (providedOptions) {

				this.each( function () {
					let elem = $( this );

					// This is code Rikki had in here, but the function removeExistingWidget() doesn't exist anywhere in the repo (do a project search, you'll see). Left it here commented out just in case
					// if( elem.attr( dataID ) ){
					// 	removeExistingWidget( widgetID, this );
					// }

					// Add the main widget attr
					elem.attr('data-' + dataID, '');

					// Add each option
					for (let [key, value] of Object.entries(providedOptions)) {
						if (acceptedOptions.includes(key)) {
							elem.attr(`data-${dataID}-${key}`, value);
						}
					}

					if( widgetOptions.lazyLoad === false ){
						_callWidget( widgetID, elem, _getWidgetOptions( widgetID, elem ) );
					}
				});

			};
		},

		/**
		 * Register a widget module. Widget modules are for interface items, and work with
		 * a dataAPI that looks for data- options in HTML.
		 *
		 * @param	{Element|Document} 	context 	The dom node that will be searched for widgets
		 * @param	{boolean} 	forceInit 	Force init widgets even if already initialized?
		 * @returns {void}
		 */
		_initializeWidgets = function (context /*, forceInit*/) {

			const immediateWidgets = [],
				lazyWidgets = [],
				componentWidgets = [];

			context = context instanceof Element ? context : document;

			// Get all the widgets we'll attempt to load now
			_.each( widgets, function (item, key) {
				if (item === COMPONENT_LAZY_LOAD_ON_EVENT_SYMBOL || isElementConstructor(item)) {
					return; // there's nothing we need to do when this is a web component and defined
				}

				if (item === COMPONENT_LAZY_LOAD_SYMBOL) {
					componentWidgets.push(key)
				} else if( _.isUndefined( item.widgetOptions.lazyLoad ) || item.widgetOptions.lazyLoad === false ){
					immediateWidgets.push( key );
				} else {
					lazyWidgets.push( key );
				}
			});

			_doImmediateWidgets( immediateWidgets, context );
			if (componentWidgets.length) {
				_doComponentWidgets(componentWidgets, context)
			}

			// Lazy widgets only get set up once since they use delegated events
			if( !doneInitialInit && context === document ){
				_doLazyWidgets( lazyWidgets, context );
				doneInitialInit = true;
			}
		},

		destructAllWidgets = function (context) {
			const widgetIDs = [...Object.entries(widgets)]
				.filter(([key, widget]) => !(widget === COMPONENT_LAZY_LOAD_SYMBOL || isElementConstructor(widget)))
				.map(([key]) => key);

			// Builds a selector that finds all of our widgets
			var selector = _.map( widgetIDs, function (item) {
				return "[data-ips" + item + "]";
			});

			// This is an expensive selector, so only do it once if possible.
			// We get all dom nodes that match any of our widgets, then we'll match them
			// up and fire off their respond methods
			var foundWidgets = $( context ).find( selector.join(',') );

			// Now we've found our widgets, we can set them up
			foundWidgets.each( function (idx, elem) {
				elem = $( elem );

				for( var i=0; i < widgetIDs.length; i++ ){
					if( !_.isUndefined( elem.attr( 'data-ips' + widgetIDs[i] ) ) ){
						_destructWidget( widgetIDs[i], elem );
					}
				}
			});
		},

		/**
		 * Calls the destruct method on a widget
		 *
		 * @param	{string} 	widgetID 	ID of the widget to destruct
		 * @param	{element} 	elem 		Element on which the widget exists
		 * @returns {void}
		 */
		_destructWidget = function (widgetID, elem) {
			if( _.isFunction( widgets[ widgetID ].handler.destruct ) ){
				try {
					widgets[ widgetID ].handler.destruct.call( widgets[ widgetID ].handler, elem );
				} catch (err) {
					Debug.error("Error calling destruct on " + widgetID );
					Debug.error( err );
				}
			}
		},

		/**
		 * Sets up immediately-initialized widgets
		 *
		 * @param	{array} 	widgetsToLoad 	Keys of those widgets to initialize immediately
		 * @param	{element} 	context 		The dom node that will be searched for widgets
		 * @returns {void}
		 */
		_doImmediateWidgets = function (widgetsToLoad, context) {

			if( !widgetsToLoad.length ){
				return;
			}

			// We'll create another var that this time contains the format needed for a css selector
			let selector = widgetsToLoad.map(item => "[data-ips" + item + "]");

			// This is an expensive selector, so only do it once if possible.
			// We get all dom nodes that match any of our widgets, then we'll match them
			// up and fire off their respond methods
			const foundWidgets = $( context ).find( selector.join(',') );

			// Now we've found our widgets, we can set them up
			for(let elem of foundWidgets) {
				elem = $(elem);

				for( var i=0; i < widgetsToLoad.length; i++ ){
					if( !_.isUndefined( elem.attr( 'data-ips' + widgetsToLoad[i] ) ) ){
						_callWidget( widgetsToLoad[i], elem, _getWidgetOptions( widgetsToLoad[i], elem ) );
					}
				}
			}
		},

		/**
		 * Sets up events for lazily-loaded widgets
		 *
		 * @param	{string[]} 	widgetsToLoad 	Keys of those widgets to initialize immediately
		 * @param	{Element} 	[context] 		The dom node that will be searched for widgets
		 * @returns {void}
		 */
		_doLazyWidgets = function (widgetsToLoad, context) {

			if( !widgetsToLoad.length ){
				return;
			}

			context = context instanceof Element ? context : document;

			for( let i=0; i < widgetsToLoad.length; i++ ){
				const widget = widgets[widgetsToLoad[i]];
				const lazyEvents = widget.widgetOptions.lazyEvents || 'click';

				$( context ).on( lazyEvents, "[data-ips" + widgetsToLoad[i] + "]", _.partial( function (widgetKey, e) {
					_callWidget( widgetKey, this, _getWidgetOptions( widgetKey, this ), e );
				}, widgetsToLoad[i] ) );
			}

		},


		/**
		 * Load web components if there are any
		 *
		 * @param	{string[]} 	widgetsToLoad 	Keys of those widgets to initialize immediately
		 * @param	{Element} 	[context] 		The dom node that will be searched for widgets
		 * @returns {void}
		 */
		_doComponentWidgets = function(widgetsToLoad, context) {
			context = $(context || document).get(0);
			widgetsToLoad.forEach(widgetID => {
				const widget = widgets[widgetID];
				if (widget !== COMPONENT_LAZY_LOAD_SYMBOL) {
					return;
				}
				try {
					const name = webComponentName(widgetID);
					if (context.querySelector(name)) {
						loadWebComponent(name);
					}
				} catch (e) {}
			})
		},

		/**
		 * Calls a widget callback. If a callback is provided, that will be called. If not, we look
		 * for a 'respond' method on the handler and call that instead.
		 *
		 * @param	{string} 	widgetID 	The ID of the widget being processed
		 * @param	{element} 	elem 		The element being passed through
		 * @params 	{object} 	options 	The widget options being passed through
		 * @params 	{event} 	e 			Event object that may be passed for lazy-load widgets
		 * @returns {void}
		 */
		_callWidget = function (widgetID, elem, options, e) {
			if (widgets[ widgetID ].callback instanceof Function) {
				widgets[ widgetID ].callback.call( widgets[ widgetID ].handler, elem, options, e );
			} else if (widgets[ widgetID ].handler.respond instanceof Function) {
				widgets[ widgetID ].handler.respond.call( widgets[ widgetID ].handler, elem, options, e );
			} else {
				Debug.error("No callback method specified for " + widgetID);
			}
		},

		/**
		 * Calls a widget callback. If a callback is provided, that will be called. If not, we look
		 * for a 'respond' method on the handler and call that instead.
		 *
		 * @param	{string} 	widgetID 	The ID of the widget being processed
		 * @param	{element} 	elem 		The element being passed through
		 * @params 	{object} 	options 	The widget options being passed through
		 * @returns {void}
		 */
		_getWidgetOptions = function (widgetID, elem) {

			var options = {},
				optionKeys = widgets[ widgetID ].acceptedOptions;

			elem = $( elem );

			// First let's see there's a full options object waiting for us
			try {
				if( elem.attr('data-ips' + widgetID + '-options') ){
					var optionsObj = $.parseJSON( elem.attr('data-ips' + widgetID + '-options') );

					if( _.isObject( optionsObj ) ){
						return optionsObj;
					}
				}
			} catch(err) {
				Debug.warn("Invalid options object passed in for a " + widgetID + " widget. Must be valid JSON.");
			}

			// Loop through each option this widget will accept in order to see whether
			// that option exists on this element.
			if( optionKeys.length ){
				for( var i=0; i < optionKeys.length; i++ ){
					var thisOption = elem.attr( 'data-ips' + widgetID + '-' + optionKeys[i] );

					if( !_.isUndefined( thisOption ) ){

						// Try and correct numbers
						if( thisOption.match(/^[1-9][0-9]*$/g) ){
							// Don't match numbers with leading zeros
							// We do this since parsing as an int will strip leading zeros. We'll assume that if a
							// leading zero exists, it's intentional, so skip this to treat it as a string instead.
							thisOption = parseInt( thisOption, 10 );
						}

						// And try and cast booleans
						if( thisOption === 'true' ){
							thisOption = true;
						} else if( thisOption === 'false' ){
							thisOption = false;
						}

						// If no value is supplied, treat it as true
						if( typeof thisOption === 'string' && thisOption.trim() === '' ){
							thisOption = true;
						}

						options[ optionKeys[i] ] = thisOption;
					}
				}
			}

			return options;
		},

		/**
		 * Returns the next zIndex value
		 *
		 * @returns 	{string}
		 */
		zIndex = function () {
			ziCounter += ziIncrement;

			if (document?.body?.style instanceof CSSStyleDeclaration) {
				document.body.style.setProperty('--ips-js-zindex-top', ziCounter.toString());
			}
			return ziCounter.toString();
		},

		/**
 		 * Returns the modal element, building it if necessary
		 *
		 * @returns 	{element}
		 */
		getModal = function () {

			return $('<div/>')
						.addClass( 'ipsModal' )
						.hide()
						.appendTo( $('body') )
						.identify();
		},

		/**
 		 * Initialize ips.ui
		 *
		 * @returns 	{void}
		 */
		init = function () {
			// Listen for content change
			$( document ).on('contentChange', function (e, newContent) {

				// Initialize widgets; if we're passed a jQuery collection, loop through each
				if( newContent instanceof jQuery ){
					newContent.each( function () {
						if( Debug.isEnabled ){
							Debug.info("contentChange event, reinitializing widgets in " + $( this ).identify().attr('id') );
						}
						_initializeWidgets( this );
					});
				} else {
					if( Debug.isEnabled ){
						Debug.info("contentChange event, reinitializing widgets in " + $( newContent ).identify().attr('id') );
					}
					_initializeWidgets( newContent );
				}
			});

			_initializeWidgets( document );

		};

		if (document?.body?.style instanceof CSSStyleDeclaration) {
			zIndex(); // this sets the initial css variable values
		} else {
			window.addEventListener('load', () => {
				zIndex();
			})
		}


		/**
		 * Base widget class that ui modules can use
		 */
		class BaseWidget {
			static _defaults = {};

			/**
			 * @type {WeakMap<Element, BaseWidget>}
			 */
			static instances = new WeakMap();

			/**
			 *
			 * @param {Element|jQuery}	elem
			 * @param {object}	options
			 */
			constructor(elem, options) {
				this.options = options;
				this.elem = $(elem);
			}

			_element = undefined;

			/**
			 * Get the Element instance (rather than a jQuery result)
			 *
			 * @return {Element}
			 */
			get element() {
				if (this._element === undefined) {
					this._element = this.elem.get(0);
				}
				return this._element;
			}

			/**
			 * "Setter" which really just warns the caller than the element is not an allowed field
			 */
			set element(val) {
				Debug.warn(`The field "element" is not settable`);
			}

			/**
			 * Destruct this object
			 */
			destruct() {
				// BaseWidget.instances.get(this.element)?.destroy(this);
				BaseWidget.instances.delete(this.element);
			}

			/**
			 * Reset this object. To be overridden ad-hoc
			 */
			reset() {

			}

			/**
			 * Do something using jquery's event system. The difference is that the function passed will preserve its 'this' value
			 *
			 * If the first argument is not a string, it is treated as the 'base' of the event - the thing the listener is actually attached to. It is not passed to $().on()
			 *
			 * @typedef {Node|jQuery|object|function}	_jq
			 * @param {([_jq, string, function(ev?:Event, data?:object)])|(string, function(ev?:Event, data?:object))|([_jq, string, string, function(ev?:Event, data?:object)])|([string, string, function(ev?:Event, data?:object)])}	args
			 */
			on(...args) {
				const cb = args.pop();
				if (!(cb instanceof Function)) {
					return;
				}

				let base = this.elem;
				if (typeof args[0] !== 'string') {
					base = $(args.shift());
				}

				base.on(...args, (...ev) => cb.call(this, ...ev))
			}

			/**
			 * TO be overridden. This is called before creating an instance to make sure the options are valid. The options are already applied to the defaults, so this would only be post-fixers such as splitting a delimited string into an array
			 *
			 * @param options
			 * @return {*}
			 */
			static fixOptions(options) {
				return options
			}

			/**
			 * Initialize on an element
			 * @param {Element|jQuery|*}	elem
			 * @param options
			 */
			static initializeOnElem(elem, options) {
				elem = elem instanceof Element ? elem : $(elem).get(0)
				if (!(elem instanceof Element)) {
					return;
				}

				if (!this.getInstance(elem)) {
					options = this.fixOptions({...this._defaults, ...options});
					const instance = new this(elem, options);
					this.instances.set(elem, instance);
				}
			}

			/**
			 * Get the instance associated with an element
			 *
			 * @param {jQuery|Element|*}	elem
			 *
			 * @return {undefined|BaseWidget}
			 */
			static getInstance(elem) {
				elem = elem instanceof Element ? elem : $(elem).get(0)
				if (elem && this.instances.has(elem)) {
					return this.instances.get(elem);
				}
				return undefined;
			}

			/**
			 * Register the ips ui module and get some basic methods that ips.ui.* modules use
			 *
			 * @param 	{string}				name				The ips.ui module's name. This is the key that is used in ips.ui; if it is not defined, the widget will not be registered, however make sure you manually register in this case
			 * @param	{string[]}				[options=[]]		The options
			 * @param   {object}    			[widgetOptions]    	Options to change the way this widget is registered/executed
			 * @param   {function}    			[fnCallback]        The callback function when a widget is found on the page
			 *
			 * @return {{destruct: function(Element|jQuery), getObj: (function(Element|jQuery): BaseWidget|undefined), reset: (function(Element|jQuery): *), respond: (function(jQuery|Element, object?):void), finalClass:*}}
			 */
			static buildModuleAndRegisterWidget(name, options=[], widgetOptions=undefined, fnCallback=undefined) {
				if (name) {
					ips.ui.registerWidget(name, ips.ui[name], options, widgetOptions, fnCallback);
				}

				return {
					respond: (elem, options) => this.initializeOnElem(elem, options),
					destruct: (elem) => this.getInstance(elem)?.destruct(),
					getObj: elem => this.getInstance(elem),
					reset: elem => this.getInstance(elem)?.reset(),
					finalClass: this
				}
			}
		}

		/**
		 * Check that a variable is a class/constructor that extends HTMLElement
		 * @param cls
		 * @return {boolean}
		 */
		function isElementConstructor(cls) {
			if (typeof cls !== 'function' || !cls.prototype) {
				return false
			}
			return HTMLElement.prototype.isPrototypeOf(cls.prototype);
		}

		/**
		 * Load a web component file from the server
		 *
		 * @param name
		 * @return {Promise<void>}
		 * @throws {RangeError}		Will throw a range error if the name is not a valid ips ui web component (e.g. /^i(-[a-z][a-z0-9])+$/i)
		 */
		async function loadWebComponent(name) {
			if (!LOADING_COMPONENTS.has(name)) {
				// convert the name up top to fail fast
				const widgetID = webComponentWidgetID(name);
				LOADING_COMPONENTS.add(name);
				let urlPath;

				// Compile the URL path depending on whether we're using compiled files
				if (ips.getSetting('useCompiledFiles') === false) {
					urlPath = "/applications/core/interface/js/webcomponents.php?component=" + widgetID;
				} else {
					urlPath = '/static/js/global/root_component_' + widgetID + ".js";
				}
				const url = window.ips.getSetting('baseURL').replace(/\/+$/, '') + urlPath + (urlPath.includes('?') ? '&' : '?') + 'v=' + ips.getSetting('jsAntiCache');
				const script = document.createElement('script');
				script.defer = true;
				script.src = url;
				script.dataset.ips = '';
				document.body.appendChild(script);
			}
			await customElements.whenDefined(name);
			LOADING_COMPONENTS.delete(name);
		}

		/**
		 * Register a web component
		 *
		 * @param {string} widgetID
		 * @param {CustomElementConstructor}	cls
		 *
		 * @throws RangeError
		 * @throws TypeError
		 */
		function registerWebComponent(widgetID, cls) {
			const name = webComponentName(widgetID);
			// is the constructor valid?
			if (!isElementConstructor(cls)) {
				throw new TypeError(`Cannot register web component because the provided cls is not a subclass of HTMLElement`);
			}

			// Is it already registered
			if (customElements.get(name)) {
				throw new RangeError(`The web component ${name} is already registered`);
			}

			// If it's not yet known as a widget, let's register so the system remembers it
			if (!(widgetID in widgets)) {
				Debug.log(`Registering the web component ${name}, however no widget is currently registered for this component. Registering the widget ${widgetID} now.`);
				registerWidget(widgetID, cls);
			} else {
				customElements.define(name, cls);
			}
		}


		/**
		 * Get or generate the Web Component name for a given widget
		 * @param {string} widgetID
		 * @return {string}
		 * @throws RangeError
		 */
		function webComponentName(widgetID) {
			if (!(widgetID in WEB_COMPONENT_NAMES)) {
				const name = 'i-' + widgetID.replaceAll(/[A-Z]/g, (match) => `-${match.toLowerCase()}`).replace(/^-+/, '');
				try {
					validateWebComponentName(name);
					WEB_COMPONENT_NAMES[widgetID] = name;
					WEB_COMPONENT_NAMES_REVERSE[name] = widgetID;
				} catch (e) {
					WEB_COMPONENT_NAMES[widgetID] = () => new RangeError(`The widgetID ${widgetID} converts to a disallowed Web Component name, ${name}`);
				}
			}

			return WEB_COMPONENT_NAMES[widgetID];
		}

		/**
		 * Get or generate the widgetID for a given web component's name
		 *
		 * @param {string} name
		 * @return {string}
		 * @throws RangeError
		 */
		function webComponentWidgetID(name) {
			if (!(name in WEB_COMPONENT_NAMES_REVERSE)) {
				try {
					validateWebComponentName(name);
					const widgetID = name.replace(/^i-/, '').replaceAll(/-([a-z])/g, (match, $1) => $1.toUpperCase());
					WEB_COMPONENT_NAMES[widgetID] = name;
					WEB_COMPONENT_NAMES_REVERSE[name] = widgetID;
				} catch (e) {
					WEB_COMPONENT_NAMES_REVERSE[name] = () => new RangeError(`${name} is not a valid web component name`);
				}
			}

			if (WEB_COMPONENT_NAMES_REVERSE[name] instanceof Function) {
				throw WEB_COMPONENT_NAMES_REVERSE[name]();
			}

			return WEB_COMPONENT_NAMES_REVERSE[name];
		}

		/**
		 * Validate the name of a web component
		 * @param name
		 * @throws RangeError
		 */
		function validateWebComponentName(name) {
			if (typeof name !== 'string' || !name.match(/^i-[a-z][a-z-0-9\-]*$/i)) {
				throw new RangeError(`${name} is not a valid web component name`);
			}
		}

		return {
			registerWidget,
			init,
			zIndex,
			getModal,
			getAcceptedOptions,
			key,
			destructAllWidgets,
			BaseWidget,
			registerWebComponent,
			loadWebComponent
		};
	});

}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.lightbox.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.lightbox.js - Lightbox component
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	/**
	 * @type {Object.<string, {width: number, height: number, solid: boolean}>}
	 */
	const imageDimCache = {};

	/**
	 * @type {Object.<string, Set.<Function>>}
	 */
	const imageResolveCache = {};

	ips.createModule('ips.ui.lightbox', function(){

		var defaults = {
			className: 'ipsLightbox',
			useEvents: false
		};

		var currentLightbox;

		var respond = function (elem, options, e) {
			options = _.defaults( options, defaults );
			currentLightbox = new lightboxObj( elem, options, e );
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			if( currentLightbox ){
				currentLightbox.destruct();
				currentLightbox = null;
			}
		};

		ips.ui.registerWidget('lightbox', ips.ui.lightbox, 
			[ 'group', 'commentsURL', 'className', 'preload', 'useEvents' ],
			{ lazyLoad: true, lazyEvents: 'click' }
		);

		return {
			respond: respond,
			destruct: destruct,

			/**
			 * Get the image dimensions for a given URL
			 *
			 * @param {string} url
			 * @return {Promise<{width: number, height: number, solid: boolean}>}
			 */
			getImageDimensions(url) {
				return new Promise(resolve => {
					if (url in imageDimCache) {
						resolve(imageDimCache[url])
					} else if (url in imageResolveCache) {
						imageResolveCache[url].add(resolve)
					} else {
						imageResolveCache[url] = new Set();
						imageResolveCache[url].add(resolve)
						const img = document.createElement('img')
						let timeout;
						const loaded = () => {
							img.removeEventListener('load', loaded)
							img.removeEventListener('error', loaded)
							clearTimeout(timeout)

							const dims = {
								width: img.naturalWidth,
								height: img.naturalHeight,
								solid: !!(img.naturalWidth && img.naturalHeight)
							}

							img.remove()
							imageDimCache[url] = dims
							setTimeout(() => delete imageDimCache[url], 300000); // clear that cache after 5 minutes
							imageResolveCache[url].forEach(cb => cb(dims))
							imageResolveCache[url].clear()
							delete imageResolveCache[url]
						}

						timeout = setTimeout(loaded, 5000)
						img.addEventListener('load', loaded)
						img.addEventListener('error', loaded)
						img.src = url
					}
				})
			}
		};
	});


	/**
	 * Lightbox instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var lightboxObj = function (elem, options, e) {
		
		if( e ){
			e.preventDefault();
		}

		var imageCollection = [],
			commentsAjax,
			modal, 
			pieces, 
			currentImage,
			phoneBreakpoint = false;

		/**
		 * Kick off showing the lightbox
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			// Blur the trigger
			elem.blur();
			
			_getAllImages();
			_buildModal();
			_buildWrapper();
			_setUpEvents();
			_show();
			_loadFirstImage();
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function () {
			$( document ).off( 'keydown', _keyPress );
			modal.off( 'click', close );
		},

		/**
		 * Sets up the events we'll need to watch for, on the modal, lightbox and doc
		 *
		 * @returns 	{void}
		 */
		_setUpEvents = function () {

			// Lightbox events
			pieces.lightbox
				.on( 'click', '.' + options.className + '_next', nextImage )
				.on( 'click', '.' + options.className + '_prev', prevImage )
				.on( 'click', '.' + options.className + '_close', close )
				.on( 'click', clickedLightbox )
				.on( 'click', '[data-action="rotateImage"]', _rotateImage );

			// Modal events
			modal.on( 'click', close );

			// Document key events
			$( document ).on( 'keydown', _keyPress );

			// Monitor for content changes that we might need to act on
			$( document ).on( 'imageUpdated', _updateImage );
			$( document ).on( 'imageLoading', _mainImageLoading );

			// If we are using events for managing the lightbox, listen for those events
			if( options.useEvents ){
				$( document ).on( 'lightboxDisable_next', function() {
					$('.' + options.className + '_next').hide();
				});

				$( document ).on( 'lightboxDisable_prev', function() {
					$('.' + options.className + '_prev').hide();
				});

				$( document ).on( 'lightboxEnable_next', function() {
					$('.' + options.className + '_next').show();
				});

				$( document ).on( 'lightboxEnable_prev', function() {
					$('.' + options.className + '_prev').show();
				});
			}
		},

		/**
		 * Image needs to be updated event
		 *
		 * @returns 	{void}
		 */
		_mainImageLoading = function( e ) {
			_setLoading( true );

			pieces.imagePanel
				.find('.' + options.className + '_image ')
					.hide();
		},

		/**
		 * Image needs to be updated event
		 *
		 * @returns 	{void}
		 */
		_updateImage = function( e, data ) {
			if( data.closeLightbox === true )
			{
				close(e);
			}
			else if( data.updateImage )
			{
				_showImage( data.updateImage );
			}
		},

		/**
		 * Handles a keydown event
		 *
		 * @returns 	{void}
		 */
		_keyPress = function (e) {
			if( !pieces.lightbox.is(':visible') ){
				return;
			}

			switch( e.keyCode ){
				case ips.ui.key.ESCAPE:
					close(e);
				break;
				case ips.ui.key.RIGHT:
					nextImage(e);
				break;
				case ips.ui.key.LEFT:
					prevImage(e);
				break;
			}
		},

		/**
		 * Retrieves the image that was clicked from imageCollection, then passes it to showImage
		 *
		 * @returns 	{void}
		 */
		_loadFirstImage = function () {
			// Find the image that was clicked
			var firstImage = function () {
				for( var i = 0; i < imageCollection.length; i++ ){
					if( imageCollection[ i ].elem == elem ){
						return imageCollection[ i ];		
					}
				}
			}();

			currentImage = firstImage;
			_showImage( firstImage );
		},

		/**
		 * Handles the process of showing a new image, including loading the image and comments,
		 * determining whether next/prev should show, updating meta data
		 *
		 * @param	{object} 	image 		The image data object from imageCollection, for this image
		 * @returns {void}
		 */
		_showImage = function (image) {
			_setLoading( true );

			pieces.imagePanel
				.find('.' + options.className + '_image ')
					.hide();

			if( image.imageElem ){

				// Hide all images
				pieces.imagePanel.find('.' + options.className + '_image ').hide()

				// Show this image, then hand it off to the event handler
				var thisImage = image.imageElem.css( { opacity: "0" } ).show();

				_imageLoaded( thisImage );
			} else {	

				// New image, so build it and set the event handler
				var thisImage = image.imageElem = $('<img/>')
										.attr( 'src', image.largeImage )
										.addClass( options.className + '_image' )
										.css( { opacity: "0" } )
										.imagesLoaded( function (imagesLoaded){
											try {
												_imageLoaded( $( imagesLoaded.images[0].img ) );
											} catch(err) {
												Debug.error("Error loading image");
											}
										});

				if ( ! _.isUndefined( $(image.elem).attr('data-fileId') ) ) {
					thisImage.attr( 'data-fileId', $(image.elem).attr('data-fileId') );
				}
				
				// Hide all images, and append this new one
				pieces.imagePanel
					.find('.' + options.className + '_image ')
						.hide()
					.end()
					.append(
						thisImage
					);
			}

			// rotate the image if we need to
			var rotatedImage = $( '.ipsAttachLink_image img[data-rotate][data-fileId=\'' + thisImage.attr( 'data-fileId' ) + '\']' );
			if ( rotatedImage.length ){
				thisImage.attr( 'data-rotate', $( rotatedImage ).attr( 'data-rotate' ) );
				_applyRotation( thisImage, $( rotatedImage ).attr( 'data-rotate' ) );
			}
			
			// Full size link
			pieces.fullSize.attr( 'href', image.largeImage );

			// Handle comments
			if( image.commentsURL ){
				_loadComments( image );
			} else {
				_hideCommentsPanel();
			}

			// Build meta info
			if( image.meta ){
				pieces.metaPanel
					.show()
					.html( ips.templates.render('core.lightbox.meta', { title: image.meta } ) );
			} else {
				pieces.metaPanel.hide();
			}

			$( elem ).trigger( 'lightboxImageShown', {
				image: image,
				triggerElem: elem
			});
		},

		/**
		 * Loads remote comments into the lightbox
		 *
		 * @param	{object} 	image 		The image data object from imageCollection, for this image
		 * @returns {void}
		 */
		_loadComments = function (image) {

			// Abort anything running already
			if( commentsAjax ){
				Debug.warn("Aborting comment load");
				commentsAjax.abort();
			}

			// Get new ajax object
			pieces.commentsPanel
				.html('')
				.show()
				.addClass( 'ipsLoading' );

			pieces.imagePanel
				.addClass( options.className + '_withComments' );

			commentsAjax = ips.getAjax()( image.commentsURL )
				.done( function (response){
					pieces.commentsPanel
						.html( response )
						.removeClass( 'ipsLoading' );

					$( document ).trigger('contentChange', [ pieces.commentsPanel ]);

					$( elem ).trigger( 'lightboxCommentsLoaded', {
						image: image,
						triggerElem: elem,
						commentsArea: pieces.commentsPanel
					});
				});
		},

		/**
		 * Hides the comments panel
		 *
		 * @returns 	{void}
		 */
		_hideCommentsPanel = function () {
			pieces.commentsPanel.hide();
			pieces.imagePanel.removeClass( options.className + '_withComments' );
		},

		/**
		 * Shows and hides the loading widget on the lightbox
		 *
		 * @param	{boolean} 	status 		True to show, false to hide
		 * @returns {void}
		 */
		_setLoading = function (status) {
			if( status === true ){
				pieces.imagePanel.addClass( 'ipsLoading' );
			} else {
				pieces.imagePanel.removeClass( 'ipsLoading' );

				$( '.' + options.className + '_imagePanel > img, .' + options.className + '_fullSize' )
					.on( 'mouseover', function(){ $( '.' + options.className + '_fullSize' ).show(); } )
					.on( 'mouseout', function(){ $( '.' + options.className + '_fullSize' ).hide(); } );
			}
		},

		/**
		 * Event handler fired when an image has finished loading
		 *
		 * @param	{array} 	image 		Image that has loaded
		 * @returns {void}
		 */
		_imageLoaded = function (image) {
			image.css( { opacity: "1" } );
			_setLoading( false );
			_setButtons( image );
			
			// If we are using events, we can return now and let the events handle the rest
			if( options.useEvents )	{
				return;
			}

			// Toggle the navigation buttons as needed
			if( imageCollection.length < 2 ){
				pieces.next.hide();
				pieces.prev.hide();
			} else {
				var curPos = _.indexOf( imageCollection, currentImage );

				pieces.next.show();
				pieces.prev.show();

				if( curPos == 0 ){
					pieces.prev.hide();	
				}

				if( curPos == ( imageCollection.length - 1 ) ){
					pieces.next.hide();
				}
			}
		},
		
		/**
		 * Adds any image buttons needed
		 *
		 * @param	{object} 	image 		The image data object from imageCollection
		 * @returns {void}
		 */
		_setButtons = function (image) {
			if( !_.isUndefined( image.attr( 'data-fileId' ) ) ){
				/*$( '.' + options.className + '_toolsPanel' ).html(
					ips.templates.render('core.lightbox.toolsMenu', {
						url: ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=attachments&do=rotate&id=' + image.attr('data-fileId')
					} )
				).show();*/

				// Inform the document
				$( document ).trigger( 'contentChange', [ $( '.' + options.className ) ] );
			}
		},

		/**
		 * A click on the lightbox
		 *
		 * @param	{event} 	e 		The event object
		 * @returns {void}
		 */
		clickedLightbox = function (e) {
			// Don't fire if we're inside an <a>
			if( $( e.target ).closest('a').length ){
				return;
			}

			// Get window width
			var width = $( document ).width();
			var halfPos = width / 2;

			// If we're clicking the right side of the screen, go forwards.
			// If we're clicking the left side of the screen, go backwards.
			// Otherwise, close the lightbox.
			if( e.pageX >= halfPos && pieces.next.is(':visible') ){
				pieces.next.click();
			} else if( e.pageX < halfPos && pieces.prev.is(':visible') ){
				pieces.prev.click();
			} else {
				close();
			}
		},

		/**
		 * Retrieves the next image and shows it
		 *
		 * @param	{event} 	e 		The event object
		 * @returns {void}
		 */
		nextImage = function (e) {
			e.preventDefault();
			e.stopPropagation();

			// If we are using events, we can return now and let the events handle the rest
			if( options.useEvents )
			{
				$( document ).trigger( 'lightboxNextImage' );
				return;
			}

			currentImage = _getNextImage();
			_showImage( currentImage );
		},

		/**
		 * Retrieves the previous image and shows it
		 *
		 * @param	{event} 	e 		The event object
		 * @returns {void}
		 */
		prevImage = function (e) {
			e.preventDefault();
			e.stopPropagation();

			if( options.useEvents )
			{
				$( document ).trigger( 'lightboxPrevImage' );
				return;
			}

			currentImage = _getPrevImage();
			_showImage( currentImage );
		},

		/**
		 * Returns the previous image from imageCollection
		 *
		 * @param	{event} 	e 		The event handler
		 * @returns {object} 	The previous image object
		 */
		_getPrevImage = function (e) {
			var curPos = _.indexOf( imageCollection, currentImage );

			if( curPos === 0 ){
				return imageCollection[ imageCollection.length - 1 ];
			}

			return imageCollection[ curPos - 1 ];
		},

		/**
		 * Returns the next image from imageCollection
		 *
		 * @param	{event} 	e 		The event handler
		 * @returns {object} 	The next image object
		 */
		_getNextImage = function () {
			var curPos = _.indexOf( imageCollection, currentImage );

			if( curPos == ( imageCollection.length - 1 ) ){
				return imageCollection[0];
			}

			return imageCollection[ curPos + 1 ];	
		},

		/**
		 * Rotates the image
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		_rotateImage = function (e) {
			e.preventDefault();

			var visibleImage = $( 'img.ipsLightbox_image:visible' );
			var url = $( e.currentTarget ).attr('href') + '&current=' + $( visibleImage ).attr( 'data-rotate' );

			ips.getAjax()( url, {
				showLoading: true
			} )
				.done( function (response) {

					/* Images on the page */
					$('img[data-fileId="' + response.fileId + '"]').each( function() {
						$( visibleImage ).attr( 'data-rotate', response.rotate );
						_applyRotation( this, response.rotate );

						/* Only trigger the imageRotated event if we permanently stored the rotation angle */
						if( response.saved == 1 ){
							$( document ).trigger( 'imageRotated', response );
						}
					} );
										
					ips.ui.flashMsg.show( response.message );
				})
				.fail( function () {
					window.location = url;
				});
		},

		/**
		 * Apply the transformation CSS to rotate the image properly
		 *
		 * @param	{object}	elem
		 * @param 	{string}	angle
		 * @returns	{void}
		 */
		_applyRotation = function( elem, angle ){
			$(elem).css( { 'transform': 'rotate(' + angle + 'deg)' } );

			/* If we are rotating the image on its side, adjust the width so that it fits in the panel */
			if( angle == '90' || angle == '-90' ) {
				var panelHeight = $( elem ).parents( '.ipsLightbox_imagePanel' ).height();
				$( elem ).css( {
					'max-width': ( panelHeight - 20 ).toString() + 'px'
				});
			}
		},

		/**
		 * Closes the lightbox
		 *
		 * @param	{event} 	e 		The event handler
		 * @returns {void}
		 */
		close = function (e) {
			if( e ){
				e.preventDefault();
				e.stopPropagation();	
			}
			
			$( document ).off( 'imageUpdated', _updateImage );
			$( document ).off( 'imageLoading', _mainImageLoading );

			modal.hide();
			pieces.lightbox.hide();
		},

		/**
		 * Displays the lightbox on-screen
		 *
		 * @returns 	{void}
		 */
		_show = function () {
			ips.utils.anim.go( 'fadeIn fast', modal );
			ips.utils.anim.go( 'fadeIn fast', pieces.lightbox );
			//pieces.lightbox.show();
		},

		/**
		 * Builds the lightbox UI
		 *
		 * @returns 	{void}
		 */
		_buildWrapper = function () {

			// Build pieces
			pieces = {
				lightbox: $('<div/>')
					.addClass( options.className )
					.css( { zIndex: ips.ui.zIndex() } ),

				imagePanel: $('<div/>')
					.addClass( options.className + '_imagePanel' ),

				commentsPanel: $('<div/>')
					.addClass( options.className + '_commentsPanel' )
					.html('')
					.hide(),
				
				toolsPanel: $('<div/>')
					.addClass( options.className + '_toolsPanel' )
					.html('')
					.hide(),
				
				next: $('<a/>')
					.addClass( options.className + '_next' )
					.html("<i class='fa-solid fa-angle-right'></i>"),

				prev: $('<a/>')
					.addClass( options.className + '_prev' )
					.html("<i class='fa-solid fa-angle-left'></i>"),

				close: $('<a/>')
					.addClass( options.className + '_close' )
					.html("&times;"),

				fullSize: $('<a/>')
					.attr( 'href', '#' )
					.attr( 'target', '_blank' )
					.addClass( options.className + '_fullSize' ),

				metaPanel: $('<div/>')
					.addClass( options.className + '_meta' )
					.hide()
			};

			// Assemble
			pieces.lightbox
				.append( 
					pieces.imagePanel
						.append( pieces.next )
						.append( pieces.prev )
						.append( pieces.fullSize )
						
				)
				.append( pieces.metaPanel )
				.append( pieces.commentsPanel )
				.append( pieces.toolsPanel )
				.append( pieces.close );

			$('body').append( pieces.lightbox );
		},

		/**
		 * Populates imageCollection with the images grouped with this lightbox
		 *
		 * @returns 	{void}
		 */
		_getAllImages = function () {
			
			if( options.group ){
				var images = $('[data-ipslightbox-group="' + options.group + '"]');
			} else {
				var images = $( elem );
			}

			$.each( images, function (i, thisElem) {
				imageCollection.push( _returnImageData( thisElem ) );
			});
		},

		/**
		 * Returns image data for the provided element
		 *
		 * @param	{element} 	thisElem 		The element being worked with
		 * @returns {object} 	Image data
		 */
		_returnImageData = function (thisElem) {

			var origImage,
				largeImage;

			if( thisElem.tagName != 'IMG' ){
				origImage = $( thisElem ).find('img').attr('src');
			} else {
				origImage = $( thisElem ).attr('src');
			}

			if( $( thisElem ).attr('data-fullURL') ){
				largeImage = $( thisElem ).attr('data-fullURL');
			} else if( $(thisElem).is(':is(a, i-lightbox)') && $( thisElem ).attr('href') ){
				largeImage = $( thisElem ).attr('href');
			}

			return {
				elem: thisElem,
				originalImage: origImage,
				largeImage: largeImage || origImage,
				meta: $( thisElem ).attr('data-ipsLightbox-meta'),
				commentsURL: $( thisElem ).attr('data-ipsLightbox-commentsURL')
			};
		},

		/**
		 * Gets the modal element from ips.ui, and sets a new zIndex on it
		 *
		 * @returns 	{void}
		 */
		_buildModal = function () {
			modal = ips.ui.getModal();
			modal.css( { zIndex: ips.ui.zIndex() } );
		};

		init();

		return {
			destruct: destruct
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.map.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.map.js - Interactive Map
 *
 * Author: Matt Finger
 */
;( function($, _){

	ips.createModule('ips.ui.map', function(){

		/**
		 * @typedef {{contentUrl?: null, maxZoom?: number, zoom?: number, markers?: string}} MapOptions
		 */

		/**
		 * @type {MapOptions}
		 */
		const defaults = {
			zoom: 2,
			maxZoom: 16,
			markers: '[]',
			contentUrl: null
		};

		/**
		 * Handle Mapbox
		 *
		 * @param {jQuery}		elem
		 * @param {MapOptions}	options
		 *
		 * @returns {void}
		 */
		function _mapbox (elem, options) {
			$('head').append( "<link rel='stylesheet' type='text/css' media='all' href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css'><link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v1.0.0/MarkerCluster.css' rel='stylesheet' /><link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v1.0.0/MarkerCluster.Default.css' rel='stylesheet' />" );

			/**
			 * Handle popup events
			 * @param {Event} e
			 */
			function handlePopup(e) {
				const popup = e.target.getPopup();
				const clubID = e.target.options.clubID;

				ips.getAjax()( options.contentUrl + clubID )
					.done(response => {
						popup.setContent( response );
						popup.update();
					});
			}

			ips.loader.get( [ 'https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js' ] ).then( function () {
				ips.loader.get( [ 'https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v1.0.0/leaflet.markercluster.js' ] ).then(function () {
					L.mapbox.accessToken = ips.getSetting('mapApiKey');
					const map = L.mapbox
						.map(elem.get(0))
						.setView([45, 0], options.zoom)
						.addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/streets-v11'));

					const cluster = new L.MarkerClusterGroup();
					map.addLayer( cluster );

					const markers = $.parseJSON(options.markers);
					for (const id in markers) {
						const marker = L.marker([markers[id].lat, markers[id].long], {
							icon: L.mapbox.marker.icon({
								'marker-color': '#0000ff'
							}),
							clubID: id,
							title: markers[id].title,
							draggable: false
						});

						cluster.addLayer( marker );

						// Build info popup for this marker
						if (options.contentUrl) {
							marker.bindPopup(ips.getString('loading'));
							marker.on('click', handlePopup );
						}
					}

					// Center on markers
					map.fitBounds(cluster.getBounds().pad(0.5));
				});
			});
		}

		/**
		 * Handle google maps
		 *
		 * @param {jQuery}	elem
		 * @param {MapOptions}	options
		 *
		 * @returns {void}
		 */
		function _google(elem, options) {
			ips.ui.map.afterGoogleMapsLoaded(() => {
				const mapOptions = {
					zoom: options.zoom,
					maxZoom: options.maxZoom,
					scrollwheel: false
				};
				if ( options.zoom ) {
					mapOptions.center = { lat: 45, lng: 0 };
				} else {
					mapOptions.center = { lat: 30, lng: 0 };
				}

				const map = new google.maps.Map(elem.get(0), mapOptions);
				const bounds = new google.maps.LatLngBounds();

				const infowindow = new google.maps.InfoWindow({
					content: ips.getString('loading')
				});

				const markers = $.parseJSON(options.markers);
				for (const id in markers ) {

					const marker = new google.maps.Marker({
						position: {lat: markers[id].lat, lng: markers[id].long},
						map: map,
						title: markers[id].title,
						id: id
					});

					if ( options.contentUrl ) {
						marker.addListener('click', function() {

							infowindow.setContent( ips.getString('loading') )
							infowindow.open(map,this);

							ips.getAjax()( options.contentUrl + this.id ).done(function(response){
								infowindow.setContent( response );
							});

						});
					}

					// Increase bounds to include this marker
					bounds.extend(marker.position);
				}

				//Center on markers
				map.fitBounds(bounds);
			})
		}

		/**
		 *
		 * @type {'unloaded'|'loaded'|'loading'}
		 */
		let googleMapsState = 'unloaded';

		/**
		 * @type {Set<function>}
		 */
		const googleMapsCallbacksQueue = new Set();

		ips.ui.registerWidget('map', ips.ui.map, [ 'zoom', 'maxZoom', 'markers', 'contentUrl' ] );

		return {

			/**
			 * Respond to a map widget
			 *
			 * @param    {jQuery}    elem        The element this widget is being created on
			 * @param    {MapOptions}    options    The options passed into this instance
			 *
			 * @returns {void}
			 */
			respond(elem, options) {
				options = {
					...defaults,
					...options
				}

				const generator = {google: _google, mapbox: _mapbox}[ips.getSetting('mapProvider')]

				if (ips.getSetting('lazyLoadEnabled')) {
					ips.utils.lazyLoad.observe(elem, {
						loadCallback() {
							generator?.(elem, options)
						}
					});
				} else {
					generator?.(elem, options)
				}
			},

			/**
			 * Call the callback after Google Maps api is loaded. If it's already loaded it will be called immediately
			 *
			 * @param {function} cb
			 */
			afterGoogleMapsLoaded(cb) {
				if (!(cb instanceof Function) || googleMapsCallbacksQueue.has(cb)) {
					return;
				}

				if (googleMapsState === 'loaded') {
					cb();
				}
				googleMapsCallbacksQueue.add(cb)

				if (googleMapsState === 'unloaded') {
					googleMapsState = 'loading'
					ips.loader.get( [ 'https://maps.googleapis.com/maps/api/js?key=' + ips.getSetting('mapApiKey') + '&libraries=places&sensor=false&loading=async' ] )
						.then(() => {
							googleMapsState = 'loaded'
							for (const queuedCallback of googleMapsCallbacksQueue) {
								queuedCallback();
							}
						})
				}
			}
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.menu.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.menu.js - Menu component
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){

	ips.createModule('ips.ui.menu', function(){

		var defaults = {
			className: 'ipsMenu',
			activeClass: '',
			closeOnClick: true,
			closeOnBlur: true,
			selectable: false,
			withStem: true,
			stemOffset: 16, // half the stem width
			stopLinks: false,
			above: 'auto'
		};

		var stems = ['topLeft', 'topRight', 'topCenter', 'bottomLeft', 'bottomRight', 'bottomCenter'];

		if( !defaults.withStem ){
			defaults.stemOffset = 0;
		}

		var _menuRegistry = {};

		/**
		 * Respond to a menu trigger being clicked
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object
		 * @returns {void}
		 */
		var respond = function (elem, options, e) {
			e.preventDefault();

			var elemID = $( elem ).identify().attr('id'),
				options = _.defaults( options, defaults );

			if( $( elem ).attr('data-disabled') || $( elem ).is(':disabled') ){
				return;
			}

			if( !$( elem ).data('_menuBody') ){
				var menu = _getMenu(elem, elemID, options);
				$( elem ).data('_menuBody', menu);
			} else {
				var menu = $( elem ).data('_menuBody');
			}

			if( !menu.length ){
				Debug.warn( "Couldn't find or build a menu for " + elemID );
				return;
			}

			$( window ).on( 'resize', function (e) {
				if( menu.is(':visible') ){
					menu.hide();
					_positionMenu( elem, elemID, options, menu, true );
					menu.show();
				} 				
			});

			// Show or hide the menu depending on visibility
			if( !menu.is(':visible') ){
				_showMenu( elem, elemID, options, menu, e );
			} else {
				_hideMenu( elem, elemID, options, menu, false );
			}
		},

		/**
		 * Shows the menu, and sets necessary events
		 *
		 * @param	{element} 	elem 		The element this widget belongs to
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{element} 	menu 		The menu itself
		 * @param	{event} 	e 			The original event
		 * @returns {void}
		 */
		_showMenu = function ( elem, elemID, options, menu, e ) {
			if( options.closeOnBlur ){
				$( document ).on('click.' + elemID, _.partial( _closeOnBlur, elem, menu ) );
			}

			$( menu )
				.on( 'closeMenu', _.partial( _hideMenu, elem, elemID, options, menu ) )
				.on( 'mouseenter', '.ipsMenu_subItems', _.bind( _showSubMenu, this, elem, elemID, options, menu ) );
				

			$( elem ).on( 'closeMenu', _.partial( _hideMenu, elem, elemID, options, menu, false ) ); 

			menu.get(0).style.opacity = 0;
			menu.show();

			// Move it into place
			_positionMenu( elem, elemID, options, menu );

			menu.get(0).style.opacity = '';

			// Add active class to trigger
			$( elem ).addClass( options.activeClass );
			$( elem ).trigger('menuOpened', {
				elemID,
				originalEvent: e,
				menu
			});
			// in the transition to native events for v5, we also dispatch a native event
			$(elem).each((i, el) => {
				$(el).get(0)?.dispatchEvent(new MenuOpenedEvent(elemID, e, menu))
			})
		},

		/**
		 * Shows a submenu
		 *
		 * @param	{element} 	elem 		The element this widget belongs to
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{element} 	menu 		The menu itself
		 * @param	{event} 	e 			The original event
		 * @returns {void}
		 */
		_showSubMenu = function ( elem, elemID, options, menu, e ) {
			var menuItem = $( e.currentTarget ).find('> a');
			var subMenu = menuItem.next('.ipsMenu');

			// Set the mouseleave event on this item
			$( e.currentTarget ).on( 'mouseleave', _.bind( _hideSubMenu, this, elem, elemID, options, menu ) );

			// Try and position the menu
			var itemPosition = ips.utils.position.getElemPosition( menuItem );
			var itemSize = ips.utils.position.getElemDims( menuItem );
			var subMenuSize = ips.utils.position.getElemDims( subMenu );
			
			// If we're in RTL, we should open to the left #attentionToDetail
			if( $('html').attr('dir') == 'rtl' ) {
				
				var left = ( itemSize.outerWidth - 5 );
				var top = menuItem.position()['top'] - 5;

				// If the submenu won't fit to the left of the item...
				if( ( itemPosition.viewportOffset.left - subMenuSize.outerWidth - 5 ) < 0 ){
					// ... See if it will fit to the right of the item...
					if( ( itemPosition.viewportOffset.right + 5 + subMenuSize.outerWidth ) <= $( window ).width() ){
						left = ( itemSize.outerWidth + 5 );
					} else {
						// ... but if not, position it *under* the item.
						// Since the submenu is pos relative to the parent item, we need to subtract the parent item pos from the ideal left pos
						left = 15 - itemPosition.absPos.left; 
						top = menuItem.position()['top'] + itemSize.height + 15;
					}
				}
	
				subMenu
					.css({
						left: left + 'px',
						top: top + 'px'
					})
					.show();
				
			} else {
							
				var left = ( itemSize.outerWidth - 5 );
				var top = menuItem.position()['top'] - 5;
	
				// If the submenu won't fit to the right of the item...
				if( ( itemPosition.viewportOffset.left + itemSize.outerWidth + subMenuSize.outerWidth - 5 ) > $( window ).width() ){
					// ... See if it will fit to the left of the item...
					if( ( itemPosition.viewportOffset.left + 5 - subMenuSize.outerWidth ) >= 0 ){
						left = ( ( subMenuSize.outerWidth * -1 ) + 5 );
					} else {
						// ... but if not, position it *under* the item.
						// Since the submenu is pos relative to the parent item, we need to subtract the parent item pos from the ideal left pos
						left = ( $( window ).width() - subMenuSize.outerWidth ) - itemPosition.absPos.left - 15; 
						top = menuItem.position()['top'] + itemSize.height + 15;
					}
				}
	
				subMenu
					.css({
						left: left + 'px',
						top: top + 'px'
					})
					.show();
			
			}
		},

		/**
		 * Hides submenus within the item identified by e.currentTarget
		 *
		 * @param	{element} 	elem 		The element this widget belongs to
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{element} 	menu 		The menu itself
		 * @param	{event} 	e 			The original event
		 * @returns {void}
		 */
		_hideSubMenu = function ( elem, elemID, options, menu, e ) {
			var subMenus = $( e.currentTarget ).closest('.ipsMenu_item').find('.ipsMenu');
			subMenus.hide();
		},

		/**
		 * Hides the menu, and unsets necessary events
		 *
		 * @param	{element} 	elem 		The element this widget belongs to
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{element} 	menu 		The menu itself
		 * @param	{boolean} 	immediate 	Whether to hide this immediately, or animate
		 * @returns {void}
		 */
		_hideMenu = async function ( elem, elemID, options, menu, immediate) {
			if( options.closeOnBlur ){
				$( document ).off('click.' + elemID );
			}

			if (!$(menu).is(":visible")) {
				return;
			}

			// Remove active class on trigger element
			$( elem ).removeClass( options.activeClass );

			// Cancel any animations, then hide it. After any animations created by hiding it are done, remove the event listeners
			await Promise.all(
				$(menu)
					.get(0)
					.getAnimations()
					.filter(() => !!immediate) // we only need to cancel if it's going to be immediately hidden
					.map(animation => {
						animation.pending && animation.cancel();
						return animation.finished;
					})
			);

			if (!immediate) {
				ips.utils.anim.go('fadeOut fast', menu);
				await Promise.all($(menu).get(0).getAnimations().map(animation => animation.finished));
			}

			$(menu).hide();
			$(elem).off('closeMenu');
			$(menu).off('closeMenu');

			$( elem ).trigger('menuClosed', { 
				elemID: elemID,
				menu: menu 
			});
		},

		/**
		 * Positions the menu correctly
		 *
		 * @param	{element} 	elem 		The element this widget belongs to
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options		Options object
		 * @param	{element} 	menu 	 	The menu element
		 * @param 	{boolean}	repositioning	Whether we're repositioning a menu rather than showing it for the first time
		 *
		 * @returns {void}
		 */
		_positionMenu = function (elem, elemID, options, menu, repositioning) {
			ips.utils.position.startCaching();
			let above = options.above;
			const element = $(elem).get(0);
			const menuElement = $(menu).get(0);
			const {rect: docRect} = ips.utils.position.getElemRectAndStyle(document.documentElement);
			if (above === 'auto') {
				const {rect} = ips.utils.position.getElemRectAndStyle(element);
				const {rect: menuRect} = ips.utils.position.getElemRectAndStyle(menuElement);
				above = (rect.top + menuRect.height > window.innerHeight);
			}

			const positionInfo = {
				trigger: elem,
				target: menu,
				center: true,
				above,
				stemOffset: {left: options.stemOffset, top: -2}
			};

			// Reset menu positioning
			Object.assign(menuElement.style, {
				left: menuElement.style.left || '',
				top: menuElement.style.top || '',
				// position: 'static'
			});

			if (menuElement.dataset.originalwidth) {
				Object.assign(menuElement.style, {
					width: menuElement.dataset.originalwidth + 'px'
				});
			}

			const appendTo = options.appendTo ? _getAppendContainer( elem, options.appendTo ) : undefined;
			if (options.appendTo && appendTo?.length) {
				positionInfo.targetContainer = appendTo;
			}

			const menuPosition = ips.utils.position.positionElem(positionInfo);

			// Position the menu with the resulting styles
			Object.assign(menuElement.style, {
				left: menuPosition.left + 'px',
				top: menuPosition.top + 'px',
				position: ( menuPosition.fixed ) ? 'fixed' : 'absolute',
			});

			ips.utils.position.endCaching(menuElement);
			const menuDims = ips.utils.position.getElemDims(menu);

			// Only update zindex if we're showing afresh, rather than simply repositioning
			if (!repositioning) {
				ips.ui.zIndex();
			}

			// If the menu is wider than the window, reset some styles
			if ((menuDims.width > docRect.clientWidth) || (ips.utils.position.getElemRectAndStyle(menuElement).rect.left < 0)) {
				options.noStem = true;

				let left = "10px";

				// If we're appending somewhere else, we need to subtract the offset of it to get a value relative to the window
				if (options.appendTo && appendTo?.length) {
					left = (10 - $(appendTo).get(0).getBoundingClientRect().left) + 'px';
				}

				menuElement.dataset.originalwidth = menuDims.width;
				Object.assign(menuElement.style, {
					left,
					width: (docRect.width - 20) + 'px'
				})
			}

			// Remove existing stems
			_removeExistingStems(menu, options);

			// Add a stem if needed
			if (!menuElement.classList.contains(options.className + '_noStem') && !options.noStem) {
				menuElement.classList.add(options.className +
					'_' +
					menuPosition.location.vertical +
					menuPosition.location.horizontal.charAt(0).toUpperCase() +
					menuPosition.location.horizontal.slice(1)
				);
			}
			ips.utils.position.endCaching();
		},

		/**
		 * Removes any existing stem classes
		 *
		 * @param	{element} 	menu 	 	The menu element
		 * @param	{object} 	options		Options object
		 * @returns {void}
		 */
		_removeExistingStems = function (menu, options) {
			var stemClasses = [];

			$.each( stems, function (idx, value) {
				stemClasses[ idx ] = options.className + '_' + value;
			});

			menu.removeClass( stemClasses.join(' ') );
		},

		/**
		 * Returns the menu dom node, after setting appropriate events 
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{string} 	elemID 		ID of the trigger element
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {*} 	Returns the menu node, or false if it can't be found
		 */
		_getMenu = function (elem, elemID, options) {

			// We can find a menu either by ID, or by an option param
			let menu;

			// We can also build it from a provided JSON object
			if( $( '#'+options.menuID ).length ){
				menu = $( '#'+options.menuID );
			} else if( $( '#'+elemID+'_menu' ).length ){
				menu = $('#' + elemID + '_menu');
			} else if( options.menuContent ) {
				menu = buildMenuFromJSON( elem, elemID, options.menuContent );
			} else {
				return false;
			}

			// Move menu to appropriate place
			if( options.appendTo ){
				var appendTo = _getAppendContainer( elem, options.appendTo );

				if( appendTo.length ){
					appendTo.append( menu );	
				}				
			} else {
				ips.getContainer().append( menu );
			}

			// Event handler for clicking within the menu
			$( menu ).on('click.' + elemID, _.partial( _menuClicked, elem, elemID, options, menu ) );

			// Add a reference to our trigger
			$( menu ).data('_owner', elem);

			// Add to registry
			_menuRegistry[ elemID ] = { elem: elem, options: options, menu: menu };

			return $(menu);
		},

		/**
		 * Event handler for clicking on the document, outside of the menu or trigger
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{element} 	menu 		The menu element
		 * @param	{Event} 	e 			The event object
		 * @returns {void} 	
		 */
		_closeOnBlur = function (elem, menu, e) {
			// Element isn't in the tree anymore? We don't care
			if (e?.target?.closest?.('body') !== document.body) {
				return;
			}

			// This function returns the trigger element that was clicked on, if any
			const clickedOnTrigger = function () {
				if ($(e.target).is('[data-ipsMenu]')) {
					return e.target;
				} else if ($(e.target).parent('[data-ipsMenu]')) {
					return $(e.target).parent('[data-ipsMenu]').get(0);
				}
			}();

			// Here we loop through each menu we have registered in order to close them
			// Don't hide the menu if:
			// 		- We clicked inside this menu, or
			// 		- We clicked the trigger element for this menu
			// If we have clicked on a trigger, we tell _hideMenu to do an immediate hide
			// so that it feels snappy to the user.
			$.each( _menuRegistry, function (key, value){
				var clickInMenu = _clickIsChildOfMenu( e.target, value.elem, value.menu.get(0) );

				if( value.elem ){
					if( clickInMenu || value.elem === clickedOnTrigger || $.contains( value.elem, e.target ) ){
						return;
					}
				}

				if( value.menu.is(':visible') ){
					_hideMenu( value.elem, key, value.options, value.menu, !!clickedOnTrigger );
				}
			});
		},

		/**
		 * Determines whether the clicked element is within a menu element
		 *
		 * @param	{element} 	clickTarget		The element directly clicked on
		 * @param	{element} 	triggerElem 	An element that triggers a menu
		 * @param	{element} 	menuElem 		The menu element opened by triggerElem
		 * @returns {boolean} 	Whether the click occurred within this menu 	
		 */
		_clickIsChildOfMenu = function (clickTarget, triggerElem, menuElem) {

			// Also check if this is within a jQuery date picker
			// Some jQUI elements are detatched from the dom by the time we get here, so we can't easily check its ancestors to 
			// figure out if it's in a datepicker. Instead, we'll check the classname applied to the clickTarget.
			if( _.isString( $( clickTarget ).get(0).className ) && ( $( clickTarget ).get(0).className.startsWith('ui-datepicker') || $( clickTarget ).closest('#ui-datepicker-div').length ) ) {
				return true;
			}

			if( clickTarget == menuElem || $.contains( menuElem, clickTarget ) ){
				return true;
			}			

			return false;
		},

		/**
		 * Main event handler for the menu itself
		 *
		 * @param	{event} 	e 		The event object
		 * @returns {void}
		 */
		_menuClicked = function (elem, elemID, options, menu, e) {


			if( $( e.target ).hasClass( options.className + '_item' ) ){
				var itemClicked = $( e.target );
			} else {
				var itemClicked = $( e.target ).parents( '.' + options.className + '_item' );
			}

			if( itemClicked.length === 0 ){
				return;
			}

			if( options.stopLinks ){
				e.preventDefault();
			}

			if( itemClicked.hasClass( options.className + '_itemDisabled') || itemClicked.is(':disabled') ){
				return;
			}
			
			if( options.closeOnClick ){
				if( itemClicked.find('[data-action="ipsMenu_ping"]').length ){
					e.preventDefault();
					itemClicked.find('[data-action="ipsMenu_ping"]').each( function () {
						ips.getAjax()( $( this ).attr('href') ).done( function () {
							$( elem ).trigger( 'menuPingSuccessful', {} );
						});
					});
				}
				
				// Cause the selected item to blink briefly, then add
				// a short delay before hiding the menu				
				var addItemClicked = function () {
					itemClicked.addClass( options.className + '_itemClicked');
				};

				var removeItemClicked = function () {
					itemClicked.removeClass( options.className + '_itemClicked');
				};

				if( e.button !== 1 ){
					_.delay( addItemClicked, 100 );
					_.delay( removeItemClicked, 200 );
					_.delay( _hideMenu, 300, elem, elemID, options, menu, false );
				}
			}
			
			if( itemClicked.find('[data-role="ipsMenu_selectedText"]').length ){
				$( elem ).find('[data-role="ipsMenu_selectedText"]').html( itemClicked.find('[data-role="ipsMenu_selectedText"]').html() );
			}

			if( itemClicked.find('[data-role="ipsMenu_selectedIcon"]').length ){
				$( elem ).find('[data-role="ipsMenu_selectedIcon"]').replaceWith( itemClicked.find('[data-role="ipsMenu_selectedIcon"]').clone() );
			}

			var data = {
				triggerElem: elem,
				triggerID: elemID,
				menuElem: $( menu[0] ),
				originalEvent: e
			};

			if( options.selectable ){
				_.extend( data, _handleSelectableClick( elem, elemID, options, menu, e ) );
			}
			
			if( !_.isUndefined( itemClicked.attr('data-ipsmenuvalue') ) ){
				_.extend( data, { selectedItemID: itemClicked.attr('data-ipsmenuvalue') } );
			}

			$( elem ).trigger('menuItemSelected', data);
		},

		/**
		 * Handles toggling settings if this is a selectable menu
		 *
		 * @param	{event} 	e 		The event object
		 * @returns {void}
		 */
		_handleSelectableClick = function (elem, elemID, options, menu, e) {

			var thisItem = $( e.target ).closest( '.' + options.className + '_item' );

			if( !thisItem.length ){
				return;
			}
			if ( thisItem.attr('data-noselect') ){
				return;
			}

			if( options.selectable == 'radio' ){
				menu
					.find( '.' + options.className + '_itemChecked' )
					.removeClass( options.className + '_itemChecked' );
					
				thisItem
					.addClass( options.className + '_itemChecked' )
					.find('input[type="radio"]').prop( 'checked', true )
						.change();
			} else {
				if( thisItem.hasClass( options.className + '_itemChecked' ) ){
					thisItem
						.removeClass( options.className + '_itemChecked' )
						.find('input[type="checkbox"]').prop( 'checked', false )
							.change();
				} else {
					thisItem
						.addClass( options.className + '_itemChecked' )
						.find('input[type="checkbox"]').prop( 'checked', true )
							.change();
				}					
			}			

			// Get selected items
			var selectedItems = menu.find( '.' + options.className + '_itemChecked' ),
				selected = {};

			$.each( selectedItems, function (idx, item) {
				selected[ $( item ).identify().attr( 'id' ) ] = item;
			});

			return {
				selectedItems: selected
			};
		},

		/**
		 * Gets the element into which the menu will be inserted.
		 * We support a comma-delimited list of selectors, and will choose the first that exists.
		 * If an ID is provided, match it explicitly. Other selectors are based on a match with .closest().
		 *
		 * @param 	{element} 	elem 		The trigger element
		 * @param	{string} 	appendTo 	The value from options.appendTo
		 * @returns {element}
		 */
		_getAppendContainer = function (elem, appendTo) {
			const appends = appendTo.split(',');
			elem = $( elem );

			for (let append of appends) {
				const selector = append.trim();
				const jq = elem.closest(selector);
				if (jq.length) {
					return jq;
				}

				if (selector.startsWith('#')) {
					const jq = $(selector);
					if (jq.length) {
						return jq;
					}
				}
			}
		};

		// Register menu as a widget
		ips.ui.registerWidget('menu', ips.ui.menu, 
			[ 'className', 'menuID', 'closeOnClick', 'closeOnBlur', 'menuContent', 'appendTo',
				'activeClass', 'selectable', 'withStem', 'stemOffset', 'stopLinks', 'above' ],
			{ lazyLoad: true, lazyEvents: 'click' } 
		);

		return {
			respond
		};
	});

	class MenuOpenedEvent extends Event {
		/**
		 * An event that fires after a menu has been opened
		 *
		 * @param 	{string}	elemID				The html ID of the menu
		 * @param 	{Event}		originalEvent		The event that let to the opening of the menu
		 * @param 	{jQuery}	menu				The menu itself
		 */
		constructor(elemID, originalEvent, menu) {
			super('ipsMenuOpened');
			this.elemID = elemID;
			this.originalEvent = originalEvent;
			this.menu = menu
		}
	}

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.offCanvasContent.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.offCanvasContent.js - Load offcanvas content (notifications and inbox)
 *
 * Author: Ehren Harber
 */
;( function(){
	"use strict";

	ips.createModule('ips.ui.offCanvasContent', function(){

		/**
		 * Responder for offCanvasContent widget
		 *
		 * @param	{jQuery} 	elem 		The element this widget is being created on
		 */
		function respond(elem) {
			let trigger = $(elem).get(0);
			trigger.addEventListener('click', e => _loadContent(e, trigger));
		}
		/**
		 * If an off-canvas menu was opened, load its data
		 *
		 * @param	{Event} 		event
		 * @param	{HTMLElement} 	elem
		 */
		function _loadContent(event, elem){

			let menuName = elem.getAttribute("aria-controls"),
				menu = document.getElementById(menuName);

			$(document).trigger('menuOpened', {
				elemID: menuName,
				originalEvent: event,
				menu: $(menu)
			});
			
		}

		ips.ui.registerWidget( 'offCanvasContent', ips.ui.offCanvasContent );
		return { respond }
	});
}());]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.pageAction.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.pageAction.js - Page action widget
 * Converts a select box of actions (e.g. moderator actions) into a fancy floating button bar with menus.
 * The select should be formatted like the following example. Optgroups are turned into a menu, while options are
 * turned into buttons. optgroups and options can have a data-icon attribue to specify the icon to use.
 * @example
 * 
 *	<select>
 *		<optgroup label="Pin" data-action='pin' data-icon='thumb-tack'>
 *			<option value='pin'>Pin</option>
 *			<option value='unpin'>Unpin</option>
 *		</optgroup>
 *		<option value='split' data-icon='code-fork'>Split</option>
 *	</select>
 * 
 * Author: Matt Finger (based on file by Rikki Tissier)
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.pageAction', function() {
		class PageActionWidget extends ips.ui.BaseWidget {
			wrapper = null;
			initialized = false;
			id = "";
			_checkedItems = {};

			constructor(elem, options) {
				super(elem, options);
				this._setUpEvents();
				setTimeout(() => this.elem.trigger('pageActionReady'))
			}

			reset() {
				super.reset();
				this._checkedItems = {};
				this._updateBar();
			}

			/**
			 * Sets up events that this instance will watch for
			 *
			 * @returns 	{void}
			 */
			_setUpEvents() {
				this.on( 'change', 'input[type="checkbox"][data-actions]', this._toggleCheckbox );
				this.on( 'refresh.pageAction', this._refreshPageAction );
				this.on( 'addManualItem.pageAction', this._addManualItem );
			}


			/**
			 * Allows controllers to manually add an ID to the page action widget if necessary
			 *
			 * @param 		{event} 	e 		Event object
			 * @param 		{object} 	data 	Event data object, containing keys 'id' and 'actions'
			 * @returns 	{void}
			 */
			_addManualItem(e, data) {
				this._checkedItems[ data.id ] = data.actions;
				this._updateBar( true );
			}

			/**
			 * Called when the contents are refreshed. Loops through our checkedItems list, and checks any
			 * of the matching checkboxes found on the page.
			 *
			 * @returns 	{void}
			 */
			_refreshPageAction() {
				for (const key in this._checkedItems) {
					if (this.element.querySelector(`input[type="checkbox"][name="${key}"]`)) {
						this
							.elem
							.find(`input[type="checkbox"][name="${key}"]`)
							.attr('checked', true)
							.trigger('change');
					}
				}
			}

			/**
			 * Updates the display of the bar, including available actions and the count
			 *
			 * @param {Event}	e
			 *
			 * @returns 	{void}
			 */
			_toggleCheckbox(e) {
				const checkbox = $( e.currentTarget );

				if (checkbox.is(':checked')) {
					this._checkedItems[ checkbox.attr('name') ] = checkbox.attr('data-actions');
				} else {
					delete this._checkedItems[ checkbox.attr('name') ];
				}

				this._updateBar( true );
			}

			/**
			 * Updates the display of the bar, including available actions and the count
			 *
			 * @param {boolean}		[doImmediate=false]
			 *
			 * @returns 	{void}
			 */
			_updateBar(doImmediate=false) {

				if( !this.initialized ){
					// Build the action bar
					this._buildActionBar();
					doImmediate = true;
					this.initialized = true;
				}

				const possibleValues = this._getActionValues();
				const size = _.size(this._checkedItems);

				// Update the bar to show/hide appropriate buttons
				this._showCorrectButtons( possibleValues );

				// Update the 'with x selected' text
				this.wrapper.find('[data-role="count"]').text( ips.pluralize( ips.getString('pageActionText_number'), size ) );
				this.wrapper.attr("data-ipspageaction-selected-count", size);

				// Animate the wrapper as needed (fade out if none selected)
				if( !size ){
					if( doImmediate ){
						this.wrapper.hide();
					} else {
						ips.utils.anim.go( 'fadeOut fast', this.wrapper );
					}
				} else if( this.initialized ){
					if( this.wrapper.is(':visible') ){
						ips.utils.anim.go( 'pulseOnce fast', this.wrapper );
					} else {
						if( doImmediate ){
							this.wrapper.show();
						} else {
							ips.utils.anim.go( 'fadeIn', this.wrapper );
						}
					}
				}
			}

			/**
			 * Shows/hides the buttons on the action bar depending on the actions we need
			 *
			 * @param	{array} 	possibleValues		Array of action keys we want to show
			 * @returns {void}
			 */
			_showCorrectButtons(possibleValues) {
				// Hide/show each button as needed
				this.wrapper.get(0).querySelectorAll('[data-role="actionMenu"], [data-role="actionButton"]').forEach(el => {
					let show = false;
					let action = el.dataset.action;

					if (el.dataset.role === 'actionButton') {
						if (possibleValues.includes(action)) {
							show = true;
						}
					} else {
						const menuID = this.id + "_" + action + "_menu";
						document.querySelectorAll(`#${menuID} [data-ipsmenuvalue]`).forEach(menuValItem => {
							const menuAction = menuValItem.dataset.ipsmenuvalue;
							if (possibleValues.includes(menuAction)) {
								show = true;
								menuValItem.removeAttribute("data-disabled");
							} else {
								menuValItem.setAttribute("data-disabled", true);
							}
						});
					}

					// just in case legacy templates still have ipsHide set by default
					el.classList.remove('ipsHide');
					if (show) {
						el.removeAttribute('hidden')
					} else {
						el.setAttribute('hidden', '')
					}
				});
			}


			/**
			 * Event handler for clicking a button in the action bar
			 *
			 * @param	{Event} 	e			Event object
			 *
			 * @returns {void}
			 */
			_selectItem(e) {
				e.preventDefault();
				this._triggerAction( $( e.currentTarget ).attr('data-action') );
			}


			/**
			 * Event handler for a menu item being clicked
			 *
			 * @param	{Event} 	e			Event object
			 * @param	{object} 	data 		Event data object
			 *
			 * @returns {void}
			 */
			_selectMenuItem(e, data = e.detail) {
				e.preventDefault();

				if( !_.isUndefined( data.originalEvent ) ){
					data.originalEvent.preventDefault();
				}

				this._triggerAction( data.selectedItemID );
			}


			/**
			 * Triggers an action by setting the original select value and submitting the form
			 *
			 * @param	{string} 	action 		Action to trigger
			 *
			 * @returns {void}
			 */
			_triggerAction(action) {
				const tools = this.elem.find('[data-role="pageActionOptions"]');

				// Set the select to the value
				tools.find('select').val( action );

				// Add any missing checkboxes as hidden values in the form
				for (const key in this._checkedItems) {
					if ( !this.elem.find('input[type="checkbox"][name="' + key + '"]').length && !this.elem.find('input[type="hidden"][name="' + key + '"]').length ){
						this.elem.append( $('<input/>').attr( 'type', 'hidden' ).attr( 'name', key ).attr( 'data-role', "moderation" ).val(1) );
					}
				}

				// Add page number
				const page = ips.utils.url.getPageNumber('page');

				if (page !== undefined) {
					const pageNumber = $('<input/>').attr( 'type', 'hidden' ).attr( 'name', 'page' ).attr( 'value', ips.utils.url.getPageNumber('page') );
					tools.find('[type="submit"]').before( pageNumber );
					tools.closest('form').attr( 'action', tools.closest('form').attr( 'action' ) + '&page=' +ips.utils.url.getPageNumber('page') );
				}

				// Click submit
				tools.find('[type="submit"]').click();
			}


			/**
			 * Builds the action bar
			 *
			 * @returns {void}
			 */
			_buildActionBar() {
				let content = '';
				const select = this.element.querySelector('[data-role="pageActionOptions"] select');

				// Get ID of select
				this.id = $(select).identify().attr('id');
				for (const child of select.querySelectorAll(":scope > *")) {
					if (child.tagName.toLowerCase() === 'optgroup') {
						content += this._buildOptGroup(child, this.id);
					} else {
						content += this._buildOption(child, this.id);
					}
				}

				const bar = ips.templates.render('core.pageAction.wrapper', {
					content,
					id: this.id,
					selectedLang: ips.getString('pageActionText')
				});

				this.elem.after( bar );

				this.wrapper = this.elem.next();
				this.on( this.wrapper, 'click', '[data-role="actionButton"]', this._selectItem )
				this.on( this.wrapper, 'menuItemSelected', '[data-role="actionMenu"]', this._selectMenuItem );


				$( document ).trigger( 'contentChange', [ this.wrapper ] );
			}


			/**
			 * Build an option group menu for the action bar
			 *
			 * @param	{Element} 	optgroup	The optgroup element
			 * @param	{string} 	id 			The ID of the select control this optgroup belongs to
			 *
			 * @returns {string}	The built template
			 */
			_buildOptGroup(optgroup, id) {
				let content = '';
				for (const option of optgroup.querySelectorAll('option')) {
					content += ips.templates.render('core.menus.menuItem', {
						value: option.value,
						title: option.innerHTML,
						link: "#"
					});
				}

				return ips.templates.render('core.pageAction.actionMenuItem', {
					icon: optgroup.dataset.icon,
					title: optgroup.getAttribute('label'),
					id,
					action: optgroup.dataset.action,
					menucontent: content
				});
			}

			/**
			 * Build an option menu item for the action bar
			 *
			 * @param	{HTMLOptionElement} 	option 		The option element
			 * @param	{string} 	id 			The ID of the select control this option belongs to
			 *
			 * @returns {string} 	The built template
			 */
			_buildOption(option, id) {
				return ips.templates.render('core.pageAction.actionItem', {
					icon: option.dataset.icon,
					id,
					title: option.innerHTML,
					action: option.value
				});
			}

			/**
			 * Gets the action values from the provided checkboxes
			 *
			 * @returns {Array<string>}
			 */
			_getActionValues() {
				const values = new Set();
				for (const value of Object.values(this._checkedItems)) {
					value.split(" ").forEach(val => values.add(val));
				}

				return [...values];
			}

			/**
			 * Returns a jQuery object of the checked checkboxes
			 *
			 * @returns {jQuery}    Checkbox elements
			 */
			_getCheckedBoxes() {
				return this.elem.find('input[type="checkbox"][data-actions]:checked');
			}
		}

		return PageActionWidget.buildModuleAndRegisterWidget('pageAction', []);
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.pagination.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.pagination.js - Pagination UI component
 * Fires events that a controller can look for to facilitate AJAX pagination
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.pagination', function(){

		var defaults = {
			ajaxEnabled: true,
			perPage: 25, // number of items per perPage,
			pageParam: 'page',
			seoPagination: false,
		};

		/**
		 * Responder for pagination widget
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object passed through
		 * @returns {void}
		 */
		var respond = function (elem, options) {
			options = _.defaults( options, defaults );

			if( !$( elem ).data('_pagination') ){
				$( elem ).data('_pagination', paginationObj(elem, _.defaults( options, defaults ) ) );
			}
		};

		// Register this widget with ips.ui
		ips.ui.registerWidget('pagination', ips.ui.pagination,
			['ajaxEnabled', 'perPage', 'pages', 'pageParam', 'seoPagination']
		);

		return {
			respond: respond
		};
	});

	/**
	 * Pagination instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var paginationObj = function (elem, options) {

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			// The ajaxEnabled option is read at run-time in this case,
			// meaning controller can disable it on the fly if necessary
			if( !options.ajaxEnabled ){
				return;
			}

			// Set events
			// Click on a page number
			elem.on( 'click', '[data-page]', function (e) {

				var targetElem = $( e.currentTarget );

				$( elem ).trigger('paginationClicked', { 
					href: targetElem.attr('href') || '#',
					hrefTitle: targetElem.attr('title') || '',
					paginationElem: $(elem),
					seoPagination: options.seoPagination,
					pageElem: targetElem,
					perPage: options.perPage,
					pageParam: options.pageParam,
					pageNo: targetElem.attr('data-page'),
					lastPage: ( parseInt( targetElem.attr('data-page') ) === parseInt( options.pages ) ),
					originalEvent: e || null
				});
			});
				
			// Use the page jump
			elem.on( 'menuOpened', function (e, data) {
				$( elem ).find('input[type="number"]').focus();
			});

			elem.on( 'submit', '[data-role="pageJump"]', function (e) {
				var value = parseInt( $( e.currentTarget ).find('input[type="number"]').val() );
                var href = $( e.currentTarget ).closest('[data-baseURL]').attr('data-baseurl');

				if( value < 1 || value > options.pages ){
					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warning',
						message: ips.getString('not_valid_page', [ options.pages ] ),
						callbacks: {}
					});

					return;
				}

				$( elem ).trigger('paginationJump', { 
					originalEvent: e || null,
					href: href || '#',
					paginationElem: $(elem),
					seoPagination: options.seoPagination,
					pageNo: value,
					perPage: options.perPage,
					pageParam: options.pageParam,
					lastPage: ( parseInt( value ) === parseInt( options.pages ) )
				});
			});
		};

		init();

		return {
			init: init
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.passwordStrength.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.passwordStrength.js - Checks password fields for strength
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.passwordStrength', function(){

		var defaults = {};

		var respond = function (elem, options) {
			if( !$( elem ).data('_passwordStrength') ){
				$( elem ).data('__passwordStrength', passwordStrengthObj(elem, _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Destruct the passwordStrength widgets in elem
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		},

		/**
		 * Retrieve the passwordStrength instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The passwordStrength instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_passwordStrength') ){
				return $( elem ).data('_passwordStrength');
			}

			return undefined;
		};

		ips.ui.registerWidget('passwordStrength', ips.ui.passwordStrength, 
			[ 'enforced', 'enforcedStrength', 'checkAgainstMember', 'checkAgainstRequest' ]
		);

		return {
			respond: respond,
			getObj: getObj,
			destruct: destruct
		};
	});

	/**
	 * passwordStrength instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var passwordStrengthObj = function (elem, options) {

		var _popup = null,
			_passwordBlurred = false,
			_field = null,
			_dirty = false,
			_timer = null,
			_ajax = ips.getAjax();

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			elem.on( 'focus', 'input[type="password"]', _passwordFocus );
			elem.on( 'blur', 'input[type="password"]', _passwordBlur );
			elem.on( 'keyup blur', 'input[type="password"]', _passwordKeyEvent );

			_field = elem.find('input[type="password"]');
			_field.after( $('<span/>').attr( 'data-role', 'validationCheck' ) );

			// If there's a value already in the box, run now
			if( _field.val() !== '' ){
				_changePassword();
			}
		},

		/**
		 * Destruct
		 * Removes event handlers assosciated with this instance
		 *
		 * @returns {void}
		 */
		destruct = function () {
			if( _timer ){
				clearTimeout( _timer );
			}

			if( _ajax && _ajax.abort ){
				_ajax.abort();
			}

			elem.off( 'focus', 'input[type="password"]', _passwordFocus );
			elem.off( 'blur', 'input[type="password"]', _passwordBlur );
			elem.off( 'keyup blur', 'input[type="password"]', _passwordKeyEvent );
		},

		/**
		 * Focus handler for password field
		 *
		 * @returns 	{void}
		 */
		_passwordFocus = function () {
			// We encountered a strange issue where Chrome's password auto-fill would focus
			// the password field before the form was actually visible, causing the field to
			// be hidden due to the way getElemPosition in _buildAdvicePopup works.
			// So if the field isn't visible when focus is called, just blur and return.
			if( !elem.is(':visible') ){
				_field.blur();
				return;
			}

			if( _.isNull( _popup ) ){
				_buildAdvicePopup();
			}

			_popup.show();
			_positionAdvicePopup();
			_passwordBlurred = false;
		},

		/**
		 * Blur handler for password field
		 *
		 * @returns 	{void}
		 */
		_passwordBlur = function () {
			if( _popup ){
				_popup.hide();
			}

			_passwordBlurred = true;
		},

		/**
		 * Clears error/success status from field
		 *
		 * @returns 	{void}
		 */
		_clearResult = function () {
			// Rmmove error/success classes
			_field
				.removeClass('ipsField_error')
				.removeClass('ipsField_success')
					.next('[data-role="validationCheck"]')
						.html('');
		},

		/**
		 * Main event handler for password field. Sets a timeout so that we don't
		 * bombard the ajax handler with requests.
		 *
		 * @returns 	{void}
		 */
		_passwordKeyEvent = function (e) {
			if( _timer ){
				clearTimeout( _timer );
			}

			if( _field.val().length > 2 || e.type != "keyup" ){
				_timer = setTimeout( _changePassword, 750 );
			} else {
				_clearResult();
			}
		},

		/**
		 * Main business happens here. Fire ajax request to check password
		 * strength; show error or status
		 *
		 * @returns 	{void}
		 */
		_changePassword = function () {
			var value = _field.val();
			var resultElem = _field.next('[data-role="validationCheck"]');
			var wrapper = elem.find('[data-role="strengthInfo"]');
			var meter = elem.find('[data-role="strengthMeter"]');
			var text = elem.find('[data-role="strengthText"]');

			if( _ajax && _ajax.abort ){
				_ajax.abort();
			}

			if( value.length ){
				_dirty = true;
			} else {
				if( !_dirty ){
					return;
				}
			}

			// Show meter if needed
			if( !meter.is(':visible') ){
				ips.utils.anim.go('fadeInDown fast', wrapper);
			}

			// Set loading
			_field.addClass('ipsField_loading');

			// Capture other useful values to check against, if available
			var alsoCheckAgainst = new Array;

			if( options.checkAgainstRequest )
			{
				var requestNames = JSON.parse( options.checkAgainstRequest );

				_.each( requestNames, function( value ){
					if( elem.closest('form').find('input[name="' + value + '"]') )
					{
						alsoCheckAgainst.push( elem.closest('form').find('input[name="' + value + '"]').val() );
					}
				});
			}

			if( options.checkAgainstMember )
			{
				var memberValues = JSON.parse( options.checkAgainstMember );

				_.each( memberValues, function( value ){
					alsoCheckAgainst.push( value );
				});
			}

			// Do _ajax
			_ajax( ips.getSetting('baseURL') + '?app=core&module=system&controller=ajax&do=passwordStrength', {
				dataType: 'json',
				data: {
					input: value,
					checkAgainstRequest: alsoCheckAgainst
				},
				method: 'post'
			})
				.done( function (response) {
					if( response.result == 'ok' ){
						
						meter.val( response.granular );
						meter.attr( 'data-adviceValue', response.score );
						text.html( ips.getString('strength_' + response.score) );

						if( options.enforced ){
							_clearResult();

							if( response.score >= parseInt( options.enforcedStrength ) ){
								// If our score is above the threshold show the success state
								resultElem.hide().html('');
								_field.addClass('ipsField_success');

								// If the row has error status (i.e. we arrived at this page with an error)
								// remove it.
								_field.closest('.ipsFieldRow')
									.removeClass('ipsFieldRow_error')
									.find('.i-color_warning')
										.hide();	
							} else {
								// If our score is below the threshold and we're blurred
								// show the error state
								if( _passwordBlurred ){
									resultElem
										.show()
										.html( ips.templates.render( 'core.forms.validateFailText', { 
											message: ips.getString('err_password_strength', { 
												strength: ips.getString('strength_' + options.enforcedStrength ) 
											}) 
										}));
									_field.addClass('ipsField_error');
								}
							}
						}
					} else {
						resultElem.show().html( ips.templates.render( 'core.forms.validateFailText', { message: response.message } ) );
						_field.removeClass('ipsField_success').addClass('ipsField_error');
					}
				})
				.fail( function () {} )
				.always( function () {
					_field.removeClass('ipsField_loading');
				});
		},

		/**
		 * Builds the advice popup
		 *
		 * @returns 	{void}
		 */
		_buildAdvicePopup = function () {
			var text = ips.getString('password_advice');
			var min = false;

			if( !_.isNull( _popup ) ){
				return;
			}

			if( options.enforced ){
				min = ips.getString('err_password_strength', { strength: ips.getString('strength_' + options.enforcedStrength) } );
			}

			var tmpPopup = ips.templates.render('core.forms.advicePopup', {
				id: elem.identify().attr('id'),
				min: min,
				text: text
			});

			$('body').append( tmpPopup );

			_popup = $('body').find( '#elPasswordAdvice_' + elem.identify().attr('id') );

			_popup.css({
				position: 'absolute'
			});
		},

		/**
		 * Positions the advice popup
		 *
		 * @returns 	{void}
		 */
		_positionAdvicePopup = function () {
			var isRTL = $('html').attr('dir') == 'rtl';
			var position = ips.utils.position.getElemPosition( _field );
			var fieldWidth = _field.width();
			var fieldHeight = _field.height();
			var adviceWidth = _popup.width();
			var adviceHeight = _popup.height();
			var windowWidth = $( window ).width();
			var stemOffset = 30;

			_popup
				.removeClass('cStem_rtl cStem_ltr cStem_above')
				.css({
					zIndex: ips.ui.zIndex()
				});

			if( isRTL && ( position.absPos.left - adviceWidth - stemOffset ) > 0 ){
				_popup
					.addClass('cStem_rtl')
					.css({
						top: ( position.absPos.top - ( stemOffset / 2 ) ) + 'px',
						left: ( position.absPos.left - stemOffset - adviceWidth ) + 'px'
					});
			} else if( !isRTL && ( position.absPos.left + fieldWidth + adviceWidth + stemOffset ) < windowWidth ) {
				_popup
					.addClass('cStem_ltr')
					.css({
						top: ( position.absPos.top - ( stemOffset / 2 ) ) + 'px',
						left: ( position.absPos.left + fieldWidth + stemOffset ) + 'px'
					});
			} else {
				_popup
					.addClass('cStem_above')
					.css({
						top: ( position.absPos.top - ( stemOffset / 2 ) - adviceHeight ) + 'px',
						left: ( position.absPos.left + ( fieldWidth / 2 ) - ( adviceWidth / 2 ) ) + 'px'
					});
			}
		};

		init();

		return {
			destruct: destruct
		};
	};

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.pullToRefresh.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.pullToRefresh.js - Pull to refresh for iOS PWA
 *
 * Author: Ehren Harber
 */
;if (navigator.standalone) {
    (function($, _) {
        ips.createModule('ips.ui.pullToRefresh', function() {

            ips.ui.registerWidget('pullToRefresh', false);

        });
    }(jQuery, _));
};</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.pwaLoading.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.pwaLoading.js - A loading indicator for PWAs
 *
 * Author: Ehren Harber
 */
;(function($, _) {
	if (window.matchMedia('(display-mode: standalone)').matches) {
		ips.createModule('ips.ui.pwaLoading', function() {
			// Load JS when the element is identified on page load
			ips.ui.registerWidget('pwaLoading', false);
		});
	}
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.quote.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.quote.js - Quote widget, builds the citations for quotes in content
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.quote', function(){

		var defaults = {
			timestamp: '',
			userid: 0,
			username: '',
			contenttype: '',
			contentclass: '',
			contentid: 0
		};

		/**
		 * Respond method for quotes.
		 * Builds the quote HTML using the options passed into the widget and inserts it into the content post
		 *
		 * @param 	{element}	elem 		The quote element
		 * @param	{object} 	options	 	Options for this quote
		 * @returns {void}
		 */
		var respond = function (elem, options) {
			
			/* Don't rebuild if we've already done this */			
			if( elem.data('quoteBuilt') || elem.parents( '[data-ipsEditorV5], .tiptap' ).length ){
				return;
			}
			
			/* Do we have an existing citation block? (quotes from older versions won't, newer will) */
			var existingCitation = elem.children('.ipsQuote_citation');
			
			/* What should the citation say? */
			var citation = ips.utils.getCitation( options, true, existingCitation.length ? existingCitation.text() : ips.getString('editorQuote') );
			
			/* Build the citation block */
			var data = {
				citation: citation,
				contenturl: options.contentid && options.contentcommentid ? ips.getSetting('baseURL') + "?app=core&module=system&controller=content&do=find&content_class=" + options.contentclass + "&content_id=" + options.contentid + "&content_commentid=" + options.contentcommentid : ''
			};
			var citation = ips.templates.render( 'core.editor.citation', data );
			
			/* Add or replace it */
			if ( existingCitation.length ) {
				existingCitation.replaceWith( citation );
			} else {
				elem.prepend( citation );
			}
			
			/* Set the event handler for opening/closing */
			elem.find('> .ipsQuote_citation').on( 'click', _toggleQuote );
			elem.find('> .ipsQuote_contents')
				.addClass('ipsClearfix')
				.attr('data-ipsTruncate', true)
				.attr('data-ipsTruncate-expandText', ips.getString('expand_quote'));
			
			/* Hide embedded quotes */
			if( elem.is('blockquote.ipsQuote > blockquote.ipsQuote') ){
				elem
					.find('> *:not( .ipsQuote_citation )')
						.hide()
					.end()
					.find('> .ipsQuote_citation')
						.removeClass('ipsQuote_open')
						.addClass('ipsQuote_closed');					
			}
			
			/* And save that we've done this */
			elem.trigger('quoteBuilt.quote');
			elem.data( 'quoteBuilt', true );

			$( document ).trigger( 'contentChange', [ elem ] );
		},
		
		/**
		 * Event handler for toggling the quote visibility
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		_toggleQuote = function (e) {
			var cite = $( e.currentTarget );
			var target = $( e.target );

			if( target.is('a:not( [data-action="toggleQuote"] )') || ( target.closest('a').length && !target.closest('a').is('[data-action="toggleQuote"]') ) ){
				return;
			}

			e.preventDefault();

			if( cite.hasClass('ipsQuote_closed') ){
				ips.utils.anim.go( 'fadeIn', cite.siblings() );
				cite.removeClass('ipsQuote_closed').addClass('ipsQuote_open');
			} else {
				cite.siblings().hide();
				cite.removeClass('ipsQuote_open').addClass('ipsQuote_closed');
			}

			e.stopPropagation();
		};

		ips.ui.registerWidget('quote', ips.ui.quote, 
			[ 'timestamp', 'userid', 'username', 'contentapp', 'contenttype', 'contentclass', 'contentid', 'contentcommentid' ]
		);

		return {
			respond: respond
		};
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.rating.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.rating.js - Rating widget
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.rating', function(){

		var defaults = {
			changeRate: true,
			canRate: true
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_rating') ){
				$( elem ).data('_rating', ratingObj(elem, _.defaults( options, defaults ) ) );
			}
		};

		ips.ui.registerWidget('rating', ips.ui.rating, 
			[ 'url', 'changeRate', 'canRate', 'size', 'value', 'userRated' ]
		);

		/**
		 * Rating instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		var ratingObj = function (elem, options) {

			var selected = null,
				max = 0,
				ratingElem = null,
				userRated = false, // Has the user rated on this page load?
				loading = false;

			/**
			 * Sets up this instance
			 * Hides the contents of the widget, fetch the current value (based on which radio is selected),
			 * then build the stars dynamically
			 *
			 * @returns 	{void}
			 */
			var init = function () {
				// Hide all inputs
				elem.children().hide();

				// Get the selected value (if any)
				if ( options.value ) {
					selected = options.value;
				} else {
					selected = elem.find('input[type="radio"]:checked').val();
				}
				
				var maxElem = _.max( elem.find('input[type="radio"]'), function (value) {
					return parseInt( $( value ).attr('value') );
				});

				max = $( maxElem ).attr('value');

				_buildRatingElem();

				// Set up events
				ratingElem.on( 'mouseenter', 'li', _enterStar );
				ratingElem.on( 'mouseleave', 'li', _leaveStar );
				ratingElem.on( 'click', 'li', _clickStar );
			},

			/**
			 * Builds the stars elements
			 *
			 * @returns {void}
			 */
			_buildRatingElem = function () {
				var content = '';
				
				for( var i = 1; i <= max; i++ ){
					if ( i <= selected ) {
						content += ips.templates.render('core.rating.star', {
							value: i,
							className: 'ipsRating_on'
						});
					} else if ( ( i - 0.5 ) <= selected ) {
						content += ips.templates.render('core.rating.halfStar', {
							value: i
						});
					} else {
						content += ips.templates.render('core.rating.star', {
							value: i,
							className: 'ipsRating_off'
						});
					}
				}

				content = ips.templates.render('core.rating.wrapper', {
					content: content,
					status: ( options.userRated ) ? ips.pluralize( ips.getString('youRatedThis'), [ options.userRated ] ) : ''
				});
				
				elem.append( content );

				// Get new rating elem
				ratingElem = elem.find('.ipsRating');

				// Size?
				if( options.size ){
					ratingElem.addClass( 'ipsRating_' + options.size );
				}

				// URL?
				/*if( options.url ){
					ratingElem.after( ips.templates.render('core.rating.loading') );
				}*/
			},

			/**
			 * User hovers on a star
			 * If rating is possible, highlight the stars up the one being hovered
			 *
			 * @param	{event}		e 		Event object
			 * @returns {void}
			 */
			_enterStar = function (e){
				if( ( selected != null && !options.changeRate ) || !options.canRate || loading ){
					return;
				}

				_starActive( $( e.currentTarget ).attr('data-ratingValue'), true );
			},

			/**
			 * User stops hovering on a star
			 * If rating was possible, unhighlight all the stars then set them back to the proper rating
			 *
			 * @param	{event}		e 		Event object
			 * @returns {void}
			 */
			_leaveStar = function (e) {
				if( ( selected != null && !options.changeRate ) || !options.canRate || loading ){
					return;
				}

				// Put the rating back to what it was
				_starActive( selected, false );
			},

			/**
			 * User clicks a star
			 * If rating is possible, either fire an ajax request or set a radio
			 *
			 * @param	{event}		e 		Event object
			 * @returns {void}
			 */
			_clickStar = function (e) {
				e.preventDefault();

				if( ( selected != null && !options.changeRate ) || !options.canRate || loading ){
					return;
				}

				var value = $( e.currentTarget ).attr('data-ratingValue');
				selected = value;
				userRated = true;

				_starActive( value );

				// Animate the selected one
				ips.utils.anim.go( 'pulseOnce', $( e.currentTarget ) );

				elem.find('[data-role="ratingStatus"]').text( ips.pluralize( ips.getString('youRatedThis'), [ value ] ) );

				// If this is pinging a URL, do that now
				if( options.url ){
					_remoteRating( value );
					return;
				}

				// Set the form field
				elem
					.find('input[type="radio"]')
						.prop( 'checked', false )
						.filter('input[type="radio"][value="' + value + '"]')
							.prop( 'checked', true );

				elem.trigger('ratingSaved', {
					value: value
				});				
			},

			/**
			 * Makes a star active, either in 'on' or 'hover' state
			 *
			 * @param	{number}		value 		Value up to and including the highlighted value
			 * @param 	{boolean}		hover 		Should the value be shown as 'hover'?
			 * @returns {void}
			 */
			_starActive = function (value, hover) {
				ratingElem
					.find('> ul[data-role="ratingList"]')
						.toggleClass('ipsRating_mine', ( hover || userRated ) )
					.end()
					.find('.ipsRating_half').each(function(){
						$(this).replaceWith( ips.templates.render('core.rating.star', {
							value: $(this).attr('data-ratingValue'),
							className: 'ipsRating_off'
						}) );
					})
					.end()
					.find('li')
						.removeClass('ipsRating_on')
						.removeClass('ipsRating_hover')
						.addClass('ipsRating_off')
					.end()
					.find('li[data-ratingValue="' + value + '"]')
						.prevAll('li')
						.andSelf()
							.removeClass('ipsRating_off')
							.addClass( 'ipsRating_on');
			},

			/**
			 * Handles pinging a URL with the rating value
			 *
			 * @param	{number}		value 		Value the user rated
			 * @returns {void}
			 */
			_remoteRating = function (value) {
				_setLoading( true );

				var statusElem = elem.find('[data-role="ratingStatus"]');

				// Show loading
				statusElem.html( ips.templates.render('core.rating.loading' ) );

				ips.getAjax()( options.url, {
					data: {
						rating: parseInt( value )
					}
				})
					.done( function (response) {
						statusElem.text( ips.getString('rating_saved') );
						elem.trigger('ratingSaved', {
							value: value
						});
					})
					.fail( function (jqXHR) {
						statusElem.text( ips.getString('rating_failed') );
						elem.trigger('ratingFailed', {
							value: value
						});
					})
					.always( function () {
						//_setLoading( false );
					});
			},

			/**
			 * Toggle the loading status of the widget
			 *
			 * @param 	{boolean} 	isLoading 	Show as loading?
			 * @returns {void}
			 */
			_setLoading = function (isLoading) {
				loading = isLoading;
				ratingElem.toggleClass( 'ipsRating_loading', isLoading );
			};

			init();

			return {};
		};

		return {
			respond: respond
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.readmore.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350">;( function(){
	&quot;use strict&quot;;

	ips.createModule('ips.ui.readmore', function(){

		let respond = function(elem){
			let el = elem[0];
			let content = el.querySelector('.iReadMore__content--js');
			Debug.log(content);
		}

		ips.ui.registerWidget( 'readmore', ips.ui.readmore,
			['expandText']
		);

		return{
			respond: respond
		};

	});
}());</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.selectTree.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.selectTree.js - Allows users to select values from a dynamic tree select
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.selectTree', function(){

		var defaults = {
			multiple: false,
			selected: false,
			searchable: true,
			placeholder: ips.getString('select')
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_selecttree') ){
				$( elem ).data('_selecttree', selectTreeObj( $( elem ), _.defaults( options, defaults ) ) );
			}
		},

		/**
		 * Retrieve the select tree instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {mixed} 	The select tree instance or undefined
		 */
		getObj = function (elem) {
			if( $( elem ).data('_selecttree') ){
				return $( elem ).data('_selecttree');
			}

			return undefined;
		},

		/**
		 * Destruct this widget on this element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {void}
		 */
		destruct = function (elem) {
			var obj = getObj( elem );

			if( !_.isUndefined( obj ) ){
				obj.destruct();
			}
		};

		/**
		 * Select Tree instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {{destruct:function:void}|Object<string,*>}
		 */
		function selectTreeObj(elem, options) {

			let results = null,
				elemID = null,
				selectedItems = [],
				name = '',
				autoExpand = false,
				ro;

			var init = function () {
				elemID = elem.identify().attr('id');
				results = elem.find('.ipsSelectTree_nodes');
				name = elem.attr('data-name');

				// if we're inside a dropdown, make sure the results are a child of the element directly
				if ($(elem).closest('i-dropdown').length) {
					$(elem).after($(results).get(0));
					$(results).addClass('ipsSelectTree_nodes--collapsed').removeClass('ipsHide').css({display: ""});

					// if this is the only element inside the form, show it
					const inputEl = $(elem).closest('form .ipsForm > .ipsFieldRow').get(0);
					if (inputEl instanceof HTMLElement && inputEl.matches(':not([hidden],[hidden] *)') &&
						![...inputEl.parentElement.querySelectorAll(':scope > .ipsFieldRow')].some(row => row !== inputEl && row.querySelector("input:not([hidden], [hidden] *)"))
					) {
						autoExpand = true;
						$(results).addClass('ipsSelectTree_nodes--auto-expanded');
					}
				}

				// Events
				if (!autoExpand) {
					elem.on('click', _toggleResults);
				}
				results.on( 'click', '[data-action="getChildren"]', _toggleChildren );
				results.on( 'click', '[data-action="nodeSelect"]', _toggleNodeSelection );

				elem.on( 'click', '[data-action="nodeLoadMore"] a:not(.ipsButton--disabled)', _nodeLoadMore );
				results.on( 'click', '[data-action="nodeLoadMore"] a:not(.ipsButton--disabled)', _nodeLoadMore );

				if( $('input[name="' + name + '-zeroVal"]') ){
					$('input[name="' + name + '-zeroVal"]').on( 'change', _zeroValChange );
				}

				// Show the placeholder if nothing is selected
				if( options.selected ){
					try {
						var preSelected = $.parseJSON( options.selected );
					} catch( err ) { }

					if( preSelected && _.isObject( preSelected ) && _.size( preSelected ) ){
						_buildPreSelected( preSelected );
						return;
					}
				}

				elem
					.find('.ipsSelectTree_value')
						.addClass('ipsSelectTree_placeholder')
						.text( ( options.placeholder ) ? options.placeholder : ips.getString('select') );

				_zeroValChange();
				if (autoExpand) {
					_showResults();
				}
			},

			/**
			 * Destruct this widget on this element
			 *
			 * @returns {void}
			 */
			destruct = function () {
				$( document ).off('click.' + elemID );
			},

			/**
			 * Builds the values that are already selected
			 *
			 * @param 	{object} 	preSelected 	Object containing pre-selected node data
			 * @returns {void}
			 */
			_buildPreSelected = function (preSelected) {
				if( _.size( preSelected ) ){
					_.each( preSelected, function (val, key) {
						selectedItems.push( key );

						if( options.multiple ){
							var id = key;
							if ( val.id ) {
								id = val.id;
							}
							_addToken( val.title, id );
						} else {
							_setValue( val.title );
						}

						// Check our results panel and select if it exists
						if( results.find('[data-id="' + key + '"]').length ){
							results.find('[data-id="' + key + '"]').addClass('ipsSelectTree_selected');
						}
					});

					_updateSelectedValues();
					
					// Emit event that indicates our initial values are in place
					elem.trigger( 'nodeInitialValues', {
						selectedItems: selectedItems
					});
				}
			},

			/**
			 * Event handler for changing the state of the 'zero val' checkbox
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_zeroValChange = function (e) {
				elem.toggleClass('ipsSelectTree_disabled', $('input[name="' + name + '-zeroVal"]').is(':checked') );

				if( !$('input[name="' + name + '-zeroVal"]').is(':checked') && results.is(':visible') ){
					_closeResults();
				}
			},

			/**
			 * Show or hide children in this node
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_toggleChildren = function (e, ignoreClosed) {
				e.preventDefault();
				e.stopPropagation();

				var item = $( e.currentTarget ).closest('.ipsSelectTree_item');
				var listItem = item.closest('li');
				var id = item.attr('data-id');
				var url = options.url + '&_nodeSelect=children&_nodeId=' + id;

				if( !item.hasClass('ipsSelectTree_withChildren') ){
					// No children to load in this node
					return;
				}

				if( item.hasClass('ipsSelectTree_itemOpen') ){
					if( ignoreClosed !== true ){
						item.removeClass('ipsSelectTree_itemOpen');
						listItem.find('> [data-role="childWrapper"]').hide();
						_positionResults();
					}
				} else {
					item.addClass('ipsSelectTree_itemOpen');

					// Does this node already have children loaded?
					if( item.attr('data-childrenLoaded') ){	
						ips.utils.anim.go( 'fadeIn fast', listItem.find('> [data-role="childWrapper"]') );
						_positionResults();
					} else {
						listItem.append( $('<div/>').attr('data-role', 'childWrapper').html( ips.templates.render('core.general.loading', { text: ips.getString('loading') } ) ) );
						_positionResults();

						// Fetch it
						ips.getAjax()( url )
							.done( function (response) {
								item.attr( 'data-childrenLoaded', true );
								listItem.find('[data-role="childWrapper"]').html( response.output );
								listItem.find('[data-role="childWrapper"] .ipsSelectTree_item').each(function(){
									if ( $(this).attr('data-id') && selectedItems.indexOf( $(this).attr('data-id') ) != -1 ) {
										$(this).addClass('ipsSelectTree_selected');
									}
								});	

								_positionResults();
							});

					}
				}
			},

			/**
			 * Toggles the selected state of a node
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_toggleNodeSelection = function (e) {
				var node = $( e.currentTarget );

				// Is this node already selected?
				if( node.hasClass('ipsSelectTree_selected') ){
					_unselectNode( node, e );
				} else {
					_selectNode( node, e );
				}

				_updateSelectedValues();
			},

			/**
			 * Load more nodes
			 *
			 * @param 	{Event} 	e 		Event object
			 * @returns {void}
			 */
			 _nodeLoadMore = function(e) {
				e.stopPropagation();
			 	var offset = results.find('[data-action="nodeLoadMore"]').attr('data-offset');
			 	var url = options.url + '&_nodeSelect=loadMore&_nodeSelectOffset=' + offset;

			 	results.find('[data-action="nodeLoadMore"] span.ipsLoading').removeClass('ipsHide');
			 	results.find('[data-action="nodeLoadMore"] > a.ipsButton').addClass('ipsButton--disabled');

				// Fetch it
				ips.getAjax()( url )
					.done( function (response) {
						if( !_.isUndefined( response.globalOutput ) )
						{
							results.find('[data-role="globalNodeList"]').append( response.globalOutput );

							if( !_.isUndefined( response.clubsOutput ) )
							{
								results.find('[data-role="clubNodeList"]').append( response.clubsOutput );
							}
						}
						else
						{
							results.find('[data-role="nodeList"]').append( response.output );
						}

						results.find('[data-action="nodeLoadMore"] span.ipsLoading').addClass('ipsHide');

						if( response.loadMore )
						{
							results.find('[data-action="nodeLoadMore"]').attr( 'data-offset', response.loadMore );
						}
						else
						{
							results.find('[data-action="nodeLoadMore"]').addClass( 'ipsHide' );
						}

						results.find('[data-action="nodeLoadMore"] > a.ipsButton').removeClass('ipsButton--disabled');

						results.find('[data-role="nodeList"]').find('.ipsSelectTree_item').each(function(){
							if ( $(this).attr('data-id') && selectedItems.indexOf( $(this).attr('data-id') ) != -1 ) {
								$(this).addClass('ipsSelectTree_selected');
							}
						});	

						_positionResults();
					});
			 },

			/**
			 * Selects the provided node
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_selectNode = function (node, e) {				
				// Remove selected class from other nodes
				if( !options.multiple ){
					elem.find('.ipsSelectTree_selected').removeClass('ipsSelectTree_selected');
				}

				// Add our selected class
				node.addClass('ipsSelectTree_selected');

				var title = node.find('[data-role="nodeTitle"]').text();
				var id = node.attr('data-id');

				// Add the value to the select box
				if( !options.multiple ){
					_setValue( title );
				} else {
					_addToken( title, id );
				}

				// Add value to our array
				if( options.multiple ){
					selectedItems.push( node.attr('data-id') );
				} else {
					selectedItems = [ node.attr('data-id') ];
				}

				// If this node has children, we'll also load them
				if( e ){
					_toggleChildren(e, true);
				}

				// Emit event that node items have been updated
				elem.trigger( 'nodeItemSelected', {
					title: title,
					id: id
				});

				// If we aren't allowing multiple selections, close the widget now
				if( !options.multiple && !node.hasClass('ipsSelectTree_withChildren') ){
					setTimeout( function () {
						_closeResults();
					}, 200 );
				}
			},

			/**
			 * Unselects the provided node
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_unselectNode = function (node, e) {
				// Remove selected class from this node
				node.removeClass('ipsSelectTree_selected');

				// Remove value from our selected items
				selectedItems = _.without( selectedItems, node.attr('data-id') );
				
				// Emit event that node items have been updated
				elem.trigger( 'nodeItemUnselected', {
					title: node.find('[data-role="nodeTitle"]').text(),
					id: node.attr('data-id')
				});
				
				if( !options.multiple ){
					_setValue();
				} else {
					_removeToken( node );
				}
			},

			/**
			 * Adds a token to the select
			 *
			 * @param 	{string} 	value 		Value to set
			 * @returns {void}
			 */
			_addToken = function (title, id) {
				var valueElem = elem.find('.ipsSelectTree_value');
				var elemHeight = elem.outerHeight();

				if( !elem.find('[data-role="tokenList"]').length ){
					valueElem.html( $('<ul/>').attr('data-role', 'tokenList' ) );
				}

				elem.find('[data-role="tokenList"]').append( ips.templates.render('core.selectTree.token', {
					title: title,
					id: id
				}) );

				elem.find('.ipsSelectTree_value').removeClass('ipsSelectTree_placeholder');

				// Recheck the height
				if( elemHeight != elem.outerHeight() ){
					_positionResults();
				}
			},

			/**
			 * Removes a token from the selector
			 *
			 * @param 	{string} 	value 		Value to set
			 * @returns {void}
			 */
			_removeToken = function (node) {
				var id = node.attr('data-id');
				var tokenList = elem.find('[data-role="tokenList"]');
				var elemHeight = elem.outerHeight();

				// Find the token
				var token = tokenList.find('[data-nodeId="' + id + '"]').closest('li').remove();

				if( !tokenList.find('[data-nodeId]').length ){
					tokenList.remove();
					_setValue();
				}

				// Recheck the height
				if( elemHeight != elem.outerHeight() ){
					_positionResults();
				}

			},

			/**
			 * Updates the hidden form field containing our current values
			 *
			 * @returns {void}
			 */
			_updateSelectedValues = function () {
				elem.find('[data-role="nodeValue"]').val( _.uniq( selectedItems ).join(',') );

				// Emit event that node items have been updated
				elem.trigger( 'nodeSelectedChanged', {
					selectedItems: selectedItems
				});
			},

			/**
			 * Changes the value of the select box
			 *
			 * @param 	{string} 	value 		Value to set
			 * @returns {void}
			 */
			_setValue = function (value) {
				if( value ){
					elem.find('.ipsSelectTree_value').text( value ).removeClass('ipsSelectTree_placeholder');
				} else {
					elem.find('.ipsSelectTree_value').text( ( options.placeholder ) ? options.placeholder : ips.getString('select') ).addClass('ipsSelectTree_placeholder');
				}
			},

			/**
			 * Toggle showing the results list
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_toggleResults = function (e) {
				if( !$(results).get(0).classList.contains('ipsSelectTree_nodes--collapsed') && results.is(':visible') ){
					_maybeHideResults(e);
				} else {
					_showResults(e);
				}
			},

			/**
			 * Hides the results panel if the click is not within the results (i.e. if it's on the select itself)
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_maybeHideResults = function (e) {
				var rawResults = results.get(0);

				if( ( !$.contains( rawResults, e.target ) && rawResults != e.target ) ){
					_closeResults();
				}
			},

			/**
			 * Closes the results list
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_closeResults = function () {
				if ($(elem).closest('i-dropdown').length) {
					$(results).addClass('ipsSelectTree_nodes--collapsed');
				} else {
					ips.utils.anim.go('fadeOut fast', results);
				}
				$( document ).off('click.' + elemID );
				elem.removeClass('ipsSelectTree_active');
				elem.trigger( 'nodeSelectionClosed' );
			},

			/**
			 * Show the results list
			 *
			 * @returns {void}
			 */
			_showResults = function () {
				// Don't collapse if this is automatically expanded
				if (!autoExpand) {
					$(document).on('click.' + elemID, _closeResultsOnBlur);
				}

				if ($(elem).closest('i-dropdown').length) {
					$(results).removeClass("ipsSelectTree_nodes--collapsed");
				} else {
					_positionResults();
					results.show();
				}

				elem.addClass('ipsSelectTree_active');

				// Focus the text box if searching is enabled
				if( elem.find('[data-role="nodeSearch"]') ){
					elem.find('[data-role="nodeSearch"]').focus();
				}
			},

			/**
			 * Position the results panel so that it appears attached to the select
			 *
			 * @returns {void}
			 */
			_positionResults = function () {
				// are we in a dropdown? Then don't do anything since the element needs to be simply placed after the form element to prevent overflow/clipping issues
				if ($(elem).closest('i-dropdown').length) {
					return;
				}
				var above = false;			
				var elemTop = elem.offset().top;
				var elemHeight = elem.height();

				// Do we need to prefer upwards-opening due to being near the bottom of the browser?
				if( ( elemTop + elemHeight + results.height() ) > $(window).height() ){
					above = true;

					var scrollParent = _getScrollParent();
					var scrollParentTop = $(scrollParent).offset().top;

					Debug.log("elemTop: " + elemTop);
					Debug.log("elemTop - resultsHeight: " + (elemTop - results.height()));
					Debug.log("scrollParentTop: " + scrollParentTop);

					// If our selecttree is inside a scrollable container (including <body>), we need to make sure
					// that if it opens upwards that it won't extend beyond the top, otherwise some items won't
					// be visible. In that case, we'll go back to opening downwards.
					if( ( elemTop - results.height() ) < scrollParentTop ){
						above = false;
					}
					
				}

				// Get position of select box
				var positionInfo = {
					trigger: elem,
					target: results,
					targetContainer: elem,
					above: above
				};

				var resultsPosition = ips.utils.position.positionElem( positionInfo );

				results.css({
					top: resultsPosition.top + 'px',
					zIndex: ips.ui.zIndex()
				});

				if( resultsPosition.location.vertical == 'top' ){
					results.removeClass('ipsSelectTree_bottom').addClass('ipsSelectTree_top');
					elem.removeClass('ipsSelectTree_bottom').addClass('ipsSelectTree_top');
				} else {
					results.removeClass('ipsSelectTree_top').addClass('ipsSelectTree_bottom');
					elem.removeClass('ipsSelectTree_top').addClass('ipsSelectTree_bottom');
				}
			},

			/**
			 * Close the results list when the element is blurred
			 *
			 * @param 	{event} 	e 		Event object
			 * @returns {void}
			 */
			_closeResultsOnBlur = function (e) {
				if( !_clickIsInElem( e.target ) ){
					_closeResults();
				}
			},

			/**
			 * Determines whether the provided target element is contained within the select or results list
			 *
			 * @param 	{element} 	target 		Target element
			 * @returns {boolean}
			 */
			_clickIsInElem = function (target) {
				var rawElem = elem.get(0);
				var rawResults = results.get(0);

				if( target == rawElem || target == rawResults || $.contains( rawResults, target ) || $.contains( rawElem, target ) ){
					return true;
				}

				return false;
			},

			_getScrollParent = function (includeHidden) {
				var element = elem.get(0);
				var style = getComputedStyle(element);
				var excludeStaticParent = style.position === "absolute";
				var overflowRegex = /(auto|scroll|hidden)/;

				if (style.position === "fixed") {
					return document.body;
				}
				
				for (var parent = element; (parent = parent.parentElement); ) {
					style = getComputedStyle(parent);
					if (excludeStaticParent && style.position === "static") {
						continue;
					}
					if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {
						return parent;
					}
				}

				return document.body;
			}

			init();

			return {
				destruct
			};
		}

		ips.ui.registerWidget( 'selectTree', ips.ui.selectTree, [
			'placeholder', 'multiple', 'selected', 'url', 'searchable'
		] );

		return {
			respond: respond,
			destruct: destruct
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.sideMenu.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.sideMenu.js - Side menu widget. Simple widget that adds responsive interactivity to side menus
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.sideMenu', function(){

		var defaults = {
			type: 'radio',
			responsive: true,
			group: false
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_sidemenu') ){
				$( elem ).data('_sidemenu', sideMenuObj(elem, _.defaults( options, defaults ) ) );
			}
		};

		ips.ui.registerWidget( 'sideMenu', ips.ui.sideMenu, [
			'responsive', 'type', 'group'
		] );


		/**
		 * Side menu instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		var sideMenuObj = function (elem, options) {

			var init = function () {
				if( options.responsive && ips.utils.responsive.enabled() ){
					$( elem ).on( 'click', '[data-action="openSideMenu"]', _toggleSideMenu );
				}

				// Set up event
				$( elem ).on( 'click', '.ipsSideMenu_item', _clickEvent );
				$( elem ).on( 'selectItem.sideMenu', _selectItem );
			},

			/**
			 * Handles click events on the items
			 *
			 * @param	{event} 	e 		Event object
			 * @returns {void}
			 */
			_clickEvent = function (e) {
				_doSelectItem( $( e.currentTarget ), e );
				_toggleSideMenu();
			},

			/**
			 * Handles a selectItem event
			 *
			 * @param	{event} 	e 		Event object
			 * @param	{object} 	data	Event data object
			 * @returns {void}
			 */
			_selectItem = function (e, data) {
				_doSelectItem( elem.find('[data-ipsMenuValue="' + data.value + '"]'), e );
			},

			/**
			 * Selects an item in the menu
			 *
			 * @param 	{element} 	item 	jQuery object containing the menu item to be selected
			 * @param	{event} 	e 		Event object
			 * @returns {void}
			 */
			_doSelectItem = function (item, e) {

				// We'll only handle the click in this widget if the item has a menu value attribute
				if( ( _.isUndefined( item.attr('data-ipsMenuValue') ) && !item.find('input[type="radio"], input[type="checkbox"]').length ) ||
						!item.length ){
					return;
				}

				if( e ){
					e.preventDefault();
				}

				// If this item is disabled, bail out
				if( item.hasClass('ipsSideMenu_itemDisabled') ){
					return;
				}

				var workingItems;

				if( !options.group ){
					workingItems = $( elem ).find('.ipsSideMenu_item');
				} else {
					workingItems = item.closest('.ipsSideMenu__list').find('.ipsSideMenu_item');
				}

				if( options.type === 'check' ){
					/** @type {HTMLElement} item */
					item = $(item).get(0);
					item
						.classList[item.classList.contains('ipsSideMenu_itemActive') ? 'remove' : 'add']('ipsSideMenu_itemActive');

					item
						.querySelectorAll('input[type="radio"], input[type="checkbox"]')
						.forEach(input => {
							input.checked = !input.checked;
							input.dispatchEvent(new CustomEvent('change', {bubbles: true}));
						});
				} else {
					const items = [...workingItems]
					items.forEach(item => {
						item.classList.remove('ipsSideMenu_itemActive')
						item.querySelectorAll('input[type="radio"], input[type="checkbox"]')
							.forEach(input => {
								if (input.checked) {
									input.checked = false;
									input.dispatchEvent(new CustomEvent('change', {bubbles: true}))
								}
							});
					});

					item = $(item).get(0);
					item.classList.add('ipsSideMenu_itemActive')
					item.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
						if (!input.checked) {
							input.checked = true;
							input.dispatchEvent(new CustomEvent("change", {bubbles: true}));
						}
					});
				}

				// Get all selected items
				var selectedItems = [];

				workingItems.filter('.ipsSideMenu_itemActive').each( function () {
					selectedItems.push( $( this ).attr('data-ipsMenuValue') );
				});

				$( elem ).trigger('itemClicked.sideMenu', {
					id: $( elem ).identify().attr('id'),
					menuElem: $( elem ),
					selectedElem: $(item),
					selectedItemID: $(item).attr('data-ipsMenuValue'),
					selectedItems: selectedItems
				});
			},

			/**
			 * Toggles the menu when in responsive mode
			 *
			 * @param	{Event} 	e 		Event object
			 * @returns {void}
			 */
			_toggleSideMenu = function (e) {
				if( e ){
					e.preventDefault();	
				}				

				// var menuContainer = $( elem ).find('.ipsSideMenu__menu');
				$(elem).toggleClass('ipsSideMenu_open');
				$(elem)
					.find('.ipsSideMenu__view')
					.each(function() {
						this.scrollIntoView({behavior: "smooth"})}
					);

				/* if( $( elem ).hasClass('ipsSideMenu_open') ){
					$( elem ).removeClass('ipsSideMenu_open');
				} else {
					$( elem ).addClass('ipsSideMenu_open');
					// ips.utils.anim.go('fadeIn', menuContainer );
				}*/
			};

			init();

			return {};
		};

		return {
			respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.spoiler.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.spoiler.js - Spoiler widget for use in posts
 * Content is hidden until the user elects to view it
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";



	ips.createModule('ips.ui.spoiler', function(){

		/**
		 * Responder for spoiler widget
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @param	{event} 	e 		 	The event object passed through
		 * @returns {void}
		 */
		function respond(elem, options, e) {

			/* Create a details element and put the legacy spoiler contents inside it */
			elem.contents().hide();
			const details = document.createElement('details');
			for (const attr of [...$(elem).get(0).getAttributeNames()]) {
				try {
					details.setAttribute(attr, $(elem).get(0).getAttribute(attr));
				} catch (e) {
					Debug.warn(e);
				}
			}
			$(elem).get(0).after(details);
			elem.hide();

			for (const child of [...$(elem).get(0).childNodes]) {
				details.appendChild(child);
			}
			elem = $(details);

			/* Do we have an existing citation block? (quotes from older versions won't, newer will) */
			var existingHeader = elem.children('.ipsSpoiler_header');

			/* Build the header block */
			var header = ips.templates.render( 'core.editor.spoilerHeader' );

			/* Add or replace it */
			if ( existingHeader.length ) {
				existingHeader.replaceWith( header );
			} else {
				elem.prepend( header );
			}

			/* Set the event handler for opening/closing */
			elem.find('> .ipsSpoiler_header').on( 'click', _toggleSpoiler );
		}
		
		/**
		 * Event handler for toggling the spoiler visibility
		 *
		 * @param 	{Event} 	e 		Event object
		 * @returns {void}
		 */
		function _toggleSpoiler(e) {
			var header = $( e.currentTarget );
			var target = $( e.target );
			var spoiler = $( e.target ).closest('[data-ipsSpoiler]');

			if( target.is('a:not( [data-action="toggleSpoiler"] )') || ( target.closest('a').length && !target.closest('a').is('[data-action="toggleSpoiler"]') ) ){
				return;
			}

			e.preventDefault();

			if( header.hasClass('ipsSpoiler_closed') ){
				spoiler.attr('open', '');
				ips.utils.anim.go( 'fadeIn', header.siblings() );
				header.removeClass('ipsSpoiler_closed').addClass('ipsSpoiler_open').find('span').text( ips.getString('spoilerClickToHide') );
				$( document ).trigger('contentChange', [ spoiler ] );
			} else {
				spoiler.attr('open', null);
				header.siblings().hide();
				header.removeClass('ipsSpoiler_open').addClass('ipsSpoiler_closed').find('span').text( ips.getString('spoilerClickToReveal') );
			}

			e.stopPropagation();
		}
		
		// Register this widget with ips.ui
		ips.ui.registerWidget( 'spoiler', ips.ui.spoiler );

		return {
			respond: respond
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.stack.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.stack.js - Stack widget for use in ACP
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.stack', function(){

		var defaults = {
			sortable: true,
			itemTemplate: 'core.forms.stack'
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_stack') ){
				$( elem ).data('_stack', stackObj( elem, _.defaults( options, defaults ) ) );
			}
		};

		ips.ui.registerWidget( 'stack', ips.ui.stack, [
			'sortable', 'maxItems', 'itemTemplate'
		]);

		return {
			respond: respond
		};
	});

	/**
	 * Stack instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var stackObj = function (elem, options) {

		var stack = null;
		var currentIndex = 0;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
								
			if ( !elem.attr('data-initiated') ) {
				stack = elem.find('[data-role="stack"]');
				currentIndex = _getItemCount();

				if( options.maxItems && currentIndex >= options.maxItems ){
					elem.find('[data-action="stackAdd"]').hide();
				}

				// Events
				elem.on( 'click', '[data-action="stackAdd"]', _addItem );
				elem.on( 'click', '[data-action="stackDelete"]', _deleteItem );
				elem.on( 'keydown', '[data-role="stackItem"] input[type="text"]', _keyDown );
	
				if( options.sortable ){
					ips.loader.get( ['core/interface/jquery/jquery-ui.js'] ).then( function () {
						stack.sortable( {
							handle: '[data-action="stackDrag"]'
						});
					});
				}
				
				elem.attr( 'data-initiated', 'true' );

				$( elem ).trigger( 'stackInitialized', {
					count: _getItemCount()
				});
			}
		},

		/**
		 * Event handler for keydown event in a stack textbox
		 * Creates a new stack row if Enter is pressed
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_keyDown = function (e) {
			if( e.keyCode == ips.ui.key.ENTER ){
				e.preventDefault();
				_addItem(null, $( e.currentTarget ).closest('[data-role="stackItem"]') );
			}
		},

		/**
		 * Event handler for the Add Item link
		 * Adds a new stack row, either at the end of the stack or after a provided element
		 *
		 * @param 	{event} 	e 			Event object
		 * @param 	{element} 	[after] 	Optional element after which the new row should be inserted
		 * @returns {void}
		 */
		_addItem = function (e, after) {
						
			if( e ){
				e.preventDefault();
			}

			if( options.maxItems && _getItemCount() >= options.maxItems ){
				return;
			}

			currentIndex++;
			
			var field = stack.find('[data-ipsStack-wrapper]')
				.first()
				.html()
				.replace( /(name=['"][a-zA-Z0-9\-_]+?)\[([^\]]+?)?\]/g, '$1[' + currentIndex + ']' )
				.replace( /data-ipsFormData=['"](.+?)['"]/ig, '' )
				.replace( /id=['"](.+?)['"]/g, 'id="$1_' + currentIndex + '"' )
				.replace( /data-toggles=['"](.+?)['"]/g, function (match, p1) {
					var pieces = p1.split(',');
					var newPieces = [];

					_.each( pieces, function (val) {
						if( val.match( /_[0-9]+$/g) ){
							newPieces.push( val + '_' + currentIndex );
						} else {
							newPieces.push( val );
						}
					});

					return 'data-toggles="' + newPieces.join(',') + '"';
				});

			field = field.replace( /\<input(.+?)value=['"](.*?)['"](.*?)\>/g, '<input$1value=""$3>' );

			if( stack.find('select').length ) {
				field = field.replace( /\<option(.+?)selected(?:=['"]selected["'])?(.*?)\>/g, '<option$1$2>' );
			}

			var html = ips.templates.render( options.itemTemplate, {
				field: field
			});

			// Insert the new row either at the end of the stack or after the current item
			if( after ){
				after
					.after( html )
					.next('[data-role="stackItem"]')
						.find('input,textarea')
							.focus();
			} else {
				stack
					.append( html )
					.find('[data-role="stackItem"] input,[data-role="stackItem"] textarea')
						.last()
						.focus();
			}

			if( options.maxItems && _getItemCount() >= options.maxItems ){
				elem.find('[data-action="stackAdd"]').hide();
			}

			$( document ).trigger( 'contentChange', [ elem ] );

			$( elem ).trigger( 'stackRowAdded', {
				count: _getItemCount()
			});
		},

		/**
		 * Event handler for the Delete Item link
		 * Removes the row from the stack
		 *
		 * @param 	{event} 	e 			Event object
		 * @returns {void}
		 */
		_deleteItem = function (e) {
			e.preventDefault();
			var row = $( e.currentTarget ).closest('[data-role="stackItem"]');

			if( _getItemCount() === 1 ){
				// Only one item left, so just empty it
				row.find('input,textarea').val('');
				row.find("option:selected").removeAttr("selected");
				return;
			}

			ips.utils.anim.go( 'fadeOutDown', row )
				.done( function () {
					row.hide();
					// Add a little timeout before removing, so that any widgets
					// which rely on clicks work properly, e.g. menus
					setTimeout( function () {
						row.remove();
                        if( options.maxItems && _getItemCount() < options.maxItems ){
                            elem.find('[data-action="stackAdd"]').show();
                        }
					}, 100);
				});
		},

		/**
		 * Returns a count of the number of items in the stack
		 *
		 * @returns {number}
		 */
		_getItemCount = function () {
			return stack.find('[data-role="stackItem"]').length;
		};

		init();
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.tabbar.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.tabbar.js - A tab bar UI component
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.createModule('ips.ui.tabbar', function(){

		// Default widget options
		const defaults = {
			itemSelector: '.ipsTabs__tab', // The CSS selector used to find clickable tab items
			activeClass: false, // Classname applied to the active item
			loadingClass: 'ipsLoading ipsTabs_loadingContent', // Classname applied to loading panel
			panelClass: 'ipsTabs__panel', // Classname applied to panels
			updateURL: true, // Whether the browser URL should be updated when tab is switched
			updateTitle: false, // Whether the browser title should also be updated, when updateURL is true
			disableNav: false // Disables fancy tab loading functionality. Ideal for using this widget just for the mobile tab menu.
		};

		// Register this widget with ips.ui
		ips.ui.registerWidget('tabbar', ips.ui.tabbar, [ 
			'contentArea', 'itemSelector', 'activeClass', 'loadingClass', 'disableNav',
			'panelClass', 'updateURL', 'updateTitle'
		]);

		return {
			/**
			 * Responder for tab widget
			 *
			 * @param	{element} 	elem 		The element this widget is being created on
			 * @param	{object} 	options 	The options passed into this instance
			 * @returns {void}
			 */
			respond(elem, options) {
				if( !$( elem ).data('_tabbar') ){
					$( elem ).data('_tabbar', tabBarObj(elem, _.defaults( options, defaults ) ) );
				}
			}
		};
	});

	/**
	 * Tab Bar instance
	 * Handles events and logic for a single tab bar instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {{init: function}}
	 */
	function tabBarObj(elem, options) {
		/** @type {HTMLElement} */
		const rawElem = $(elem).get(0);
		const tabs = $(elem).find(options.itemSelector);	// Collection of the tabs in this bar
		let barId = rawElem.id; // ID of this tab bar
		let active;	// The active tab
		let ajaxObj; // Reference to the ajax object we use

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		function init() {

			if (!barId) {
				barId = $(rawElem).identify().attr('id');
			}

			if (!options.contentArea || !$(options.contentArea).length) {
				options.contentArea = '#' + $( rawElem ).next().identify().attr('id');
			}

			if (!tabs.length) {
				Debug.warn( "No tabs found in tab bar" + barId );
				return;
			}

			// Find our active tab
			active = _getActiveTab();

			// And do we need to enable it?
			_initializeActive();

			// Finally set the event handlers
			$( elem ).on( 'click', options.itemSelector, _handleTabClick );


			// Query elements for scrollable button functionality
			let tabbar = elem[0],
				tablist = tabbar.querySelector('[role="tablist"]'),
				scrollers = tabbar.querySelector('[data-role="tabScrollers"]');

			if (scrollers) {
				// If scrollers already exist, add the click event
				scrollers.addEventListener("click", e => _handleScrollerClick(e, tablist));

				// Determine if first/last tabs are visible, and show arrows based on their intersectionRatio. The .99 caters for sub-pixel rounding
				let scrollerObserver = new IntersectionObserver(
					tabs => tabs.forEach(
						tab => tabbar.querySelector(`[data-direction="${tab.target.matches(':first-child') ? 'prev' : 'next'}"]`).hidden = tab.intersectionRatio > .99
					),
					{
						root: tablist,
						threshold: 0.99
					}
				);

				// Attach intersection observer to first and last tab
				tablist.querySelectorAll(':scope > :first-child, :scope > :last-child').forEach(el => { scrollerObserver.observe(el) });
			}

		}

		/**
		 * Event handler for a tab click
		 *
		 * @param	{Event} 	e 	Event object
		 * @param {HTMLElement|jQuery} tablist
		 *
		 * @returns {void}
		 */
		function _handleScrollerClick(e, tablist) {
			let direction = e.target.closest('button').getAttribute("data-direction"),
				currentScroll = tablist.scrollLeft,
				listWidth = tablist.offsetWidth / 2;

			if (direction === "prev") {
				listWidth = -listWidth;
			}

			// Scroll tab bar by 50%. We don't want to scroll the entire width, since some tabs may be obscured by the scroll buttons
			tablist.scrollTo({left: currentScroll + listWidth, behavior:"smooth"})
		}

		/**
		 * Event handler for a tab click
		 *
		 * @param	{MouseEvent|Event} 	e 	Event object
		 *
		 * @this {HTMLElement}
		 * @returns {void}
		 */
		function _handleTabClick(e) {
			// If we aren't handling any navigation here, then let the browser handle it
			if (options.disableNav) {
				return;
			}

			e.preventDefault();

			// Is this tab active?
			if ($(this).attr('aria-selected') === 'true') {
				return;
			}
			let thisId = $(this).identify().attr('id'),
				thisContent = $('#' + $(this).attr('aria-controls'));

			// Fallback to legacy panel name if the aria-controls element doesn't exist
			if(!thisContent.length){
				thisContent = $('#' + thisId + '_panel');
			}

			// Does this tab content area exist already?
			if (!thisContent.length) {
				thisContent = _createTabPanel(thisId);
				// Load content
				_loadContent(this, thisContent)
					.done(() => _switchTab( thisId ))
					.fail(() => Debug.log('failed'));
			} else {
				_hideAllPanels();
				_switchTab( thisId );
			}

			// Update URL if necessary
			_updateURL( thisId );
		}

		/**
		 * Switches to the specified tab
		 *
		 * @param	{string} 	tabId 		ID of the tab to make active
		 * @returns {void}
		 */
		function _switchTab(tabId) {

			// Hide all panels
			_hideAllPanels();

			// Get the new panel
			const thisContent = $('#' + tabId + '_panel'),
				thisContentParent = document.querySelector(elem[0].getAttribute("data-ipstabbar-contentarea"));

			thisContent.removeAttr( 'hidden' );

			$( elem ).trigger('tabShown', {
				barID: barId,
				tabID: tabId,
				tab: active,
				panel: thisContent
			});

			// Let everyone know
			$( document ).trigger( 'contentChange', [ thisContent ] );

			// Scroll to top of tab area if it's not visible. This is helpful when the sidemenu is very long, such as "See my activity" in profiles.
			// The exception is tabs inside .ipsMenu (such as the "Edit widget" menu) and .ipsDialog (Select Category in Gallery upload form)
			if(elem[0].matches(".ipsTabs--sticky") && thisContentParent && window.scrollY > thisContentParent.offsetTop){
				thisContentParent.scrollIntoView({ behavior: "smooth" });
			}

			// Set as active
			active = $( '#' + tabId );

			// Switch tab
			_makeTabActive( active );

			// Let document know
			$(elem).trigger('tabChanged', {
				barID: barId,
				tabID: tabId,
				tab: active,
				panel: thisContent
			});

		}

		/**
		 * Updates the browser URL
		 *
		 * @param	{string} 	tabId 	ID of the tab to make active
		 * @returns {void}
		 */
		function _updateURL(tabId) {
			if (!options.updateURL) {
				return;
			}

			const tabLink = $(`#${tabId}`);
			const href = tabLink.attr('href');
			const title = ( options.updateTitle && tabLink.attr('title') ) ? tabLink.attr('title') : document.title;

			if (!_.isEmpty(href) && !href.startsWith('#')) {
				// Replace the current state
				ips.utils.history.replaceState({}, 'ips.ui.tabbar', href);
				document.title = title

				// Track page view
				ips.utils.analytics.trackPageView(href);
			}
		}

		/**
		 * Determines which tab is 'active'
		 *
		 * @returns 	{element}	The tab deemed to be 'active'
		 */
		function _getActiveTab() {

			// Try [aria-selected] first
			const activeTab = elem.find('[aria-selected="true"]');

			if (activeTab.length) {
				return activeTab.get(0);
			}

			// Otherwise just return the first tab
			return $(elem).find(options.itemSelector).first();
		}

		/**
		 * Initializes the tab that is first to be active
		 *
		 * @returns {void}
		 */
		function _initializeActive() {
			// Do we have an active panel?
			const activeId = $(active).identify().attr('id');

			if( !$( '#' + activeId + '_panel' ).length ){
				if( $( options.contentArea ).children().length ){
					// We have content in the content area, so make that this panel
					$( options.contentArea ).wrapInner( _createTabPanel( activeId, true ) );
					_switchTab( activeId );
				} else {
					// Load content
					var newPanel = _createTabPanel( activeId );
					_loadContent( active, newPanel ).done( function () {
						_switchTab( activeId );
					});
				}
			} else {
				_switchTab( activeId );
			}
		}

		/**
		 * Makes a tab active and other tabs inactive
		 *
		 * @param 	{Element} 	activeTab 	Reference to the tab to make active
		 * @returns {void}
		 */
		function _makeTabActive(activeTab) {

			// Unselect all tabs
			$( elem )
				.find( options.itemSelector )
				.attr( 'aria-selected', 'false' );

			if(options.activeClass){
				$(elem).find( options.itemSelector ).removeClass( options.activeClass );
			}

			// Select the new tab
			$( activeTab )
				.attr( 'aria-selected', 'true' );

			if(options.activeClass){
				$(activeTab).addClass( options.activeClass );
			}
		}

		/**
		 * Loads and inserts content via ajax
		 *
		 * @param	{element} 	tab 		The tab element being loaded
		 * @param	{element} 	container 	The container panel for the content
		 * @returns {promise} 	Promise object
		 */
		function _loadContent(tab, container) {
			let url;
			const deferred = $.Deferred();

			// Hide all other panels before we start
			_hideAllPanels();

			// Which URL should we load?
			if( $( tab ).attr('data-tabURL') ){
				url = $( tab ).attr('data-tabURL');
			} else {
				url = $(tab).attr('href');
			}

			// Set loading class
			$( options.contentArea ).addClass( options.loadingClass );

			// Get ajax object
			ajaxObj = ips.getAjax();

			ajaxObj(url)
				.done(response => {
					$(container).html(response);

					// Let everyone know
					//$( document ).trigger( 'contentChange', [ container ] );

					// Resolve promise so callbacks can execute
					deferred.resolve();
				})
				.fail(() => window.location = $( tab ).attr('href'))
				.always(() => $( options.contentArea ).removeClass( options.loadingClass ));

			return deferred.promise();
		}

		/**
		 * Hides all tab panels
		 * @returns 	{element} 	The new panel
		 */
		function _hideAllPanels() {
			$( options.contentArea )
				.find( '> .' + options.panelClass )
				.attr('hidden', '');
		}

		/**
		 * Creates an empty panel for the specific tab
		 *
		 * @param	{string} 	tabId 		Tab ID from which the panel is being created
		 * @param 	{boolean} 	[noAppend=false] 	Whether to not append this to the content area
		 * @returns {element} 	The new panel
		 */
		function _createTabPanel(tabId, noAppend=false) {

			const newPanel = $('<div/>')
				.attr({'id': tabId + '_panel'})
				.addClass(options.panelClass)
				.attr({'role': 'tabpanel'})
				.attr({'aria-labelledby': tabId});

			if( !noAppend ){
				$( options.contentArea ).append( newPanel );
			}

			return newPanel;
		}

		init();

		return { init };
	}

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.tableOfContents.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/* global ips, _ */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.tableOfContents - Table of contents widget
 * This widget creates and manages a table of contents for a page
 *
 * Author: Matt Finger
 */

;(($, _) => {
    "use strict";

    /**
     * @typedef {{item?: Element, title: string, fullText: string, children?: TableOfContentsTree[], id: string}} TableOfContentsTree
     *
     */

    /**
     * @typedef     ItemDef
     * @property    {string}    selector    This is the selector to get the item in the DOM. The selector should be unique
     * @property    {number}    [indentLevel]   This is the amount the item is indented in the TOC. It should be treated as 0 if empty
     * @property    {string}    selectorHash    The id generated by the item's innerText and its selector. It is set as the id used in the url anchor,
     */

    /**
     * @typedef {{currentItems: null|ItemDef[], canEdit: boolean}} TableOfContentsOptions
     */

    /**
     * @type {TableOfContentsOptions}
     */
    const defaults = {
        currentitems: [],
        canEdit: false
    }

    const _globalExclude = () => `:not(.ipsTableOfContents *, .ipsEdited, aside *, #elPostFeed [data-ips-hook="postWrapper"] :not([data-first-post] *))`;
    const _pagebuilderContainer = () => `:is([data-blockid*="app_cms_Wysiwyg"], [data-blockid*="app_cms_Codemirror"], [data-pageid] [data-widgetarea*="col"] [data-blockid]) > .ipsWidget__content`
    const _rootTocTextNodes = () => `:is(p,h1,h2,h3,h4,h5,h6)`;
    const _doubleNestedTocTextNodes = () => `:is(details, .ipsRichTextBox) > :is(summary, .ipsRichTextBox__title)`
    const _contentFeedItem = () => `:is(:is(.ipsRichText--user, .ipsRichText--user > [data-ipstruncate]), [data-role="imageDescription"] .ipsRichText, [data-commentid] [data-ips-hook="postContent"]${ips.getSetting('firstPostID') ? `, [data-ips-hook="topicPostFeed"] [data-commentid="${ips.getSetting('firstPostID')}"]` : ''})`;


    /**
     * A base selector for getting potential titles of the page
     *
     * @type {function:string}
     */
    const _baseSelector = () => `
[data-ips-hook="main"] :is(
    :is(
        :is(${_contentFeedItem()},${_pagebuilderContainer()}) > ${_rootTocTextNodes()},
        :is(${_contentFeedItem()},${_pagebuilderContainer()}) > ${_doubleNestedTocTextNodes()},
        [data-ips-hook*="entry__"] [data-ips-hook*="contentTitle__"]
    )${_globalExclude()}
)`;


    class TableOfContents {
        /**
         *
         * @type {Map<Element, TableOfContents>}
         */
        static _instanceMap = new Map()

        static get instanceMap () {
            return this._instanceMap
        }

        /**
         *
         * @type {boolean}
         */
        static canEdit = false

        static _modified = false;

        static _hashes = {}

        /**
         * The tree structure of the list
         *
         * @type {TableOfContentsTree[]|undefined}
         * @private
         */
        static __tree = []

        static get _tree() {
            return this.__tree;
        }

        static set _tree(value) {
            if (!Array.isArray(value)) {
                throw new TypeError(`The tree is not an array`);
            }

            this.__tree = value
            const hash = ips.utils.crypto.md5(JSON.stringify(this.__tree))
            if (this._hashes.tree === hash) {
                return
            }

            if (this._modified) {
                this._saveState();
                this._modified = false;
            }

            this._hashes.tree = hash;

            this.drawLinks()
            for (const instance of this._instanceMap.values()) {
                instance._renderTree()
            }
        }

        /**
         * The 1D list of items in the tree. Each item defines its own indent level
         * @type {ItemDef[]}
         * @private
         */
        static __treeList = []

        /**
         *
         * @return {ItemDef[]}
         * @private
         */
        static get _treeList() {
            return this.__treeList
        }

        /**
         *
         * @param {ItemDef[]}   value
         * @private
         */
        static set _treeList(value) {
            if (!Array.isArray(value)) {
                throw new TypeError(`Cannot set a tree list to a non-array value`)
            }

            const selectorsBefore = new Set(value.map(item => item.selector));
            this.__treeList = this._cleanItems(value)

            // we consider it modified, and to be saved, if the selectors were rewritten. This likely indicates the content was changed, either via a theme update, page reordering, or just simply editing the contents
            if (this.__treeList.some(item => !selectorsBefore.has(item.selector))) {
                Debug.log('Setting table of contents as modified because an item\'s selector was updated.');
                this._modified = true;
            }

            const currentHash = ips.utils.crypto.md5(JSON.stringify(this.__treeList))
            if (this._hashes.treeList === currentHash) {
                return
            }

            this._hashes.treeList = currentHash
            this._tree = this.buildTreeFromItems(this.__treeList)
        }

        /**
         * Create a new table of contents
         *
         * @param {Element}                 elem
         * @param {TableOfContentsOptions}  options
         */
        constructor(elem, options) {
            this.options = options;
            this.elem = elem;
            this._renderTree()
        }

        /**
         * Check if an id is in the tree
         *
         * @param {TableOfContentsTree[]|undefined}   tree
         * @param {string|Element}    searchId
         *
         * @return {boolean}
         */
        static inTree(tree, searchId) {
            if (!tree) {
                tree = this._tree
            }

            if (typeof searchId === "string" && !searchId?.match(/^[a-z0-9\-_]+$/i)) {
                return false;
            }

            for (const {id, children, item} of tree) {
                if (item === searchId || id === searchId || TableOfContents.inTree(children, searchId)) {
                    return true
                }
            }
            return false
        }


        /**
         * Set the items inside the table of contents
         *
         * @param {ItemDef[]|null} items
         * @param {boolean}     [reset=false]
         */
        static setItems(items, reset=false) {
            if (items === null) {
                const allOptions = this._getOptionsFromRoot();
                items = [];
                let lastLevel, minLevel;
                allOptions.forEach((option) => {
                    if (option instanceof HTMLHeadingElement) {
                        const headingLevel = parseInt(option.tagName.match(/^h(\d)/i)?.[1] || '1') - 1;
                        if (minLevel === undefined || minLevel > headingLevel) {
                            minLevel = headingLevel;
                        }
                        if (lastLevel === undefined) {
                            lastLevel = headingLevel;
                        }
                        const itemDef = this.getItemFromElem(option);
                        itemDef.indentLevel = headingLevel;
                        lastLevel = headingLevel;
                        items.push(itemDef);
                    }
                });
                items = items.map(item => ({...item, indentLevel: item.indentLevel - (minLevel || 0)}));
            }
            if (reset) {
                delete this._hashes.treeList;
                delete this._hashes.tree;
            }
            this._treeList = items
        }


        /**
         * Build a tree based on a list of items where each item has an indent level
         *
         * @param {ItemDef[]}       items
         *
         * @return {TableOfContentsTree[]}
         */
        static buildTreeFromItems(items) {
            // select the items and build the tree
            const _items = []
            const ancestorStack = []
            for (let {selector, indentLevel=0, selectorHash} of items) {
                if (!selector) {
                    continue;
                }

                const element = document.querySelector(`:is(${selector}):is(${_baseSelector()})`)
                if (!element) {
                    continue
                }
                indentLevel = Math.round(Math.min(3, Math.max(indentLevel, 0)))

                // sync the hash to the element
                selectorHash = element.hasAttribute('id') ? element.getAttribute('id') : (selectorHash || ips.utils.md5(selector))
                element.setAttribute('id', selectorHash)
                const fullText = element.textContent?.trim().slice(0, 300).trim();
                const selectorText = element.textContent.trim().length > 150 ? element.textContent.trim().slice(0, 147) + '...' : element.textContent.trim()

                // bubble up the ancestorStack
                while (ancestorStack.length > indentLevel) {
                    ancestorStack.pop()
                }

                while (ancestorStack.length < indentLevel) {
                    ancestorStack.push({title: '', id: '', children:[]})
                    if (ancestorStack.length >= 2) {
                        ancestorStack[ancestorStack.length - 2].children.push(ancestorStack[ancestorStack.length - 1])
                    }
                }

                ancestorStack.push({item: element, title: selectorText, fullText, id: selectorHash, children: []})

                if (ancestorStack.length > 1) {
                    ancestorStack[ancestorStack.length - 2].children.push(ancestorStack[ancestorStack.length - 1])
                } else {
                    _items.push(ancestorStack[0])
                }
            }

            return _items
        }

        /**
         * Clean a list of items so every item is in the DOM and it is in the same order as items appear in the DOM
         *
         * @param {ItemDef[]}   items
         *
         * @return {ItemDef[]}
         *
         * @private
         */
        static _cleanItems(items) {
            const bigList = [...document.querySelectorAll(`:is(${_baseSelector()}):is(${items.map(item => `:is(${item.selector})`).join(',')})`)]

            const sorted = items
                .map(item => ({...item, element: document.querySelector(`:is(${_baseSelector()}):is(${item.selector})`)}))
                .filter(({element}) => bigList.includes(element))
                .sort((a, b) => bigList.indexOf(a.element) - bigList.indexOf(b.element))

            return sorted
                .map((item, i) => {
                    if (item.element instanceof Element) {
                        item.selector = this.createSelector(item.element); // recreate the selector to guarantee it's updated in the saved data
                    }
                    delete item.element;

                    if (item.indentLevel) {
                        if (i === 0) {
                            item.indentLevel = 0;
                        } else if (item.indentLevel - 1 > (sorted[i - 1].indentLevel || 0)) {
                            // the indent level must be no more than one deeper than the previous item
                            item.indentLevel = (sorted[i - 1].indentLevel || 0) + 1;
                        }
                    }

                    return {...item}
                })
        }

        /**
         * Get the HTML Details/Summary combo for the table of contents as a stromg
         *
         * @param {TableOfContentsTree} tree
         *
         * @returns {string}
         *
         * @private
         */
        _getTreeHTML(tree) {
            const children = tree.children.map(child => `<li>${this._getTreeHTML(child)}</li>`)
            const encodeHTMLEntities = text => {
                const t = document.createElement('textarea');
                t.innerText = text;
                return t.innerHTML.replaceAll('"', '&quot;');
            }

            if (children.length && (!tree.id || !tree.title)) { // this is an empty link; really just used to preserve indent levels
                return `
                    <div class="ipsTableOfContents__wrapper">
                        <ul>
                            ${children.join('\n')}
                        </ul>
                    </div>`

            } else if (tree.id && tree.title && children.length) { // if the tree has children
                return `
                    <details class="ipsTableOfContents__expandable" >
                        <summary class="">
                            <span data-item-id="${tree.id}" class="ipsTableOfContents__item">
                                <a href="#${encodeHTMLEntities(tree.id)}" title="${encodeHTMLEntities(tree.fullText || "")}">${encodeHTMLEntities(tree.title)}</a>                 
                            </span>
                        </summary>
                        <ul>
                            ${children.join('\n')}
                        </ul>
                    </details>`

            } else if (tree.id && tree.title) { // the tree is a leaf
                return `<span data-item-id="${tree.id}" class="ipsTableOfContents__item">
                            <a href="#${encodeHTMLEntities(tree.id)}" title="${encodeHTMLEntities(tree.fullText || "")}">${encodeHTMLEntities(tree.title)}</a>
                        </span>`
            }

            return ''
        }

        /**
         * Render the tree inside the element
         * @private
         */
        _renderTree() {
            // TableOfContents.options.forEach(el => el.style.background = 'pink')
            if (!TableOfContents._tree.length) {
                this.elem.closest('.ipsWidget').ipsHide();
            } else {
                this.elem.closest('.ipsWidget').ipsShow()
                const contentArea = this.elem.querySelector('.ipsTableOfContents__content')
                contentArea.classList.remove('ipsLoading', 'ipsLoading--small', 'ipsWidget__padding')
                contentArea.innerHTML = ''
                for (const tree of TableOfContents._tree) {
                    contentArea.innerHTML += this._getTreeHTML(tree)
                }
            }

            $("#ipsLayout_sidebar").trigger('managingFinished.widgets')
        }

        /**
         * Position the link options based on its root element
         *
         * @param {Element}     linkOptions
         * @param {Element}     root
         * @private
         */
        static _positionLinkOptions(linkOptions, root) {
            linkOptions.style.zIndex = linkOptions.style.zIndex || `${ips.ui.zIndex() - 1}`;
            linkOptions.style.top = (((root.getBoundingClientRect().top + root.getBoundingClientRect().bottom - linkOptions.getBoundingClientRect().height) / 2) - document.body.getBoundingClientRect().top) + 'px'
            linkOptions.style.left = (root.getBoundingClientRect().left - (linkOptions.getBoundingClientRect().width) - document.body.getBoundingClientRect().left) + 'px'
        }

        /**
         * Get all options inside a root element, including possibly the root itself (if the root is a valid option AND it is inside the DOM)
         *
         * @param {Element|undefined} [root]        The Element from which to search from
         *
         * @return {Element[]}
         * @private
         */
        static _getOptionsFromRoot(root) {
            this.__tempRoot = root?.parentElement || root;
            const options = this.options;
            delete this.__tempRoot;
            return options;
        }

        /**
         * Draw the links in the main area
         *
         * @param {Element}     [root]      The root of the tree to draw
         *
         */
        static drawLinks(root) {

            for (const el of this._getOptionsFromRoot(root instanceof Element ? root : undefined)) {
                if (!this._linkOptions.has(el)) {
                    if (TableOfContents.inTree(undefined, el) || this.canEdit) {
                        try {
                            el.classList.add('ipsTableOfContents__link')
                            const dummy = document.createElement('div')
                            dummy.innerHTML = ips.templates.render('tableOfContents.linkOptions', {
                                canEdit: this.canEdit,
                                id: this._generateId(el)
                            })
                            const linkOptions = dummy.children[0]
                            document.body.appendChild(linkOptions)
                            this._positionLinkOptions(linkOptions, el)
                            window.addEventListener('resize', () => this._positionLinkOptions(linkOptions, el))
                            window.addEventListener('scroll', () => this._positionLinkOptions(linkOptions, el))
                            let inEl = false, inLinkOptions = false;
                            const debouncedClose = _.debounce(() => {
                                if (!inLinkOptions && !inEl) {
                                    linkOptions.classList.remove('ipsTableOfContents__linkOptions--visible')
                                }
                            }, 30)
                            el.addEventListener('mouseenter', () => {
                                const box = el.getBoundingClientRect()
                                if (!box) {
                                    return;
                                }
                                const container = el.closest('.cWidgetContainer--carousel')?.getBoundingClientRect()
                                if (container && (container.left > box.left || container.right < (box.left + box.right) / 2)) {
                                    return
                                }
                                inEl = true
                                linkOptions.classList.add('ipsTableOfContents__linkOptions--visible')
                                this._positionLinkOptions(linkOptions, el)
                            })
                            linkOptions.addEventListener('mouseenter', () => {
                                inLinkOptions = true
                            })
                            el.addEventListener('mouseleave', () => {
                                inEl = false
                                debouncedClose()
                            })
                            linkOptions.addEventListener('mouseleave', () => {
                                inLinkOptions = false
                                debouncedClose()
                            })

                            linkOptions.querySelector('[data-role="add"]')?.addEventListener('click', () => this._addElement(el))
                            linkOptions.querySelector('[data-role="remove"]')?.addEventListener('click', () => this._removeElement(el))
                            linkOptions.querySelector('[data-role="increment"]')?.addEventListener('click', () => this._incrementIndent(el))
                            linkOptions.querySelector('[data-role="decrement"]')?.addEventListener('click', () => this._decrementIndent(el))
                            linkOptions.querySelector('[data-role="link"]')?.addEventListener('click', () => {
                                const fakeElement = document.createElement('span')
                                fakeElement.innerHTML = window.location.href.toString().split('#')[0] + `#${el.getAttribute('id')}`
                                document.body.appendChild(fakeElement)
                                const currentSelection = []
                                for (let i = 0; i < document.getSelection().rangeCount; i++) {
                                    currentSelection.push(document.getSelection().getRangeAt(i))
                                }

                                const range = document.createRange()
                                range.setStart(fakeElement, 0)
                                range.setEnd(fakeElement, fakeElement.childNodes.length)
                                document.getSelection().removeAllRanges()
                                document.getSelection().addRange(range)

                                try {
                                    document.execCommand('copy')
                                    ips.ui.flashMsg.show(ilang`copied`)
                                } catch (e) {

                                }
                                document.getSelection().removeAllRanges()
                                fakeElement.remove()

                                for (const range of currentSelection) {
                                    document.getSelection().addRange(range)
                                }
                            })

                            // The pagebuilder calls this to close all the tooltips associated with areas that vanish
                            linkOptions.addEventListener('remove', e => {
                                e.stopPropagation()
                                this._linkOptions.delete(el)
                                linkOptions.remove()
                            })
                            this._linkOptions.set(el, linkOptions)
                            dummy.remove()
                        } catch (e) {
                            e.message  = 'Failed to create a table of contents link!\n\n' + e.message
                            Debug.warn(e)
                        }
                    }
                }
            }

            this._updateCurrentItems()

            // If we just put the id for an element on the page that is also in the URL, we need to make sure it's visible then scroll to it
            if (window.location.href.split('#')[1] && document.querySelector(`.ipsTableOfContents__link#${window.location.href.split('#')[1]}`)) {
                setTimeout(async () => {
                    document.querySelectorAll(`#${window.location.href.split('#')[1]},[data-item-id="${window.location.href.split('#')[1]}"]`).forEach(el => {
                        let details = el.closest('details')
                        while (details) {
                            details.setAttribute('open', '')
                            details = details.parentElement?.closest('details')
                        }
                    })

                    await new Promise(resolve => setTimeout(resolve, 10)) // we have to add a timeout to make sure the scroll happens AFTER the element is all the way open
                    document.getElementById(window.location.href.split('#')[1]).scrollIntoView({behavior:'smooth'})
                }, 10)
            }
        }

        /**
         * Update the items in the main page area that are in the table of contents
         * @param {TableOfContentsTree[]|null}   [tree=null]
         *
         * @return {Set<Element>}
         * @private
         */
        static _updateCurrentItems(tree=null) {
            const isRoot = tree === null;
            tree = tree || this._tree
            const visibleElements = new Set();
            for (let i = 0; i < tree.length; i++) {
                const {item, children, id} = tree[i]
                if (item instanceof Element) {
                    const linkItem = this._linkOptions.get(item)
                    visibleElements.add(item)
                    if (linkItem) {
                        linkItem.querySelectorAll('[data-role="add"]').ipsHide()
                        linkItem.querySelectorAll('[data-role="remove"], [data-role="link"], .ipsTableOfContents__incrementOptions').ipsShow()
                        const treeItem = this._treeList.find(el => (document.querySelector(`:is(${el.selector}):is(${_baseSelector()})`) === item));

                        // the first item in the ToC cannot be indented or outdented
                        if (isRoot && i === 0) {
                            linkItem.querySelector(`.ipsTableOfContents__incrementOptions`)?.ipsHide()
                        } else {
                            linkItem.querySelector(`.ipsTableOfContents__incrementOptions`)?.ipsShow()
                            if (treeItem?.indentLevel <= 0) {
                                linkItem.querySelector(`[data-role="decrement"]`)?.ipsDisable()
                            } else {
                                linkItem.querySelector(`[data-role="decrement"]`)?.ipsEnable()
                            }

                            // Max indent level is 3. The item also needs to be succeeding another item at the same level to be indented
                            if (treeItem?.indentLevel >= 3 || i === 0) {
                                linkItem.querySelector(`[data-role="increment"]`)?.ipsDisable()
                            } else {
                                linkItem.querySelector(`[data-role="increment"]`)?.ipsEnable()
                            }
                        }
                        linkItem.querySelector('[data-role="link"]').setAttribute('href', `#${id}`)
                    }
                    item.setAttribute('id', id)
                }
                this._updateCurrentItems(children).forEach(item => visibleElements.add(item))
            }

            if (!arguments[0]) {
                for (const item of this.options) {
                    if (visibleElements.has(item)) {
                        continue;
                    }

                    item.setAttribute('id', this._generateId(item))

                    const linkItem = this._linkOptions.get(item)
                    if (linkItem instanceof HTMLElement) {
                        linkItem.querySelectorAll(`[data-role="add"]`).ipsShow()
                        linkItem.querySelectorAll('[data-role="remove"], [data-role="link"], .ipsTableOfContents__incrementOptions').ipsHide()
                    }
                }
            }
            return visibleElements
        }

        /**
         * Generate the ID to use for an element based on its selector and the position in the page
         *
         * @param element
         * @return {string}
         *
         * @private
         */
        static _generateId(element) {
            const clone = element.cloneNode(true)
            const innerText = clone.innerText;
            clone.remove();
            return encodeURIComponent(innerText.trim().replaceAll(/[^a-z0-9A-Z]+/g, '_').replaceAll(/(^_)|(_$)/g, '')) + '__' + ips.utils.crypto.md5Short(this.createSelector(element))
        }

        /**
         *
         * @type {Map<HTMLElement, HTMLElement>}
         * @private
         */
        static _linkOptions = new Map()

        /**
         * Create a selector for this element based on the positional offsets
         *
         * @param {Element}     element      The element in the DOM. Note not every element can have a proper offset
         *
         * @return string
         */
        static createSelector(element) {
            let selector = element.tagName.toLowerCase() + `:nth-child(${[...element.parentElement.children].indexOf(element) + 1})`
            element = element.parentElement
            while (element instanceof Element && element?.parentElement && element.parentElement.closest('[data-ips-hook="main"]')) {

                if (element.dataset.blockid?.match(/^(?:app|plugin)_[a-z0-9]{3,}_[a-z0-9]+_[a-z0-9]{6,8}$/i)) {
                    selector = `[data-blockid="${element.dataset.blockid}"] > ${selector}`
                    break;
                }

                if (element.getAttribute('id') === 'elCmsPageWrap') {
                    selector = `${element.tagName.toLowerCase()}${element.hasAttribute('id') ? `#${element.getAttribute('id')}` : ''} > ${selector}`
                    break;
                }

                if (element.dataset.ipsHook) {
                    selector = `[data-ips-hook="${element.dataset.ipsHook}"] > ${selector}`
                    break;
                }

                // if this is user content, we can use a selector relative to this endpoint
                if (element.matches(".ipsRichText.ipsRichText--user")) {
                    selector = `.ipsRichText.ipsRichText--user > ${selector}`;
                    break;
                }

                let nthChild = `:nth-child(${[...element.parentElement.children].indexOf(element) + 1})`

                selector = `${element.tagName.toLowerCase()}${element.hasAttribute('id') ? `#${element.getAttribute('id')}` : ''}${nthChild} > ${selector}`
                element = element.parentElement
            }

            return selector
        }


        /**
         * @returns {Element[]}
         */
        static get options() {
            const options = [
                ...(this.__tempRoot instanceof Element ? this.__tempRoot : document)
                    .querySelectorAll(_baseSelector())
            ]
                .map(el => el.tagName.toLowerCase() === 'details' ? el.querySelector(':scope > summary') : el)
                .filter(el => {
                    if (!el.textContent?.trim()) {
                        return false;
                    }

                    // Either the element must be a semantic heading OR it must have less than 100 chars
                    return el.matches?.('h1,h2,h3,h4,h5,h6') || el.textContent.trim().length < 100;
                });
            return options;
        }

        /**
         * Get a toc item definition from an element
         *
         * @param element
         *
         * @return {ItemDef}
         */
        static getItemFromElem(element) {
            return {
                selector: this.createSelector(element),
                selectorHash: this._generateId(element),
                indentLevel: 0
            }
        }

        /**
         * Add an element to the table of contents
         *
         * @param {HTMLElement} element
         *
         * @private
         */
        static _addElement(element) {
            for (const item of this._treeList) {
                if (element === document.querySelector(`:is(${item.selector}):is(${_baseSelector()})`)) {
                    return
                }
            }

            /**
             *
             * @type {ItemDef}
             */
            const newItem = this.getItemFromElem(element)

            this._modified = true;
            this._treeList = this._cleanItems([...this._treeList, newItem])
        }


        /**
         * Remove an element from the Table Of Contents
         *
         * @param {string|Element} idOrElement
         *
         * @private
         */
        static _removeElement(idOrElement) {

            const element = idOrElement instanceof Element ? idOrElement : document.querySelector(`:is(${_baseSelector()}):is(#${idOrElement})`)
            const list = this._treeList
            // ugly classic loop because we update while iterating
            for (let idx = 0; idx < list.length; idx++) {
                const item = list[idx]
                if (document.querySelector(`:is(${_baseSelector()}):is(${item.selector})`) === element) {
                    list.splice(idx, 1)
                    this._modified = true
                    this._treeList = list;
                    return;
                }
            }
        }

        /**
         * Increase the indent of the id in the TOC
         *
         * @param {Element|string}  idOrElement
         *
         * @private
         */
        static _incrementIndent(idOrElement) {
            const treeList = this._treeList
            for (let i = 0; i < treeList.length; i++) {
                if (treeList[i].selectorHash === idOrElement || (idOrElement instanceof Element && document.querySelector(`:is(${_baseSelector()}):is(${treeList[i].selector})`) === idOrElement)) {
                    this._modified = true;
                    treeList[i].indentLevel = Math.max(0,Math.min(3, (treeList[i].indentLevel || 0) + 1))
                    this._treeList = [...treeList]
                    return
                }
            }
        }


        /**
         * Increase the indent of the id in the TOC
         *
         * @param {Element|string}  idOrElement
         *
         * @private
         */
        static _decrementIndent(idOrElement) {
            const treeList = this._treeList
            for (let i = 0; i < treeList.length; i++) {
                if (treeList[i].selectorHash === idOrElement || (idOrElement instanceof Element && document.querySelector(`:is(${_baseSelector()}):is(${treeList[i].selector})`) === idOrElement)) {
                    this._modified = true;
                    treeList[i].indentLevel = Math.max(0,Math.min(3, (treeList[i].indentLevel || 0) - 1))
                    this._treeList = [...treeList]
                    return
                }
            }
        }

        /**
         * Save any changes made by the user
         * @private
         */
        static async _saveState() {
            const widget = document.querySelector(`[data-blockid*="app_core_tableofcontents_"]`)
            const blockID = widget.dataset.blockid.split('_').pop()
            await ips.fetch('/', {
                method: 'post',
                data: {
                    app: 'core',
                    module: 'system',
                    controller: 'ajax',
                    do: 'updateTableOfContents',
                    pageArea: widget.closest('[data-widgetarea]').dataset.widgetarea,
                    blockID,
                    ...this.getContentContext(),
                    items: JSON.stringify(this._treeList)
                }
            })
            this._modified = false;
        }

        /**
         * Get the context of the content the table of contents refers to on this 'page'. For CMS pages, sometimes it's a record while other times it's just a raw page-builder or WYSIWYG page, so we need to check both IDs
         * @return {{pageModule: string, pageApp: string, pageController: string, pageElse: string, pageID: (*|number|string), pageContentClass: string|null}}
         */
        static getContentContext() {
            const context = {
                pageID:  window.ips?.getSetting?.('pageID') || parseInt(document.querySelector(`#elCmsPageWrap[data-pageid]`)?.dataset.pageid) || '',
                pageElse: document.body.dataset.pageid || document.body.dataset.id || '',
                pageApp: document.body.dataset.pageapp,
                pageModule: document.body.dataset.pagemodule,
                pageController: document.body.dataset.pagecontroller,
                pageContentClass: document.body.dataset.contentclass || null
            };

            // do some safety checks
            ['pageApp', 'pageModule', 'pageController'].forEach(prop => {
                if (!context[prop] || typeof context[prop] !== 'string') {
                    throw new TypeError(`Cannot determine the ${prop} for the table of contents`);
                }
            });

            return context;
        }

        /**
         * Open the details (dropdowns) in all the table of contents widgets on the page
         */
        static openDetailsInWidgets() {
            const currentId = window.location.href.split('#')[1]?.match(/^.*[^_]__([a-f0-9]{0,6})$/i)?.[1]
            if (!currentId) return;
            for (const item of this._treeList) {
                const el = document.querySelector(`.ipsTableOfContents__link:is(${_baseSelector()}):is(${item.selector})`)
                if (el && el.getAttribute('id')?.endsWith(`__${currentId}`)) {
                    const id = el.getAttribute('id')
                    document.querySelectorAll(`.ipsTableOfContents__root [data-item-id="${id}"]`).forEach(el => {
                        let details = el.closest('details')
                        while (details) {
                            details.setAttribute('open', '')
                            details = details.parentElement?.closest('details')
                        }
                    })

                    break;
                }
            }
        }
    }

    // This updates the table of contents when the url changes. We use popstate instead of the ips-generated historychange to be a bit more thorough (non-core JS can change crap)
    window.addEventListener('popstate', () => {
        TableOfContents.openDetailsInWidgets()
    })

    let lastItems;

    ips.createModule('ips.ui.tableOfContents', function() {
        ips.ui.registerWidget('tableOfContents', ips.ui.tableOfContents, [...Object.keys(defaults)])

        return {
            /**
             * Instantiate the table of contents on its element if needed
             *
             * @param elem
             * @param options
             *
             * @return {TableOfContents|undefined}
             */
            respond(elem, options) {
                const realElem = $(elem).get(0)
                if (realElem.closest('.pageBuilderRoot')) {
                    return;
                }

                options = {...defaults, ...options}

                TableOfContents.canEdit = !!options.canEdit

                // create a new element if there is none
                if (realElem && !TableOfContents.instanceMap.has(realElem)) {
                    if (!Array.isArray(options.currentitems)) {
                        if (typeof options.currentitems === 'string') {
                            try {
                                options.currentitems = JSON.parse(atob(options.currentitems))
                                if (!Array.isArray(options.currentitems) && options.currentitems !== null) {
                                    throw new TypeError();
                                }
                                lastItems = options.currentitems;
                                TableOfContents.setItems(options.currentitems)
                            } catch (e) {
                                options.currentitems = []
                            }
                        } else {
                            options.currentitems = defaults.currentitems
                        }
                    } else {
                        lastItems = options.currentitems;
                        TableOfContents.setItems(options.currentitems)
                    }
                    TableOfContents.instanceMap.set(realElem, new TableOfContents(realElem, options))
                }
                return TableOfContents.instanceMap.get(realElem)
            },

            refreshElems() {
                if (Array.isArray(lastItems) || lastItems === null) {
                    TableOfContents.setItems(lastItems, true);
                }
            },

            /**
             * Get the instance associated with an HTMLElement if there is one
             * @param elem
             * @return TableOfContents|null
             */
            getInstance(elem) {
                if (TableOfContents.instanceMap.has($(elem).get(0))) {
                    return TableOfContents.instanceMap.get($(elem).get(0))
                }
                return null;
            },

            /**
             *
             * @param   {Element}   elem
             * @return {string}
             */
            createSelector(elem) {
                return TableOfContents.createSelector(elem)
            },
            getOptions() {
                return TableOfContents.options
            },
            /**
             *
             * @return {{pageModule: string, pageApp: string, pageController: string, pageElse: string, pageID: (*|number|string), pageContentClass: (string|null)}}
             */
            getContext() {
                return TableOfContents.getContentContext()
            }
        }
    })
})(jQuery, _)]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.tooltip.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.tooltip.js - Tooltip UI component
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	const endCachingDebounced = _.throttle((elem) => {
		ips.utils.position.endCaching(elem);
	}, 100, {leading:false});
	ips.createModule('ips.ui.tooltip', function(){

		let _tooltip = null,
			_timer = [],
			_currentElem = null,
			_showTimeout,
			_visible = false,
			_lastOptions = {},
			_mo = new MutationObserver(_.throttle(() => {
				if (_currentElem && _tooltip && _visible && !_lastOptions.ajax) {
					/**
					 * @type {Function[]}
					 */
					let mutations = [];
					// reset the _title temporary attribute to regenerate it
					if (_currentElem.getAttribute('title')) {
						mutations.push(() => _currentElem.removeAttribute("_title"));
					}
					const content = _getContent($(_currentElem), _lastOptions);
					if (_lastOptions.safe) {
						mutations.push(() => _tooltip.html(content));
					} else {
						mutations.push(() => _tooltip.text(content));
					}

					if (mutations.length) {
						requestAnimationFrame(() => mutations.forEach(mutation => mutation()));
					}
				}
			}, 30));

		let _frame;
		const _ro = new ResizeObserver((entries) => {
			const tooltipEntry = entries.find(entry => entry.target === $(_tooltip).get(0));
			const tooltipHeight = tooltipEntry?.borderBoxSize[0]?.blockSize || 0;
			const tooltipWidth = tooltipEntry?.borderBoxSize[0]?.inlineSize || 0;
			const tooltipEl = $(_tooltip).get(0);
			const docBox = document.body.getBoundingClientRect();
			const mutations = [];
			for (const entry of entries) {
				if (entry.target === $(_tooltip).get(0)) {
					continue;

				}
				if (entry.target !== _currentElem) {
					_currentElem = entry.target;
					mutations.push(() => {
						_tooltip[0].showPopover();

						// Set an interval which checks the element is still on the page (useful when a dialog closes, for example)
						_visible = true;
						_timer.push( setInterval( _checkForElemPresence, 100 ) );
						// setTimeout(() => {
						// 	_visible = true;
						// }, 10);
						setTimeout(() => $(_currentElem).trigger( 'tooltipShown' ), 1);
					});
				}

				break;

			}

			const anchorBox = _currentElem.getBoundingClientRect();
			// make sure the anchor is visible
			if (!anchorBox.width || !anchorBox.height) {
				Debug.log(`Hiding tooltip because the anchor is not visible`);
				_hide();
				return;
			}

			if (tooltipWidth === 0 || tooltipHeight === 0) {
				// mutations.push(() => tooltipEl.style.opacity = '0');
			} else {
				// mutations.push(() => tooltipEl.style.opacity = '1')
				// can we put it above?
				let top = anchorBox.top - tooltipHeight - docBox.top;
				if (top < -docBox.top) {
					mutations.push(() => {
						tooltipEl.classList.remove('ipsTooltip_top');
						tooltipEl.classList.add('ipsTooltip_bottom')
					});
					top = anchorBox.bottom - docBox.top;
				} else {
					mutations.push(() => {
						tooltipEl.classList.remove('ipsTooltip_bottom');
						tooltipEl.classList.add('ipsTooltip_top')
					});
				}
				const leftRaw = (anchorBox.left + anchorBox.right) / 2 - tooltipWidth / 2 - docBox.left;
				let left = leftRaw;
				if (leftRaw < 10 - docBox.left) {
					left = (anchorBox.left + anchorBox.right) / 2 - 9;
					mutations.push(() => {
						tooltipEl.classList.remove('ipsTooltip_right');
						tooltipEl.classList.add('ipsTooltip_left');
					});
				} else if (left > window.innerWidth - tooltipWidth - 20 - docBox.left) {
					left = (anchorBox.left + anchorBox.right) / 2 - tooltipWidth + 9;
					mutations.push(() => {
						tooltipEl.classList.remove('ipsTooltip_left');
						tooltipEl.classList.add('ipsTooltip_right');
					});
				} else {
					mutations.push(() => {
						tooltipEl.classList.remove('ipsTooltip_left');
						tooltipEl.classList.remove('ipsTooltip_right');
					});
				}
				mutations.push(() => {
					tooltipEl.style.left = Math.round(left * 10) / 10 + 'px';
					tooltipEl.style.top = Math.round(top * 10) / 10 + 'px';
				});

			}


			if (_frame !== undefined) {
				cancelAnimationFrame(_frame);
			}
			_frame = requestAnimationFrame(() => {
				mutations.forEach(mutation => mutation());
			})
		});

		/**
		 * Widget responder
		 * Creates the tooltip if it doesn't exist, then gets the content and shows/hides tooltip
		 *
		 * @param 	{element} 	elem		Original element
		 * @param 	{object} 	options		Widget options
		 * @param 	{Event} 	e 			Event object
		 * @returns {void}
		 */
		function respond(elem, options, e) {
			clearTimeout(_showTimeout);
			// Don't show tooltips on touch devices
			if (ips.utils.events.isTouchDevice()) {
				return;
			}

			if (!_tooltip) {
				_createTooltipElement();
			}

			if (e.type === 'mouseleave' || e.type === 'blur' || e.type === 'focusout') {
				_hide();
			} else {
				const content = _getContent(elem, options);
				if (content) {
					ips.utils.position.startCaching();
					_showTimeout = setTimeout(() => {
						_show(elem, options, content);
						endCachingDebounced();
					});
				}
			}
		}
		
		/**
		 * Actually show a tooltip
		 *
		 * @param 	{jQuery|Element} 	elem 		Original element
		 * @param 	{object} 	options		Widget options
		 * @param	{string}	content 	Content of tooltip
		 * @returns {void}
		 */
		function _show(elem, options, content) {
			elem = $( elem );
			_lastOptions = options;

			// Hide the tooltip and update the content
			_tooltip[0].hidePopover();
			if( options.safe ){
				_tooltip.html( content );
			} else {
				_tooltip.text( content );
			}

			// Fire an AJAX request for the real content if needed
			if (options.ajax && !elem.data('_tooltip')) {
				ips.getAjax()( options.ajax ).done(response => {
					$(elem).data( '_tooltip', response );
					if (options.safe) {
						_tooltip.html(response);
					} else {
						_tooltip.text(response);
					}
				});
			} else {
				_mo.observe(elem.get(0), {attributes: true, subtree: true, characterData: true});
			}

			// Remove the title if any
			const element = $(elem).get(0);
			if (element.hasAttribute('title')) {
				element.setAttribute('_title', element.getAttribute('title'));
				element.removeAttribute('title');
			}

			// Use the resize observer to "show" it. This way, the size evaluations can be taken off this thread performed without any forced reflows
			_ro.observe($(elem).get(0), {box: 'border-box'});
			_ro.observe($(_tooltip).get(0), {box: 'border-box'});
		}

		/**
		 * Hides the tooltip
		 *
		 * @returns {void}
		 */
		function _hide() {
			_mo.disconnect();
			_ro.disconnect();
			_tooltip[0].hidePopover();
			_visible = false;
			_currentElem = null;

			// Clear out current timers
			if( _timer.length ){
				for( var i = 0; i < _timer.length; i++ ){
					clearInterval( _timer[ i ] );
				}

				_timer = [];
			}
		}

		/**
		 * Checks that an element exists
		 * @returns {void}
		 */
		function _checkForElemPresence() {
			if (!(_currentElem instanceof Element) || _currentElem.ownerDocument !== document) {
				Debug.log(`Hiding the tooltip because there is no current tooltip anchor, or it has been removed from the document.`);
				_hide();
			}
		}

		/**
		 * Figures out which string should form the tooltip text
		 *
		 * @param 	{element} 	elem 		Original element
		 * @param 	{object} 	options		Widget options
		 * @returns {string}
		 */
		function _getContent(elem, options) {
			elem = $( elem );

			if ( elem.data('_tooltip') ) {
				return elem.data('_tooltip');
			}
			else if( options.label ){
				if ( options.json ) {
					return $.parseJSON( options.label ).join("<br>");
				} else {
					return options.label;
				}
			} else if( elem.attr('aria-label') ){
				return elem.attr('aria-label');
			} else if( elem.attr('_title') ){
				return elem.attr('_title');
			} else if( elem.attr('title') ){
				return elem.attr('title');
			}

		}

		/**
		 * Creates the tooltip element from a template
		 *
		 * @returns {void}
		 */
		function _createTooltipElement() {
			// Build it from a template
			var tooltip = ips.templates.render( 'core.tooltip', {
				id: 'ipsTooltip'
			} );

			// Append to body
			ips.getContainer().append( tooltip );

			_tooltip = $('#ipsTooltip');
		}

		// Register this module as a widget to enable the data API and
		// jQuery plugin functionality
		ips.ui.registerWidget('tooltip', ips.ui.tooltip, 
			['label', 'extraClass', 'safe', 'json', 'ajax' ], 
			{ lazyLoad: true, lazyEvents: 'mouseenter mouseleave focus blur' } 
		);

		return { respond };
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.truncate.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.truncate.js - Text truncating widget
 * Hides the overflow with a 'show more' link
 *
 * Author: Ehren Harber
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.truncate', function(){
		/**
		 * @type {WeakMap<Element, function>}
		 */
		const TRUNCATE_CALLBACK_MAP = new WeakMap();
		document.addEventListener('ips:truncateCollapse', e => {
			if (TRUNCATE_CALLBACK_MAP.has(e.target)) {
				TRUNCATE_CALLBACK_MAP.get(e.target)();
				TRUNCATE_CALLBACK_MAP.delete(e.target);
			}
		}, {capture: true});

		var defaults = {
			expandText: ips.getString('show_more'),
			deferred: false,
			deferredClasses: undefined,
		};

		var respond = function (elem, options) {

			let el = elem[0];

			// let the editor take care of this for itself
			if (el.closest('[data-ipseditorv5],.tiptap')) {
				return;
			}

			const collapseIfNeeded = () => {
				delete el.dataset.ipstruncateDeferred; // this causes the css to remove the overflow effect; we need to remove it before evaluating the scroll height.
				if (el.scrollHeight > el.offsetHeight) {
					if (options.deferred && options.deferredClasses) {
						for (const cls of options.deferredClasses.split(/\s+/)) {
							el.classList.add(cls);
						}
					}
					_hideTruncate(elem, _.defaults(options, defaults));
				}
			}

			if (options.deferred) {
				TRUNCATE_CALLBACK_MAP.set(el, collapseIfNeeded);
				return;
			}

			collapseIfNeeded();
		},

		/**
		 * Truncates content by hiding text
		 *
		 * @param	{elem} 		elem 		The element containing text being truncated
		 * @param	{object} 	options 	The options passed into this widget
		 * @returns {void}
		 */
		_hideTruncate = function (elem, options) {
			if( elem.attr('data-truncated') ){
				return;
			}

			// Build the template
			var showMore = ips.templates.render( 'core.truncate.expand', {
				text: options.expandText
			});

			$( elem ).after( showMore );

			var expander = elem.next("[data-action='expandTruncate']");

			elem.attr('data-truncated', true);

			// Hook up event
			expander.on('click', function (e) {
				elem.attr('data-truncate-expanded', true);
				expander.remove();
			});
		};

		ips.ui.registerWidget( 'truncate', ips.ui.truncate,
			['expandText', 'deferred']
		);

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.uploader.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.uploader.js - Uploading component, serving as a wrapper to plupload
 *
 * Author: Rikki Tissier 
 */
;( function($, _, undefined){
	const imageExtensions = new Set([ 'jpg', 'jpeg', 'jpe', 'gif', 'png', 'webp', 'avif' ]),
		audioExtensions = new Set([ 'mp3', 'ogg', 'wav', 'm4a' ]),
		videoExtensions = new Set([ 'mp4', '3gp', 'mov', 'ogg', 'ogv', 'mpg', 'mpeg', 'flv', 'webm', 'wmv', 'avi', 'm4v' ]);

	/**
		 * Upload instance
		 * Interfaces with plupload to provide consistent uploading behavior
		 *
		 * @param    {jQuery}    elem        The element this widget is being created on
		 * @param    {object}    options    The options passed into this instance
		 * @param e
		 * @returns {{init:Function, refresh:Function}}
		 */
	const uploadObj = function (elem, options, e) {
		elem = $(elem);

		let pluploadObj,
			runtime,
			listContainer,
			uploadCount = 0,
			totalSize = 0,
			injectIds = {},
			uploaderID = '',
			sound = null;

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		function init() {

			uploaderID = $( elem ).identify().attr('id');

			if( options.listContainer ){
				listContainer = $( options.listContainer );
			} else if( $( elem ).find('[data-role="fileList"]').length ) {
				listContainer = $( elem ).find('[data-role="fileList"]');
			} else {
				listContainer = $( elem );
			}

			// Do we need to insert a wrapper though?
			if( ips.templates.get( options.template + 'Wrapper' ) ){
				listContainer.prepend( ips.templates.render( options.template + 'Wrapper' ) );

				// Move any existing items
				const firstItem = listContainer.children().first();
				firstItem.append( listContainer.children().not( firstItem ) );

				// Set listContainer to the wrapper
				listContainer = firstItem;

				// And initialize any widgets we might have
				$( document ).trigger( 'contentChange', [ listContainer.parent() ] );
			}

			// Add document events
			$( document ).on( 'addUploaderFile', _addUploaderFile );
			$( document ).on( 'removeAllFiles', _removeAllFiles );

			// Any files to start with?
			if( options.existingFiles ){
				try {
					const files = $.parseJSON(options.existingFiles);

					if( files.length ){
						_buildExistingFiles( files );
					}
				} catch (err) {
					Debug.error("Couldn't build existing files: " + err );
				}
			}

			ips.utils.cookie.set('editor_supports_drag', _supportsDraggable() ? 'true' : 'false');
			$(elem)
				.find('[data-action="browse"],[data-supports-drag]')
				.attr('data-supports-drag', _supportsDraggable() ? 'true' : 'false');

			// Load the appropriate files
			const load = ips.getSetting('useCompiledFiles') ?
				['core/interface/plupload/plupload.full.min.js'] :
				['core/interface/plupload/moxie.js', 'core/interface/plupload/plupload.dev.js'];

			ips.loader.get( load ).then( function () {
				_setUpUploader();
				_initUploader();
				_postInitEvents();
				_setUpFormEvents();
			});
		}

		/**
		 * Refreshes the pluploader, if available
		 *
		 * @returns   {void}
		 */
		function refresh() {
			if (pluploadObj) {
				Debug.log("Refreshing");
				pluploadObj.refresh();
			}
		}

		/**
		 * Sets up form handling, allowing us to stop a form submit if an upload is in progress
		 *
		 * @returns   {void}
		 */
		function _setUpFormEvents() {
			const form = _getForm();
			if (!form.length) {
				return;
			}

			/* Stock photo handler init */
			if ( options.allowStockPhotos !== false ) {
				$( elem ).find('[data-action="stockPhoto"]').on( 'click', function(e) {
					e.preventDefault();
					e.stopPropagation();

					const dialogRef = ips.ui.dialog.create({
						title: ips.getString("stockphoto_header"),
						fixed: false,
						destructOnClose: true,
						url: ips.getSetting('baseURL') + '?app=core&module=system&controller=pixabay&uploader=' + $(elem).attr('data-ipsUploader-name'),
					});
					dialogRef.show();
				} );
			}

			// plupload.STOPPED indicates either nothing has been uploaded or all files
			// have finished uploading. For any other state, we'll stop the form submitting.
			form.on( 'submit', function (e) {
				if( pluploadObj.state !== plupload.STOPPED ){
					e.preventDefault();
					e.stopPropagation();

					ips.ui.alert.show({
						type: 'alert',
						message: ips.getString('filesStillUploading'),
						subText: ips.getString('filesStillUploadingDesc'),
						icon: 'warn'
					});

					$(elem).trigger('fileStillUploading');
				}
			});
		}

		/**
		 * Responds to event and adds an uploaded file to the uploader container
		 *
		 * @param 	  {event} 	e 		Event object
		 * @param 	  {object} 	data	Event data object
		 * @returns   {void}
		 */
		function _addUploaderFile(e, data) {
			if (data.uploaderID === uploaderID) {
				data.extIcon = ips.ui.uploader.getExtensionIcon( data.title );
				listContainer.append( ips.templates.render( _getTemplateName(data), data ) );
			}
		}

		/**
		 * Return the appropriate template name based on options.template or the data type
		 *
		 * @param 	  {object} 	data	Event data object
		 * @returns   {string}
		 */
		function _getTemplateName(data) {
			if( options.template !== null ){
				return options.template;
			}

			let type = 'fileItem'; // Default type

			// Show the appropriate container for this kind of file
			if( data.isImage ){
				type = 'imageItem';
			} else if( data.isVideo ){
				type = 'videoItem';
			}

			return `core.attachments.${type}`;
		}

		/**
		 * Responds to event and removes all the files in the uploader
		 *
		 * @returns   {void}
		 */
		function _removeAllFiles() {
			listContainer.find('[data-role="file"]').remove();
		}

		/**
		 * Builds existing file items using the parsed JSON from the widget settings
		 *
		 * @param 	  {{
		 imagesrc:string|undefined,
		 thumbnail: string|undefined,
		 originalFileName: string,
		 size:  *,
		 default,
		 id,
		 hasThumb
		 }[]} 	files 	Object containing file data
		 * @returns   {void}
		 */
		function _buildExistingFiles(files) {
			if( !files.length ){
				return;
			}

			for (let file of files) {
				const data = {
					id: file.id,
					imagesrc: file.imagesrc,
					thumbnail: file.thumbnail ? file.thumbnail : '',
					thumbnail_for_css: file.thumbnail ? file.thumbnail.replace('(', '\\(').replace(')', '\\)') : '',
					title: file.originalFileName,
					size: file.size,
					field_name: $(elem).attr('data-ipsUploader-name'),
					newUpload: false,
					insertable: !options.insertable,
					done: true,
					'default': file.default ? file.default : null,
					supportsDelete: options.supportsDelete,
					extIcon: ips.ui.uploader.getExtensionIcon(file.originalFileName)
				};

				if (file.id === $(elem).attr('data-ipsUploader-default')) {
					data['checked'] = "checked";
				}
				if (file.hasThumb) {
					data['thumb'] = "<img src='" + ( file['thumbnail'] ? file['thumbnail'] : file['imagesrc'] ) + "' class='ipsImage' alt='An uploaded image'>";
				}

				listContainer.append(ips.templates.render(options.template, data));

				$('#' + file.id)
					.trigger( 'newItem', [ $('#' + file.id) ] );
			}

			$(elem).trigger('fileAdded', {
				count: files.length,
				uploader: options.name
			});
		}

		/**
		 * Passes a settings object through to plupload, but does not initialize it yet
		 *
		 * @returns   {void}
		 */
		 function _setUpUploader() {
			pluploadObj = new plupload.Uploader( _getUploaderSettings() );
			pluploadObj.bind('Init', events.init );
			listContainer.find( '[data-role="file"]' ).each( function () {
				const fileElem = $(this);
				fileElem.on( 'click', '[data-role="deleteFile"]', _.bind( _deleteFile, fileElem, fileElem ) );
				uploadCount++;
			});
		}

		/**
		 * Get the form this uploader belongs to
		 *
		 * @return {*|jQuery}
		 *
		 * @private
		 */
		function _getForm() {
			let form = $(elem).parentsUntil('', 'form');
			if (!form.length && options.postkey) {
				form = $(`[data-ipseditorv5-postkey="${options.postkey}"]`).closest('form');
			}

			return form;
		}

		/**
		 * Builds the settings object which will be passed to plupload
		 *
		 * @returns   {object}
		 */
		 function _getUploaderSettings() {

			// If there is no action, find one
			const form = _getForm();
			if ( options.action === null ) {
				options.action = form.attr('action');
			}
			if ( options.key === null ) {
				options.key = form.children("[name='plupload']").val();
			}

			// Init Plupload Options
			const pluploadOptions = {
				runtimes: 'html5,flash,silverlight,html4',
				multi_selection: options.multiple,
				url: encodeURI(_decodeUrl(options.action)),
				file_data_name: options.name,
				flash_swf_url: 'applications/core/interface/plupload/Movie.swf',
				silverlight_xap_url: 'applications/core/interface/plupload/Movie.xap',
				browse_button: $(elem).find(options.button).identify().attr('id'),
				headers: {'x-plupload': options.key},
				chunk_size: options.maxChunkSize + 'mb'
			};

			/*if( options.maxFileSize ) {
				pluploadOptions.filters = {
					'max_file_size': ( options.maxFileSize > 1 ) ? options.maxFileSize + 'mb' : ( options.maxFileSize * 1024 ) + 'kb'
				};
			}*/
			/*if ( options.maxFileSize ) {
				pluploadOptions.max_file_size = ( options.maxFileSize > 1 ) ? options.maxFileSize + 'mb' : ( options.maxFileSize * 1024 ) + 'kb';
			}*/

			// Dragdrop target
			if( options.dropTarget ){
				pluploadOptions.drop_element = $( options.dropTarget ).attr('id');
			} else if( $( elem ).hasClass('ipsAttachment_dropZone') ){
				pluploadOptions.drop_element = $( elem ).attr('id');
			} else if( $( elem ).find('.ipsAttachment_dropZone').length ){
				pluploadOptions.drop_element = $( elem ).find('.ipsAttachment_dropZone').identify().attr('id');
			}

			return pluploadOptions;
		}

		/**
		 * Tests to see if the URL is encoded or not
		 *
		 * @returns   boolean
		 */
		 function _isEncoded(url) {
			url = url || '';

			return url !== decodeURI( url );
		}

		/**
		 * Decode an encoded URL
		 *
		 * @returns   {string}
		 */
		function _decodeUrl(url) {
			while( _isEncoded( url ) ) {
				url = decodeURI( url );
			}
			return url;
		}

		/**
		 * Inits pluploader
		 *
		 * @returns   {void}
		 */
		function _initUploader() {
			pluploadObj.init();
		}

		/**
		 * Binds all of the post-init events for pluploader
		 *
		 * @returns   {void}
		 */
		function _postInitEvents() {
			pluploadObj.bind('Error', events.error );						// An error occurred
			pluploadObj.bind('FilesAdded', events.filesAdded );				// Files added to the queue
			pluploadObj.bind('FilesRemoved', events.filesRemoved );			// Files are removed from the queue
			pluploadObj.bind('UploadFile', events.uploadFile );				// A file is starting
			pluploadObj.bind('UploadProgress', events.uploadProgress );		// There's progress on a file
			pluploadObj.bind('FileUploaded', events.fileUploaded );			// A file finished
			pluploadObj.bind('UploadComplete', events.uploadComplete );		// All files in the queue finished

			$( elem )
				.on( 'injectFile', function( e, data ){
					data = data === undefined ? e.originalEvent?.data : data;
					if (typeof data !== 'object' || !(data.file instanceof File) || !('data' in data)) {
						Debug.log('Cannot handle the file injection because there is no file to inject');
						return;
					}
					const pluploadFile = new plupload.File(new moxie.file.File(getRuntimeUid(), data.file));
					injectIds[pluploadFile.id] = data.data;

					pluploadObj.addFile( pluploadFile );
				} )
				.on( 'resetUploader', function ( data ){
					_resetUploader();
				} );

			$(window).on( 'resize', function(){
				pluploadObj.refresh();
			} );
		}

		/**
		 * Gets runtime UID
		 *
		 * @returns	{obj}
		 */
		 function getRuntimeUid() {
			if( !runtime )
			{
				runtime = new (moxie.runtime.Runtime.getConstructor(pluploadObj.runtime))();
				runtime.init();
			}

			return runtime.uid;
		}

		/**
		 * Resets this uploader instance, clearing it of files
		 *
		 * @returns 	{void}
		 */
		function _resetUploader() {
			// Update upload count
			uploadCount = 0;
			totalSize = 0;
			_updateCount();

			$( elem ).trigger( 'removeAllFiles', { uploaderID: uploaderID } );
		}

		/**
		 * Begins the upload process (called automatically when files are added)
		 *
		 * @returns 	{void}
		 */
		 function _startUpload() {
			Debug.log('Starting upload process...');
			pluploadObj.start();
		}

		/**
		 * Returns a human-readable, translated status string
		 *
		 * @param 	{number}	status 		Status code
		 * @returns {string}
		 */
		function _getStatus(status) {
			switch( status ) {
				case plupload.QUEUED:
					return ips.getString('attachQueued');
				case plupload.UPLOADING:
					return ips.getString('attachUploading');
				case plupload.FAILED:
					return ips.getString('attachFailed');
				case plupload.DONE:
					return ips.getString('attachDone');
			}
		}

		/**
		 * Updates a file element with the current status
		 *
		 * @param 	{object} 	file 	File information object from plupload
		 * @returns {jQuery} 	The file element
		 */
		function _updateFileElement(file) {
			const fileElem = _findFileElem(file);

			_removeStatusClasses( fileElem );
			_updateStatus( fileElem, file.status );
			_updateCount();

			return fileElem;
		}

		/**
		 * Returns the file element for a given file object
		 *
		 * @param 	{object}	file 	 	File object from plupload
		 * @returns {jQuery}
		 */
		function _findFileElem(file) {
			return $( elem ).find('#' + file.id);
		}

		/**
		 * Updates the relevant elements within a file element with the current file status
		 *
		 * @param 	{jQuery}	fileElem 	The element that represents this file
		 * @param	{number} 	status 	 	Current status code
		 * @returns {void}
		 */
		function _updateStatus(fileElem, status) {
			$(fileElem).find('[data-role="status"]').html( _getStatus(status) );
			$(fileElem).toggleClass('ipsAttach_error', status === plupload.FAILED);
		}

		/**
		 * Removes the 4 status classes from the provided file element
		 *
		 * @param 	{element}	fileElem 	The element that represents this file
		 * @returns {void}
		 */
		function _removeStatusClasses(fileElem) {
			_.each( ['uploading', 'done', 'error', 'queued'], function (type) {
				fileElem.removeClass( 'ipsAttach_' + type );
			});
		}

		/**
		 * Updates relevant elements with the uploaded count, and fires an event to let everyone know
		 *
		 * @returns 	{void}
		 */
		function _updateCount() {
			$( elem ).find('[data-role="count"]').text( uploadCount );

			elem.trigger('uploadedCountChanged', {
				count: uploadCount,
				percent: pluploadObj.total.percent,
				uploader: options.name
			});
		}

		/**
		 * Updates relevant element within a file element with the percentage completed
		 *
		 * @param 	{element}	fileElem 	The element that represents this file
		 * @param	{number} 	percent 	Percentage complete
		 * @returns {void}
		 */
		function _setPercent(fileElem, percent) {
			$(fileElem).find('[data-role="progressbar"]').attr('value', percent);

			if( percent === 100 ){
				fileElem.find('.ipsMeter').slideUp();
			}
		}

		/**
		 * Builds a thumbnail element
		 *
		 * @param 	{element}	fileElem 	The element that represents this file
		 * @param	{object} 	file 	 	File information object
		 * @param	{object} 	info 	 	Info object from events.uploadDone
		 * @returns {void}
		 */
		function _buildThumb(fileElem, file, info) {
			let toInsert = '';

			if( info.imagesrc ){

				Debug.log( fileElem.find('[data-role="preview"]') );

				toInsert = $('<img/>').attr( { src: info.thumbnail ? info.thumbnail : info.imagesrc, alt: '' } );
				fileElem
					.attr( 'data-fullsizeurl', info.imagesrc )
					.attr( 'data-thumbnailurl', info.thumbnail ? info.thumbnail : info.imagesrc )
					.find('[data-role="preview"]')
						.html( toInsert );
			} else if( info.videosrc ){
				toInsert = $('<video/>').append( $('<source/>').attr( { src: info.videosrc, type: fileElem.attr('data-mimeType') } ) );
				fileElem
					.attr( 'data-fullsizeurl', info.videosrc )
					.find('[data-role="preview"]')
						.html( toInsert );
			}


			fileElem.attr( 'data-fileid', info.id );
			if ( info.securityKey ) {
				fileElem.attr( 'data-filekey', info.securityKey );
			}
		}

		/**
		 * Deletes a pre-existing file
		 *
		 * @param 	{element}	fileElem 	The element that represents this file
		 * @param	{event} 	e 	 		Info object from events.uploadDone
		 * @returns {void}
		 */
		function _deleteFile(fileElem, e) {
			e.preventDefault();
			e.stopPropagation();

			let baseUrl = options.action;

			if( baseUrl.match(/\?/) ) {
				if( baseUrl.slice(-1) !== '?' ){
					baseUrl += '&';
				}
			} else {
				baseUrl += '?';
			}

			// Delete via ajax
			ips.getAjax()( baseUrl + 'getUploader&postKey=' + options.postkey + '&deleteFile=' + encodeURIComponent( fileElem.attr('data-fileid') ) );

			// Update upload count
			uploadCount--;
			totalSize = totalSize - fileElem.attr('data-filesize');
			_updateCount();

			// Remove element
			/*fileElem.animationComplete( function () {
				fileElem.remove();

				// Let the document know
				elem.trigger( 'fileDeleted', { fileElem: fileElem, uploader: options.name, count: uploadCount } );
			});

			ips.utils.anim.go( 'fadeOutDown', fileElem );*/

			fileElem.fadeOut( function () {
				fileElem.remove();
				// Let the document know
				elem.trigger( 'fileDeleted', { fileElem: fileElem, uploader: options.name, count: uploadCount, postkey: options.postkey } );
			});
		}

		/**
		 * Returns boolean indicating if dragging is supported
		 *
		 * @returns {boolean}	Supports draggable?
		 */
		function _supportsDraggable() {
			return 'draggable' in document.createElement('span') && FileReader !== undefined && !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
		}

		/**
		 * Fix the z-index of the upload messages prompt. For some reason, plupload and/or moxie.js sets the z-index to 1 but we don't need that.
		 *
		 * @returns {void}
		 *
		 * @private
		 */
		function _fixZIndex() {
			$(elem).get(0).querySelector(options.button)?.style.setProperty('z-index', '')
		}

		// Events object
		let events = {
			/**
			 * Init
			 */
			init(up) {
				_fixZIndex();
				if( _supportsDraggable() ) {
					const dropElement = $(up.settings.drop_element);

					// Handles adding the dragging class to the upload element.
					// dragleave is a pain and works like mouseout instead of mouseleave in that it fires as soon as we leave the parent,
					// even if we're actually in a child now. So we have to get creative about detecting it correctly by listening for
					// dragenters on the whole document, and seeing whether they're children of our upload element.
					let currentElem = null;

					$( document )
						.on('dragenter', function (e) {
							if( currentElem && !$( e.target ).is( dropElement) && !$.contains( dropElement.get(0), currentElem ) ){
								dropElement.removeClass('ipsDragging');
								currentElem = null;
							}
						});

					dropElement
						.on('dragleave', function () {
							if( !$( currentElem ).is( dropElement) && !$.contains( dropElement.get(0), currentElem ) ){
								dropElement.removeClass('ipsDragging');
								currentElem = null;
							}
						})
						.on('dragenter', function (e) {
							const target = $(e.target);

							if( target.is( dropElement ) || $.contains( dropElement.get(0), e.target ) ){
								dropElement.addClass('ipsDragging');
								currentElem = e.target;
							}
						})
						.on('drop', function () {
							dropElement.removeClass('ipsDragging');
							currentElem = null;
						});
				}
			},

			/**
			 * Files Added
			 */
			filesAdded(up, files) {
				_fixZIndex();
				if (!options.multiple) {
					listContainer.find( '[data-role="deleteFile"]' ).click();
					if (files.length > 1) {
						ips.ui.alert.show({
							type: 'alert',
							icon: 'warn',
							message:ips.getString('uploadSingleErr')
						});

						for (const file of files) {
							up.removeFile(file);
						}

						return false;
					}
				} else if (options.maxFiles) {
					if (files.length > options.maxFiles || ( uploadCount + files.length ) > options.maxFiles) {
						ips.ui.alert.show( {
							type: 'alert',
							icon: 'warn',
							message: ips.pluralize( ips.getString( 'uploadMaxFilesErr' ), options.maxFiles ),
							callbacks: {}
						});

						for (const file of files) {
							up.removeFile( file );
						}

						return false;
					}
				} else if (options.maxTotalSize && totalSize > ( options.maxTotalSize * 1048576 )) {

					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warn',
						message: ips.getString( 'uploadTotalErr', {
							size: parseFloat(
								( options.maxTotalSize >= 1 ) ? options.maxTotalSize : ( options.maxTotalSize * 1024 )
							).toLocaleString( $('html').attr('lang') ),
							size_suffix: ( options.maxTotalSize >= 1 ) ? ips.getString('size_mb') : ips.getString('size_kb')
						} ),
						callbacks: {}
					});

					for (const file of files) {
						up.removeFile( file );
					}

					return false;
				}

				const allowedFileTypes = (options.allowedFileTypes !== null) ? new Set(JSON.parse(options.allowedFileTypes?.toLowerCase?.()) || []) : '';
				let tooLarge = 0,
					overTotalLimit = 0,
					badType = 0,
					sizeAllowance = options.maxTotalSize ? (options.maxTotalSize * 1048576) - totalSize : null,
					fileSizeAllowance = options.maxFileSize ? options.maxFileSize * 1048576 : null

				for (let file of files) {
					// Check the size of this file
					if (fileSizeAllowance !== null && file.size > fileSizeAllowance) {
						// The file is too big, so remove it
						tooLarge++;
						up.removeFile( file );
						continue;
					}

					// Check max size allowed
					if (sizeAllowance !== null) {
						if (sizeAllowance < file.size) {
							// The file would put us over our limit, so remove it
							overTotalLimit++;
							up.removeFile( file );
							continue;
						}
						sizeAllowance -= file.size;
					}

					// And the extension
					const ext = file.name.split('.').pop().toLowerCase();
					if ( allowedFileTypes?.size && !allowedFileTypes.has(ext)) {
						badType++;
						up.removeFile( file );
						continue;
					}

					const size = plupload.formatSize( file.size ),
						status = _getStatus( file.status );

					// Trigger event for adding the file element, to allow controllers to intercept
					$( elem ).trigger( 'addUploaderFile', {
						uploaderID: uploaderID,
						id: file.id,
						title: file.name,
						mime: file.type,
						size: size,
						sizeRaw: file.size,
						status,
						statusCode: file.status,
						statusText: ips.getString('attachStatus', { size: size, status: status } ),
						field_name: elem.attr('data-ipsUploader-name'),
						newUpload: true,
						insertable: true,
						isImage: imageExtensions.has(ext),
						isVideo: videoExtensions.has(ext),
						isAudio: audioExtensions.has(ext),
						supportsDelete: options.supportsDelete
					} );

					$('#' + file.id)
						.addClass( 'ipsAttach_queued' )
						.trigger( 'newItem', [ $('#' + file.id) ] );
				}

				// Do we need to warn the user?
				if (tooLarge) {
					ips.ui.alert.show({
						type: 'alert',
						icon: 'warn',
						message: ips.pluralize(
							ips.getString(
								'uploadSizeErr',
								{
									max_file_size: parseFloat(( options.maxFileSize > 1 ) ? options.maxFileSize : ( options.maxFileSize * 1024 ))
										.toLocaleString(document.documentElement.lang),
									size_suffix: ( options.maxFileSize > 1 ) ? ips.getString('size_mb') : ips.getString('size_kb')
								}),
							[tooLarge, tooLarge])
					});
					for (const file of files) {
						up.removeFile(file);
					}
				}

				if (overTotalLimit) {
					ips.ui.alert.show({
						type: 'alert',
						icon: 'warn',
						message: ips.pluralize(
							ips.getString(
								'uploadSizeTotalErr',
								{
									max_file_size: parseFloat(options.maxTotalSize > 1 ? options.maxTotalSize : options.maxTotalSize * 1024)
										.toLocaleString(document.documentElement.lang),
									size_suffix: ( options.maxTotalSize > 1 ) ? ips.getString('size_mb') : ips.getString('size_kb')
								}),
							[overTotalLimit, overTotalLimit]
						),
						callbacks: {}
					});
				}

				if (badType) {
					ips.ui.alert.show({
						type: 'alert',
						icon: 'warn',
						message: ips.pluralize(
							ips.getString(
								'pluploaderr_-601',
								{ allowed_extensions: [...allowedFileTypes].join(', ') }
							),
							[tooLarge, tooLarge]
						),
						callbacks: {}
					});
				}

				// If we still have some files, we can start them
				if (up.files.length) {
					$(elem).trigger('fileAdded', {
						count: up.files.length,
						uploader: options.name
					});

					if (options.autoStart) {
						_startUpload();
					}
				}
			},

			filesRemoved(uploader, files) {
				if (files instanceof Array || Symbol.iterator in files) {
					for (const file of files) {
						if (file.id && injectIds[file.id]?.error instanceof Function) {
							try {
								injectIds[file.id].error();
							} catch (e) {
								console.error(e);
							}
						}
					}
				}
				_fixZIndex();
				Debug.log('removed');
			},

			/**
			 * Upload File
			 */
			uploadFile(up, file) {
				_fixZIndex();
				$(elem).find('.ipsAttachment_loading').show();
				_updateFileElement( file ).addClass('ipsAttach_uploading');
			},

			/**
			 * Upload Progress
			 */
			uploadProgress(up, file) {
				_fixZIndex();
				const fileElem = _updateFileElement(file);
				fileElem.addClass('ipsAttach_uploading');

				// Set the progress percent
				_setPercent( fileElem, file.percent );

				elem.trigger('uploadProgress', {
					count: uploadCount,
					percent: pluploadObj.total.percent,
					uploader: options.name
				});
			},

			/**
			 * All files have finished uploading
			 * We'll show a notification & sound if supported
			 */
			uploadComplete(up, files) {
				_fixZIndex();
				let success = 0;
				let error = 0;

				// Figure out how many files were successful/errors, ignore other statuses
				_.each( files, function (file) {
					if( file.status === 5 ){
						success++;
					} else if ( file.status === 4 ){
						error++;
					}
				});

				const total = success + error;


				/* Make sure the spinner is reset */
				$(elem).find('.ipsAttachment_loading').hide();

				elem.trigger('uploadComplete', {
					success: success,
					error: error,
					total: total,
					uploader: options.name
				});

				// Only if we aren't active on the page
				if( ips.utils.events.getVisibilityProp() !== undefined || !document[ ips.utils.events.getVisibilityProp() ] ){
					return;
				}

				const text = [];

				if( !total ){
					return;
				}

				if( success ){
					text.push( ips.pluralize( ips.getString('notifyUploadSuccess'), [ success ] ) );
				}

				if( error ){
					text.push( ips.pluralize( ips.getString('notifyUploadError'), [ error ] ) );
				}

				if( ips.utils.notification.hasPermission() ){
					ips.utils.notification.create({
						title: ips.pluralize( ips.getString('yourUploadsFinished'), [ total ] ),
						body: text.join(' '),
						icon: ips.getSetting('upload_imgURL'),
						onClick: function () {
							try {
								window.focus();
							} catch (err) {}
						}
					}).show();
				}

				if( sound ){
					try {
						sound.play();
					} catch (err) { }
				}
			},

			/**
			 * File Uploaded
			 */
			fileUploaded(up, file, info) {
				_fixZIndex();

				// Update count of completed files
				uploadCount++;

				totalSize += file.size;

				const fileElem = _updateFileElement(file);

				fileElem.addClass('ipsAttach_done');

				if( options.insertable ){
					ips.utils.anim.go('fadeIn', fileElem.find('[data-role="insert"]') );
				}

				fileElem.find('[data-role="deleteFileWrapper"]').slideDown();
				//ips.utils.anim.go('fadeIn',  );

				// Set the progress percent
				_setPercent( fileElem, 100 );

				// Do we have an image to process?
				try {
					const jsonInfo = $.parseJSON(info.response);

					elem.before( $('<input type="hidden">').attr( 'name', elem.attr('data-ipsUploader-name') + '_existing[' + file.id + ']' ).attr( 'value', jsonInfo.id ) );

					if( jsonInfo['error'] ){
						fileElem.on( 'click', '[data-role="deleteFile"]', _.bind( _deleteFile, fileElem, fileElem ) );
						file.status	= plupload.FAILED;

						up.trigger('error', {
							code: jsonInfo['error'],
							extra: jsonInfo['extra'],
							subText: jsonInfo['sub'],
							file: file,
							uploader: options.name
						});

						return;
					}

					if( jsonInfo ){
						_buildThumb( fileElem, file, jsonInfo );
						fileElem.on( 'click', '[data-role="deleteFile"]', _.bind( _deleteFile, fileElem, fileElem ) );
					}
				} catch (err) {

					fileElem.on( 'click', '[data-role="deleteFile"]', _.bind( _deleteFile, fileElem, fileElem ) );
					file.status	= plupload.FAILED;

					up.trigger('error', {
						code: 'upload_error',
						extra: err.message,
						file: file,
						uploader: options.name
					});

					Debug.warn( err );
				}

				// Are we handling this immediately?
				if ( file.id && injectIds[ file.id ] ) {
					$( elem ).trigger( 'fileInjected', { 'fileElem': fileElem, 'data': injectIds[ file.id ] } );
					delete injectIds[ file.id ];
				}
			},

			/**
			 * Error
			 */
			error(up, err) {
				_fixZIndex();
				if( err.file ){
					const {file} = err;
					if (file.id && file.id in injectIds && injectIds[file.id].error instanceof Function) {
						injectIds[file.id].error();
					}
					_updateFileElement( file );
				}

				// If this is a 'too large' error, we won't
				if( err.code === -600 || err.code === -601 ){
					return;
				}

				let errorMessage = ips.getString('pluploaderr_' + err.code, {
					max_file_size: parseFloat(
						(options.maxFileSize > 1) ? options.maxFileSize : (options.maxFileSize * 1024)
					).toLocaleString($('html').attr('lang')),
					size_suffix: (options.maxFileSize > 1) ? ips.getString('size_mb') : ips.getString('size_kb'),
					allowed_extensions: (options.allowedFileTypes !== null) ? $.parseJSON(options.allowedFileTypes).join(',') : '',
					server_error_code: (err.extra !== null) ? err.extra : 0,
				});

				if ( !errorMessage ) {
					errorMessage = ips.getString( 'pluploaderr_SERVER_CONFIGURATION', {
						server_error_code: err.code
					} );

					err.subText = ips.getString('pluploaderr_error_code', { code: err.code });
				}

				if (typeof err?.file?.id === 'string') {
					delete injectIds[err.file.id];
				}

				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: errorMessage,
					callbacks: {},
					subTextHtml: err.subText ? err.subText : null
				});
			}
		};

		init();

		return {
			init,
			refresh
		};
	};
	"use strict";

	const iconMap = {
		'txt': 'file-lines',
		'rtf': 'file-lines',
		'csv': 'file-lines',
		'pdf': 'file-pdf',
		'doc': 'file-word',
		'docx': 'file-word',
		'xls': 'file-excel',
		'xlsx': 'file-excel',
		'xlsm': 'file-excel',
		'zip': 'file-archive',
		'tar': 'file-archive',
		'gz': 'file-archive',
		'ppt': 'file-powerpoint',
		'pptx': 'file-powerpoint',
		'ico': 'file-image',
		'gif': 'file-image',
		'jpeg': 'file-image',
		'jpg': 'file-image',
		'jpe': 'file-image',
		'png': 'file-image',
		'avif': 'file-image',
		'psd': 'file-image',
		'webp': 'file-image',
		'aac': 'file-audio',
		'mp3': 'file-audio',
		'ogg': 'file-audio',
		'ogv': 'file-audio',
		'wav': 'file-audio',
		'm4a': 'file-audio',
		'flv': 'file-video',
		'mkv': 'file-video',
		'mp4': 'file-video',
		'mpg': 'file-video',
		'mpeg': 'file-video',
		'3gp': 'file-video',
		'webm': 'file-video',
		'wmv': 'file-video',
		'avi': 'file-video',
		'm4v': 'file-video',
		'mov': 'file-video',
		'css': 'file-code',
		'html': 'file-code',
		'js': 'file-code',
		'xml': 'file-code',
	};

	ips.createModule('ips.ui.uploader', function(){

		const defaults = {
			multiple: false,
			allowedFileTypes: null,
			maxFileSize: null, // in megabytes
			maxTotalSize: null, // in megabytes
			maxChunkSize: null,
			action: null,
			name: 'upload',
			button: '.ipsButton--primary',
			key: null,
			autoStart: true,
			insertable: false,
			template: 'core.attachments.fileItem',
			postkey: '',
			supportsDelete: true,
			allowStockPhotos: false,
		};

		function respond(elem, options) {
			if( !$( elem ).data('_uploader') ){
				$( elem ).show();
				$( elem ).data('_uploader', uploadObj(elem, _.defaults( options, defaults ) ) );
			} else {
				try {
					const obj = $(elem).data('_uploader');
					obj.refresh();
				} catch (err) {
					Debug.log("Couldn't refresh uploader " + $( elem ).identify().attr('id') );
				}
			}
		}

		/**
		 * Refresh an existing uploader instance
		 *
		 * @param	{element} 	elem 		The element to refresh
		 * @returns {void}
		 */
		function refresh(elem) {
			try {
				const obj = $(elem).data('_uploader');
				obj.refresh();
			} catch (err) {
				Debug.log("Couldn't refresh uploader " + $( elem ).identify().attr('id') );
			}
		}

		/**
		 * Retrieve the uploader instance (if any) on the given element
		 *
		 * @param	{element} 	elem 		The element to check
		 * @returns {*} 	The uploader instance or undefined
		 */
		function getObj(elem) {
			if( $( elem ).data('_uploader') ){
				return $( elem ).data('_uploader');
			}

			return undefined;
		}

		/**
		 * Return an appropriate file type icon based on a provided filename extension
		 *
		 * @param	{string} 	filename 		The filename to use
		 * @returns {string} 	A fontawesome classname
		 */
		function getExtensionIcon(filename) {
			const extRegex = /(?:\.([^.]+))?$/;
			const ext = extRegex.exec(filename);

			if( !_.isUndefined( iconMap[ext[1]] ) ){
				return iconMap[ext[1]];
			}

			return 'file';
		}

		ips.ui.registerWidget('uploader', ips.ui.uploader, [ 
			'multiple', 'allowedFileTypes', 'maxFileSize', 'maxTotalSize', 'maxChunkSize', 'action', 'name', 'button', 'key', 
			'maxFiles', 'dropTarget', 'listContainer', 'autoStart', 'insertable', 'template', 'existingFiles', 'postkey',
			'supportsDelete', 'allowStockPhotos'
		] );

		return {
			respond: respond,
			refresh: refresh,
			getObj: getObj,
			getExtensionIcon: getExtensionIcon
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.validation.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.validation.js - A form validation UI component
 * A wrapper for our main form validation that enables us to show
 * pretty messages to the user, and expose a data api
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.validation', function(){

		var defaults = {
			live: true,
			submit: true,
			characterLimit: 3,
			displayAs: 'list'
		};

		/**
 		 * Respond to a dialog trigger
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed
		 * @returns {void}
		 */
		var respond = function (elem, options, e) {
			if( !$( elem ).data('_validation') ){
				$( elem ).data('_validation', validateObj(elem, _.defaults( options, defaults ) ) );
			}
		};

		/**
		 * Validation instance
		 *
		 * @param	{element} 	elem 		The element this widget is being created on
		 * @param	{object} 	options 	The options passed into this instance
		 * @returns {void}
		 */
		var validateObj = function (elem, options) {

			/**
			 * Sets up this instance
			 * Adds necessary events using delegates to fields in this form
			 *
			 * @returns 	{void}
			 */
			var init = function () {
				
				// Set up events
				if( options.live ){
					// Text-like inputs
					$( elem ).on( 'keyup blur', 'input:not( [type="button"] ):not( [type="checkbox"] ):not( [type="hidden"] )' + 
						':not( [type="radio"] ):not( [data-validate-bypass] ), textarea:not( [data-validate-bypass] )', _textEvent );	

					// Selects
					$( elem ).on( 'change', 'select', _selectEvent );
				}

				if( options.submit ){
					$( elem ).closest('form').on( 'submit', _submitEvent );
				}				
			},

			/**
			 * Handles the form submit event
			 *
			 * @param	{event} 	e 		Event object
			 * @returns {void}
			 */
			_submitEvent = function (e) {
				var errors = 0;

				// Find all relevant fields
				var elements = $( elem ).find('input:not( [type="submit"] ):not( [type="checkbox"] )' + 
						':not( [type="radio"] ):not( [type="hidden"] ), select, textarea');

				// Validate each field in turn
				elements.each( function () {
					if( !_validate( $( this ) ) ){
						errors++;
					}
				});

				if( errors > 0 ){
					e.preventDefault();
					$( e.currentTarget ).trigger( 'error.validation', { count: errors } );
				} else {
					$( e.currentTarget ).trigger( 'success.validation' );
				}
			},

			_selectEvent = function (e) {

			},

			/**
			 * Handles events on text-like fields
			 *
			 * @param	{element} 	elem 		The element this widget is being created on
			 * @param	{object} 	options 	The options passed into this instance
			 * @returns {void}
			 */
			_textEvent = function (e) {
				var field = $( e.currentTarget );

				// If this is the blur event, only validate if we're above the character limit or this is a numerical field
				// If this is the keyup event, only validate if we're currently displaying some errors
				if( e.type == 'blur' || e.type == 'focusout' ){
					if( field.val().length >= options.characterLimit || field.is('[type="number"], [type="range"]') ){
						_validate( field );	
					}			
				} else {
					if( field.attr('data-hasErrors') ){
						_validate( field );
					} 
				}
			},

			/**
			 * Validates an individual field, displaying or clearing errors as needed
			 *
			 * @param	{element} 	target 		The element being validated
			 * @returns {boolean}	Whether the field is valid
			 */
			_validate = function (target) {
				var result = ips.utils.validate.validate( target );

				if( result !== true && !result.result ){
					_displayErrors( target, result );
				} else {
					_clearErrors( target );
				}

				return result.result;
			},

			/**
			 * Displays errors for a field
			 *
			 * @param	{element} 	target 		The element being validated
			 * @param	{object} 	results 	Results object returned from ips.utils.validate.validate
			 * @returns {void}
			 */
			_displayErrors = function (target, results) {
				var id = target.identify().attr('id');
				var errorList = $( '#' + id + '_errors' );

				// Build error list if necessary
				if( !errorList.length ) {
					var wrapper = ips.templates.render( 'core.forms.validationWrapper', {
						id: id + '_errors'
					} );

					target.after( wrapper );
					errorList = $('#' + id + '_errors');
				}

				// Reset contents of list
				errorList.html('');

				// Loop through each message
				for( var i = 0; i < results.messages.length; i++ ){
					errorList.append( ips.templates.render( 'core.forms.validationItem', {
						message: results.messages[ i ].message
					}));
				}

				// Add error class and attribute to the input
				target
					.addClass('ipsField_error')
					.attr( 'data-hasErrors', true );
			},

			/**
			 * Clears errors for a field
			 *
			 * @param	{element} 	target 		The form element being cleared
			 * @returns {void}
			 */
			_clearErrors = function (target) {
				var id = target.identify().attr('id');

				if( $( '#' + id + '_errors').length ){
					$( '#' + id + '_errors' ).remove();
				}

				// Remove classname and attribute
				target
					.removeClass('ipsField_error')
					.removeAttr('data-hasErrors');
			}

			init();

			return { };
		};

		ips.ui.registerWidget('validation', ips.ui.validation);

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.webcomponents.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
* Invision Community
* (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
*
* ips.ui.webcomponents.js - Module to register all ad-hoc web components
*
* Author: Matt Finger
*/
;(function($, _) {
	[
		"card",
		"dropdown",
		"pwaInstall",
		"pushNotificationsPrompt",
		"themeEditor",
		"latex",
		"latexNodeview"
	].forEach(component => {
		ips.createModule(`ips.ui.${component}`, function() {
			// Load JS when the element is identified on page load
			ips.ui.registerWidget(component, false);
			return {};
		});
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/ui" javascript_name="ips.ui.wizard.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.wizard.js - Wizard widget
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.wizard', function(){
		
		var respond = function (elem, options, e) {
			elem.on( 'click', '[data-action="wizardLink"]', _.bind( refresh, e, elem ) );
			elem.on( 'submit', 'form', _.bind( refresh, e, elem ) );
		};
		
		/**
		 * Reloads a page of the wizard
		 *
		 * @param 		{element} 	elem 	The wizard element
		 * @param		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		var refresh = function(elem, e) {
			var target = $( e.currentTarget );
			
			_showLoading( elem );
						
			if( target.is('form') ){
				if( target.attr('data-bypassAjax') ){
					return true;
				}

				// Stop all the propagations too because the wizard could be inside a menu or a dialog which have their own listeners on the submit events.
				e.preventDefault();
				e.stopPropagation();
				e.stopImmediatePropagation();

				var data = target.serialize() + '&_wizardHeight=' + elem.find('[data-role="loading"]').outerHeight();

				// Include the value of any button clicked
				if( e.originalEvent && e.originalEvent.submitter && e.originalEvent.submitter.name && e.originalEvent.submitter.value ) {
					data += '&' + e.originalEvent.submitter.name + '=' + e.originalEvent.submitter.value;
				}

				ips.getAjax()( target.attr('action'), {
					data: data,
					type: 'post'
				}).done( function (response) {
					_insertHtml( response, elem );
				})
				.fail(function(response, textStatus, errorThrown){
					target.attr( 'data-bypassAjax', true );
					target.submit();
				})
			} else {
				e.preventDefault();
				
				ips.getAjax()( target.attr('href') ).done( function (response) {
					_insertHtml( response, elem );
				});
			}
			
		},

		/**
		 * Get wizard response HTML (including assets) and insert
		 *
		 * @param		{string}	response	HTML response (or, occasionally, an object with a redirect URL)
		 * @param		{element}	elem	The wizard element
		 * @return		{void}
		 */
		 _insertHtml = function (response, elem) {
			// If a json object is returned with a redirect key, send the user there
			if( _.isObject( response ) && response.redirect ){
				window.location = response.redirect;
				return;
			}

			var responseDiv		= $( '<div>' + response + '</div>' );
			var responseWizard	= responseDiv.find('[data-ipsWizard]').html();
			if ( !responseWizard ) {
				responseWizard = response;
			}

			// Find any CSS or JS references and include them. This is necessary if, e.g., a codemirror form element
			// was included in a wizard step as we need to include its js and CSS files.
			responseDiv.find( "link", "script" ).appendTo( 'head' );

			ips.controller.cleanContentsOf( elem );
			elem.html( responseWizard );
			$( document ).trigger( 'contentChange', [ elem ] );

			elem.trigger( 'wizardStepChanged' );
		 },

		/**
		 * Shows the loading thingy by working out the size of the form its replacing
		 *
		 * @param 		{element} 	elem 	The wizard element
		 * @returns 	{void}
		 */
		_showLoading = function (elem) {
			var loading = elem.find('[data-role="loading"]');
			var formContainer = elem.find('[data-role="wizardContent"]');
			
			if ( !formContainer.is(':visible') ) { // May have already been replaced by a loading indicator in userland code - for example, nexus.global.gateways.stripe does this
				return;
			}

			if( !loading.length ){
				loading = $('<div/>').attr('data-role', 'loading').addClass('ipsLoading').hide();
				elem.append( loading );
			}

			var dims = {
				width: formContainer.outerWidth(),
				height: formContainer.outerHeight()
			};

			loading
				.css({
					width: dims.width + 'px',
					height: dims.height + 'px'
				})
				.show();

			formContainer
				.hide()
				.after( loading.show() );
		},

		/**
		 * Hides the loading thingy
		 *
		 * @returns 	{void}
		 */
		_hideLoading = function () {
			var loading = elem.find('[data-role="loading"]');
			var formContainer = elem.find('[data-role="registerForm"]');

			loading.remove();
			formContainer.show();
		};

		// Register this module as a widget to enable the data API and
		// jQuery plugin functionality
		ips.ui.registerWidget( 'wizard', ips.ui.wizard );

		return {
			respond: respond
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.analytics.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.analytics.js - Analytics helper methods
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	&quot;use strict&quot;;
	
	ips.createModule('ips.utils.analytics', function () {

		/**
		 * Initialize analytics module
		 *
		 * @returns 	{void}
		 */
		var init = function () {

		},

		trackPageView = function (url) {
			try {
				if( ips.getSetting('googleAnalyticsEnabled') ){
					if( !_.isUndefined( window.ga ) ){
						var urlObj = ips.utils.url.getURIObject( url || document.location );
						Debug.log(&quot;Manual page view tracked with Google Analytics: &quot; + urlObj.relative);
						ga('send', 'pageview', urlObj.relative);
					}
				}
				
				if( ips.getSetting('matomoEnabled') ){
					if( !_isUndefined( window._paq ) ){
						Debug.log(&quot;Manual page view tracked with Matomo&quot;);
						_paq.push(['trackPageView']);
					}
				}
				
				if( _.isFunction( ips.getSetting('paginateCode') ) ){
					ips.getSetting('paginateCode').call(url);
				}
			} catch (err) {
				Debug.log(&quot;Error tracking page view: &quot; + err);
			}
		};

		return {
			init: init,
			trackPageView: trackPageView
		};
	});

}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.anim.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.anim.js - Simple CSS classname-based animations
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
"use strict";

	ips.createModule('ips.utils.anim', function(){

		/* Check for animation support */
		var animationSupport = false;
		var elm = document.createElement('div'),
			animation = false,
		    animationstring = 'animation',
		    keyframeprefix = '',
		    domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
		    pfx  = '';
		if( elm.style.animationName ){
			animationSupport = true; 
		}    
		if( animationSupport === false ) {
			for( var i=0; i < domPrefixes.length; i++ ) {
		    	if( elm.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
		      		pfx = domPrefixes[ i ];
		      		animationstring = pfx + 'Animation';
		      		keyframeprefix = '-' + pfx.toLowerCase() + '-';
		      		animationSupport = true;
		      		break;
		    	}
		 	}
		}

		var init = function () {
			
		},

		/** Object containing all of our transition definitions */
		_transitions = {
			// Fades a single element in
			fadeIn: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem							
							.show()
							.addClass( [ 'ipsAnim', 'ipsAnim_fade', 'ipsAnim_in', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.fadeIn('fast');
				}
			},

			// Fades a single element out
			fadeOut: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem							
							.addClass( [ 'ipsAnim', 'ipsAnim_fade', 'ipsAnim_out', speed ].join(' ') )
							.animationComplete( function() { 
								elem.hide();
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					let cb;
					setTimeout(() => {
						elem.fadeOut('fast', () => elem.forEach(function() { cb?.(this) }));
					});
					return {
						/**
						 *
						 * @param {function(Element)} callback
						 */
						done: callback => cb = callback,
					}
				}
			},

			// Fades a single element in while sliding down a little
			fadeInDown: {
				anim: function (elem, speed) {
					cleanClasses( elem );
					
					return elem
							.show()
							.addClass( [ 'ipsAnim', 'ipsAnim_fade', 'ipsAnim_in', 'ipsAnim_down', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.fadeIn('fast');
				}
			},

			// Fades a single element out while sliding down a little
			fadeOutDown: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_fade', 'ipsAnim_out', 'ipsAnim_down', speed ].join(' ') )
							.animationComplete( function() { 
								elem.hide();
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.fadeOut('fast');
				}
			},

			// Slide an element from the right, to the left
			slideLeft: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_slide', 'ipsAnim_left', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.show();
				}
			},

			// Blind down animation, from 0 height to full height
			blindDown: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.show()
							.addClass( [ 'ipsAnim', 'ipsAnim_blind', 'ipsAnim_down', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.show();
				}
			},

			// Blind up animation, from full to 0 height
			blindUp: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.show()
							.addClass( [ 'ipsAnim', 'ipsAnim_blind', 'ipsAnim_up', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.hide();
				}
			},

			// Zoom element in from 0x0 to normal size
			zoomIn: {
				anim: function (elem, speed) {
					cleanClasses( elem );
					
					return elem
							.show()
							.addClass( [ 'ipsAnim', 'ipsAnim_zoom', 'ipsAnim_in', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.show();
				}
			},

			// Zoom element in from 0x0 to normal size
			zoomOut: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_zoom', 'ipsAnim_out', speed ].join(' ') )
							.animationComplete( function() {
								elem.hide();
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem.hide();
				}
			},

			// Shake from left to right
			wobble: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_wobble', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem;
				}
			},

			jiggle: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_jiggle' ].join(' ') )
							.animationComplete( function () {
								cleanClasses( elem );
							})
				},
				fallback: function (elem) {
					return elem;
				}
			},

			// Pulse one time
			pulseOnce: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_pulseOnce', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem;
				}
			},
			
			// Pulse one time and jiggle
			pulseAndJiggle: {
				anim: function (elem, speed) {
					cleanClasses( elem );

					return elem
							.addClass( [ 'ipsAnim', 'ipsAnim_pulseAndJiggle', speed ].join(' ') )
							.animationComplete( function() {
								cleanClasses( elem );
							});
				},
				fallback: function (elem) {
					return elem;
				}
			}
		},

		/**
		 * Executes the given transition, passing through provided objects
		 *
		 * @param	{string} 	animationInfo 	Name of the transition to use, and 
		 *										optionally a speed (space-separated)
		 * @param	{element} 	[...]	 		Arbitrary number of elements to pass to the transition handler
		 * @returns {object}	Returns a promise object that resolves when animation is completed on ALL provided elements
		 */
		go = function (animationInfo) {

			var thisArgs = arguments,
				run = 'anim';

			// Make arguments an array first
			thisArgs = ips.utils.argsToArray( thisArgs );

			// Get rid of the first item
			thisArgs.shift();

			// Get animName pieces
			animationInfo = animationInfo.split(' ');

			var animName = animationInfo[0];
			var animSpeed = ( animationInfo[1] ) ? 'ipsAnim_' + animationInfo[1] : ''; // default is blank right now

			if( !_transitions[ animName ] ){
				Debug.warn( "The animation '" + animName + "' doesn't exist");
				return;
			}

			// Which kind of function should we run?
			if( !animationSupport ){
				run = 'fallback';	
			}

			// Make the animation speed the last argument
			thisArgs.push( animSpeed );

			var elem = $( thisArgs[0] );
			var deferred = $.Deferred();
			var done = 0;

			// Function which checks whether all elements are done animating
			var _checkCount = function () {
				done++;

				if( done >= elem.length ){
					deferred.resolve();
				}
			};

			// Loop through each element, adding to its animation queue
			_.each( elem, function () {
				_addToQueue( elem, animName, run, thisArgs ).always( _checkCount );
				_checkQueue( elem );
			});
			
			return deferred.promise();
		},

		/**
		 * Add an animation to the queue of the provided element
		 *
		 * @param	{element} 	elem 		Element on which the animation executes
		 * @param	{string} 	animName	Animaton to be run
		 * @param 	{string}	toRun 		Type of anim to run (anim, or fallback)
		 * @param	{array} 	args 		Array of arguments to be passed to animation method
		 * @returns {object}	Returns a promise object, resolved when this animation has been executed
		 */
		_addToQueue = function (elem, animName, toRun, args) {
			var deferred = $.Deferred();

			// If we currently have a queue, then add this item
			if( !elem.data('animQueue') || !_.isArray( elem.data('animQueue') ) ){
				elem.data( 'animQueue', [] );
			}

			elem.data('animQueue').push({
				animName: animName,
				run: toRun,
				args: args,
				deferred: deferred
			});

			return deferred.promise();
		},

		/**
		 * Checks the queue of the provided element, and executes the next animation if ready
		 *
		 * @param	{element} 	elem 	Element to be checked
		 * @returns {void}
		 */
		_checkQueue = function (elem) {
			var queue = elem.data('animQueue');

			if( elem.attr('animating') == true || !queue || !_.isArray( queue ) || !queue.length ){
				return;
			}

			const item = queue.shift();
			let done = false;
			item.deferred.then(() => {
				if (!done) {
					done = true;
					_checkQueue(elem)
				}
			});

			if( item.run === 'anim' ){
				elem.animationComplete( function () {
					elem.attr( 'animating', false );
					item.deferred.resolve();
				});
				requestAnimationFrame(() => {
					elem.attr( 'animating', true );
					_transitions[ item.animName ][ item.run ].apply( this, item.args );
				});
			} else {
				requestAnimationFrame(() => {
					_transitions[ item.animName ][ item.run ].apply( this, item.args );
					item.deferred.resolve();
				});
			}

			// just in case, make sure we return something if no animation is running. If no animations are even started after 7ms, it's probably not worth waiting around. Worth mentioning transition delays in CSS transitions can break this.
			setTimeout(async () => {
				await Promise.allSettled(elem.get(0).getAnimations().map(anim => anim.finished));
				await new Promise(resolve => setTimeout(resolve, 1));
				if (!done) {
					item.deferred.resolve();
				}
			}, 7);
		},

		/**
		 * Removes all ipsAnim_* classnames from an element
		 * Used to prepare an element for new animations
		 *
		 * @param	{element} 	elem 	Element to clean
		 * @returns {element} 	Cleaned element
		 */
		cleanClasses = function (elem) {
			$( elem ).removeClass('ipsAnim').removeClass( function (index, css) {
				return ( css.match( /ipsAnim[0-9a-z_\-]+/gi ) || [] ).join(' ');
			});

			return elem;
		},

		/**
		 * Determines whether a transition already exists
		 *
		 * @param	{string} 	name 	Name of transition to check
		 * @returns {boolean}
		 */
		isTransition = function (name) {
			return !_.isUndefined( _transitions[ name ] );
		},

		/**
		 * Registers a transition
		 *
		 * @param	{string} 	name 				Name of this transitions
		 * @param	{function} 	cssAnimation		Function to execute when CSS animation is used
		 * @param 	{function} 	fallbackAnimation	Function to execute when fallback animation is needed
		 * @returns {void}
		 */
		addTransition = function (name, cssAnimation, fallbackAnimation) {
			if( _transitions[ name ] ){
				Debug.warn("A transition with the name '" + name + "' already exists");
				return;
			}

			_transitions[ name ] = {
				anim: cssAnimation,
				fallback: fallbackAnimation
			};
		};

		return {
			init: init,
			cleanClasses: cleanClasses,
			animationSupport: animationSupport,
			isTransition: isTransition,
			addTransition: addTransition,
			go: go,
			cancel: cleanClasses
		};

	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.broadcastChannel.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[;(function ($, _) {
    "use strict";

    /**
     * @module ips.utils.broadcastChannel
     *
     * Module for handling broadcast channels
     */
    ips.createModule('ips.utils.broadcastChannel', () => {
        const channel = 'BroadcastChannel' in window ? new window.BroadcastChannel("ipsBroadcastChannel") : undefined;
        return {
            channel: channel,
            enabled: 'BroadcastChannel' in window
        }
    })
})(jQuery, _);]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.color.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.color.js - Utilities for working with colors
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.color', function () {

		/**
		 * Initialize color module
		 *
		 * @returns 	{void}
		 */
		var init = function () {};

		/**
		 * Changes the provided hex value to have the provided hue/saturation levels
		 *
		 * @param		{string}	hex 	Hex color to start with
		 * @param 		{number}	toHue	New hue level
		 * @param 		{number}	toSat 	New saturation level
		 * @returns 	{string} 	New hex color
		 */
		var convertHex = function (hex, toHue, toSat) {
			hex = hex.replace( '#', '' );
			
			// Check for shorthand hex
			if( hex.length === 3 ){
				hex = hex.slice( 0, 1 ) + hex.slice( 0, 1 ) + hex.slice( 1, 2 ) + hex.slice( 1, 2 ) + hex.slice( 2, 3) + hex.slice( 2, 3 );
			}
			
			if( hex.length !== 6 ){
				Debug.write( hex + " isn't a valid hex color");
				return false;
			}
			
			// Split the hex into pieces, convert to RGB, and create fraction
			var r = ( hexToRGB( hex.slice( 0, 2 ) ) / 255 );
			var g = ( hexToRGB( hex.slice( 2, 4 ) ) / 255 );
			var b = ( hexToRGB( hex.slice( 4, 6 ) ) / 255 );

			// Convert to HSL
			var hsl = RGBtoHSL( r, g, b );

			// Change our hue to a fraction
			hsl[0] = (1 / 360) * toHue;			
			hsl[1] = (1 / 100) * toSat;

			// Back to RGB
			var rgb = HSLtoRGB( hsl[0], hsl[1], hsl[2] );

			return RGBtoHex( rgb[0], rgb[1], rgb[2] );
		},
		
		/**
		 * Converts the provided HSL values to their RGB versions
		 *
		 * @param		{number}	h 	Hue
		 * @param 		{number}	s	Saturation
		 * @param 		{number}	l 	Luminosity
		 * @returns 	{array} 	[ red, green, blue ]
		 */
		HSLtoRGB = function( h, s, l ){			
			var red = 0;
			var green = 0;
			var blue = 0;
			var v2 = 0;

			if( s == 0 ){
				red = l * 255;
				green = l * 255;
				blue = l * 255;
			} else {
				if( l < 0.5 ){
					v2 = l * ( 1 + s );
				} else {
					v2 = ( l + s ) - ( s * l );
				}
				
				var v1 = 2 * l - v2;
				
				red = 255 * hueToRGB( v1, v2, (h + ( 1 / 3 ) ) );
				green = 255 * hueToRGB( v1, v2, h );
				blue = 255 * hueToRGB( v1, v2, (h - ( 1 / 3 ) ) );
			}

			return [ Math.round( red ), Math.round( green ), Math.round( blue ) ];
		},
		
		/**
		 * Changes the provided hue values into an RGB value
		 *
		 * @returns 	{number} 	New RGB value
		 */
		hueToRGB = function( v1, v2, h ){
			if( h < 0 ){ 
				h += 1; 
			}

			if( h > 1 ){
				h -= 1; 
			}
			
			if( ( 6 * h ) < 1 ){
				return ( v1 + ( v2 - v1 ) * 6 * h );
			}

			if( ( 2 * h ) < 1 ){
				return v2;
			}

			if( ( 3 * h ) < 2 ){
				return ( v1 + ( v2 - v1 ) * ( ( 2 / 3 ) - h ) * 6 );
			}
			
			return v1;
		},
		
		/**
		 * Converts the provided RGB values to their HSL versions
		 *
		 * @param		{number}	r 	Red
		 * @param 		{number}	g	Green
		 * @param 		{number}	b 	Blue
		 * @returns 	{array} 	[ hue, saturation, lightness ]
		 */
		RGBtoHSL = function (r, g, b) {
			var lightness, hue, saturation = 0;
			
			var min = _.min( [ r, g, b ] );
			var max = _.max( [ r, g, b ] );

			var delta = max - min;
			
			lightness = ( max + min ) / 2;
			
			if( delta == 0 ){ 	// Grey
				hue = 0;
				saturation = 0;
			} else {
				if( lightness < 0.5 ){
					saturation = delta / ( max + min );
				} else {
					saturation = delta / ( 2 - max - min );
				}
				
				var delta_r = ( ( ( max - r ) / 6 ) + ( delta / 2 ) ) / delta;
				var delta_g = ( ( ( max - g ) / 6 ) + ( delta / 2 ) ) / delta;
				var delta_b = ( ( ( max - b ) / 6 ) + ( delta / 2 ) ) / delta;
				
				if( r == max ){
					hue = delta_b - delta_g;
				} else if( g == max ){
					hue = ( 1 / 3 ) + delta_r - delta_b;
				} else if( b == max ){
					hue = ( 2 / 3 ) + delta_g - delta_r;
				}
				
				if( hue < 0 ){
					hue += 1;
				}
				
				if( hue > 1 ){
					hue -= 1;
				}
			}
			
			return [ hue, saturation, lightness ];
		},
		
		/**
		 * Converts the provided hex into an RGB value
		 *
		 * @param		{string}	hex 	Hex value
		 * @returns 	{number} 	RGB value (0-255)
		 */
		hexToRGB = function (hex) {
			if( hex.length === 2 ){
				return parseInt( hex,16 );
			}

			hex = hex.replace( '#', '' );

			if( hex.length === 3 ){
				hex = hex.slice( 0, 1 ) + hex.slice( 0, 1 ) + hex.slice( 1, 2 ) + hex.slice( 1, 2 ) + hex.slice( 2, 3) + hex.slice( 2, 3 );
			}

			if( hex.length !== 6 ){
				Debug.write( hex + " isn't a valid hex color");
				return [0,0,0];
			}

			return [ hexToRGB( hex.slice( 0, 2 ) ) / 255, hexToRGB( hex.slice( 2, 4 ) ) / 255, hexToRGB( hex.slice( 4, 6 ) ) / 255 ];
		},
		
		/**
		 * Converts the provided RGB values to their Hex version
		 *
		 * @param		{number}	r 	Red
		 * @param 		{number}	g	Green
		 * @param 		{number}	b 	Blue
		 * @returns 	{string} 	Hex
		 */
		RGBtoHex = function (r, g, b) {
			var hex = [ r.toString(16), g.toString(16), b.toString(16) ];

			_.each( hex, function (val, nr) {
				if( val.length == 1 ){
					hex[ nr ] = '0' + val;
				}
			});

			return hex.join('');
		};

		let iroState = 'unloaded';
		const iroCallbacks = new Set();

		return {
			convertHex: convertHex,
			HSLtoRGB: HSLtoRGB,
			hueToRGB: hueToRGB,
			RGBtoHSL: RGBtoHSL,
			hexToRGB: hexToRGB,
			RGBtoHex: RGBtoHex,
			/**
			 *
			 * @return {Promise<void>}
			 */
			loadIro() {
				return new Promise((resolve, reject) => {
					if (iroState === 'loaded' || ips.utils.iro) {
						iroState = 'loaded';
						resolve();
						return;
					}

					iroCallbacks.add([resolve, reject]);
					if (iroState === 'loading') {
						return;
					}

					iroState = 'loading';

					function failed(e) {
						if (iroState === 'loading') {
							iroState = 'error';
						}

						iroCallbacks.forEach(cb => cb[1](e || new Error('Could not load iro js dependency after 10s')));
						iroCallbacks.clear();
					}

					window.addEventListener('ips:iroLoaded', () => {
						iroState = 'loaded';
						Debug.log("Loaded color picker");
						iroCallbacks.forEach(cb => cb[0]());
						iroCallbacks.clear();
					}, {once: true});

					if (document.querySelector('script[data-iro-loader]')) {
						iroState = 'loading';
					} else {
						const manifestURL = ips.getSetting('baseURL').replace(/\/+$/, '') + `/applications/core/interface/static/iro/manifest.json?antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`;
						ips.fetch(manifestURL)
							.then(response => {
								for (const detail of Object.values(response)) {
									if (detail.isEntry) {
										const script = document.createElement('script');
										script.setAttribute('data-iro-loader', '');
										script.setAttribute('type', 'module')
										document.body.appendChild(script);
										script.src = ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/iro/' + detail.file + "?antiCache=" + encodeURIComponent(ips.getSetting('jsAntiCache'));
									}
								}
							})
							.catch(failed);
					}

					setTimeout(() => failed(), 10000);
				});
			}
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.contentViews.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.contentViews.js - A module for working with content views via the socket handler
 *
 * Author: Matt F
 */

/**
 * @typedef viewEntity  The entity used in the views cache
 * @property    {Number|null}    start       The time the entity started being viewed
 * @property    {Number|null}    end         The time the entity was no longer being viewed
 * @property    {otherData}         otherData   Must be JSON Serializable
 *
 * @typedef otherData Mixed type, must be JSON Serializable
 */

(function ($, _, undefined) {
    "use strict";

    ips.createModule("ips.utils.contentViews", () => ({
        /**
         * @type {Object.<string, viewEntity>}
         */
        _viewsCache: {},

        /**
         * @type {Object.<string, Function>}
         */
        _onRemoveCache: {},

        init() {},

        /**
         *
         * Is realtime interaction enabled?
         */
        enabled() {
            let res = !!(ips.getSetting('memberID') && ips.getSetting('socketEnabled') && ips.getSetting('page_token'));
            return res;
        },

        /**
         * Register an entity that is being tracked This must be done before calling setIsViewing() on a given item
         *
         * @param   {string}        key         A unique key to use; This generally should be a data- attribute generated by the PHP
         * @param   {boolean}       isViewed    Whether to set this as being viewed or not initially
         * @param   {otherData}     otherData   Other data for this entity: e.g. content class, content id, etc. Must be JSON serializable
         * @param   {boolean}       [force=false]   Whether or not to force the entity to be registered (i.e. if you paginate away then back, all the comments will have loaded twice, and you want to replace with the new one)
         * @param   {null|Function} [onRemove=null] This function will be called if/when the entity registry is replaced (e.g. to clear intervals and intersection observers)
         *
         * @returns void
         */
        registerEntity(key, isViewed=false, otherData={}, force=false, onRemove=null) {
            if (key in this._viewsCache) {
                if (!force) {
                    throw new RangeError(`The key, '${key}' is already registered!`);
                }

                if (this._onRemoveCache[key]) {
                    this._onRemoveCache[key]();
                    delete this._onRemoveCache[key];
                }
            }

            if (onRemove instanceof Function) {
                this._onRemoveCache[key] = onRemove;
            }

            try {
                if (!JSON.stringify(otherData)) {
                    throw new Error();
                }
            } catch (e) {
                throw new TypeError(`The otherData argument for a viewEntity is not JSON serializable (or is a false-y value)`);
            }

            this._viewsCache[key] = {
                start: isViewed ? Math.floor(Date.now() / 1000) : null,
                end: null,
                otherData
            }

            ips.utils.sockets.send('view:entity', {key, data: this._viewsCache[key]});
        },

        /**
         * Set whether the entity with this key is being viewed or not
         *
         * @param   {string}        key         The unique key of this entity; A range error will be thrown if it was not already registered
         * @param   {boolean}       isViewing   Whether or not the entity is currently being viewed. If this value is different from the current value, the cache will be updated and synced with Node
         *
         * @returns void
         */
        setIsViewing(key, isViewing) {
            if (!(key in this._viewsCache)) {
                throw new RangeError(`The key '${key}' is not registered`);
            }

            const entity = this._viewsCache[key];
            const isCurrentlyViewed = (entity.start && entity.end && (!entity.end || entity.end < entity.start));
            if (isCurrentlyViewed !== isViewing) {
                this._viewsCache[key][isViewing ? 'start' : 'end'] = Math.floor(Date.now() / 1000);
                ips.utils.sockets.send('view:entity', {key, data: this._viewsCache[key]});
            }
        },

        /**
         * See if an entity is being viewed by its key
         *
         * @param   {string}    key     The key registered
         *
         * @returns {boolean}
         */
        isViewing(key) {
            if (!(key in this._viewsCache)) {
                Debug.warn('Checking to see if an unregistered entity is being viewed');
                return false;
            }

            const entity = this._viewsCache[key];
            return (entity.start && (!entity.end || entity.end < entity.start));
        },
    }));
})(jQuery, _);]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.cookie.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.cookie.js - Cookie management module
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.cookie', function () {

		var _store = {},
			_init = false;

		/**
		 * Initialize cookie module
		 *
		 * @returns 	{void}
		 */
		var init = function () {

			var cookies = _parseCookies( document.cookie.replace(" ", '') ),
				cookieID = ips.getSetting('cookie_prefix') || false;

			$.each( cookies, function (key, cookie) {
				
				if( cookieID ){
					if( key.startsWith( cookieID ) ){
						key = key.replace( cookieID, '' );
						_store[ key ] = unescape( cookie || '' );
					}
				}				
			});

			_init = true;
		},

		/**
		 * Return a cookie value
		 *
		 * @param	{string} 	cookieKey 	Cookie value to get, passed without the prefix
		 * @returns {mixed}		Cookie value or undefined
		 */
		get = function (cookieKey) {
			if( !_init ){
				init();
			}

			if( _store[ cookieKey ] ){
				return _store[ cookieKey ];
			}

			return undefined;
		},

		/**
		 * Set a cookie value
		 *
		 * @param	{string} 	cookieKey 	Key to set
		 * @param 	{mixed} 	value 		Value to set in this cookie
		 * @param 	{boolean} 	sticky 		Whether to make this a long-lasting cookie
		 * @returns {void}
		 */
		set = function( cookieKey, value, sticky ) {

			var expires = '',
				path = '/',
				domain = '',
				ssl = '',
				prefix = '';
			
			if( !cookieKey ){
				return;
			}
			
			/* Exit if we want to skip optional cookies */
			let allowOptional = true;

			/** Cookie consent enabled */
			if( $('#elGuestTerms[data-role="cookieConsentBar"]').length > 0 )
			{
				allowOptional = !!(ips.utils.cookie.get('cookie_consent') && ips.utils.cookie.get('cookie_consent_optional'));
			}

			if( !allowOptional && ips.getSetting('essential_cookies').indexOf( cookieKey ) === -1 )
			{
				return;
			}

			if( !_.isUndefined( sticky ) ){	
				if( sticky === true ){
					var expirationDate = new Date();
					expirationDate.setFullYear( expirationDate.getFullYear() + 100 );

					expires = "; expires=" + expirationDate.toUTCString();
				} else if( sticky === -1 ){
					expires = "; expires=Thu, 01-Jan-1970 00:00:01 GMT";
				} else if( sticky.length > 10 ){
					expires = "; expires=" + sticky;
				}
			}

			if( !_.isUndefined( ips.getSetting('cookie_domain') ) && ips.getSetting('cookie_domain') != '' ){
				domain = "; domain=" + ips.getSetting('cookie_domain');
			}

			if( !_.isUndefined( ips.getSetting('cookie_path') ) && ips.getSetting('cookie_path') != '' ){
				path = ips.getSetting('cookie_path');
			}

			if( !_.isUndefined( ips.getSetting('cookie_prefix') ) && ips.getSetting('cookie_prefix') != '' ){
				prefix = ips.getSetting('cookie_prefix');
			}

			if( !_.isUndefined( ips.getSetting('cookie_ssl') ) && ips.getSetting('cookie_ssl') != '' ){
				ssl = '; secure';
			}
			
			document.cookie = prefix + cookieKey + "=" + escape( value ) + "; path=" + path + expires + domain + ssl + ';';

			_store[ cookieKey ] = value;
		},

		/**
		 * Deletes a cookie
		 *
		 * @param	{string} 	cookieKey 	Key to delete
		 * @returns {void}
		 */
		unset = function (cookieKey) {
			if( _store[ cookieKey ] ){
				set( cookieKey, '', -1 );
			}
		},

		/**
		 * Parses the provided string as a query string and returns an object representation
		 *
		 * @param	{string} 	cookieString 	Query string to parse
		 * @returns {object}
		 */
		_parseCookies = function (cookieString) {
			var pairs = cookieString.split(";"),
				cookies = {};
			
			for ( var i=0; i<pairs.length; i++ ){
				var pair = pairs[i].split("=");
				cookies[ pair[0].trim() ] = unescape( pair[1] ).trim();
			}

			return cookies;
		};

		return {
			init: init,
			get: get,
			set: set,
			unset: unset
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.crypto.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * ips.utils.crypto.js - Functions implementing cryptographic hashes and other algorithms
 *
 * @author  Matt Finger
 * @copyright 2024 Invision Power Services, Inc.
 */
(($, _) => {
    'use strict';

    ips.createModule('ips.utils.crypto', function () {
        return {
            /**
             *
             * @param {string} text
             */
            md5(text) {
                function md5cycle(x, k) {
                    let a = x[0], b = x[1], c = x[2], d = x[3];

                    a = ff(a, b, c, d, k[0], 7, -680876936);
                    d = ff(d, a, b, c, k[1], 12, -389564586);
                    c = ff(c, d, a, b, k[2], 17,  606105819);
                    b = ff(b, c, d, a, k[3], 22, -1044525330);
                    a = ff(a, b, c, d, k[4], 7, -176418897);
                    d = ff(d, a, b, c, k[5], 12,  1200080426);
                    c = ff(c, d, a, b, k[6], 17, -1473231341);
                    b = ff(b, c, d, a, k[7], 22, -45705983);
                    a = ff(a, b, c, d, k[8], 7,  1770035416);
                    d = ff(d, a, b, c, k[9], 12, -1958414417);
                    c = ff(c, d, a, b, k[10], 17, -42063);
                    b = ff(b, c, d, a, k[11], 22, -1990404162);
                    a = ff(a, b, c, d, k[12], 7,  1804603682);
                    d = ff(d, a, b, c, k[13], 12, -40341101);
                    c = ff(c, d, a, b, k[14], 17, -1502002290);
                    b = ff(b, c, d, a, k[15], 22,  1236535329);

                    a = gg(a, b, c, d, k[1], 5, -165796510);
                    d = gg(d, a, b, c, k[6], 9, -1069501632);
                    c = gg(c, d, a, b, k[11], 14,  643717713);
                    b = gg(b, c, d, a, k[0], 20, -373897302);
                    a = gg(a, b, c, d, k[5], 5, -701558691);
                    d = gg(d, a, b, c, k[10], 9,  38016083);
                    c = gg(c, d, a, b, k[15], 14, -660478335);
                    b = gg(b, c, d, a, k[4], 20, -405537848);
                    a = gg(a, b, c, d, k[9], 5,  568446438);
                    d = gg(d, a, b, c, k[14], 9, -1019803690);
                    c = gg(c, d, a, b, k[3], 14, -187363961);
                    b = gg(b, c, d, a, k[8], 20,  1163531501);
                    a = gg(a, b, c, d, k[13], 5, -1444681467);
                    d = gg(d, a, b, c, k[2], 9, -51403784);
                    c = gg(c, d, a, b, k[7], 14,  1735328473);
                    b = gg(b, c, d, a, k[12], 20, -1926607734);

                    a = hh(a, b, c, d, k[5], 4, -378558);
                    d = hh(d, a, b, c, k[8], 11, -2022574463);
                    c = hh(c, d, a, b, k[11], 16,  1839030562);
                    b = hh(b, c, d, a, k[14], 23, -35309556);
                    a = hh(a, b, c, d, k[1], 4, -1530992060);
                    d = hh(d, a, b, c, k[4], 11,  1272893353);
                    c = hh(c, d, a, b, k[7], 16, -155497632);
                    b = hh(b, c, d, a, k[10], 23, -1094730640);
                    a = hh(a, b, c, d, k[13], 4,  681279174);
                    d = hh(d, a, b, c, k[0], 11, -358537222);
                    c = hh(c, d, a, b, k[3], 16, -722521979);
                    b = hh(b, c, d, a, k[6], 23,  76029189);
                    a = hh(a, b, c, d, k[9], 4, -640364487);
                    d = hh(d, a, b, c, k[12], 11, -421815835);
                    c = hh(c, d, a, b, k[15], 16,  530742520);
                    b = hh(b, c, d, a, k[2], 23, -995338651);

                    a = ii(a, b, c, d, k[0], 6, -198630844);
                    d = ii(d, a, b, c, k[7], 10,  1126891415);
                    c = ii(c, d, a, b, k[14], 15, -1416354905);
                    b = ii(b, c, d, a, k[5], 21, -57434055);
                    a = ii(a, b, c, d, k[12], 6,  1700485571);
                    d = ii(d, a, b, c, k[3], 10, -1894986606);
                    c = ii(c, d, a, b, k[10], 15, -1051523);
                    b = ii(b, c, d, a, k[1], 21, -2054922799);
                    a = ii(a, b, c, d, k[8], 6,  1873313359);
                    d = ii(d, a, b, c, k[15], 10, -30611744);
                    c = ii(c, d, a, b, k[6], 15, -1560198380);
                    b = ii(b, c, d, a, k[13], 21,  1309151649);
                    a = ii(a, b, c, d, k[4], 6, -145523070);
                    d = ii(d, a, b, c, k[11], 10, -1120210379);
                    c = ii(c, d, a, b, k[2], 15,  718787259);
                    b = ii(b, c, d, a, k[9], 21, -343485551);

                    x[0] = add32(a, x[0]);
                    x[1] = add32(b, x[1]);
                    x[2] = add32(c, x[2]);
                    x[3] = add32(d, x[3]);

                }

                function cmn(q, a, b, x, s, t) {
                    a = add32(add32(a, q), add32(x, t));
                    return add32((a << s) | (a >>> (32 - s)), b);
                }

                function ff(a, b, c, d, x, s, t) {
                    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
                }

                function gg(a, b, c, d, x, s, t) {
                    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
                }

                function hh(a, b, c, d, x, s, t) {
                    return cmn(b ^ c ^ d, a, b, x, s, t);
                }

                function ii(a, b, c, d, x, s, t) {
                    return cmn(c ^ (b | (~d)), a, b, x, s, t);
                }

                function md51(s) {
                    // txt = '';
                    var n = s.length,
                        state = [1732584193, -271733879, -1732584194, 271733878], i;
                    for (i=64; i<=s.length; i+=64) {
                        md5cycle(state, md5blk(s.substring(i-64, i)));
                    }
                    s = s.substring(i-64);
                    var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
                    for (i=0; i<s.length; i++)
                        tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
                    tail[i>>2] |= 0x80 << ((i%4) << 3);
                    if (i > 55) {
                        md5cycle(state, tail);
                        for (i=0; i<16; i++) tail[i] = 0;
                    }
                    tail[14] = n*8;
                    md5cycle(state, tail);
                    return state;
                }

                /* there needs to be support for Unicode here,
                 * unless we pretend that we can redefine the MD-5
                 * algorithm for multi-byte characters (perhaps
                 * by adding every four 16-bit characters and
                 * shortening the sum to 32 bits). Otherwise
                 * I suggest performing MD-5 as if every character
                 * was two bytes--e.g., 0040 0025 = @%--but then
                 * how will an ordinary MD-5 sum be matched?
                 * There is no way to standardize text to something
                 * like UTF-8 before transformation; speed cost is
                 * utterly prohibitive. The JavaScript standard
                 * itself needs to look at this: it should start
                 * providing access to strings as preformed UTF-8
                 * 8-bit unsigned value arrays.
                 */
                function md5blk(s) { /* I figured global was faster.   */
                    let md5blks = [], i; /* Andy King said do it this way. */
                    for (i=0; i<64; i+=4) {
                        md5blks[i>>2] = s.charCodeAt(i)
                            + (s.charCodeAt(i+1) << 8)
                            + (s.charCodeAt(i+2) << 16)
                            + (s.charCodeAt(i+3) << 24);
                    }
                    return md5blks;
                }

                const hex_chr = '0123456789abcdef'.split('');

                function rhex(n)
                {
                    let s = '', j = 0;
                    for(; j<4; j++)
                        s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
                            + hex_chr[(n >> (j * 8)) & 0x0F];
                    return s;
                }

                function hex(x) {
                    for (let i=0; i<x.length; i++)
                        x[i] = rhex(x[i]);
                    return x.join('');
                }

                function _md5(s) {
                    return hex(md51(s));
                }

                /* this function is much faster,
                so if possible we use it. Some IEs
                are the only ones I know of that
                need the idiotic second function,
                generated by an if clause.  */

                let add32 = (a, b) => {
                    return (a + b) & 0xFFFFFFFF;
                }

                if (_md5('hello') != '5d41402abc4b2a76b9719d911017c592') {
                    add32 = (x, y) => {
                        const lsw = (x & 0xFFFF) + (y & 0xFFFF),
                            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                        return (msw << 16) | (lsw & 0xFFFF);
                    }
                }

                return _md5(text)
            },
            /**
             * A simple helper to get the first 6 chars of an md5 hash. It's useful when there's not many elements, but there is a risk of collision for large sets. For example, the table of contents system uses this in combination with the slugified text of the links
             *
             * @param {string}  text
             *
             * @return {string}
             */
            md5Short(text) {
                return this.md5(text).slice(0, 6)
            }
        }
    })
})(jQuery, _)]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.css.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.css.js - CSS utilities
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.css', function () {

		var prefixes = [ 'webkit', 'moz', 'ms', 'o', 'w3c' ];

		/**
		 * Initialize CSS module
		 *
		 * @returns 	{void}
		 */
		var init = function () {},

		/**
		 * Builds a CSS style block from the provided selector/styles object
		 *
		 * @param 		{string} 	selector 		Selector to use
		 * @param 		{object}	styles			Object of styles, with the key being the property. If value is an array, 
		 *		multiple entries for the same property will be added (good for vendor prefixed)
		 * @returns 	{string}	Complete CSS style block
		 */
		buildStyleBlock = function (selector, styles, important) {
			var output = selector + " {\n";

			var getValue = function (key, value) {
				return "\t" + key + ': ' + value + ( ( important ) ? ' !important' : '' ) + ";\n";
			};

			_.each( styles, function (value, key) {
				if( _.isArray( value ) ){
					for( var i = 0; i < value.length; i++ ){
						output += getValue( key, value[ i ] );
					}
				} else {
					output += getValue( key, value );
				}
			});

			output += "}";

			return output;
		},

		/**
		 * Checks support for CSS transforms
		 *
		 * @returns 	{boolean}
		 */
		supportsTransform = function() {
			var bs = document.body.style;

			if( !_.isUndefined( bs.transform ) || !_.isUndefined( bs.WebkitTransform ) || 
					!_.isUndefined( bs.MozTransform ) || !_.isUndefined( bs.OTransform ) ){
				return true;
			}

			return false;
		},

		/**
		 * Replaces a style rule based on selector, in the stylesheet with the provided ID
		 *
		 * @param		{string}	stylesheetID	ID of stylesheet to update
		 * @param 		{string}	selector 		Selector to replace
		 * @param 		{object}	styles 			Object of style rules to build into a style block
		 * @returns 	{void}
		 */
		replaceStyle = function (stylesheetID, selector, styles) {	
			var stylesheet = getStylesheetRef( stylesheetID );
			var styleBlock = buildStyleBlock( selector, styles );
			var rulesKey = ( stylesheet['cssRules'] ) ? 'cssRules' : 'rules';
			var done = false;		

			// Loop through rules
			for( var rules = 0; rules < stylesheet[ rulesKey ].length; rules++ ){
				if( stylesheet[ rulesKey ][ rules ].selectorText == selector ){
					// Remove rule completely then readd it
					stylesheet.deleteRule( rules );
					stylesheet.insertRule( styleBlock, rules );
					done = true;
				}
			}

			// If we need a new rule...
			if( !done ){
				var idx = stylesheet.insertRule( styleBlock, stylesheet[ rulesKey ].length );
			}
		},

		/**
		 * Returns a reference to the stylesheet DOM object with the given ID
		 *
		 * @param 		{string}		stylesheet 		ID of the stylesheet to match
		 * @returns 	{element|boolean}	False if not found in document
		 */
		getStylesheetRef = function (stylesheetID) {
			var stylesheets = document.styleSheets;

			for( var sheet = 0; sheet < stylesheets.length; sheet++ ){
				if( stylesheets[ sheet ].ownerNode.id == stylesheetID ){
					return stylesheets[ sheet ];
				}
			}
			
			return false;
		},
		
		/**
		 * Returns an escaped version of a selector to use in jQuery
		 *
		 * @param 		{string}		selector 		Selector to escape
		 * @returns 	{string}
		 */
		escapeSelector = function (selector) {
			return selector.replace( /(:|\.|\[|\]|,)/g, "\\$1" );
		},

		/**
		 * Builds a prefixed CSS gradient
		 *
		 * @param 		{number}		angle 		The angle of the gradient (can be negative)
		 * @param		{array}			stops 		Array of stop data, in format [ [ color, location ], [ color, location ] ]
		 * @param 		{boolean} 		asPureCSS 	Should the method return ready-to-use javascript? If not, it returns an array
		 * @returns 	{string|array}
		 */
		generateGradient = function (angle, stops, asPureCSS) {
			var stops = _buildStops( stops );
			var angles = _buildAngles( angle );
			var output = [];			

			for( var i = 0; i < prefixes.length; i++ ){
				output.push( _buildPrefix( prefixes[ i ], 'linear-gradient' ) + 
					'(' + angles[ prefixes[ i ] ] + ', ' + stops + ')' );
			}

			if( !asPureCSS ){
				return output;
			} else {
				var prefixOutput = [];

				for( var i = 0; i < output.length; i++ ){
					prefixOutput.push( 'background-image: ' + output[ i ] + ';');
				}

				return prefixOutput.join("\n");
			}
		},

		/**
		 * Builds a string for stops in a gradient
		 *
		 * @param		{array}		stops 		Array of stop data, in format [ [ color, location ], [ color, location ] ]
		 * @returns 	{string}	Stops in the format: <code>#fff 0%,#333 50%,#000 100%</code>
		 */
		_buildStops = function (stops) {
			var line = [];

			for( var i = 0; i < stops.length; i++ ){
				if( stops[ i ][0].charAt(0) != '#' ){
					stops[ i ][0] = '#' + stops[ i ][0];
				}

				line.push( stops[ i ][0] + ' ' + stops[ i ][1] + '%' );
			}

			return line.join(',');
		},

		/**
		 * Returns the correct angle value for each supported vendor, accounting for w3c difference and directional keywords
		 *
		 * @param 		{number}	angle 		The angle of the gradient (can be negative)
		 * @returns 	{object} 	e.g. { w3c: 'to bottom', moz: 'top', webkit: 'top', o: 'top', ms: 'top' }
		 */
		_buildAngles = function (angle) {
			var mapDegrees = {
				'0': 'right',
				'90': 'top',
				'-90': 'bottom',
				'180': 'left'
			};

			var opposites = { '0':'180', '90':'-90', '-90':'90', '180':'0' };
			var output = {};

			for( var i = 0; i < prefixes.length; i++ ){
				if( !_.isUndefined( mapDegrees[ angle ] ) ){
					if( prefixes[ i ] == 'w3c' ){
						output[ prefixes[ i ] ] = 'to ' + mapDegrees[ opposites[ angle ] ];
					} else {
						output[ prefixes[ i ] ] = mapDegrees[ angle ];
					}
				} else {
					output[ prefixes[ i ] ] = angle + 'deg';
				}				
			}

			return output;
		},

		/**
		 * Builds a vendor-prefixed version of the given style property
		 * Does not validate that the style property is one that actually needs prefixing
		 *
		 * @param 		{string} 	vendor 		Vendor key to use
		 * @param 		{string}	style		Style property to prefix
		 * @returns 	{string}	e.g. -webkit-linear-gradient
		 */
		_buildPrefix = function (vendor, style) {
			return ( ( vendor != 'w3c' ) ? '-' + vendor + '-': '' ) + style;
		};

		return {
			generateGradient: generateGradient,
			replaceStyle: replaceStyle,
			getStylesheetRef: getStylesheetRef,
			buildStyleBlock: buildStyleBlock,
			escapeSelector: escapeSelector
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.db.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.db.js - A module for writing to per-user storage
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.db', function () {

		let enabled = null;
		let sessionStorageSupported = null;
		const expirations = {};

		function init(queryString) {
			enabled = isEnabled();
		}

		/**
		 * Sets a record in storage
		 *
		 * @param	{string} 	type 	 	Category to store in
		 * @param 	{string} 	key 		Key for this value
		 * @param 	{*} 		value 		Value to store - must be JSON serializable
		 * @param	{boolean}		[isPrivate = false]		If TRUE, and the member has not used the "Remember Me" setting to log in, the value will be stored in session storage rather than persistant storage
		 * @param 	{number|null}	[expire=null]			When the value is no longer valid. The value is a UNIX Timestamp (second precision, not ms precision)
		 * @returns {void}
		 */
		function set(type, key, value, isPrivate, expire=null) {
			if( enabled ){
				var storageEngine = localStorage;
				
				if ( isPrivate && ( !_.isUndefined( ips.getSetting('isAcp') ) || ( _.isUndefined( ips.utils.cookie.get('login_key') ) && _.isUndefined( ips.getSetting('cookie_prefix') + ips.utils.cookie.get('login_key') ) ) ) && sessionStorageIsSupported() ) {
					storageEngine = sessionStorage;
				}
				
				if( value ){
					try {
						storageEngine.setItem( type + '.' + key, JSON.stringify( value ) );
					} catch (err) {}

					if (!type.startsWith('__expirations__:')) {
						setExpiration(type, key, typeof expire === 'number' ? expire : undefined);
					}
				} else {
					storageEngine.removeItem( type + '.' + key );
				}
			}
		}

		/**
		 * Sets a record in storage
		 * If no key is specified, all items in the category are returned
		 *
		 * @param	{string} 	type 	 	Category to get
		 * @param 	{string} 	[key] 		Key of value to get
		 * @returns {*} 	If key is omitted, returns object containing all values, otherwise returns original value
		 */
		function get(type, key) {
			if (!type.startsWith('__expirations__:')) {
				const {[key]: expiration} = getExpirations(type);
				if (typeof expiration === 'number' && expiration < Date.now() / 1000) {
					setExpiration(type, key, expiration);
					return null;
				}
			}

			if( _.isUndefined( key ) ){
				return getByType( type );
			}

			var val = localStorage.getItem( type + '.' + key );
			if ( _.isNull( val ) && sessionStorageIsSupported() ) {
				val = sessionStorage.getItem( type + '.' + key );
			}

			try {
				return JSON.parse( val );
			} catch(err) {
				return val;
			}
		}

		/**
		 * Get the expirations object for a db type
		 *
		 * @param {string}	type
		 *
		 * @return {{[p:string]: number}} Returns an object mapping the type's keys to their expiration values. Keys not in the object are not set to expire
		 */
		function getExpirations(type) {
			if (!expirations[type]) {
				try {
					expirations[type] = get("__expirations__:" + type, '');
					if (!expirations[type] || typeof expirations[type] !== 'object') {
						throw new TypeError();
					}
				} catch (e) {
					expirations[type] = {};
				}
			}
			return expirations[type];
		}

		/**
		 * Set the expiration for a given type and key
		 *
		 * @param {string}	type
		 * @param {string}	key
		 * @param {number|undefined}	expiration
		 */
		function setExpiration(type, key, expiration) {
			const _expirations = getExpirations(type);
			if (typeof expiration === 'number') {
				_expirations[key] = expiration;
				if (expiration < Date.now() / 1000) {
					delete _expirations[key];
					remove(type, key);
				}
			} else {
				delete _expirations[key];
			}

			expirations[type] = _expirations
			if (Object.keys(_expirations).length) {
				set("__expirations__:" + type, '', _expirations);
			} else {
				remove('__expirations__:' + type);
			}
		}

		/**
		 * Removes values from storage
		 * If no key is specified, all items in the category are removed
		 *
		 * @param	{string} 	type 	 	Category to remove
		 * @param 	{string} 	[key] 		Key of value to remove
		 * @returns {void, number} 	If key is omitted, returns count of removed items, otherwise returns void
		 */
		function remove(type, key) {
			if( _.isUndefined( key ) ){
				removeByType( type );
				return;
			}

			localStorage.removeItem( type + '.' + key );
			if ( sessionStorageIsSupported() ) {
				sessionStorage.removeItem( type + '.' + key );
			}
		}

		/**
		 * Returns all values for the given category
		 *
		 * @param	{string} 	type 	 	Category to return
		 * @returns {object} 	Key/value pairs of each value in the category
		 */
		function getByType(type) {
			try {
				var results = {};
				
				if ( sessionStorageIsSupported() && sessionStorage.length ) {
					for( var key in sessionStorage ){
						if( key.startsWith( type + '.' ) ){
							var actualKey = key.replace( type + '.', '' );
							results[ actualKey ] = get( type, actualKey );
						}
					}
				}
				
				if ( localStorage.length ) {
					for( var key in localStorage ){
						if( key.startsWith( type + '.' ) ){
							var actualKey = key.replace( type + '.', '' );
							results[ actualKey ] = get( type, actualKey );
						}
					}
				}
	
				return results;
			} catch(e) {
				return {};
			}
		}

		/**
		 * Removes all values in the given category
		 *
		 * @param	{string} 	type 	 	Category to return
		 * @returns {number} 	Number of values removed
		 */
		function removeByType(type) {
			var count = 0;
						
			for( var key in getByType(type) ){
				remove( type, key );
				count++;
			}

			return count;
		}

		/**
		 * Returns boolean indicating if localStorage is available
		 *
		 * @returns {boolean}
		 */
		function isEnabled() {
			if( !_.isBoolean( enabled ) ){
				try {
					if( 'localStorage' in window && window['localStorage'] !== null && window.JSON ){
						return _testEnabled();
					} else {
						return false;
					}
				} catch (e) {
					return false;
				}
			} else {
				return enabled;
			}
		}

		/**
		 * Tests whether using localstorage will trigger a QuotaExceeded error
		 *
		 * @returns {boolean}
		 */
		function _testEnabled() {
			try {
				localStorage.setItem('test', 1);
				localStorage.removeItem('test');
			} catch (err) {
				Debug.log("Writing to localstorage failed");
				return false;
			}

			return true;
		}
		
		/**
		 * Returns boolean indicating if sessionStorage is available
		 *
		 * @returns {boolean}
		 */
		function sessionStorageIsSupported() {
			if( !_.isBoolean( sessionStorageSupported ) ){
				try {
					sessionStorageSupported = !!('sessionStorage' in window && window['sessionStorage'] !== null && window.JSON);
				} catch (e) {
					sessionStorageSupported = false;
				}
			}
			return sessionStorageSupported;
		}

		init();

		return {
			set,
			get: get,
			getByType: getByType,
			remove: remove,
			removeByType: removeByType,
			enabled: enabled,
			isEnabled: isEnabled
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.events.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.events.js - A module for working with events
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.events', function () {

		/**
		 * Fires a manual event on an element
		 *
		 */
		var manualEvent = function (element, ev) {
			if( _.isObject( element ) ){
				element.each( function () {
					_fireEvent( this, ev );
				});
			} else {
				_fireEvent( element, ev );
			}			
		},

		/**
		 * Simple test to determine if this is a touch browser
		 *
		 * @returns	boolean
		 */
		isTouchDevice = function () {
			return ( ('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) );
		},

		/**
		 * Returns the correct Page Visibility API event
		 *
		 * @returns string
		 */
		getVisibilityEvent = function () {
			if( !_.isUndefined( document.hidden ) ){
				return 'visibilitychange';
			} else if( !_.isUndefined( document.mozHidden ) ){
				return 'mozvisibilitychange';
			} else if( !_.isUndefined( document.msHidden ) ){
				return 'msvisibilitychange';
			} else if( !_.isUndefined( document.webkitHidden ) ){
				return 'webkitvisibilitychange';
			}

			return '_unsupported';
		},

		/**
		 * Returns the correct Page Visibility API property
		 *
		 * @returns string or undefined
		 */
		getVisibilityProp = function () {
			if( !_.isUndefined( document.hidden ) ){
				return 'hidden';
			} else if( !_.isUndefined( document.mozHidden ) ){
				return 'mozHidden';
			} else if( !_.isUndefined( document.msHidden ) ){
				return 'msHidden';
			} else if( !_.isUndefined( document.webkitHidden ) ){
				return 'webkitHidden';
			}

			return undefined;
		},

		/**
		 * Does the actual firing
		 *
		 */
		_fireEvent = function (element, ev) {
			if( document.createEvent ) {
				var evObj = document.createEvent('MouseEvents');
				evObj.initEvent( ev, true, false );
				element.dispatchEvent( evObj );
			} else if ( document.createEventObject ) {
				var evObj = document.createEventObject();
				element.fireEvent( 'on' + evt, evObj );
			}
		};
		
		return {
			manualEvent: manualEvent,
			isTouchDevice: isTouchDevice,
			getVisibilityEvent: getVisibilityEvent,
			getVisibilityProp: getVisibilityProp
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.fileDownload.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * ips.utils.fileDownload.js
 *
 * Module to handle downloading of files from a URL by JS. Uses native es promises
 *
 *
 * @author Matt Finger
 */
;(function($, _) {
    "use strict";

    ips.createModule('ips.utils.fileDownload', function() {
        class DownloadError extends RangeError {
            /**@type{Error}*/
            sourceErr = undefined

            /**@type{XMLHttpRequest}*/
            xhr = undefined

            constructor(message, xhr) {
                super(message);
                this.sourceErr = this;
                this.xhr = xhr;
            }

            static fromError(err, xhr) {
                const downloadError = new DownloadError(`Failed to download - ${err.message}`, xhr);
                downloadError.sourceErr = err;
                return downloadError;
            }
        }
        return {
            /**
             * Use an XHR request to download a blob of data
             *
             * @param {string}  url                     The url from which to download the file
             * @param {string}  blobName                The default filename of the downloaded file
             * @param {boolean} [forceBlobName=false]   By default, if the xhr request receives a filename in the content disposition header, it will use that as the filename. When this is true, the provided blobName will be used no matter what.
             * @param {undefined|function(ProgressEvent):void} [onProgress]         An optional callback that is invoked as chunks are downloaded
             * @param {FormData|undefined}    [formData]        Form data to include in the request. When this is not a FormData instance, the XHR request will be GET instead of POST
             * @param {boolean}                 [forceDownload=false]       If true, this will download a file containing the response even if there is no content-disposition header in the response
             *
             * @return {Promise<void>}
             */
            download({url, blobName, onProgress, formData, forceBlobName=false, forceDownload=false}) {
                return new Promise((resolve, _reject) => {
                    const xhr = new XMLHttpRequest();
                    let blob;
                    xhr.open(formData ? 'POST' : 'GET', url, true);

                    const reject = e => {
                        _reject(DownloadError.fromError(e, xhr));
                    }

                    xhr.responseType = "arraybuffer";
                    xhr.onload = function(e) {
                        blob = new Blob([this.response]);
                    };

                    xhr.onprogress = function(e) {
                        onProgress?.call(this, e);
                    };

                    xhr.onerror = function(e) {
                        reject(e);
                    }

                    xhr.onloadend = function(e) {
                        try {
                            // downloadable type?
                            if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob' && xhr.responseType !== 'text') {
                                throw new RangeError(`Cannot download data from response of type ${xhr.responseType}`);
                            }

                            // is this a 2xx response?
                            if (!xhr.status?.toString().match(/^2\d\d$/)) {
                                throw new RangeError(`Response did not receive a 2xx response status. Got status code ${xhr.status}`);
                            }

                            const tempLink = document.createElement('a');
                            let href = window.URL.createObjectURL(blob);
                            tempLink.href = href;
                            tempLink.setAttribute('hidden', '');

                            let contentDispositionName = this.getResponseHeader('content-disposition')?.match(/filename="(.+)"/i)?.[1];
                            if (!contentDispositionName && !forceDownload) {
                                throw new RangeError(`There is no content-disposition name in the response`);
                            }
                            if (forceBlobName || !contentDispositionName) {
                                contentDispositionName = blobName;
                            } else {
                                contentDispositionName = decodeURIComponent(contentDispositionName);
                            }
                            tempLink.setAttribute('download', contentDispositionName);
                            document.body.appendChild(tempLink);
                            tempLink.click();
                            window.URL.revokeObjectURL(href);

                            setTimeout(() => {
                                tempLink.remove();
                                resolve();
                            });
                        } catch (e) {
                            reject(e);
                        }
                    };

                    xhr.setRequestHeader('X-REQUESTED-WITH', 'XMLHttpRequest');
                    if (formData) {
                        xhr.send(formData);
                    } else {
                        xhr.send();
                    }
                });
            }
        };
    });
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.form.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.form.js - Form utilities
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.form', function () {

		/**
		 * Serialize a jquery object as an object of values
		 *
		 * @returns object
		 */
		var serializeAsObject = function (jQueryObj, customSerializers) {
			var asArray = jQueryObj.serializeArray();
			var output = {};

			_.each( asArray, function (val) {
				var outValue = val.value;

				// Do we have a custom serializer function for this field?
				if( customSerializers && !_.isUndefined( customSerializers[ val.name ] ) && _.isFunction( customSerializers[ val.name ] ) ){
					outValue = customSerializers[ val.name ]( val.name, val.value );
				} 

				var keys = _splitFieldName( val.name );
				_addValueToKey( output, keys, outValue );
			});

			return output;
		};

		/**
		 * Splits a field name into an array of keys
		 * e.e. key[subkey][subsubkey] becomes ['key', 'subkey', 'subsubkey']
		 *
		 * @returns 	{array}
		 */
		var _splitFieldName = function (name) {
			var parts = name.split('[');

			parts = _.map( parts, function (part) {
				return part.replace(/\]/g, '')
			});

			if( parts[0] === '' ){
				parts.shift(); 
			}

			return parts;
		},

		/**
		 * Takes an array of keys (from _splitFieldName) and creates the deep array in 
		 * output with the specified value
		 *
		 * @returns 	{void}
		 */
		_addValueToKey = function (output, keys, value) {
			if( !_.isObject( output ) ){
				output = {};
			}

			var currentPath = output;

			if( _.isArray( keys ) ){
				for( var i = 0; i < keys.length; i++ ){
					if( _.isUndefined( currentPath[ keys[i] ] ) ){
						currentPath[ keys[i] ] = ( i == keys.length - 1 ) ? value : {};
					}
					currentPath = currentPath[ keys[i] ];
				}
			} else {
				output[ keys ] = value;
			}
		};

		return {
			serializeAsObject: serializeAsObject		
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.geolocation.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.geolocation.js - Geolocation helper methods
 * 
 * Author: IPS
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.geolocation', function () {

        const permissions = {
            GRANTED: 'granted',
            DENIED: 'denied',
            PROMPT: 'prompt'
        },
        type = 'geolocation',

        /**
         * Checks geolocation is allowed asynchronously 
         * 
         * @returns {boolean|null}
         */
		getGeolocationIsAllowed = function () {

            if ( ! "geolocation" in navigator ) return false; 

            const permission = ips.utils.db.get( type, `permission.${ipsSettings.memberID}` );

            if ( permission == permissions.GRANTED ) return true;

            return false;          
        },

        /**
         * @function ips.utils.geolocation.setGeolocationIsAllowed
         * Set - user allowed location or not. 
         * 
         * @param {string}     status   Permission Status ('granted', 'denied', 'prompt')
         * @returns {void}
         */
        setGeolocationIsAllowed = function ( status ) {

            if ( ! _.values( permissions ).includes( status ) ) return;

            ips.utils.db.set( type, `permission.${ipsSettings.memberID}`, status, false );
            
        },

        /** 
         * Gets the user coordinates asynchronously 
         * 
         * @returns {Promise<object>}    The coordinates
         */
        getCurrentPosition = function () {
            return new Promise( ( res, rej ) => {
                navigator.geolocation.getCurrentPosition( position => {
                    setGeolocationIsAllowed( permissions.GRANTED );
                    res( position.coords );
                }, error => {
                    if ( error.code == error.PERMISSION_DENIED ) {
                        setGeolocationIsAllowed( permissions.DENIED );
                    }
                    rej( error );
                });
            });
        },

        /** == INCOMPLETE ==
         *  Gets IP Address location asynchronously 
         * 
         * @returns {object}     The coordinates
         */ 
        generalLocation = function () {
            return new Promise( ( res, rej ) => {

                /* Check cache for guests first */
                if ( ! ipsSettings.memberID ) {
                    const ipLocation = ips.utils.db.get( type, `iplocation`);
                    if ( ipLocation ) {
                        res( ipLocation );
                    }
                }

                /* Fetch IP Location - TODO */
                res({
                    'latitude': 0,
                    'longitude': 0
                });
            });

        }

		return {
            getGeolocationIsAllowed,
            getCurrentPosition,
            setGeolocationIsAllowed,
            permissions
		};
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.history.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.history.js - A module for working with events
 *
 * Author: Matt Finger & Stuart Silvester
 */

;( function($, _){
    "use strict";

    ips.createModule('ips.utils.history', function () {
        const _state = {
            current: window.history.state?.state instanceof Object ? {"": {}, ...window.history.state.state} : {"" : {}},
            lastKey: window.history.state?.lastKey || ''
        }

        window.history.replaceState({..._state}, '', window.location.href)

        /**
         * Fires an event to the window indicating the page's history state was modified
         *
         * @param {Event} [e]
         * @param {"pop"|"push"|"replace"|'load'}	[type]		What event caused the event to originate
         *
         * @return {CustomEvent<{unused: null, state: any, title: string, url: string, originalEvent?: Event}>}
         * @constructor
         */
        function ipsHistoryChange(e, type) {
            const detail = {
                state: _state.current,
                unused: null,
                url: window.location.href,
                title: document.title,
                originalEvent: e,
                type
            }


            const event = new CustomEvent("historychange", {
                detail,
                bubbles: true
            })

            window.dispatchEvent(event)

            const key = _state.lastKey
            Debug.log(`IPS History: Firing historychange${key ? ` and historychange:${key}` : ``} event(s) with type ${type}`)
            if (key) {
                const event = new CustomEvent(`historychange:${key}`, {
                    detail,
                    bubbles: true
                })

                window.dispatchEvent(event)
            }
        }

        window.addEventListener('popstate', e => {
            setTimeout(() => {
                if (window.history.state instanceof Object) {
                    if (window.history.state.current instanceof Object) {
                        _state.current = window.history.state.current
                    } else {
                        _state.current = {..._state.current}
                    }
                    _state.lastKey = window.history.state.lastKey || ''
                }

                ipsHistoryChange(e, 'pop')
            })
        });

        ipsHistoryChange(undefined, 'load');

        return {
            /**
             *
             * @return {string}
             */
            getLastChangeType() {
                return _state.lastKey
            },

            /**
             * Get the current state
             *
             * @param {string}		key
             *
             * @return {Object}
             */
            getState(key) {
                return key ? (_state.current[key] || {}) : _state.current
            },

            /**
             * Add a new state to the browser using pushstate.
             *
             * @param {*} 		state		The state, this can be literally any JS value
             * @param {string}	key			The key of the state being applied. The state parameter will be stored using this state, and the event `historychange:${key}` will be fired on the window
             * @param {string}	url			The url that the state is being converted to
             * @param {Event}	[e]			Optional: an event that was the original cause of this being invoked; it is added to the historychagne event's details
             */
            pushState( state, key, url, e ) {
                _state.current = {..._state.current, [key] : state}
                _state.lastKey = key

                window.history.pushState({..._state}, '', url);
                ipsHistoryChange(e, 'push')
            },

            /**
             * Replace the state of the browser. This means that pressing back won't return the current state
             *
             * @param {*} 		state		The state, this can be literally any JS value
             * @param {string} 	key            The key of the state being applied. The state parameter will be stored using this state, and the event `historychange:${key}` will be fired on the window
             * @param {string}	url			The url that the state is being converted to
             * @param {Event}   [e]            Optional: an event that was the original cause of this being invoked; it is added to the historychagne event's details
             */
            replaceState(state, key, url, e) {
                _state.current = {..._state.current, [key]: state}
                _state.lastKey = key

                window.history.replaceState({..._state}, '', url)
                ipsHistoryChange(e, 'replace')
            }
        };
    });
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.iconpicker.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.iconpicker.js - A module for picking icons
 *
 * Author: Matt Finger
 */
;(function($, _){
    "use strict";

    const UI_CALLBACKS = {
        resolvers: new Set(),
        rejects: new Set(),
        timeout: null,
    };

    let UI_STATE = 'unloaded';
    let UI_ERR;

    document.addEventListener("ips:iconpickerUILoaded", () => {
        UI_STATE = "loaded";
        clearTimeout(UI_CALLBACKS.timeout);
        for (const cb of UI_CALLBACKS.resolvers) {
            cb();
        }
        UI_CALLBACKS.resolvers.clear();
        UI_CALLBACKS.rejects.clear();
    })
    function loadIconPickerUI() {
        return new Promise((resolve, reject) => {
            if (UI_STATE === 'loaded' || ips.ui.iconpicker) {
                UI_STATE = 'loaded';
                resolve();
                return;
            } else if (UI_STATE === 'error') {
                UI_ERR ? reject(UI_ERR) : reject();
                return;
            }

            UI_CALLBACKS.resolvers.add(resolve);
            UI_CALLBACKS.rejects.add(reject);
            if (UI_STATE === 'unloaded') {
                UI_STATE = 'loading';

                UI_CALLBACKS.timeout = setTimeout(() => {
                    UI_STATE = 'error';
                    UI_CALLBACKS.resolvers.clear();
                    for (const cb of UI_CALLBACKS.rejects) {
                        cb()
                    }
                    UI_CALLBACKS.rejects.clear();
                }, 30000);

                ips.fetch(ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/iconpicker/manifest.json')
                    .then(response => {
                        if (typeof response !== 'object') {
                            throw new TypeError(`The response from ${ips.getSetting('baseURL').replace(/\/+$/, '') + '/applications/core/interface/static/iconpicker/manifest.json'} was not an object`);
                        }

                        for (const key in response) {
                            const entry = response[key];
                            if (entry.isEntry) {
                                const src = ips.getSetting('baseURL').replace(/\/+$/, "") + "/applications/core/interface/static/iconpicker/" + entry.file.replace(/^\/+/, '');
                                if (entry.css) {
                                    const el = document.createElement('link');
                                    el.setAttribute('rel', 'stylesheet');
                                    el.href = src;
                                    document.head.appendChild(el);
                                } else {
                                    const el = document.createElement('script');
                                    el.setAttribute('type', 'module');
                                    el.src = src;
                                    document.body.appendChild(el);
                                }
                            }
                        }
                    })
                    .catch(err => {
                        clearTimeout(UI_CALLBACKS.timeout);
                        UI_STATE = 'error';
                        UI_ERR = err;
                        for (const cb of UI_CALLBACKS.rejects) {
                            cb(err);
                        }
                        UI_CALLBACKS.rejects.clear();
                        UI_CALLBACKS.resolvers.clear();
                    })
            }
        })
    }

    /**
     * @typedef IconType
     * @property {AllowedIconType}     type        The type of icon
     * @property {string}           title       The icon title
     * @property {string}           raw         The raw data type
     * @property {string}           key         A unique key to identify the icon within its type (e.g. an emoji with the key 'smiling_face' is distinct from a fa icon with the key 'smiling_face')
     * @property {string}           [hairStyle]
     * @property {string}           [skinTone]
     * @property {boolean}          [selected]  Only used internally. Whether or not this icon is selected
     * @property {string}           [image]     The source of an image for the icon; if this is set it indicates the icon is a custom emoticon
     *
     * @typedef {"fa"|"emoji"} AllowedIconType
     *
     * @typedef IconPickerOptions
     * @property {null|IconType[]}      [defaultValue]      The default value of the picker
     * @property {AllowedIconType[]}    [allowedTypes]      The allowed types that we can choose from
     * @property {Number|null}          [maxIcons=1]        The max number of icons that this function can accept
     * @property {Number|null}          [minIcons=1]        The minimum number of icons that can be submitted
     * @property  {Element|null}        [rootElement]       Pass this to make the selector hover beneath a root item (like the ips menus)
     * @property {boolean}              [svgIcons]          Whether or not to use the raw svg icons
     * @property {boolean|undefined}    [nativeEmojis=true] Native emojis are allowed
     * @property {boolean|undefined}    [customEmojis=false] Custom emojis are allowed
     */
    ips.createModule("ips.utils.iconpicker", function() {
        const fileToLoad = '/applications/core/interface/static/fontawesome/js/fontawesome.js';
        let faLoaded = 'unloaded';
        let faAvailable = false;
        let faLoadAttempts  = 0;

        /**
         *
         * @return {Promise<boolean>}
         */
        function resolveWhenLoaded() {
            return new Promise(resolve => {
                if (ips.utils.fontawesome?.searchIcons instanceof Function) {
                    resolve(true);
                }
                else if (++faLoadAttempts > 200) {
                    resolve(false)
                } else {
                    setTimeout(() => {
                        resolveWhenLoaded().then(resolve);
                    }, 100)
                }
            })
        }

        /**
         *
         * @return {Promise<unknown>}
         */
        function loadFa6() {
            return new Promise(resolve => {
                if (faLoaded === 'loaded' || ips.utils.fontawesome?.searchIcons instanceof Function) {
                    faLoaded = 'loaded';
                    resolve(true)
                } else {
                    if (faLoaded !== 'loading') {
                        faLoaded = 'loading';
                        const script = document.createElement('script');
                        script.type = "module";
                        script.src = ips.getSetting('baseURL').replace(/\/+$/, '') + fileToLoad;
                        document.body.appendChild(script);
                    }

                    resolveWhenLoaded().then(_loaded => {
                        if (_loaded) {
                            faLoaded = true;
                            faAvailable = true;
                            resolve(true)
                        } else {
                            faLoaded = true;
                            faAvailable = false;
                            resolve(true)
                        }
                    })
                }
            })
        }


        /**
         * See if fa is faIconsEnabled
         *
         * @return {Promise<boolean>}
         */
        async function faIconsEnabled() {
            return !!((await loadFa6()) || faAvailable)
        }

        function getValuesFromOptions(options) {
            const {
                defaultValue=null,
                defaultTab='fa',
                anchor,
                allowedTypes=['emoji', 'fa'],
                maxIcons=null,
                minIcons=null,
                rootElement=null,
                svgIcons=false,
                panelMode,
                submitOnClick=false,
                afterOpen,
                afterHide,
                shortCodeFixer,
                container,
                nativeEmoji=true,
                customEmoji
            } = options

            return {defaultValue, defaultTab, allowedTypes, maxIcons, rootElement, svgIcons, anchor, panelMode, submitOnClick, afterOpen, afterHide, shortCodeFixer, container, customEmoji, nativeEmoji};
        }

        /**
         * @type {IconPicker}
         */
        let iconPicker;

        let lastOpened;

        return {
            /**
             *
             * @param {IconPickerOptions}   options
             *
             * @return {Promise<Object[]>}
             */
            pick(options={}) {
                options = getValuesFromOptions(options)
                return new Promise(_resolve => {
                    if (lastOpened && Date.now() - 100 < lastOpened) {
                        return;
                    }
                    lastOpened = Date.now();

                    if (iconPicker instanceof IconPicker) {
                        iconPicker.remove();
                    }

                    /**
                     *
                     * @param {IconType[]|null} icons
                     */
                    const resolve = icons => {
                        _resolve((Array.isArray(icons) && icons.length) ? icons.map(icon => ({
                            key: icon.key,
                            hairStyle: icon.hairStyle,
                            type: icon.type,
                            raw: icon.raw,
                            title: icon.title,
                            image: icon.image,
                        })) : null)
                    }

                    iconPicker = new IconPicker(options);
                    iconPicker.show(resolve, resolve);
                })
            },
            /**
             *
             * @param {IconPickerOptions}   options
             *
             * @return {IconPicker}
             */
            create(options) {
                options = getValuesFromOptions(options)
                return new IconPicker(options)
            },
            faIconsEnabled,
            loadFa6,
            compileEmojiSearchIndex(custom=false) {
                EmojiSearchTree.instance(custom);
            },
            async hasCustomEmoji() {
                const store = await EmojiSearchTree.loadCustomEmojiStore()
                return !!Object.keys(store).length;
            },
            whenLoaded: resolveWhenLoaded,
            getEmojiSearchTree() {
                return EmojiSearchTree
            },
        }
    });

    /**
     * Class used to pick icons; it can either open or close
     */
    class IconPicker {

        /**
         * @type {undefined|string}
         * @private
         */
        _queuedSearch = undefined;
        /**
         * @type {HTMLElement|undefined}
         */
        container = undefined;

        _visible= false;

        /**
         * @type {HTMLFormElement}
         * @private
         */
        _base;
        /**
         * @type {null|IconType[]}
         */
        defaultValue= null;

        /**
         * @type {'fa'|'emoji'}
         */
        defaultTab = 'fa';

        /** @type {string|undefined} */
        defaultSearch = undefined;

        /** @type {boolean} */
        submitOnClick = false;

        /** @type {boolean} */
        panelMode = false;

        _searchString='';
        /**
         *
         * @type {AllowedIconType[]}
         * @private
         */
        allowedTypes = ['fa', 'emoji'];

        /**
         * @type {null|Number}  The skin tone used for the selector
         * @private
         */
        get _emojiSkinTone() {
            return Number(ips.utils.db.get('emoji', 'skinTone')) || null;
        }

        get _emojiHairStyle() {
            return Number(ips.utils.db.get('emoji', 'hairStyle')) || null;
        }

        /**
         * Whether to use SVG icons instead of <i class=""></i>
         * @type {boolean}
         */
        svgIcons = false;

        /**
         * @type {null|Element}
         */
        anchor = null;

        _resultsCount = 0


        /**
         *
         * @type {{emoji: Object.<string, IconType>, fa: Object.<string, IconType>}}
         * @private
         */
        _selected = {emoji: {}, fa: {}}

        /**
         * @type {Element|null}
         * @private
         */
        rootElement;

        /**
         * @type {function(IconType[]|null)|null|undefined}
         * @private
         */
        _onClose;

        /**
         * @type {function(IconType[]|null)|null|undefined}
         * @private
         */
        _onSubmit;

        /**
         * Called after this is opened
         * @type {undefined|Function}
         */
        afterOpen = undefined;

        /**
         * Called after this is closed
         * @type {undefined|Function}
         */
        afterHide = undefined;

        _customEmoji = undefined;
        /**
         * Whether custom emoji are allowed
         * @returns {boolean}
         */
        get customEmoji() {
            if (this._customEmoji === undefined) {
                const allowed = this.allowedTypes.includes('emoji') && (this.panelMode || this.anchor || this.container);
                if (this._options) { // if this has already been setup, save the value
                    this._customEmoji = allowed;
                }
                return allowed;
            }

            return this._customEmoji;
        }

        /**
         *
         * @param allowed
         */
        set customEmoji(allowed) {
            this._customEmoji = !!allowed;
        }

        /**
         *
         * @param {IconPickerOptions} options
         */
        constructor(options) {
            Object.assign(this, options)
            if (options.defaultSearch) {
                this._searchString = options.defaultSearch;
            }
            this._options = options;
            if (this.allowedTypes.includes('emoji') && !this.customEmoji && this.nativeEmoji === false) {
                this.allowedTypes = this.allowedTypes.filter(type => type !== 'emoji');
                this._options.allowedTypes = this.allowedTypes;
            }

            if (!this.allowedTypes.length) {
                throw new RangeError(`Need either emoji or fa tab to use the icon picker`);
            }

            if (!this.allowedTypes.includes('emoji') && this.defaultTab === 'emoji') {
                this.defaultTab = 'fa';
                this._options.defaultTab = 'fa';
            }

            this.selected = this.defaultValue
        }

        /**
         * Get selected icons
         *
         * @returns {IconType[]|null}
         */
        get selected() {
            const out = [];
            for (const [key, group] of Object.entries(this._selected)) {
                if (this.allowedTypes.includes(key)) {
                    for (const value of Object.values(group)) {
                        out.push(value);
                    }
                }
            }

            return out.length ? out : null;
        }

        /**
         *
         * @param {IconType[]|null}  items
         */
        set selected(items) {
            if (items !== null && !Array.isArray(items)) {
                Debug.error(new Error(`The items passed is not an array or null.`))
                return
            }
            this._selected.fa = {};
            this._selected.emoji = {};

            if (Array.isArray(items)) {
                for (const item of items) {
                    if (!this.allowedTypes.includes(item.type)) {
                        continue;
                    }

                    this._selected[item.type][item.key] = item;
                }
            }
        }

        /**
         * Show the picker
         *
         * @param {null|function(null|IconType[])} [onSubmit]  A callback, will be called when the selected icons are submitted
         * @param {null|function(null|IconType[])} [onClose]  A callback called when the selector is closed before an icon can be selected. It is passed the default value provided when creating the selector
         *
         * @return {void}
         */
        async show(onSubmit=null, onClose=null) {
            await loadIconPickerUI();
            this._onSubmit = onSubmit;
            this._onClose = onClose;
            if (!this.container) {
                // await EmojiSearchTree.loadEmojiStore() // todo not sure this is ever needed; the search tree loads this ad-hoc
                document.dispatchEvent(new CustomEvent('ipsIconPicker:show', {bubbles: true, detail: {instance: this}}))
                this._visible = true
            }
            await this.getElem()

            try {
                this.afterOpen?.(this)
            } catch (e) {
                e.message = e.message + 'An error occurred when running the after open hook of the icon picker'
                Debug.error(e)
            }
        }

        /**
         * @return {HTMLFormElement|null}
         */
        getElemSync() {
            return this._base instanceof Element ? this._base : null;
        }

        /**
         * Return the HTMLElement that is associated with this instance
         * @return {Promise<HTMLElement>}
         */
        getElem() {
            return this.getEmojiTypes()
                .then(emojiTypes => new Promise(resolve => {
                    if (this._base && this._base.closest('body') !== document.body) {
                        this._closeReactRoot?.();
                        delete this._base;
                    }
                    if (!this._base) {
                        const container = this.container || document.body;
                        let resolved = false;
                        const {close} = ips.ui.iconpicker.getIconPickerUI(container, {
                            ...this._options,
                            searchFaIcons: async (searchString) => {
                                if (typeof searchString !== "string") {
                                    searchString = "";
                                }
                                this._searchString = searchString;
                                return await this.searchFontAwesome();

                            },
                            searchEmojis: async (searchString) => {
                                if (typeof searchString !== "string") {
                                    searchString = "";
                                }
                                this._searchString = searchString;
                                return await this.searchEmojis();
                            },
                            setSelectedIcons: (icons) => {
                                this.selected = icons?.length ? icons : null
                            },
                            hairStyleOptions: emojiTypes.find(type => type.type === "hair").options,
                            skinToneOptions: emojiTypes.find(type => type.type === "skin").options,
                            onRender: ({elem, setSearchString, setOption, incrementHighlight, decrementHighlight}) => {
                                this._base = elem;
                                if (!resolved) {
                                    resolved = true;
                                    resolve(this._base);
                                    try {
                                        this.afterOpen?.(this)
                                    } catch (e) {
                                        Debug.warn(e);
                                    }
                                }
                                this.setSearchString = setSearchString;
                                this.setOption = setOption;
                                this.incrementHighlight = incrementHighlight;
                                this.decrementHighlight = decrementHighlight;
                                if (typeof this._queuedSearch === 'string') {
                                    setSearchString(this._queuedSearch);
                                    delete this._queuedSearch;
                                }
                            },
                            onSubmit: this._onSubmit,
                            onClose: this._onClose,
                            afterHide: () => {
                                // delete this._base;
                                //
                                // if (this.openListener instanceof Function) {
                                //     document.removeEventListener('ipsIconPicker:open', this.openListener)
                                // }

                                try {
                                    this.afterHide?.(this)
                                } catch (e) {
                                    Debug.warn(e)
                                }
                            },
                        });
                        this._closeReactRoot = close;
                    } else {
                        resolve(this._base);
                    }
                }));
        }

        /**
         *
         * @param {string}  query
         * @return {Promise<void>|void}
         */
        updateSearch(query) {
            if (typeof query !== 'string') {
                throw new TypeError(`The search query for the icon picker must be a string, got a ${typeof query}`);
            }
            if (this.setSearchString instanceof Function) {
                this.setSearchString(query);
            } else {
                this._queuedSearch = query;
            }
        }

        /**
         *
         * @return {Promise<Object.<string, IconType[]>>}
         */
        async searchEmojis() {
            let store = await EmojiSearchTree.search(this._searchString, this.customEmoji, this.panelMode ? 20 : null, !!this.panelMode, this.nativeEmoji !== false);
            const out = {};
            for (const category in store) {
                out[category] = [...Object.keys(store[category].emojis)].map(unicode => {
                    const emojiData = store[category].emojis[unicode]
                    let hairStyle = this._emojiHairStyle || '';
                    let skinTone = this._emojiSkinTone || '';

                    return {
                        raw: EmojiSearchTree.codePointsToString(emojiData.unicode, Number(skinTone) || null, Number(hairStyle) || null),
                        skinTone,
                        hairStyle,
                        image: emojiData.image?.image2x || emojiData.image?.image,
                        key: `${unicode}:${emojiData.skinTones ? skinTone : ''}:${emojiData.hairStyles ? hairStyle : ''}`,
                        title: emojiData.description,
                        type: 'emoji'
                    }
                })
            }

            return out
        }

        /**
         * Get the type options (skin tone and hair style) codes of emojis
         *
         * @return {Promise<{current: (Number|string), options: {label: *, value: *}[], type: string}[]>}
         */
        async getEmojiTypes() {
            await EmojiSearchTree.loadEmojiStore(this.panelMode || this.anchor || this.container);
            const stUnicode = EmojiSearchTree.emojiCodepointMap['270B'].unicode;
            const hsUnicode = EmojiSearchTree.emojiCodepointMap['1F9D1'].unicode;
            return [
                {
                    type: 'skin',
                    current: this._emojiSkinTone || '',
                    options: [['', ''], ...Object.entries(EmojiSearchTree.skinTones)].map(i => ({
                        value: i[0].toString(),
                        label: EmojiSearchTree.codePointsToString(
                            stUnicode,
                            i[0] ? `${Number(i[0]).toString(16)}` : null,
                            this._emojiHairStyle
                        ),
                        title: i[1]
                    }))
                },
                {
                    type: 'hair',
                    current: this._emojiHairStyle || '',
                    options: [['', ''], ...Object.entries(EmojiSearchTree.hairStyles)].map(i => ({
                        value: i[0].toString(),
                        label: EmojiSearchTree.codePointsToString(
                            hsUnicode,
                            this._emojiSkinTone,
                            i[0] ? `${Number(i[0]).toString(16)}` : null
                        ),
                        title: i[1]
                    }))
                }
            ];
        }

        /**
         *
         * @return {Promise<Object.<string, IconType[]>>}
         */
        async searchFontAwesome() {
            const icons = [];
            if (await ips.utils.iconpicker.faIconsEnabled()) {
                for (const [_, iconBase] of ips.utils.fontawesome.searchIcons(this._searchString, {limit: this._searchString ? 1500 : null})) {
                    for (const [iconSet, icon] of iconBase) {
                        icons.push({
                            ...icon,
                            raw: ips.utils.fontawesome.renderIcon({iconName: icon.iconName, prefix: iconSet, useSvg: !!this.svgIcons}).outerHTML,
                            title: iconBase.size > 1 ? `${icon.iconName} (${ips.getString('ipsFa__' + iconSet)})` : icon.iconName,
                            key: `${icon.iconName}:${iconSet}`,
                            selected: (`${icon.iconName}:${iconSet}` in this._selected.fa),
                            type: 'fa'
                        })
                    }
                }
            }
            return {'All icons': icons};
        }

        /**
         * Hide the picker
         */
        hide() {
            this._closeReactRoot?.();
        }

        /**
         * This is the method that destroys the instance!
         *
         * @return {void}
         */
        remove() {
            return this.hide();
        }
    }

    class EmojiSearchTree {
        constructor() {
            /** @type {Object.<string, EmojiSearchTree>} */
            this.children = {};

            /** @type {Set<string>} This set contains all the emoji unicode values at this position */
            this.results = new Set();
        }

        /**
         * Fix a key so that it is only alphanumeric for faster searching
         * @param {string} key
         * @return {string}
         */
        static fixKey(key) {
            return key.trim().toLowerCase().replaceAll(/[^\p{L}\p{N}\p{P}\p{S}_]/ugi, '')
        }

        /**
         * Add a term to the search tree
         * @param {string} key
         * @param {string} result
         */
        _addTerm(key, result) {
            key = EmojiSearchTree.fixKey(key)

            if (!key.length) {
                this.results.add(result);
                return;
            }
            if (!this.children[key[0]]) {
                this.children[key[0]] = new EmojiSearchTree();
            }
            this.children[key[0]]._addTerm(key.slice(1), result);
        }

        /**
         * Search the tree
         * @param {string}  key
         * @return {Set<string>}
         */
        _search(key) {
            key = EmojiSearchTree.fixKey(key)
            if (!key.length) {
                const results = new Set();
                for (const result of this.results) {
                    results.add(result);
                }

                for (const child of Object.values(this.children)) {
                    for (const result of child._search('')) {
                        results.add(result);
                    }
                }

                return results;
            } else if (key[0] in this.children) {
                return this.children[key[0]]._search(key.slice(1));
            }

            return new Set();
        }

        /** @type {EmojiSearchTree|undefined} */
        static _root = undefined;

        /**
         * Get the root instance to search emojis
         *
         * @param {boolean}     [custom=false]      Whether to get the instance containing custom ids
         * @param {boolean}     [includeNative=true]      Whether we want this instance to include native emojis
         *
         * @return {Promise<EmojiSearchTree>}
         */
        static async instance(custom=false, includeNative=true) {
            if (!custom && !includeNative) {
                throw new RangeError(`Need to use at least one of custom or native emojis for the emoji search`);
            }
            const key = (custom ? '_rootCustom' : '_root') + (includeNative ? '' : "-no-native")
            if (!this[key]) {
                // this has to be done first
                const store = includeNative ? {...(await this.loadEmojiStore(custom))} : {...(await this.loadCustomEmojiStore())};
                this[key] = new EmojiSearchTree();

                const termMap = {}
                for (const category in store) {
                    const {emojis} = store[category];
                    for (const code in emojis) {
                        emojis[code].indexCode = code;
                        emojis[code].shortcode = this.getShortCode(emojis[code].description);
                        termMap[emojis[code].description] = code;
                    }
                }

                for (const name of [...Object.keys(termMap)].sort()) {
                    const normalizedName = ips.utils.search.stripAccents(name);
                    const code = termMap[name];
                    const added = new Set();
                    // add the raw string for exact matching
                    added.add(normalizedName);

                    // add its shortcode for easy use
                    const shortCode = this.getShortCode(name);
                    if (shortCode) {
                        added.add(ips.utils.search.stripAccents(shortCode))
                    }

                    for (const pattern of [
                        /[^\p{L}\p{N}\p{S}\p{P}_]+/u,
                        /[^\p{L}\p{N}]+/u
                    ]) {
                        const components = normalizedName.trim().toLowerCase().split(pattern);
                        for (let i = 0; i < components.length; i++) {
                            if (!components[i]) {
                                continue;
                            }
                            added.add(components.slice(i).join(''));
                        }
                    }

                    added.forEach(term => {
                        this[key]._addTerm(term, code);
                        if (term.includes('smiling')) {
                            this[key]._addTerm(term.replace('smiling', 'smile'), code)
                        }
                    })
                }
            }

            return this[key];
        }

        static _shortCodeMap = {}
        static getShortCode(term) {
            if (!(term in this._shortCodeMap)) {
                this._shortCodeMap[term] = term
                    .toLowerCase()
                    .trim()
                    .replaceAll(/[^\p{L}\p{N}\s]+/gu, '')
                    .replaceAll(/\s+/g, '_')
                    .replaceAll(/_+/g, '_');
            }

            return this._shortCodeMap[term];
        }

        /**
         *
         * @param key
         * @param {boolean} [custom=false]
         * @param {number|null}     [limit=null]
         * @param {boolean}     [mergeCategories=false]
         * @param {boolean}     [includeNative=true]
         * @return {Promise<{"Search Results": { name: "Search Results", emojis: Object }}>}
         */
        static async search(key, custom=false, limit=null, mergeCategories=false, includeNative=true) {
            const instance = await this.instance(custom, includeNative);
            if (!key) {
                const categories = (!includeNative && custom) ? this.customEmojiStoreUnmerged : {...this.emojiStore, ...(custom ? this.customEmojiStoreMerged : {})}
                const out = {};
                for (const name in categories) {
                    out[name] = {
                        emojis: {},
                    }
                    for (const unicode in categories[name].emojis) {
                        out[name].emojis[unicode] = this.emojiCodepointMap[unicode] || this.customEmojiCodepointMap[unicode];
                    }
                }
                return out;
            }
            key = ips.utils.search.stripAccents(key);
            const results = instance._search(key);
            const ret = mergeCategories ? {
                "Search Results" : {
                    name: 'Search Results',
                    emojis: {}
                }
            } : {};

            let count = 0;
            for (const result of results) {
                if (limit !== null && count++ > limit) {
                    break;
                }
                const emojiData = this.emojiCodepointMap[result] || this.customEmojiCodepointMap[result];
                if (!mergeCategories) {
                    const category = this.emojiCategoryMap[result] || this.customEmojiCategoryMap[result];
                    ret[category] = ret[category] || {
                        name: category,
                        emojis: {}
                    }
                    ret[category].emojis[result] = emojiData;
                } else {
                    ret['Search Results'].emojis[result] = emojiData;
                }
            }

            if (!mergeCategories) {
                // one last sorting
                const sorted = {};
                for (const k in this.emojiStore) {
                    if (k in ret) {
                        sorted[k] = ret[k]
                    }
                }
                if (custom) {
                    for (const k in this.customEmojiStore) {
                        if (k in ret) {
                            delete sorted[k];
                            sorted[k] = ret;
                        }
                    }
                }
                return sorted;
            }

            return ret;
        }


        static emojiStore = undefined;
        static customEmojiStore = undefined;
        static customEmojiStoreMerged = undefined;
        static customEmojiStoreUnmerged = undefined;
        static emojiCodepointMap = {}; // this maps the code point to the emoji details. It is used for faster querying (query by codepoint)
        static customEmojiCodepointMap = {};
        static hairStyles = {};
        static skinTones = {};
        static emojiCategoryMap = {};
        static customEmojiCategoryMap = {};
        static emojiIndices = {};
        static customEmojiIndices = {};


        /**
         * Get the emoji store
         *
         * @param {boolean} [loadCustom=false]      Whether to load custom emojis
         *
         * @return {Promise<Object>}
         */
        static async loadEmojiStore(loadCustom=false) {
            if (this.emojiStore === undefined) {
                try {
                    this.emojiStore = await ips.fetch(ips.getSetting('baseURL') + '/applications/core/interface/static/emoji/emojiIndex.json');
                    for (const [key, {emojis}] of Object.entries(this.emojiStore)) {
                        let idx = 0;
                        for (const unicode in emojis) {
                            const codebase = Number('0x' + unicode.split(/\s+/)[0])
                            if (0x1f46b <= codebase && 0x1f46d >= codebase) {
                                delete this.emojiStore[key].emojis[unicode];
                                continue;
                            }
                            this.emojiCodepointMap[unicode] = emojis[unicode];
                            this.emojiCategoryMap[unicode] = key;
                            this.emojiIndices[unicode] = idx++;
                        }
                    }
                } catch (e) {
                    Debug.error(e)
                }

                try {
                    const skinTones = await ips.fetch(ips.getSetting('baseURL') + '/applications/core/interface/static/emoji/skinTones.json');
                    for (let code in skinTones) {
                        const numeric = this.hex2dec(code);
                        this.skinTones[numeric] = skinTones[code];
                    }
                } catch (e) {
                    Debug.error(e)
                }

                try {
                    const hairStyles = await ips.fetch(ips.getSetting('baseURL') + '/applications/core/interface/static/emoji/hairStyles.json')
                    for (let code in hairStyles) {
                        const numeric = this.hex2dec(code);
                        this.hairStyles[numeric] = hairStyles[code];
                    }
                } catch (e) {
                    Debug.error(e)
                }

            }

            if (loadCustom) {
                await this.loadCustomEmojiStore()
                if (this.customEmojiStoreMerged === undefined) {
                    this.customEmojiStoreMerged = {...this.emojiStore};

                    for (const k in this.customEmojiStore) {
                        let actualKey = k;
                        let i = 1;
                        while (actualKey in this.customEmojiStoreMerged) {
                            actualKey = k + ` ${i++}`
                        }

                        this.customEmojiStoreMerged[actualKey] = {name: actualKey, emojis: this.customEmojiStore[k]}
                    }
                }

                return this.customEmojiStoreMerged
            }

            return this.emojiStore;
        }

        static async loadCustomEmojiStore() {
            if (this.customEmojiStore === undefined || this.customEmojiStoreUnmerged === undefined) {
                try {
                    this.customEmojiStore = await ips.fetch(ips.getSetting('baseURL'), {data: {
                            app: 'core',
                            module: 'system',
                            controller: 'editor',
                            do: 'emoji'
                        }});

                    this.customEmojiStoreUnmerged = {};
                    for (const k in this.customEmojiStore) {
                        this.customEmojiStoreUnmerged[k] = {name: k, emojis: this.customEmojiStore[k]};
                        let idx = 0;
                        for (const [unicode, data] of Object.entries(this.customEmojiStore[k])) {
                            this.customEmojiCodepointMap[unicode] = data;
                            this.customEmojiCategoryMap[unicode] = k;
                            this.customEmojiIndices[unicode] = idx++;
                        }
                    }
                } catch (e) {
                    Debug.error(e)
                }
            }
            return this.customEmojiStoreUnmerged || {};
        }

        /**
         *
         * @return {number}
         */
        static zwj() {
            return this.hex2dec('200D');
        }

        /**
         *
         * @param hex
         * @return {number}
         */
        static hex2dec(hex) {
            return typeof hex === "string" ? Number('0x' + hex) : hex;
        }

        /** @type {Object.<string, string>}  This maps the codepoints & skintone/hairstyle to the rendered emoji string */
        static EMOJI_MAP = {}

        /**
         * Get a rendered emoji based on the code points and the skintone/hair style
         * @param {string|string[]}     codePoints      The codepoints
         * @param skinTone
         * @param hairStyle
         *
         * @return {string}
         */
        static codePointsToString(codePoints, skinTone=null, hairStyle=null) {
            if (!Array.isArray(codePoints)) {
                codePoints = codePoints.split(' ');
            }

            const key = JSON.stringify([codePoints, skinTone, hairStyle]);

            if (!(key in this.EMOJI_MAP)) {
                // If we have a skin color, this gets added to the first emoji component
                if (skinTone) {
                    skinTone = this.hex2dec(skinTone);
                    if (!(skinTone in EmojiSearchTree.skinTones)) {
                        Debug.warn(`A skin tone was given for an emoji that is not a valid supported skin tone`);
                    }
                }

                if (hairStyle) {
                    hairStyle = this.hex2dec(hairStyle);
                    if (!(hairStyle in EmojiSearchTree.hairStyles)) {
                        Debug.warn(`A hair style was given for an emoji that is not a valid supported hair style`);
                    }
                }

                this.EMOJI_MAP[key] = String.fromCodePoint(...codePoints
                    .map(codePoint => {
                        if (codePoint === '[[st]]') {
                            return skinTone
                        }
                        if (codePoint === '[[hs]]') {
                            return hairStyle ? [EmojiSearchTree.zwj(), hairStyle] : null
                        }
                        return this.hex2dec(codePoint)
                    })
                    .flat()
                    .filter(i => !!i)
                )
            }
            return this.EMOJI_MAP[key]
        }
    }
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000399"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.js - General utilities
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils', function (options) {

		/**
		 * Converts an arguments object to an array
		 *
		 * @param	{object} 	obj 	Arguments object
		 * @returns {array}
		 */
		var argsToArray = function (obj) {
			return Array.prototype.slice.call( obj );
		},

		/**
		 * Uppercases the first letter in a string
		 *
		 * @param 	{string} 	fromString 		String to use
		 * @returns {string}	String with first letter uppercased
		 */
		uppercaseFirst = function (fromString) {
			return fromString.charAt(0).toUpperCase() + fromString.slice(1);
		},

		/**
		 * Given a comma-delimited string, returns a string that can be used as a selector for IDs
		 *
		 * @param	{array,string} 	list 	Array of values, or comma-delimited string
		 * @returns {mixed}	 Selector string in format: #value1, #value2, or false if no values
		 */
		getIDsFromList = function (list) {
			if( !list ){
				return '';
			}
			
			if( !_.isArray( list ) ){
				list = list.toString().split(',');
			}

			list = _.compact( list );

			if( !list.length ){
				return false;
			}

			return _.map( list, function (val){
				return '#' + val;
			}).join(',');
		},
		
		/**
		 * Get a citation for a quote
		 *
		 * @param	{object} 	data 			The quote data
		 * @param	{bool}		[html]			If this can include HTML
		 * @param	{string}	[defaultValue]	The default value of the quote
		 *
		 * @returns {string}
		 */
		getCitation = function(data, html, defaultValue) {
			let citation = defaultValue || ips.getString('editorQuote');

			if (data.username) {
				let username = data.username;
				if ( html && data.userid && ips.getSetting('viewProfiles') ) {
					username = ips.templates.render( 'core.editor.citationLink', {
						baseURL: ips.getSetting('baseURL'),
						userid: data.userid,
						username: data.username
					} );
				} else {
					username = _.escape( username );
				}
				if (data.timestamp) {
					citation = ips.getString( 'editorQuoteLineWithTime', {
						date: ips.utils.time.readable( data.timestamp ),
						username: username
					});
				} else {
					citation = ips.getString( 'editorQuoteLine', { username: username } );
				}
			}
			return citation;
		},

		escapeRegexp = function (toEscape) {
			return toEscape.replace( /[.*+?^${}()|[\]\\]/g, "\\$&" );
		},

		/**
		 * urlBase64ToUint8Array
		 * 
		 * @param {string} base64String a public vavid key
		 */
		urlBase64ToUint8Array = function (base64String) {
			var padding = '='.repeat((4 - base64String.length % 4) % 4);
			var base64 = (base64String + padding)
				.replace(/\-/g, '+')
				.replace(/_/g, '/');

			var rawData = window.atob(base64);
			var outputArray = new Uint8Array(rawData.length);

			for (var i = 0; i < rawData.length; ++i) {
				outputArray[i] = rawData.charCodeAt(i);
			}
			return outputArray;
		};

		return {
			argsToArray: argsToArray,
			uppercaseFirst: uppercaseFirst,
			getIDsFromList: getIDsFromList,
			getCitation: getCitation,
			escapeRegexp: escapeRegexp,
			urlBase64ToUint8Array: urlBase64ToUint8Array
		};
	});
}(jQuery,_));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.lazyload.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * @module ips.utils.lazyload
 *
 * Legacy support module for v4 JS, intersection-based lazy load HTML. Elements will have a src and a data-src attribute, and used to use an intersection observer to load when they because visible. This JS uses native lazy loading on the old content structures
 *
 * @since Nov 2024
 * @author Matt Finger
 */
;(function($, _) {
    "use strict";

    ips.createModule("ips.utils.lazyload", function() {
        const fixedElements = new WeakSet();
        const imgDimsCache = {
            _cache: new Map(),
            get(key) {
                let value;
                if (!this._cache.has(key)) {
                    try {
                        value = ips.utils.db.get('ips.utils.lazyloadImgDims', key);
                    } catch (e) {}
                } else {
                    value = this._cache.get(key);
                }
                return value;
            },

            set(key, value) {
                ips.utils.db.set('ips.utils.lazyloadImgDims', key, value, false, Math.round(Date.now() / 1000) + 86400);
                return this._cache.set(key, value);
            },

            has(key) {
                return this._cache.has(key);
            },

            delete(key) {
                ips.utils.db.remove('ips.utils.lazyloadImgDims', key);
                return this._cache.delete(key);
            }
        };


        return {
            /**
             * Init - Parse lazy load elements now and on content change
             */
            init() {
                this.parseLazyLoadElements();
                $(document).on('contentChange', function(changedElement) {
                    try {
                        $(changedElement).each(function() {
                            fixedElements.delete(this);
                            ips.utils.lazyload.parseLazyLoadElements(this);
                        });
                    } catch (e) {
                        Debug.warn(`Something went wrong when processing lazy load images`);
                        Debug.warn(e);
                    }
                })
            },

            /**
             * Parse lazy load elements
             * @param {Element} [root]
             * @param {boolean} [useNativeDims=true]
             */
            parseLazyLoadElements(root, useNativeDims=true) {
                root = root instanceof Element ? root : document.body;
                if (root !== document.body && fixedElements.has(root)) {
                    return;
                }

                // Add the root as well because everything under it should be cleaned up
                fixedElements.add(root);
                root
                    .querySelectorAll(":is([data-src], [data-embed-src]):is(img, audio, video, iframe, object, embed):not(.tiptap *)")
                    .forEach(element => {
                        if (fixedElements.has(element)) {
                            return;
                        }
                        element.dataset.ipsLazyloadProcessed = '1'
                        fixedElements.add(element);
                        const dataSrc = (element.dataset.src || element.dataset.embedSrc)?.trim();
                        if (element.getAttribute('src')?.trim() === dataSrc) {
                            delete element.dataset.src;
                            delete element.dataset.embedSrc;
                            return;
                        }
                        Debug.log(`Found legacy lazy loading ${element.tagName.toLowerCase()}. src: ${dataSrc}`);
                        element.setAttribute('loading', 'lazy');
                        element.setAttribute('src', dataSrc);
                        delete element.dataset.src;
                        delete element.dataset.embedSrc;

                        // For images, let's try and set the dimensions to prevent jumps in content height
                        if (element.matches('img')) {
                            let width = parseFloat(element.getAttribute('width') || '');
                            let height = parseFloat(element.getAttribute('height') || '');

                            if (width && height && !Number.isNaN(width) && !Number.isNaN(height)) {
                                return;
                            } else if (element.style.height || element.style.width) { // if CSS if positioning this, we don't care so much
                                return;
                            } else if (parseFloat(width?.toString() || element.dataset.width || '') && parseFloat(height?.toString() || element.dataset.height || '')) {
                                width = Math.round(parseFloat(width?.toString() || element.dataset.width) * 100) / 100;
                                height = Math.round(parseFloat(height?.toString() || element.dataset.height) * 100) / 100;
                            } else if (parseFloat(width?.toString() || element.dataset.width || '') && parseFloat(element.dataset.ratio || '')) {
                                width = Math.round(parseFloat(width?.toString() || element.dataset.width) * 100) / 100;
                                height = Math.round((width / parseFloat(element.dataset.ratio)) * 100) / 100;
                            } else if (parseFloat(height?.toString() || element.dataset.height || '') && parseFloat(element.dataset.ratio || '')) {
                                height = Math.round(parseFloat(height?.toString() || element.dataset.height) * 100) / 100;
                                width = Math.round(height * parseFloat(element.dataset.ratio) * 100) / 100;
                            }

                            if (typeof height === "number" && typeof width === "number" && height > 0 && width > 0) {
                                Debug.log(`Determined the width and height from data- attributes as ${width} and ${height}`);
                                element.setAttribute('width', width.toString());
                                element.setAttribute('height', height.toString());
                            } else if (useNativeDims) {
                                this.getNativeImgDims(element.getAttribute('src'))
                                    .then(dims => {
                                        if (dims) {
                                            Debug.log(`Determined the width and height from the URL as ${dims.width} and ${dims.height}`);
                                            element.setAttribute('width', dims.width.toString());
                                            element.setAttribute('height', dims.height.toString());
                                        }
                                    })
                                    .catch(err => {
                                        Debug.warn(`Failed to determine the native dims of the image at the URL ${element.getAttribute('url')}`);
                                        Debug.warn(err);
                                    })
                            }
                        }
                    });
            },

            /**
             * Get native img dims
             *
             * @param {string } url
             *
             * @returns {Promise<undefined|{width:number,height:number}>}
             */
            getNativeImgDims(url) {
                return new Promise(_resolve => {
                    let done = false;
                    let timeout;
                    const resolve = val => {
                        if (timeout !== undefined) {
                            clearTimeout(timeout);
                        }

                        if (done) {
                            return;
                        }
                        done = true;
                        _resolve(val);
                    };

                    try {
                        let output = {width: 0, height: 0};
                        url = new URL(url);
                        if (imgDimsCache.has(url.toString())) {
                            resolve(imgDimsCache.get(url.toString()));
                            return;
                        }

                        const img = new Image();

                        // force end by 3 seconds
                        timeout = setTimeout(() => {
                            imgDimsCache.set(url.toString(), undefined);
                            resolve(undefined);
                        }, 3000);

                        img.addEventListener('load', () => {
                            output.width = img.naturalWidth;
                            output.height= img.naturalHeight;
                            if (Number.isNaN(output.width) || Number.isNaN(output.height) || output.width <= 0 || output.height <= 0) {
                                imgDimsCache.set(url.toString(), undefined);
                                resolve(undefined);
                                return;
                            }

                            output.height = Math.max(1, Math.round(output.height * 100) / 100);
                            output.width = Math.max(1, Math.round(output.width * 100) / 100);

                            imgDimsCache.set(url.toString(), output);

                            resolve(output);
                        });

                        img.addEventListener('error', () => {
                            imgDimsCache.set(url.toString(), undefined);
                            resolve(undefined);
                        });

                        img.src = url.toString();
                    } catch (e) {
                        resolve(undefined);
                    }
                });
            }
        }
    });
})(jQuery, _);]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.links.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.links.js - A module for working with links
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	&quot;use strict&quot;;
	
	ips.createModule('ips.utils.links', function () {

		/**
		 * Fires a manual event on an element
		 */
		var updateExternalLinks = function (element) {            
			if( ips.getSetting('links_external') ) {
				if( _.isUndefined( element ) ){
					return;
				}
				
				element.find('a[rel*=&quot;external&quot;]').each( function( index, elem ){
					elem.target = &quot;_blank&quot;;
					elem.rel = elem.rel.replace(&quot; noopener&quot;, &quot;&quot;) + &quot; noopener&quot;;
				});
			}
		};
		
		return {
			updateExternalLinks: updateExternalLinks
		};
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.notification.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.notification.js - A module for working with HTML5 notifications
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";
	ips.createModule('ips.utils.notification', function () {
		/**
		 * Whether notifications are supported by the current user agent, not whether they are enabled
		 * @type {boolean}
		 */
		const supported = !!(
			window.Notification?.requestPermission instanceof Function &&
			ips.getSetting('pushPublicKey') !== null);

		/**
		 * Requests permission for notifications from the user
		 *
		 * @returns 	{void}
		 */
		 async function requestPermission() {
			if (supported)
				$(document).trigger((await Notification.requestPermission()) === 'granted' ? 'permissionGranted.notifications' : 'permissionDenied.notifications')
		}

		/**
		 * Subscribes a user to push notifications
		 * Note: permission must be checked before calling or it will fail
		 *
		 * @returns 	{Promise}
		 */
		async function subscribeToPush() {
			$(document).trigger('subscribePending.notifications');

			const registration = await ips.utils.serviceWorker.registerServiceWorker('front', true);
			const options = {
				userVisibleOnly: true, // Required: https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user#uservisibleonly_options
				applicationServerKey: ips.utils.urlBase64ToUint8Array( ips.getSetting('pushPublicKey') )
			};

			const subscription = JSON.stringify(await registration.pushManager.subscribe(options));
			try {
				 await ips.fetch(ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=notifications&do=subscribeToPush', {
						method: 'POST',
						data: {
							subscription,
							encoding: PushManager.supportedContentEncodings?.[0] || 'aesgcm'
						}
					})
				$(document).trigger('subscribeSuccess.notifications')
			} catch (e) {
				$(document).trigger('subscribeFail.notifications')
			}
		}

		/**
		 * Determines whether the user has granted permission for notifications
		 *
		 * @returns 	{boolean}	Whether notifications have permission
		 */
		function hasPermission() {
			return supported && !ips.utils.cookie.get('noBrowserNotifications') && !['denied', 'default'].includes(Notification.permission);
		}

		/**
		 * Get the user's subscription, if any
		 *
		 * @returns 	{Promise}
		 */
		async function getSubscription() {
			try {
				const registration = await ips.utils.serviceWorker.getRegistration()
				const subscription = await registration.pushManager.getSubscription()
				return subscription || false;
			} catch (e) {
				Debug.log(e)
			}
		}

		/**
		 * Set any notification badge count to zero
		 * This is used to clear the badge count when the user has read all notifications.
		 */
		function clearBadgeCount() {
			if( ! this.hasPermission() ) {
				return;
			}
			if ('clearAppBadge' in navigator) {
				navigator.clearAppBadge().catch((e) => {
					Debug.log(e);
				});
			} else if ('setAppBadge' in navigator) {
				navigator.setAppBadge(0).catch((e) => {
					Debug.log(e);
				});
			}
		}

		/**
		 * Do we need permission to show notifications? If the user has agreed or explicitly declined, this
		 * will be false. If they haven't decided yet, it'll return true.
		 *
		 * @returns 	{boolean} 	Whether the browser needs to ask for permission
		 */
		function needsPermission() {
			return supported && !ips.utils.cookie.get('noBrowserNotifications') && Notification.permission === 'default';
		}

		/**
		 * Returns the granted permission level
		 *
		 * @returns 	{NotificationPermission|null}
		 */
		function permissionLevel() {
			return supported ? Notification.permission : null;
		}

		/**
		 * Creates a new notification and returns a notification object
		 *
		 * @param 		{object} 	options 	Configuration object
		 * @returns 	{IpsNotification|void}
		 */
		function create(options) {
			try {
				return new IpsNotification( options );
			} catch(e) {}
		}


		class IpsNotification {

			/**
			 * @type {null|Notification}
			 * @private
			 */
			_notification = null;
			_options = {
				title: '',
				body: '',
				icon: '',
				timeout: false,
				tag: '',
				dir: $('html').attr('dir') || 'ltr',
				lang: $('html').attr('lang') || '',
				onShow() {},
				onHide() {},
				onClick() {},
				onError() {}
			}

			/**
			 * Our notification constructor
			 *
			 * @param 		{object} 	options 	Configuration object
			 */
			constructor(options) {
				this._notification = null;
				Object.assign(this._options, options)

				// Unescape body & title because we'll be getting escaped chars from the backend
				this._options.body = _.unescape(this._options.body.replace(/&#039;/g, "'").replace(/<[^>]*?(?:>|$)/g, ''));
				this._options.title = _.unescape(this._options.title.replace(/&#039;/g, "'"));

			}

			/**
			 * Show the notification
			 */
			show() {
				this._notification = new Notification(this._options.title, this._options);
				this._notification.addEventListener('show', this._options.onShow, false);
				this._notification.addEventListener('hide', this._options.onHide, false);
				this._notification.addEventListener('click', this._options.onClick, false);
				this._notification.addEventListener('error', this._options.onError, false);

				if (!Number.isNaN(this._options.timeout)) {
					setTimeout(() => this.hide(), Number(this._options.timeout) * 1000);
				}
			}

			/**
			 * Hide the notification
			 */
			hide() {
				if (this._notification) {
					this._notification.close();
					this._notification.removeEventListener('show', this._options.onShow, false);
					this._notification.removeEventListener('hide', this._options.onHide, false);
					this._notification.removeEventListener('click', this._options.onClick, false);
					this._notification.removeEventListener('error', this._options.onError, false);
				}
			}
		}

		$( document ).on('requestPermission.notifications', requestPermission);
		$( document ).on('permissionGranted.notifications', subscribeToPush);
		
		return {
			supported,
			subscribeToPush,
			hasPermission,
			getSubscription,
			needsPermission,
			permissionLevel,
			requestPermission,
			create,
			clearBadgeCount
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.pagebuildericons.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[;((($, _) => {
    "use strict";

    ips.createModule('ips.utils.pagebuildericons', function() {
        const loadPagebuilder = async () => {
            if ( !ips.utils.pagebuilder ) {
                const url = ips.getSetting('baseURL') + `/applications/core/interface/static/pagebuilder/manifest.json?v=${ips.getSetting('pagebuilderKey')}&antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`;
                const data = await ips.fetch(url)

                const toLoad = [];

                for(const key in data) {
                    if (data[key].file?.match(/\.css$/i)) {
                        const href = ips.getSetting('baseURL') + '/applications/core/interface/static/pagebuilder/' + data[key].file + `?antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`;
                        if (!document.querySelector(`[href="${encodeURI(href)}"]`)) {
                            const style = document.createElement('link')
                            style.rel = 'stylesheet'
                            style.href = href
                            document.head.appendChild(style)
                        }

                    } else if (data[key].isEntry) {
                        toLoad.push(ips.getSetting('baseURL') + '/applications/core/interface/static/pagebuilder/' + data[key].file)
                    }

                }

                if (toLoad.length) {
                    await ips.loader.getStatic(toLoad)
                }
            }
        }

        const fillIcons = () => {
            document.querySelectorAll('[for*="elCheckbox_dev_widget_layouts_"]').forEach(async label => {
                if (!label.querySelector('svg.pagebuildericon')) {
                    await loadPagebuilder()
                    const icon = label.getAttribute('for').match(/^elCheckbox_dev_widget_layouts_([a-z\-_]+)$/i)[1]
                    ips.utils.pagebuilder.fillSemanticIcon(label, icon).then(() => {
                        label.querySelector('svg.pagebuildericon').dataset.ipstooltip = ''
                        label.querySelector('svg.pagebuildericon').setAttribute('title', ips.getString(`core_pagebuilder_wrap__${icon}`))
                    })
                }
            })
        }

        $(document).on('contentChange', fillIcons)
        fillIcons()

        return {}
    })
})(jQuery, _))]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.position.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.position.js - Positioning utilities
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.position', function () {
		/**
		 *
		 * @type {Map<Element, {rect: DOMRect, style: CSSStyleDeclaration}>}
		 */
		const CACHED_DATA = new Map();
		let caching = false;

		/**
		 * Start recording positions in a cache. REMEMBER TO END CACHING WHEN DONE
		 *
		 * @returns {true}
		 */
		function startCaching() {
			caching = true;
			return true;
		}

		/**
		 * Stop caching or clear the cache for a specific element
		 *
		 * @param {Element|undefined}	[elem=undefined]
		 *
		 * @returns {true}
		 */
		function endCaching(elem) {
			elem = elem ? $(elem).get(0) : elem;
			if (elem) {
				CACHED_DATA.delete(elem);
			} else {
				CACHED_DATA.clear();
				caching = false;
			}

			return true;
		}

		/**
		 * @deprecated
		 * Returns positioning information for the element
		 *
		 * @param 		{element} 	elem 	The element we're working on
		 * @returns 	{object}
		 */
		function getElemPositionOld(elem) {
			/*eslint-disable*/
			let _elem = elem;
			const ogReturn = ips.logTime(() => {
				let elem = _elem;
				if (!elem) {
					return false;
				}
				var props = {};
				var hidden = !elem.is(':visible');
				var opacity = elem.css('opacity');

				// We can only fetch the values we need if the element is visible
				// If it's hidden, make it ever so slightly visible - we'll hide it again later
				if (hidden) {
					elem.css({opacity: "0.0001"}).show();
				}

				var offset = elem.offset();
				var position = elem.position();
				var dims = getElemDims(elem);

				// Absolute position
				props.absPos = {
					left: offset.left,
					top: offset.top,
					right: (offset.left + dims.outerWidth),
					bottom: (offset.top + dims.outerHeight),
				};

				// Offset position
				props.offsetPos = {
					left: position.left,
					top: position.top,
					right: (position.left + dims.outerWidth),
					bottom: (position.top + dims.outerHeight)
				};

				// Viewport offsets
				// These will be overwritten for fixed elements
				props.viewportOffset = {
					left: offset.left - window.scrollX,
					top: offset.top - window.scrollY
				};

				props.offsetParent = elem.offsetParent();

				// Special values if the element is in a fixed container
				props.fixed = (hasFixedParents(elem, true));

				// Re-hide it if necessary
				if (hidden) {
					elem.hide().css({opacity: String(opacity)});
				}

				return props;
			}, 'Got position with jquery')
			const newReturn = ips.logTime(() => getElemPositionNew(_elem), 'Got the position with native js');
			ips.logTime(() => {}, {ogReturn, newReturn});

			/* Compare old and new */
			if (ogReturn) {
				for (const rootKey in ogReturn) {
					if (rootKey === 'offsetParent') {
						if (ogReturn[rootKey].get(0) !== newReturn?.[rootKey]?.get(0)) {
							ips.logTime(() => {}, `${rootKey} is different`);
						}
					} else if (typeof ogReturn[rootKey] === "object") {
						for (const k in ogReturn[rootKey]) {
							if (ogReturn[rootKey][k] !== newReturn?.[rootKey]?.[k] && !(typeof ogReturn[rootKey][k] === 'number' && typeof newReturn?.[rootKey]?.[k] === "number" && Math.round(ogReturn[rootKey][k] * 100) === Math.round(newReturn[rootKey][k] * 100))) {
								ips.logTime(() => {}, `${rootKey}.${k} is different`);
							}
						}
					} else if (ogReturn[rootKey] !== newReturn?.[rootKey]) {
						ips.logTime(() => {}, `${rootKey} is different`);
					}
				}
			} else if (newReturn) {
				ips.logTime(() => {}, 'Old and new return differ');
			}

			return ogReturn;
			/*eslint-enable*/
		}

		/**
		 * Get the offset parent of an element, or see if the element can be an offset parent
		 *
		 * @param {HTMLElement|jQuery}	elem
		 * @param {boolean}			[includeElem=false]
		 * @param {object}			[eventualStyle={}]		* Only used if includeElem === true. In that case, a temp child is created and its offset parent is evaluated. You can specify details like the position and location of the child so it behaves as you might expect
		 *
		 * @return {HTMLElement}
		 */
		function getOffsetParent(elem, includeElem=false, eventualStyle={}) {
			elem = $(elem).get(0);
			if (!includeElem) {
				return elem.offsetParent || document.body;
			}

			// If includeElem is true, then the offsetParent could be the element itself; moreover, we're testing if this element is an offsetParent (or a container box root).
			// We need to test a child
			let child = document.createElement('span');
			Object.assign(child.style, eventualStyle);
			child.style.opacity = '0';
			elem.appendChild(child);
			setTimeout(() => child.remove()); // after all this is done, remove the child

			return child.offsetParent || document.body;
		}

		/**
		 * Get various metrics on the element's position
		 * @param {Element} elem
		 * @return {object|false}
		 */
		function getElemPosition(elem) {
			if (!elem) {
				return false;
			}
			elem = $(elem).get(0);
			const toReturn = {};
			const {rect, style} = getElemRectAndStyle(elem);
			const {rect:docRect} = getElemRectAndStyle(document.body);

			toReturn.absPos = {
				left: rect.left - docRect.left,
				top: rect.top - docRect.top,
				right: rect.right - docRect.left,
				bottom: rect.bottom - docRect.top,
			};

			const offsetParent = getOffsetParent(elem) || document.body;
			const marginBlockStart = getPxFromDim(style.marginTop);
			const marginInlineStart = getPxFromDim(style.marginLeft);
			const {rect: offsetParentRect, style: offsetParentStyle} = getElemRectAndStyle(offsetParent);
			const offsetParentBorderLeft = getPxFromDim(offsetParentStyle.borderLeftWidth);
			const offsetParentBorderTop = getPxFromDim(offsetParentStyle.borderTopWidth);

			const offsetLeft = offsetParentRect.left + offsetParentBorderLeft;
			const offsetTop = offsetParentRect.top + offsetParentBorderTop;

			toReturn.offsetPos = {
				left: rect.left + marginInlineStart - offsetLeft,
				top: rect.top + marginBlockStart - offsetTop,
				right: rect.right + marginInlineStart - offsetLeft,
				bottom: rect.bottom + marginBlockStart - offsetTop,
			};

			toReturn.viewportOffset = {
				left: rect.left,
				top: rect.top,
			};

			toReturn.offsetParent = $(offsetParent);
			toReturn.fixed = hasFixedParents( $(elem), true );

			return toReturn;
		}

		function getPxFromDim(dim) {
			const match = dim?.trim?.().match?.(/^-?(\d+|\d+\.\d*|\.\d+)px$/);
			if (match) {
				return parseFloat(match[1])
			}
			return 0;
		}

		/**
		 * Figures out the coords to position a popup element appropriately
		 * Abandon hope all ye who enter here
		 *
		 * @param	{object} 	options	 	Options for positioning
		 * @param 	{element}	options.trigger 	The trigger element for this popup
		 * @param	{element}	options.target 		The target element, i.e. the popup itself
		 * @param	{element}	options.targetContainer 	Container element of target, if not body
		 * @param	{boolean}	options.center 		Should the target be centered?
		 * @returns {object}
		 */
		function positionElem(options) {
			const trigger = $(options.trigger);
			const triggerPos = getElemPosition(trigger);
			const triggerDims = getElemDims(trigger);
			const targetDims = getElemDims(options.target);
			const toReturn = {};
			const stemOffset = options.stemOffset || {top: 0, left: 0};
			let offsetParent;
			let positioned = false;

			options.targetContainer = options.targetContainer ? getOffsetParent(options.targetContainer, true) : $(getOffsetParent(options.target));

			if( options.targetContainer && $(options.targetContainer).length ){
				// If we have any fixed parents, we switch to using the viewport offsets, since that's how
				// fixed elements are measured. For normal absolute/relative positioned parents, use the
				// values from position() instead.
				if( hasFixedParents( trigger ) ){
					offsetParent = triggerPos.viewportOffset;
				} else {
					const containerPos = getElemPosition(options.targetContainer);

					// Here we work out the difference between the left positions of the trigger and the container to find out
					// how much we need to adjust the position of the target. We add in the offset to account for positioning, as above.
					offsetParent = {
						left: ( triggerPos.absPos.left - containerPos.absPos.left ),
						top: ( triggerPos.absPos.top - containerPos.absPos.top )
					};
				}

				positioned = true;
			} else {
				// Use the body
				offsetParent = triggerPos.viewportOffset;
			}

			// Work out the best fit for the target, trying to keep it from going off-screen
			const bestFit = _getBestFit(
				triggerPos.viewportOffset,
				triggerDims,
				targetDims,
				stemOffset,
				{
					horizontal: (options.center) ? 'center' : 'left',
					vertical: (options.above === true || options.above === 'force') ? 'top' : 'bottom'
				},
				(options.above === 'force') ? false : !options.above,
				!(options.above === 'force')
			);

			// Start to build the return object
			switch( bestFit.horizontal ){
				case 'center':
					toReturn.left = offsetParent.left + ( triggerDims.outerWidth / 2 ) - 
							( targetDims.outerWidth / 2 );
				break;
				case 'left':
					toReturn.left = offsetParent.left - stemOffset.left + ( triggerDims.outerWidth / 2 );
				break;
				case 'right':
					toReturn.left = offsetParent.left - targetDims.outerWidth +
							 ( triggerDims.outerWidth / 2 ) + stemOffset.left;
				break;
			}

			switch( bestFit.vertical ){
				case 'top':
					toReturn.top = offsetParent.top - targetDims.outerHeight + 
										stemOffset.top;
				break;
				case 'bottom':
					toReturn.top = offsetParent.top + triggerDims.outerHeight -
										stemOffset.top;
				break;
			}

			if( !positioned && !triggerPos.fixed ) {
				toReturn.top += window.scrollY;
			}

			toReturn.fixed = triggerPos.fixed;
			toReturn.location = bestFit;

			return toReturn;
		}

		/**
		 * Returns true if the provided element has any fixed-position ancestors (including tables)
		 *
		 * @param	{Element} 	elem	 	Element to test
		 * @param 	{boolean}	andSelf		Whether to include the element provided
		 * @returns {boolean}
		 */
		function hasFixedParents(elem, andSelf) {
			elem = $( elem ).get(0);
			if (!andSelf) {
				elem = elem.parentElement;
			}

			while (elem instanceof Element) {
				if (elem.style.position === 'fixed') {
					return true;
				}
				elem = elem.parentElement;
			}

			return false;
		}

		/**
		 * Get the style and rect for an element
		 * @param elem
		 * @return {{rect: DOMRect, style: CSSStyleDeclaration}}
		 */
		function getElemRectAndStyle(elem) {
			elem = $(elem).get(0);
			if (!(elem instanceof Element)) {
				const tempel = document.createElement('div');
				return {
					style: getComputedStyle(tempel),
					rect: tempel.getBoundingClientRect(),
				}
			}

			const cached = caching && CACHED_DATA.get(elem);
			if (cached) {
				return cached;
			}

			let style = getComputedStyle(elem);
			// Display contents causes an element to not have its own client box and therefore getBoundingClientRect() fails.
			let rect;
			if (style.display === 'contents') {
				// this is brutal but necessary for display: contents
				function checkChildren(el) {
					for (const child of el.children) {
						const childStyle = getComputedStyle(child);
						if (childStyle.position !== 'static') {
							continue;
						}
						if (childStyle.display === 'contents') {
							checkChildren(child);
						} else {
							const childRect = getElemRectAndStyle(child).rect;
							rect = rect || childRect;
							if (rect !== childRect) {
								rect = new DOMRect(
									Math.min(rect.left, childRect.left),
									Math.min(rect.y, childRect.y),
									Math.max(rect.width, childRect.width),
									Math.max(rect.height, childRect.height)
								);
							}
						}
					}
				}

				checkChildren(elem);

				if (!rect) {
					rect = elem.getBoundingClientRect();
				}
			} else {
				rect = elem.getBoundingClientRect();
			}

			const revertValues = {};
			if (!rect.width && !rect.height && !rect.top && !rect.bottom) {
				Debug.warn("Attempting to get the rect and style of an element that is not visible. Will attempt to show the element briefly");

				// if it isn't visible, make it visible
				const toSet = {
					position: 'absolute',
					visibility: 'hidden',
					display: 'block'
				};

				for (const k in toSet) {
					revertValues[k] = elem.style[k];
					elem.style[k] = toSet[k];
				}

				let time = Date.now();
				while (Date.now() - time < 5) {
					continue;
				}

				rect = elem.getBoundingClientRect();
				style = getComputedStyle(elem);

				for (const k in revertValues) {
					elem.style[k] = revertValues[k] || "";
				}
				time = Date.now();
				while (Date.now() - time < 5) {
					continue;
				}
			}

			const ret = {rect, style};
			if (caching) {
				CACHED_DATA.set(elem, ret);
			}
			return ret;
		}

		/**
		 * Works out the best location for an element such that it tries to avoid going off-screen
		 *
		 * @param	{object} 	viewportOffset	 	viewport offset values for the element
		 * @param	{object}	triggerDims			Dimensions of the trigger element
		 * @param 	{object}	targetDims			Dimentions of the target element (menu, tooltip etc.)
		 * @param 	{object} 	offset 				Any offset to apply to numbers (e.g. to allow for stem)
		 * @param 	{object} 	posDefaults 		set default vertical/horizontal position
		 * @param 	{boolean}	preferBottom		Should target prefer opening under the trigger?
		 * @param 	{boolean} 	attemptToFit		If true, will change vertical position based on available space (and depending on preferBottom)
		 * @returns {{vertical: "top"|"center"|"bottom", horizontal: "center"|"left"|"right"}}
		 */
		function _getBestFit(viewportOffset, triggerDims, targetDims, offset, posDefaults, preferBottom, attemptToFit) {
			const position = {
				vertical: 'bottom',
				horizontal: 'left',
				...(posDefaults || {})
			};
			
			// Left pos
			if( position.horizontal === 'center' ){
				const targetLeft = viewportOffset.left + (triggerDims.outerWidth / 2) - (targetDims.outerWidth / 2);
				const targetRight = targetLeft + targetDims.outerWidth;

				if( targetLeft < 0 || targetRight > window.innerWidth ){
					position.horizontal = 'left';
				}
			}

			if( position.horizontal === 'left' ){
				if( ( viewportOffset.left + (triggerDims.outerWidth / 2) + targetDims.outerWidth - offset.left ) > window.innerWidth ){
					position.horizontal = 'right';
				}
			} 
			
			if ( position.horizontal === 'right' ) {
				if( ( viewportOffset.right - (triggerDims.outerWidth / 2) - targetDims.outerWidth + offset.left ) < 0 ){
					position.horizontal = 'left';
				}
			}

			// Top pos
			if( attemptToFit ){
				if( position.vertical === 'top' || preferBottom ){
					if( ( viewportOffset.top - targetDims.outerHeight - offset.top ) < 0 ){
						position.vertical = 'bottom';
					}
				} else {
					if( ( viewportOffset.top + triggerDims.outerHeight + targetDims.outerHeight + offset.top ) > window.innerHeight ){
						position.vertical = 'top';
					}
				}
			}
			
			return position;
		}

		/**
		 * Returns dimensions for the given element
		 *
		 * @deprecated
		 * @param	{Element} 	elem	 	Element to test
		 * @returns {object}
		 */
		function getElemDimsOld(_elem) {
			const newReturn = ips.logTime(() => getElemDimsNew(_elem), 'got dims native js');
			const ogReturn = ips.logTime(() => {
				let elem = $( _elem );

				return {
					width: elem.width(),
					height: elem.height(),
					outerWidth: elem.outerWidth(),
					outerHeight: elem.outerHeight()
				};
			}, 'got dims jquery')

			console.log(ogReturn, newReturn, $(_elem).get(0));
			for (const rootKey in ogReturn) {
				if (rootKey === 'offsetParent') {
					if (ogReturn[rootKey].get(0) !== newReturn?.[rootKey]?.get(0)) {
						ips.logTime(() => {}, `${rootKey} is different`);
					}
				} else if (typeof ogReturn[rootKey] === "object") {
					for (const k in ogReturn[rootKey]) {
						if (ogReturn[rootKey][k] !== newReturn?.[rootKey]?.[k] && !(typeof ogReturn[rootKey][k] === 'number' && typeof newReturn?.[rootKey]?.[k] === "number" && Math.round(ogReturn[rootKey][k] * 100) === Math.round(newReturn[rootKey][k] * 100))) {
							ips.logTime(() => {}, `${rootKey}.${k} is different`);
						}
					}
				} else if (ogReturn[rootKey] !== newReturn?.[rootKey] && !(typeof ogReturn[rootKey] === "number" && typeof newReturn?.[rootKey] === 'number' && Math.round(ogReturn[rootKey] * 100) === Math.round(newReturn[rootKey] * 100))) {
					ips.logTime(() => {}, `${rootKey} is different ${ogReturn[rootKey]} vs ${newReturn?.[rootKey]}`);
				}
			}
			return ogReturn;
		}

		/**
		 * Returns dimensions for the given element
		 *
		 * @param	{Element} 	elem	 	Element to test
		 * @returns {object}
		 */
		function getElemDims(elem) {
			elem = $( elem ).get(0);
			if (!(elem instanceof Element)) {
				return {
					width: 0,
					height: 0,
					outerWidth: 0,
					outerHeight: 0
				}
			}

			const {rect, style} = getElemRectAndStyle(elem);
			const paddingLeft = getPxFromDim(style.paddingLeft);
			const paddingRight = getPxFromDim(style.paddingRight);
			const paddingTop = getPxFromDim(style.paddingTop);
			const paddingBottom = getPxFromDim(style.paddingBottom);
			const borderTopWidth = getPxFromDim(style.borderTopWidth);
			const borderBottomWidth = getPxFromDim(style.borderBottomWidth);
			const borderLeftWidth = getPxFromDim(style.borderLeftWidth);
			const borderRightWidth = getPxFromDim(style.borderRightWidth);

			return {
				width: rect.width - paddingLeft - paddingRight - borderLeftWidth - borderRightWidth,
				height: rect.height - paddingTop - paddingBottom - borderBottomWidth - borderTopWidth,
				outerWidth: rect.width,
				outerHeight: rect.height
			};
		}

		/**
		 * Returns the natural width for an image element
		 *
		 * @param	{element} 	elem	 	Image element to use
		 * @returns {number}
		 */
		function naturalWidth(elem) {
			return _getNatural( elem, 'Width' );
		}

		/**
		 * Returns the natural height for an image element
		 *
		 * @param	{element} 	elem	 	Image element to use
		 * @returns {number}
		 */
		function naturalHeight(elem) {
			return _getNatural( elem, 'Height' );
		}

		/**
		 * Attempts to get the line-height of the provided element. Note; there's cases where this won't be reliable.
		 * For example, if CSS styles <span> differently, it may give a value different to the parent. Test your case
		 * before relying on this.
		 *
		 * @param	{Element} 	parent	 	Element to fetch the line-height for
		 * @returns {number}
		 */
		function lineHeight(parent) {
			parent = $(parent).get(0);
			const text = document.createTextNode('A');
			parent.append(text);
			const height = text.getBoundingClientRect().height;
			parent.removeChild(text);
			text.remove();
			return height;
		}

		/**
		 * Returns the given natural dimension of an image, using the built in naturalWidth/Height property if available
		 *
		 * @param	{element} 	elem	 	Element to test
		 * @param 	{string} 	type 		Width or Height; dimension to return
		 * @returns {number}
		 */
		function _getNatural(elem, type) {
			const ret = elem[0][ 'natural' + type ];
			if (typeof ret === 'number') {
				return ret;
			}

			return 0;
		}

		return {
			getElemPosition,
			getElemDims,
			positionElem,
			hasFixedParents,
			naturalWidth,
			naturalHeight,
			lineHeight,
			getElemRectAndStyle,
			startCaching,
			endCaching,
		};
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.responsive.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.responsive.js - A library for managing breakpoints in a responsive layout, 
 * and setting callbacks to be executed when breakpoints are hit.
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.responsive', function (options) {

		options = $.extend({
			breakpoints: {
				980: 'desktop',
				768: 'tablet',
				0: 'phone'
			}
		});

		var self = this,
			previousBreakpoint = [],
			currentBreakpoint = [],
			breakpointsBySize = {},
			breakpointsByKey = {},
			callbacks = {};

		// --------------------------------------------------------------------
		// PUBLIC METHODS
		
		/**
		 * Returns boolean denoting whether the supplied key name is
		 * the current size
		 *
		 * @param 	{mixed} 	toCheck 	The breakpoint value or key name to check
		 * @returns {boolean}
		 */
		var currentIs = function (toCheck) {

			if( _.isNumber( toCheck ) ){
				return currentBreakpoint[0] == toCheck;
			} else {
				return toCheck && currentBreakpoint[1] == toCheck;
			}
		},

		/**
		 * Returns the key name of the current size (e.g. 'phone')
		 *
		 * @returns 	{string}
		 */
		getCurrentKey = function () {
			return currentBreakpoint[1];
		},

		/**
		 * Returns all breakpoints, as an object
		 *
		 * @returns 	{object}
		 */
		getAllBreakpoints = function () {
			return breakpointsBySize;
		},

		/**
		 * Adds a breakpoint value
		 *
		 * @param 	{number}	breakpoint 	The size in px being registered
		 * @param 	{string}	name		An alphanumeric name to identify this breakpoint
		 * @returns {void}
		 */
		addBreakpoint = function (breakpoint, name) {
			breakpointsBySize[ breakpoint ] = name;
			breakpointsByKey[ name ] = breakpoint;

			// Add an empty array to the callback stack for later
			callbacks[ breakpoint ] = { enter: [], exit: [] };
		},

		/**
		 * Adds a callback to the queue for the specified breakpoint
		 * 
		 * @param 	breakpoint 		The breakpoint at which the callback will fire
		 * @param 	type 			Type of callback to add (enter or exit)
		 * @param 	callback 		The callback to be fired
		 * @returns {mixed} 		Void, or false if invalid callback is provided
		 */
		addCallback = function (breakpoint, type, callback) {

			if( !breakpointsBySize[ breakpoint ] || ( type != 'enter' && type != 'exit' ) ){
				return false;
			}

			callbacks[ breakpoint ][ type ].push( callback );
		},

		/**
		 * Fetches the current relevant breakpoint, and determines whether
		 * it has changed from the previous firing. If so, calls the callbacks
		 *
		 * @returns 	{void}
		 */
		checkForBreakpointChange = function () {
			
			var newBreak = getCurrentBoundary();

			// Different to the last round?
			if( newBreak != currentBreakpoint[0] ){

				// Execute any callbacks
				executeCallbacks( newBreak, currentBreakpoint[0] );

				// Update our previous/current breakpoint records
				previousBreakpoint = currentBreakpoint;
				currentBreakpoint = [ newBreak, breakpointsBySize[ newBreak ] ];

				// Fire event
				$( document ).trigger('breakpointChange', {
					curBreakSize: newBreak,
					curBreakName: breakpointsBySize[ newBreak ]
				});
			}
		},

		/**
		 * Runs the enter/exit callbacks for given breakpoints
		 *
		 * @param 	enterPoint	The breakpoint for the 'enter' callback
		 * @param 	exitPoint	The breakpoint for the 'exit' callback
		 *
		 * @returns {void}
		 */
		executeCallbacks = function (enterPoint, exitPoint) {

			if( !_.isUndefined( enterPoint ) && !_.isUndefined( callbacks[ enterPoint ] ) &&
				 !_.isUndefined( callbacks[ enterPoint ]['enter'] ) && callbacks[ enterPoint ]['enter'].length ){
				$.each( callbacks[ enterPoint ]['enter'], function (idx, thisCallback) {
					thisCallback();
				});
			}

			if( !_.isUndefined( exitPoint ) && !_.isUndefined( callbacks[ exitPoint ] ) &&
				 !_.isUndefined( callbacks[ exitPoint ]['exit'] ) && callbacks[ exitPoint ]['exit'].length ){
				$.each( callbacks[ exitPoint ]['exit'], function (idx, thisCallback) {
					thisCallback();
				});
			}
		},

		/**
		 * Works out the most relevant breakpoint based on window width
		 *
		 * @returns 	{number} 	Breakpoint size in px
		 */
		getCurrentBoundary = function () {

			var curWidth = window.innerWidth || $( window ).width();
			var curBreak;

			// Iterate to find which breakpoints are within range,
			// given the current window width
			var possibleSizes = _.filter( breakpointsByKey, function (num) { 
				return curWidth >= num; 
			});

			// If we have any breakpoints in range, get the biggest,
			// otherwise we'll get the smallest possible size
			if( possibleSizes.length ){
				curBreak = _.max( possibleSizes, function (num) { 
					return parseInt( num ); 
				});
			} else {
				curBreak = _.min( breakpointsByKey, function (num) {
					return parseInt( num );
				});
			}

			return curBreak;
		},

		// --------------------------------------------------------------------
		// PRIVATE METHODS

		/**
		 * Initialization method; imports default breakpoints and set up
		 * window.resize event
		 *
		 * @returns 	{void}
		 */
		init = function (){

			// Add our default breakpoints to start with
			$.each( options.breakpoints, function (size, name) {
				addBreakpoint(size, name);
			});

			$( window ).on( 'resize', windowResize );

			checkForBreakpointChange();
		},

		/**
		 * Event handler fired when window resizes
		 *
		 * @returns 	{void}
		 */
		windowResize = function () {
			checkForBreakpointChange();
		},

		enabled = function () {
			return true;
		};

		// Initialize this module
		init();

		// Expose public methods
		return {
			addBreakpoint: addBreakpoint,
			addCallback: addCallback,
			currentIs: currentIs,
			getCurrentKey: getCurrentKey,
			getAllBreakpoints: getAllBreakpoints,
			enabled: enabled
		}
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.search.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.search - an easy api to register values that should be correlated to search terms
 *
 * Author: Matt Finger
 */


;( function($, _) {
    "use strict";

    ips.createModule('ips.utils.search', function () {
        const nonHumanReadableRegex = /[^\p{L}\p{N}\p{Emoji_Presentation}]/u
        class TrieNode {
            constructor() {
                this.size = 0
                this.children = new Map();
                this.values = new Set();
            }

            /**
             * Fix a term so it's "normal"
             * @param term
             * @return {string}
             */
            static fixTerm(term) {
                return stripAccents(
                    term
                        .toLowerCase()
                        .replaceAll(new RegExp(nonHumanReadableRegex, nonHumanReadableRegex.flags + 'g'), '')
                )
            }

            /**
             * Search for a given term
             *
             * @param {string}    term
             *
             * @return {Set<any>}
             */
            search(term) {
                term = TrieNode.fixTerm(term)
                if (term === '') {
                    const ret = new Set(this.values);
                    for (const child of this.children.values()) {
                        child.search('').forEach(item => ret.add(item))
                    }

                    return ret;
                }

                const firstChar = term.substring(0, 1), childTerm = term.substring(1)
                if (this.children.has(firstChar)) {
                    return this.children.get(firstChar).search(childTerm)
                }

                return new Set();
            }

            /**
             * Add a term with associated values. Returns the number of terms actually added
             *
             * @param {string}    term
             * @param {array} values
             *
             * @return {number}
             */
            addTerm(term, values = []) {
                term = TrieNode.fixTerm(term)
                if (term === '') {
                    const startSize = this.values.size
                    for (const value of values) {
                        this.values.add(value)
                    }
                    const delta = this.values.size - startSize;
                    this.size += delta;
                    return delta;
                }

                const firstChar = term.substring(0, 1)
                const childTerm = term.substring(1)
                if (!this.children.has(firstChar)) {
                    this.children.set(firstChar, new TrieNode())
                }

                const delta = this.children.get(firstChar).addTerm(childTerm, values)
                this.size += delta;
                return delta;
            }
        }

        /**
         * @type {Map<*, TrieNode>}
         */
        const staticCache = new Map();

        /**
         * Remove accents from a string
         * @param {string}  str
         * @return {string}
         */
        function stripAccents(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        return {
            /**
             * Add a term to a tree given the tree identifier
             *
             * @param {any}     tree        The tree identifier. This can be anything but try not to use HTML nodes or things that could get prevented from garbage collection (triggering a memory leak). If you don't know what that means, probably stick to just a string :)
             * @param {string}  term
             * @param {*[]}     values
             *
             * @return {number}
             */
            addTerm(tree, term, values=[]) {
                if (!staticCache.has(tree)) {
                    staticCache.set(tree, new TrieNode())
                }
                const trie = staticCache.get(tree)

                let added = 0;
                const components = term.toLowerCase().split(nonHumanReadableRegex);
                for (let i = 0; i < components.length; i++) {
                    const compoundTerm = components.slice(i).join('')
                    added += trie.addTerm(compoundTerm, values);
                }
                return added;
            },

            /**
             * Get any registered values for a given search term
             *
             * @param {any}         tree    an identifier for the tree
             * @param {string}      term    the search term
             *
             * @return {Set<*>}
             */
            search(tree, term) {
                if (staticCache.has(tree)) {
                    return staticCache.get(tree).search(term)
                }

                return new Set();
            },

            /**
             * Get the size of results in the tree of the given type
             * @param tree
             * @return {number}
             */
            getSize(tree) {
                if (staticCache.has(tree)) {
                    return staticCache.get(tree).size
                }
                return 0;
            },

            /**
             * Fix the term so that it is what the tree actually stores
             *
             * @param {string}  term
             *
             * @return {string}
             */
            fixTerm(term) {
                return TrieNode.fixTerm(term)
            },

            stripAccents
        }
    })

}(jQuery, _))]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.selection.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.selection.js - A module for working with text selection
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.selection', function () {

		/**
		 * Returns the text selected, ensuring it's fully within the provided ancestor
		 *
		 * @param 	{element} 	ancestor 	Ancestor element
		 * @returns {void}
		 */
		var getSelectedText = function (querySelector, container) {
			var text = '';
			var container = container.get(0);
			var selection = getSelection();

			if( selection.isCollapsed ){
				return '';
			}

			if( selection.rangeCount > 0 ){
				var range = selection.getRangeAt(0);
				var clonedSelection = range.cloneContents().querySelector( querySelector );

				// This loop checks that the selection is within the ancestor, so that we don't
				// show Quote This accidentally when another comment is selected.
				for (var i = 0; i < selection.rangeCount; ++i) {
					if( !_isChild( selection.getRangeAt(i).commonAncestorContainer, container ) ){
						return '';
					}
				}

				if( clonedSelection ){
					clonedSelection.querySelectorAll(`.ipsCode[data-ips-text-highlighted="yes"]`).forEach(element => {
						const text = element.innerText;
						element.innerHTML = ''
						element.innerText = text;
					})
					text = clonedSelection.innerHTML;
				} else {
					clonedSelection = range.cloneContents();
					var startNode = selection.getRangeAt(0).startContainer.parentNode;

					if( _isChild( startNode, container ) ) {
						var div = document.createElement('div');
						div.appendChild( clonedSelection );

						clonedSelection.querySelectorAll(`.ipsCode[data-ips-text-highlighted="yes"]`).forEach(element => {
							const text = element.innerText;
							element.innerHTML = ''
							element.innerText = text;
						})
						text = div.innerHTML;
					}
				}
					
				return text;
			} else if ( document.selection ){
				return document.selection.createRange().htmlText;
			}

			return '';
		};

		var getCommonAncestor = function () {
			var selection = getSelection();

			if( selection.isCollapsed ){
				return false;
			}

			var range = selection.getRangeAt(0);
			return $( range.commonAncestorContainer );
		};

		/**
		 * Get the Range of the selected text
		 *
		 * @param 	{element} 	container 	The container element
		 * @returns {object} Containing `type` (outside or inside) determining whether selection extends beyond our container, and `range`, the Range itself
		 */
		var getRange = function (container) {
			var selection = getSelection();

			if( selection.isCollapsed ){
				return false;
			}

			var range = selection.getRangeAt(0);
			var ancestor = $( range.commonAncestorContainer );

			// Figure out if the selection goes beyond our ancestor
			if( ancestor != container && !$( range.commonAncestorContainer ).closest( container ).length ){
				return {
					type: 'outside',
					range: range
				};
			}

			return {
				type: 'inside',
				range: range
			};
		};

		/**
		 * Returns the correct selection
		 *
		 * @returns {object}
		 */
		var getSelection = function () {
			return ( window.getSelection ) ? window.getSelection() : document.getSelection();
		};

		/**
		 * Returns boolean indicating whether child belongs to parent
		 *
		 * @param 	{element} 	child 	Child element
		 * @param 	{element} 	parent 	Parent element
		 * @returns {void}
		 */
		var _isChild = function (child, parent) {
			if(child === parent){
				return true;	
			} 
			
			var current = child;
			
			while (current) {
				if(current === parent){
					return true;	
				} 
				current = current.parentNode;
			}
			
			return false;
		};
		
		return {
			getSelectedText: getSelectedText,
			getSelection: getSelection,
			getRange: getRange,
			getCommonAncestor: getCommonAncestor
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.serviceWorker.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.serviceWorker.js - A module for working with service workers
 *
 * Author: Rikki Tissier
 */

(function ($, _, undefined) {
	"use strict";

	ips.createModule("ips.utils.serviceWorker", function () {
		const SERVICE_WORKER_URL = ips.getSetting("baseURL") + "index.php?app=core&module=system&controller=serviceworker&v=" + ips.getSetting("jsAntiCache");
		const supported = "serviceWorker" in navigator;

		/**
		 * Registers the service worker. When the user log in state changes, the URL of the SW changes
		 * which forces the browser to accept it as an update to the running SW. This means we can inspect the URL
		 * inside the SW and using the loggedIn param determine if the user is logged in or not.
		 *
		 * @returns {Promise}
		 */
		const registerServiceWorker = (type) => {
			return navigator.serviceWorker
				.register(`${SERVICE_WORKER_URL}&type=${type}`)
				.then((registration) => {
					// Registration was successful
					Debug.log("ServiceWorker registration successful with scope: ", registration.scope);
					return registration;
				})
				.catch((err) => {
					// registration failed :(
					Debug.log("ServiceWorker registration failed: ", err);
				});
		};

		/**
		 * Gets the service worker registration
		 *
		 * @returns {Promise}
		 */
		const getRegistration = () => {
			return navigator.serviceWorker.ready;
		};

		return {
			registerServiceWorker,
			supported,
			getRegistration,
		};
	});
})(jQuery, _);
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.sockets.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.sockets.js - A module for working with sockets
 *
 * Author: Rikki Tissier
 */

 (function ($, _) {
	"use strict";

	ips.createModule("ips.utils.sockets", function () {
		let socketIo;
		let pingInterval;
		let refreshToken;
		let refreshInterval;
		let refreshTokenUsed = false;
		let connected = false;

		function init() {
			if( !enabled() ){
				return;
			}

			ips.loader.get( [`${ips.getSetting('socketUrl')}/socket.io/socket.io.min.js`] ).then( function () {
				initializeSocketIo();
			});
		}

		/**
		 *
		 * Is realtime interaction enabled?
		 */
		function enabled() {
			let res = !!(ips.getSetting('memberID') && ips.getSetting('socketEnabled') && ips.getSetting('page_token'));
			return res;
		}

		/**
		 * Set up socket io connection and event handlers
		 */
		function initializeSocketIo() {
			if (connected) {
				return;
			}
			socketIo = io(`${ips.getSetting('socketUrl')}/site-${ips.getSetting('siteId')}`, {
				transports: ['websocket'],
				forceNew: true,
				multiplex: false,
				query: {
					token: ips.getSetting('page_token'),
					ipsVersion: "v5"
				}
			});

		
			socketIo.on('connect', _eventConnect(socketIo));
			socketIo.on('message', _eventMessage);
			socketIo.on('ping', function () {
				socketIo.emit('pong');
			});
			socketIo.on('ping_interval', interval => {
				interval = Number(interval);
				if (interval && Number.isInteger(interval) && interval > 0) {
					clearInterval(pingInterval);
					pingInterval = setInterval(() => {
						socketIo.emit('ping');
					}, interval * 0.98); // we reduce by a factor of 2% for latency
				}
			})
			socketIo.on('connect_error', _eventConnectError);
			socketIo.on('disconnect', _eventDisconnect);

			socketIo.on('refresh_token', token => {
				// we'll do some LIGHT checking to make sure this is a JWT
				let isJwt = true;
				if (typeof token !== "string") {
					isJwt = false;
				} else {
					let components = token.split('.');
					if (components.length < 3) {
						isJwt = false;
					} else {
						for (let component of components.slice(0,2)) {
							if (typeof JSON.parse(atob(component)) !== 'object') {
								isJwt = false;
								break;
							}
						}
					}
				}

				if (isJwt) {
					refreshToken = token;
					refreshTokenUsed = false;
					Debug.log(`Got a refresh token from Node Services`)
				} else {
					Debug.warn(`Got a refresh token that is not a valid JWT from Node Services`)
				}
			})
		}
		function useRefreshToken() {
			// keep trying to get an access token for 10 minutes
			let attempts = 120;
			if (refreshInterval) {
				clearInterval(refreshInterval);
			}
			refreshInterval = setInterval(() => {
				if (!attempts-- || refreshTokenUsed || typeof refreshToken !== 'string' || typeof ips.getSetting('page_token') !== 'string' || connected) {
					clearInterval(refreshInterval);
					refreshInterval = undefined;
				}

				if (!refreshToken || typeof refreshToken !== 'string') {
					return
				}

				ips.getAjax()(ips.getSetting('baseURL') + '/?app=core&module=system&controller=ajax&do=refreshRealtimeToken', {
					data: {
						page_token: ips.getSetting('page_token'),
						refresh_token: refreshToken
					},
					method: "POST"
				})
					.done( function(response) {
						if (response.page_token) {
							refreshTokenUsed = true;
							ips.setSetting('page_token', response.page_token);
							socketIo.off();
							socketIo.disconnect();
							refreshToken = undefined;
							initializeSocketIo();
						}
					} ).fail(() => Debug.log('Failed to exchange IPS Node Services\' refresh token for access token'));

			}, 5000);
		}
		
		/**
		 * Emit an event to the socket server
		 * Note: events are whitelisted on the server
		 */
		function send(event, data = {}, attempts = 50) {
			if( !enabled() || (!socketIo && !(attempts > 1)) ){
				return;
			} else if (!socketIo) {
				// we'll try every second over the next minute in case it's still trying to connect
				setTimeout(() => send(event, data, attempts - 1), 1000);
			} else {
				socketIo.emit(event, data);
			}
		}

		/**
		 * Event handlers
		 */

		/**
		 * Handle a 'message' event. This handler is a simple broker that re-emits the event
		 * on the document for interested controllers to listen to
		 */
		function _eventMessage(data = {}) {
			if( typeof data !== 'object' || data.event === undefined ){
				Debug.log('Invalid message data');
				return;
			}

			const { event, type = null, ...rest } = data;
			let eventType = '';

			if( type !== null ){
				eventType = `:${type}`;
			}

			$(document).trigger(`socket.${event}${eventType}`, rest);
		}


		const _eventConnect = socket => function() {
			connected = true;
			clearInterval(refreshInterval);
			refreshInterval = null;
			Debug.log("Connected to socket server");
			$(document).trigger('socket.connected');
			window.ips.socket = socket;
		}


		function _eventConnectError() {
			connected = false;
			Debug.log("Error connecting to socket server");
			$(document).trigger('socket.error');

			// let's try refreshing the access token
			useRefreshToken()
		}

		function _eventDisconnect() {
			connected = false;
			Debug.log("Disconnected from socket server");
			$(document).trigger('socket.disconnected');
			if (!refreshInterval) {
				useRefreshToken()
			}
		}

		return {
			init,
			enabled,
			send,
			connected() {
				return connected;
			}
		};
	});
})(jQuery, _);
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.time.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.time.js - A module for working with time/date
 *
 * Author: Mark Wade
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.time', function () {

		var _supportsLocale = null;

		/**
		 * Convert Unix Timestamp to human-readable (relative where appropriate) string
		 *
		 * @param		{number} 		timestamp 	Unix Timestamp
		 * @returns		{string}
		 */
		var readable = function (timestamp) {
			var date = new Date();
			var time = date.getTime() / 1000; // Timestamp in seconds
			var dst = 0;
			var now = time + dst;
			var elapsed = now - timestamp;

			if( ips.getSetting('relativeDates') ) {
				if ( elapsed < 60 ) {
					 return ips.getString('time_just_now');   
				} else if ( elapsed < 3600 ) {
					return ips.pluralize( ips.getString( 'time_minutes_ago' ), Math.floor( elapsed / 60 ) );  
				} else if ( elapsed < 5400 ) {
					return ips.getString( 'time_1_hour_ago' );
				} else if ( elapsed < 86400 ) {
					return ips.pluralize( ips.getString( 'time_hours_ago' ), Math.floor( elapsed / 3600 ) );   
				}
			}

			// Get an appropriate format
			var dateObj = new Date( timestamp * 1000 );
			var format = localeTimeFormat( $('html').attr('lang') );
			var time = formatTime( dateObj, format );

			// Format the datetime string
			var timeParts = ips.getString('time_at')
				? [ localeDateString( dateObj ), ips.getString('time_at') ]
				: [ localeDateString( dateObj ) ];
			timeParts.push(time);

			return ips.getString( 'time_other', { time: timeParts.join(' ') } );
		},

		/**
		 * Get date object from input field - abstracted to handle polyfills
		 *
		 * @param 		{object} 	input 	Input element
		 * @returns 	{object}	Date object
		 */
		getDateFromInput = function(input) {
			// jQuery UI Polyfill needs to be changed into the correct format
			if( !ips.utils.time.supportsHTMLDate() ) {
				// If it has been initiated, we can use the getDate method
				try {
					var thisDate = null;

					if( input.hasClass('hasDatepicker') ){
						thisDate = input.datepicker('getDate');
						Debug.log( 'hasDatePicker: ' + thisDate.toString() + '(' + thisDate.getTime() + ')' );
						//thisDate = new Date( thisDate.getUTCFullYear(), thisDate.getUTCMonth(), thisDate.getUTCDate() );
					} else {
						thisDate = new Date( input.attr('value') );
						Debug.log( 'no datepicker yet: ' + thisDate.toString()  + '(' + thisDate.getTime() + ')' );
					}

					return thisDate;
				}
				// If it hasn't we can pull the 'value' attribute which can't have been changed yet. Not .val() as that will be in the wrong format
				catch(err) {
					return new Date( input.attr('value') );
				}
			}
			// Actual HTML5 input always returns .val() in the correct YYYY-MM-DD format
			else {
				return new Date( input.val() );
			}
		},

		/**
		 * Removes the timezone from a date object, e.g. 1st Feb 00:00 EST will be turned into 1st Feb 00:00 GMT
		 *
		 * @param 		{object} 	input 	Input element
		 * @returns 	{Date}
		 */
		removeTimezone = function (date) {
			if( ips.utils.time.supportsHTMLDate() ){
				date.setTime( new Date( date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0 ).getTime() );	
			}

			var offset = date.getTimezoneOffset();
			var adjustedOffset = offset * 60000;

			if( offset > 0 ){
				date.setTime( date.getTime() + adjustedOffset );	
			} else {
				date.setTime( date.getTime() - adjustedOffset );
			}

			return date;
		},

		/**
		 * Returns a boolean indicating whether the user is in DST
		 *
		 * @param		{object} 		d 	Date object to test
		 * @returns		{boolean}
		 */
		isDST = function () {
			var today = new Date();		    
			var jan = new Date( today.getFullYear(), 0, 1);
			var jul = new Date( today.getFullYear(), 6, 1);
			var stdOffset = Math.max( jan.getTimezoneOffset(), jul.getTimezoneOffset() );

			return today.getTimezoneOffset() < stdOffset;
		},

		/**
		 * Returns true is the provided object is a valid Date object (containing a valid date)
		 *
		 * @param		{object} 		d 	Date object to test
		 * @returns		{boolean}
		 */
		isValidDateObj = function (d) {
			if( Object.prototype.toString.call( d ) !== "[object Date]" ){
				return false;
			}

			return !isNaN( d.getTime() );
		},

		/**
		 * Returns a current unix timestamp
		 *
		 * @returns		{number}
		 */
		timestamp = function () {
			return Date.now();
		},

		/**
		 * Returns javascript's toLocaleDateString, passing the options object
		 * if the browser supports the parameter
		 *
		 * @param		{date} 		date 		Date object
		 * @param 		{object} 	options		Options object (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString)
		 * @returns		{string}
		 */
		localeDateString = function (date, options) {
			if( !_.isBoolean( _supportsLocale ) ){
				_supportsLocale = _checkLocaleSupport();
			}

			if( _supportsLocale && _.isObject( options ) && $('html').attr('lang') ){
				return date.toLocaleDateString( $('html').attr('lang'), options );
			}
			else if( _supportsLocale && $('html').attr('lang') ){
				return date.toLocaleDateString( $('html').attr('lang') );
			} else {
				// UAs that don't support the options object will show the date in the system timezone, which means a midnight time will
				// show on the wrong day if you aren't UTC. To get around that, we'll work out the number of hours offset in the current
				// timezone, and adjust our date based on that to normalize it.
				//----
				// This caused all sorts of pain, so it has been commented out. Instead, methods should call ips.utils.time.removeTimezone
				// on date objects and then this method.
				/*var currentTimeZoneOffsetInHours = new Date().getTimezoneOffset() / 60;
				if ( currentTimeZoneOffsetInHours ) {
					date.setUTCHours( currentTimeZoneOffsetInHours );
				}*/
				//----
				return date.toLocaleDateString();
			}
		},

		/**
		 * Tests whether the browser supports native date pickers
		 *
		 * @returns		{boolean}
		 */
		supportsHTMLDate = function () {
			var i = document.createElement('input');
			i.setAttribute( 'type', 'date' );

			return i.type !== 'text';
		},

		/**
		 * Formats the given date object's time using the given locale format
		 *
		 * @param 		{object} 	Date object to format
		 * @param 		{object} 	Formatting object for a locale returned from localeTimeFormat()
		 * @returns		{string}	Locale-formatted time string
		 */
		formatTime = function (dateObj, localeFormat) {
			if( !_.isDate( dateObj ) ){
				dateObj = timestamp();
			}

			var formatters = {
				/* Day */
				"a": function(d) { // An abbreviated textual representation of the day
					return ips.getString( 'day_' + d.getDay() + '_short' );
				},
				"A": function(d) { // A full textual representation of the day
					return ips.getString( 'day_' + d.getDay() );
				},
				"d": function (d) { // Two-digit day of the month (with leading zeros)
					var day = d.getDate().toString();
					return ( ( day.length === 1 ) ? '0' : '' ) + day;
				},
				"e": function (d) { // Day of the month, with a space preceding single digits
					var day = d.getDate().toString();
					return ( ( day.length === 1 ) ? ' ' : '' ) + day;
				},
				"j": function (d) { // Day of the year, 3 digits with leading zeros
					var day = d.getDate();
					var month = d.getMonth();
					if ( month > 0 ) { // Jan
						day += 31;
					}
					if ( month > 1 ) { // Feb
						day += 28;
						if ( d.getFullYear() % 4 == 0 ) {
							day += 1;
						}
					}
					if ( month > 2 ) { // Mar
						day += 31;
					}
					if ( month > 3 ) { // Apr
						day += 30;
					}
					if ( month > 4 ) { // May
						day += 31;
					}
					if ( month > 5 ) { // Jun
						day += 30;
					}
					if ( month > 6 ) { // Jul
						day += 31;
					}
					if ( month > 7 ) { // Aug
						day += 31;
					}
					if ( month > 8 ) { // Sep
						day += 30;
					}
					if ( month > 9 ) { // Oct
						day += 31;
					}
					if ( month > 10 ) { // Nov
						day += 30;
					}
					if ( month > 11 ) { // Dec
						day += 31;
					}
					return day.toString().padStart( 3, '0' );
				},
				"u": function (d) { // ISO-8601 numeric representation of the day of the week
					return d.getDay() + 1;
				},
				"w": function (d) { // Numeric representation of the day of the week
					return d.getDay();
				},
				
				/* Week */
				"U": function (d) { // Week number of the given year, starting with the first Sunday as the first week
					var firstSundayDate = 1;
					var firstSunday = new Date( d.getFullYear(), 0, firstSundayDate, 0, 0, 0, 0 );
				    
					while ( firstSunday.getDay() != 0 ) {
				        firstSundayDate += 1;
				        firstSunday = new Date( d.getFullYear(), 0, firstSundayDate, 0, 0, 0, 0 );
					}
					
					var now = d.getTime() / 1000;
					var weekNumber = 0;
					var timestamp = firstSunday.getTime() / 1000;
					
					while ( timestamp < now ) {
						weekNumber++;
						timestamp += 604800;
					}
					
					weekNumber = weekNumber.toString();
					return ( ( weekNumber.length === 1 ) ? '0' : '' ) + weekNumber;
				},
				"V": function (d) { // ISO-8601:1988 week number of the given year, starting with the first week of the year with at least 4 weekdays, with Monday being the start of the week
					var firstApplicableDate = 1;
					var firstApplicable = new Date( d.getFullYear(), 0, firstApplicableDate, 0, 0, 0, 0 );
					
					while( [ 2, 3, 4, 5 ].indexOf( firstApplicable.getDay() ) == -1 ) {
						firstApplicableDate += 1;
						firstApplicable = new Date( d.getFullYear(), 0, firstApplicableDate, 0, 0, 0, 0 );
					}
					
					var now = d.getTime() / 1000;
					var weekNumber = 0;
					var timestamp = firstApplicable.getTime() / 1000;
					
					while ( timestamp < now ) {
						weekNumber++;
						timestamp += 604800;
					}
					
					weekNumber = weekNumber.toString();
					return ( ( weekNumber.length === 1 ) ? '0' : '' ) + weekNumber;
				},
				"W": function (d) { // A numeric representation of the week of the year, starting with the first Monday as the first week
					var firstMondayDate = 1;
					var firstMonday = new Date( d.getFullYear(), 0, firstMondayDate, 0, 0, 0, 0 );
				    
					while ( firstMonday.getDay() != 1 ) {
				        firstMondayDate += 1;
				        firstMonday = new Date( d.getFullYear(), 0, firstMondayDate, 0, 0, 0, 0 );
					}
					
					var now = d.getTime() / 1000;
					var weekNumber = 0;
					var timestamp = firstMonday.getTime() / 1000;
					
					while ( timestamp < now ) {
						weekNumber++;
						timestamp += 604800;
					}
					
					return weekNumber;
				},
				
				/* Month */
				"b": function(d) { // Abbreviated month name, based on the locale
					return ips.getString( 'month_' + d.getMonth() + '_short' );
				},
				"B": function(d) { // Full month name, based on the locale
					return ips.getString( 'month_' + d.getMonth() );
				},
				// OB is same as B, but is used occasionally due to oddities in certain locales
				"OB": function(d) { // Full month name, based on the locale
					return ips.getString( 'month_' + d.getMonth() );
				},
				"h": function(d) { // Abbreviated month name, based on the locale (an alias of %b)
					return ips.getString( 'month_' + d.getMonth() + '_short' );
				},
				"m": function(d) { // Two digit representation of the month
					var month = d.getMonth() + 1;
					var realMonth = month.toString();
					return ( ( realMonth.length === 1 ) ? '0' : '' ) + realMonth;
				},
				
				/* Year */
				"C": function(d) { // Two digit representation of the century (year divided by 100, truncated to an integer)
					return parseInt( ( d.getFullYear() / 100 ).toString().substr( 0, 2 ) );
				},
				"g": function(d) { // Two digit representation of the year going by ISO-8601:1988 standards (see %V)
					var year = d.getFullYear();
					if ( d.getMonth() == 0 && d.getDate() < 3 && d.getDay() < 2 ) {
						year--;
					}
					return parseInt( year.toString().substr( 0, 2 ) );
				},
				"G": function(d) { // The full four-digit version of %g
					var year = d.getFullYear();
					if ( d.getMonth() == 0 && d.getDate() < 3 && d.getDay() < 2 ) {
						year--;
					}
					return year;
				},
				"y": function(d) { // Two digit representation of the year
					return parseInt( d.getFullYear().toString().substr( 0, 2 ) );
				},
				"Y": function(d) { // Four digit representation for the year
					return d.getFullYear();
				},
				
				/* Time */
				"H": function (d) { // Two digit representation of the hour in 24-hour format
					var hrs = d.getHours().toString();
					return ( ( hrs.length === 1 ) ? '0' : '' ) + hrs;
				},
				"k": function (d) { // Hour in 24-hour format, with a space preceding single digits
					var hrs = d.getHours();
					return ( ( hrs.length === 1 ) ? ' ' : '' ) + hrs;
				},
				"I": function (d) { // Two digit representation of the hour in 12-hour format
					var hrs = d.getHours();
					hrs = ( hrs > 12 ) ? hrs - 12 : hrs;

					if( hrs == 0 )
					{
						hrs = 12;
					}

					return ( ( hrs.length === 1 ) ? '0' : '' ) + hrs;
				},
				"l": function (d) { // Hour in 12-hour format, with a space preceding single digits
					var hrs = d.getHours();
					hrs = ( hrs > 12 ) ? hrs - 12 : hrs;

					if( hrs == 0 )
					{
						hrs = 12;
					}

					return ( ( hrs.length === 1 ) ? ' ' : '' ) + hrs;
				},
				"M": function (d) { // Two digit representation of the min
					var mins = d.getMinutes().toString();
					return ( ( mins.length === 1 ) ? '0' : '' ) + mins;
				},
				"N": function (d) { // Single digit representation of the min
					return d.getMinutes();
				},
				"p": function (d) { // UPPER-CASE 'AM' or 'PM' based on the given time
					var hrs = d.getHours();
					if( !_.isFunction( localeFormat.meridiem ) ){
						return '';
					}

					return localeFormat.meridiem( hrs, false );
				},
				"P": function (d) { // lower-case 'am' or 'pm' based on the given time
					var hrs = d.getHours();
					if( !_.isFunction( localeFormat.meridiem ) ){
						return '';
					}

					return localeFormat.meridiem( hrs, true );
				},
				"r": function(d) { // Same as "%I:%M:%S %p"
					var hrs = d.getHours();
					hrs = ( hrs >= 12 ) ? hrs - 12 : hrs;
					var mins = d.getMinutes().toString();
					var seconds = d.getSeconds().toString();
					
					return ( ( hrs.length === 1 ) ? '0' : '' ) + hrs + ':' + ( ( mins.length === 1 ) ? '0' : '' ) + mins + ':' + ( ( seconds.length === 1 ) ? '0' : '' ) + seconds;
				},
				"R": function(d) { // Same as "%H:%M"
					var hrs = d.getHours().toString();
					var mins = d.getMinutes().toString();
					return ( ( hrs.length === 1 ) ? '0' : '' ) + hrs + ':' + ( ( mins.length === 1 ) ? '0' : '' ) + mins;
				},
				"S": function(d) { // Two digit representation of the second
					var seconds = d.getSeconds().toString();
					return ( ( seconds.length === 1 ) ? '0' : '' ) + seconds;
				},
				"T": function(d) { // Same as "%H:%M:S"
					var hrs = d.getHours().toString();
					var mins = d.getMinutes().toString();
					var seconds = d.getSeconds().toString();
					return ( ( hrs.length === 1 ) ? '0' : '' ) + hrs + ':' + ( ( mins.length === 1 ) ? '0' : '' ) + mins + ':' + ( ( seconds.length === 1 ) ? '0' : '' ) + seconds;
				},
				"X": function(d) { // Preferred time representation based on locale, without the date
					return d.toLocaleTimeString();
				},
				"z": function(d) { // The time zone offset
					var matches = d.toString().match( /GMT([+\-]\d{4}) \((.+)\)$/ );
					return matches[1];
				},
				"Z": function(d) { // The time zone abbreviation
					var matches = d.toString().match( /GMT([+\-]\d{4}) \((.+)\)$/ );
					return matches[2];
				},

				/* Time and Date Stamps */
				"c": function(d) { // Preferred date and time stamp based on locale
					var hrs = d.getHours().toString();
					var mins = d.getMinutes().toString();
					var seconds = d.getSeconds().toString();
					return ips.getString( 'day_' + d.getMonth() + '_short' ) + ' ' + ips.getString( 'month_' + d.getMonth() + '_short' ) + ' ' + d.getDate().toString() + ' ' + ( ( hrs.length === 1 ) ? '0' : '' ) + hrs + ':' + ( ( mins.length === 1 ) ? '0' : '' ) + mins + ':' + ( ( seconds.length === 1 ) ? '0' : '' ) + seconds + ' ' + d.getFullYear().toString();
				},
				"D": function(d) { // Same as "%m/%d/%y"
					var month = d.getMonth().toString();
					var day = d.getDate().toString();
					return ( ( month.length === 1 ) ? '0' : '' ) + month + '/' + ( ( day.length === 1 ) ? '0' : '' ) + day + '/' + parseInt( d.getFullYear().toString().substr( 0, 2 ) ).toString();
				},
				"F": function(d) { // Same as "%Y-%m-%d" (commonly used in database datestamps)
					var month = d.getMonth().toString();
					var day = d.getDate().toString();
					return d.getFullYear().toString() + '-' + ( ( month.length === 1 ) ? '0' : '' ) + month + '-' + ( ( day.length === 1 ) ? '0' : '' ) + day;
				},
				"s": function(d) { // Unix Epoch Time timestamp
					return parseInt( d.getTime() / 1000 );
				},
				"x": function(d) { // Preferred date representation based on locale, without the time
					return d.toLocaleDateString(0);
				},
				
				/* Miscellaneous */
				"n": function (d) { // A newline character ("\n")
					return "\n";
				},
				"t": function (d) { // A Tab character ("\t")
					return "\t";
				},
				"%": function (d) { // A literal percentage character ("%")
					return '%';
				}
			};
			
			return localeFormat.format.replace(/%([aAdejuwUVWbBhmCgGyYHkIlMNPprRSTXzZcDFsxnt%]|OB)/g, function (match0, match1) {
				if( formatters[ match1 ] ){
					return formatters[ match1 ]( dateObj );
				}
			});
		},

		/**
		 * Returns the formatting information for the given locale (defaults to English)
		 *
		 * @param 		{string} 	ISO 6391 code (e.g. en-gb)
		 * @returns		{object}	Formatting object containing 'format' and sometimes 'meridiem' keys
		 */
		localeTimeFormat = function (locale) {
			var locales = _getLocaleTimeFormat();
			var language = locale.split('-');

			if( !_.isUndefined( locales[ locale.toLowerCase() ] ) ){
				// Check the full locale first (e.g. en-US and en-GB dialects are different )
				return locales[ locale.toLowerCase() ];
			} else if( !_.isUndefined( locales[ language[0].toLowerCase() ] ) ){
				// Try the main language next
				return locales[ language[0].toLowerCase() ];
			} else {
				// Default to English
				return locales['en'];
			}
		},

		/**
		 * Tests if the browser supports the options parameter of toLocaleDateString
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString
		 * @returns		{boolean}
		 */
		_checkLocaleSupport = function () {
			try {
				new Date().toLocaleDateString("i");
			} catch (e) {
				return e.name === "RangeError";
			}

			return false;
		},

		/**
		 * Returns time formats for each locale
		 * Data pieced together from what moment.js provides
		 *
		 * @returns		{object}
		 */
		_getLocaleTimeFormat = function () {

			var defaultMeridiem = function (hour, lower) {
				if( hour < 12 ){
					return ( lower ? 'am' : 'AM' );
				} else {
					return ( lower ? 'pm' : 'PM' );
				}
			};

			// %H - Two digit hour in 24hr format (01, 23)
			// %k - Two digit hour in 24hr format (1, 23)
			// %l - Hour in 12hr format (1, 12)
			// %M - Two digit minute (01, 56)
			// %N - Single didget minite (1, 56)
			// %p - Uppercase AM/PM
			// %P - Lowercase am/pm
			return {
				'af': { format: '%H:%M' },
				'ar-ma': { format: '%H:%M' },
				'ar-sa': { format: '%H:%M' },
				'ar-tn': { format: '%H:%M' },
				'ar': { format: '%H:%M' },
				'az': { format: '%H:%M' },
				'be': { format: '%H:%M' },
				'bg': { format: '%k:%M' },
				'bn': { format: '%p %l:%M ', meridiem: function (hour) {
					if (hour < 4) {
						return '';
					} else if (hour < 10) {
						return '';
					} else if (hour < 17) {
						return '';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'bo': { format: '%p %l:%M', meridiem: function (hour) {
					if (hour < 4) {
						return '';
					} else if (hour < 10) {
						return '';
					} else if (hour < 17) {
						return '';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'br': { format: '%le%M %p', meridiem: defaultMeridiem },
				'bs': { format: '%k:%M' },
				'ca': { format: '%k:%M' },
				'cs': { format: '%k:%M' },
				'cv': { format: '%H:%M' },
				'cy': { format: '%H:%M' },
				'da': { format: '%H:%M' },
				'de-at': { format: '%H:%M' },
				'de': { format: '%H:%M' },
				'el': { format: '%l:%M %p', meridiem: function (hour, lower) {
					if (hour > 11) {
						return lower ? '' : '';
					} else {
						return lower ? '' : '';
					}
				} },
				'en-au': { format: '%l:%M %p', meridiem: defaultMeridiem },
				'en-ca': { format: '%l:%M %p', meridiem: defaultMeridiem },
				'en-gb': { format: '%H:%M' },
				'en': { format: '%l:%M %p', meridiem: defaultMeridiem },
				'eo': { format: '%H:%M' },
				'es': { format: '%k:%M' },
				'et': { format: '%k:%M' },
				'eu': { format: '%H:%M' },
				'fa': { format: '%H:%M' },
				'fi': { format: '%H.%M' },
				'fo': { format: '%H:%M' },
				'fr-ca': { format: '%H:%M' },
				'fr': { format: '%H:%M' },
				'fy': { format: '%H:%M' },
				'gl': { format: '%k:%M' },
				'he': { format: '%H:%M' },
				'hi': { format: '%p %l:%M ', meridiem: function (hour) {
					if (hour < 4) {
						return '';
					} else if (hour < 10) {
						return '';
					} else if (hour < 17) {
						return '';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'hr': { format: '%k:%M' },
				'hu': { format: '%k:%M' },
				'hy-am': { format: '%H:%M' },
				'id': { format: '%H.%M' },
				'is': { format: '%k:%M' },
				'it': { format: '%H:%M' },
				'ja': { format: '%p%l%N', meridiem: function (hour) {
					if (hour < 12) {
						return '';
					} else {
						return '';
					}
				} },
				'jv': { format: '%H.%M' },
				'ka': { format: '%l:%M %p', meridiem: defaultMeridiem },
				'km': { format: '%H:%M' },
				'ko': { format: '%p %l %N', meridiem: function (hour) {
					return hour < 12 ? '' : '';
				} },
				'lb': { format: '%k:%M Auer' },
				'lt': { format: '%H:%M' },
				'lv': { format: '%H:%M' },
				'me': { format: '%k:%M' },
				'mk': { format: '%k:%M' },
				'ml': { format: '%p %l:%M -', meridiem: function (hour) {
					if (hour < 4) {
						return '';
					} else if (hour < 12) {
						return '';
					} else if (hour < 17) {
						return ' ';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'mr': { format: '%p %l:%M ', meridiem: function (hour) {
					if (hour < 4) {
						return '';
					} else if (hour < 10) {
						return '';
					} else if (hour < 17) {
						return '';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'ms-my': { format: '%H.%M' },
				'ms': { format: '%H.%M' },
				'my': { format: '%H:%M' },
				'nb': { format: '%k.%M' },
				'ne': { format: '%p %l:%M ', meridiem: function (hour) {
					if (hour < 3) {
						return '';
					} else if (hour < 10) {
						return '';
					} else if (hour < 15) {
						return '';
					} else if (hour < 18) {
						return '';
					} else if (hour < 20) {
						return '';
					} else {
						return '';
					}
				} },
				'nl': { format: '%H:%M' },
				'nn': { format: '%H:%M' },
				'pl': { format: '%H:%M' },
				'pt-br': { format: '%H:%M' },
				'pt': { format: '%H:%M' },
				'ro': { format: '%k:%M' },
				'ru': { format: '%H:%M' },
				'si': { format: '%P %l:%M', meridiem: function (hours, lower) {
					if (hours > 11) {
						return lower ? '..' : ' ';
					} else {
						return lower ? '..' : ' ';
					}
				} },
				'sk': { format: '%k:%M' },
				'sl': { format: '%k:%M' },
				'sq': { format: '%H:%M' },
				'sr-cyrl': { format: '%k:%M' },
				'sr': { format: '%k:%M' },
				'sv': { format: '%H:%M' },
				'ta': { format: '%H:%M' },
				'th': { format: '%k  %N ' },
				'tl-ph': { format: '%H:%M' },
				'tr': { format: '%H:%M' },
				'tzl': { format: '%H.%M' },
				'tzm-latn': { format: '%H:%M' },
				'tzm': { format: '%H:%M' },
				'uk': { format: '%H:%M' },
				'uz': { format: '%H:%M' },
				'vi': { format: '%H:%M' },
				'zh-cn': { format: '%p%l%M', meridiem: defaultMeridiem },
				'zh-tw': { format: '%p%l%M', meridiem: defaultMeridiem }
			}
		};
		
		return {
			readable: readable,
			localeDateString: localeDateString,
			isValidDateObj: isValidDateObj,
			timestamp: timestamp,
			supportsHTMLDate: supportsHTMLDate,
			localeTimeFormat: localeTimeFormat,
			formatTime: formatTime,
			getDateFromInput: getDateFromInput,
			removeTimezone: removeTimezone
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.url.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * @copyright Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.url.js - A module for getting query params from the URL
 */

;( function($, _){
	"use strict";
	
	ips.createModule('ips.utils.url', function () {
		
		/**
		 * Returns the requested parameter from the URL
		 *
		 * @param 	{string} 	name 	Parameter to return
		 * @param 	{string} 	[url] 	Url to parse (uses current url if none specified)
		 * @returns {string|undefined}
		 *
		 * @deprecated
		 * @todo we can replace pretty much all usages of this with (new URL(url||'', location.href)).searchParams.get(name)
		 */
		function getParam(name, url) {
			return parseUri( url || window.location.href ).queryKey[ name ];
		}
		
		/**
		 * Returns the page number from the URL
		 *
		 * @param 	{string} 	param 	Parameter to return
		 * @param 	{string|URL} 	[url] 	Url to parse (uses current url if none specified)
		 *
		 * @returns {number}
		 */
		function getPageNumber(param, url='') {
			const urlObj = url instanceof URL ? url : new URL(url, location.href);
			if (param === 'page') {
				const regex = /\/page\/(\d+)(?:\/|$)/;

				// is the FURL inside the search params component?
				if (urlObj.pathname.includes('/index.php')) {
					/** @todo if someone names a custom page index.php, but isn't using the rewrite URLs option, it will break this logic because index.php is a valid path component. That said, it's probably not worth considering a method to rewrite this. A better solution is likely just checking the first param, and ensuring that the FURL path is always the first component in the search params
					 */
					for (let [key, value] of urlObj.searchParams.entries()) {
						let match;
						if (!value && (match = key.match(regex)) && match) {
							return parseInt(match[1]);
						}
					}
				} else {
					// check this is defined
					let match;
					if ((match = urlObj.pathname.match(regex)) && match) {
						return parseInt(match[1]);
					}
				}
			}
			
			const page = parseInt(urlObj.searchParams.get(param) || "1");
			return Number.isNaN(page) ? 1 : page;
		}

		/**
		 * Moves site.com/forums/topic/123-foo/?page=4&sort=foo to site.com/forums/topic/123-foo/page/4/?sort=foo
		 *
		 * @param 	{string} 	url 		URL
		 * @param 	{string} 	name 		Page param to use
		 * @param 	{string|number} 	number 		Page number
		 *
		 * @returns {string}	new URL as a string
		 */
		function pageParamToPath(url, name, number) {
			const urlObj = new URL(url||"", location.href);
			number = parseInt(number);
			if (isNaN(number)) {
				Debug.warn(`Setting the page param in the pageThe number parameter`);
				number = 1;
			}

			removeParam(name, urlObj);

			// regex to find the /page/<number>/ component in the path. todo \d+ might need to actually be \d*; the v4 code used \d+? but +? only matches if there's at least one; I think the intention was \d*, so /page//rest/of/url would be found just in case
			const regex = new RegExp(`(^.*)(\\/${name.replaceAll('\\', '\\\\')}\\/\\d+)($|\\/.*$)`);
			const pageEnding  = number > 1 ? `/${name}/${number}` : '';
			if (urlObj.pathname.includes("/index.php")) {
				const params = {
					[name]: number > 1 ? number.toString() : null, // just in case no path is in the search string, we set this as a query param directly
				};
				for (const [key,value] of urlObj.searchParams.entries()) {
					if (value) {
						continue;
					}

					if (key.startsWith('/')) {
						delete params[name];
						const newPath = key.match(pageEnding) ? key.replace(regex, `$1${pageEnding}$3`) : key.replace(/\/$/, '') + pageEnding + '/';
						removeParam(key, urlObj);
						const currentSearch = urlObj.search.replace(/^\?/, '')
						urlObj.search = '?' + newPath + (currentSearch ? `&${currentSearch}` : '');
						break;
					}
				}

				if (Object.keys(params).length) {
					urlObj.updateSearchParams({params});
				}
			} else {
				// is it in the path?
				urlObj.pathname = urlObj.pathname.match(regex) ? urlObj.pathname.replace(regex, `$1${pageEnding}$3`) : urlObj.pathname.replace(/\/$/, '') + pageEnding + '/';
			}

			return urlObj.toString();
		}

		/**
		 * Strips the requested parameter from the URL and returns the URL
		 *
		 * @param 	{string} 	name 	Parameters to strip
		 * @param 	{string|URL} 	[url] 	Url to parse (uses current url if none specified)
		 *
		 * @returns {string}
		 * @note This is just a shortcut to removeParams
		 */
		function removeParam (name, url) {
			return removeParams( [ name ], url );
		}

		/**
		 * Strips the requested parameters from the URL and returns the URL
		 *
		 * @param 	{array} 	name 	Parameters to strip
		 * @param 	{string|URL} 	[url] 	Url to parse (uses current url if none specified)
		 *
		 * @returns {string}
		 */
		function removeParams(name, url) {
			if (typeof url === 'string') {
				url = new URL(url, location.href);
			}
			if (!(url instanceof URL)) {
				url = new URL(window.location.href);
			}

			const paramList = new Set([...name, ...name.map(name=>encodeURIComponent(name))]);
			let search = (url.search || "")
				.replace(/^\?/, "")
				.split('&')
				.filter(component => !paramList.has(component.split('=',2)[0]))
				.join('&');

			url.search = search.length ? "?" + search : "";
			return url.href;
		}
		
		/**
		 * Rebuilds a parseUri object back into a URL string
		 * @todo the URL standard has been a web standard for almost a decade now; we should be able to remove all usages of this and just use the native string cast URL.prototype.toString()
		 * @deprecated
		 *
		 * @param 	{parseUriObject} 	[uriObject] 	Result of parseUri
		 * @returns {string}
		 */
		function rebuildUriObject(uriObject) {
			let returnUrl = uriObject.protocol + '://' + uriObject.host + ( ( uriObject.port !== '' ) ? ':' + uriObject.port : '' ) + uriObject.path;

			if( _.keys( uriObject.queryKey ).length )
			{
				var qsParam = '?';

				_.each( uriObject.queryKey, function( value, key ) {
					if( value )
					{
						returnUrl = returnUrl + qsParam + key + '=' + value;
					}
					else
					{
						// This is here for older style furls, e.g. /index.php?/app/path/ so that we don't end up with /index.php?/app/path/=
						returnUrl = returnUrl + qsParam + key;
					}
					qsParam = '&';
				})
			}

			return returnUrl;
		}

		/**
		 * Returns the parsed URL object from parseUri
		 * @deprecated
		 * @todo this method returns an object from the old polyfilled parseUri function. We need to remove all usages of it, and simply use `new URL()` and `window.location` instead.
		 *
		 *
		 * @param 	{string} 	[url] 	Url to parse (uses current url if none specified)
		 * @returns {parseUriObject}
		 */
		function getURIObject(url) {
			return parseUri( url || window.location.href );
		}


		let _origin;
		/**
		 * Returns an origin for use in window.postMessage. Note that this value is instantiated when the method is first invoked, then never updated again.
		 * @deprecated
		 * @todo any usages of this should be replaceable with location.origin directly
		 *
		 * @returns {string}
		 */
		function getOrigin() {
			if (!_origin) {
				_origin = location.origin;
			}
			
			return _origin;
		}

		/**
		 * @typedef {{
				[key: "source"|"protocol"|"authority"|"userInfo"|"user"|"password"|"host"|"port"|"relative"|"path"|"directory"|"file"|"query"|"anchor"] : string,
				queryKey: {[p:string]: string}
			 }}	parseUriObject
		 *
		 */

		/**
		 * parseUri 1.2.2
		 * Parses a string into a parseUriObject
		 *
		 * @deprecated
		 * @todo URL interface has been web standard for well over a decade, and a lot URL dependent JS will break anyway without supporting it. Usages of this method need to be removed in favor of the native URL object. Obviously, we cannot write to the URL.prototype.searchParams object, however it is very useful, performant, and guaranteed to parse URLs accurately
		 *
		 *
		 * @param {string}	 str
		 *
		 * @returns {parseUriObject}
		 *
		 * @copyright Steven Levithan <stevenlevithan.com>
		 * @license MIT License
		 */
		function parseUri (str) {
			let o, uri;
			// If we have the modern 'URL' API, use that definitely
			if( 'URL' in window ) {
				try {
					// Fix protocol-relative URLs as the URL API does not like them
					if( str.indexOf('//') === 0 )
					{
						str = location.protocol + str;
					}

					o = new URL( str );

					// We need to reformat the returned URL object keys
					uri = {
						'source': o.href,
						'protocol': o.protocol.substring( 0, ( o.protocol.length - 1 ) ),
						'userInfo': ( o.username ? o.username : '' ) + ( ( o.username && o.password ) ? ':' : '' ) + ( o.password ? o.password : '' ),
						'user': o.username,
						'password': o.password,
						'host': o.hostname,
						'port': o.port,
						'relative': o.pathname + ( o.search ? o.search : '' ),
						'path': o.pathname,
						'directory': '',  // The URL class does not give us just the path
						'file': '',  // The URL class does not give us just the filename
						'query': o.search.substring(1),
						'anchor': o.hash,
						'queryKey': {}
					};

					// Set the authority using shortcuts we just set
					uri.authority = uri.userInfo + ( uri.userInfo ? '@' : '' ) + uri.host;

					// Set the queryKey object
					o.searchParams.forEach( function( v, k ) {
						uri.queryKey[ k ] = v;
					});

					// Figure out the path and file
					var urlBits		= uri.path.split('/');
					uri.file		= urlBits.pop();
					uri.directory	= urlBits.join('/');

					return uri;
				} catch( err ) {
					// If it failed, likely due to a bad URL, we can let the older polyfill take a stab at it - but log it so we know.
					Debug.log( "Failed to parse URL: " + str + " ; " + err );
				}
			}

			o   = parseUri.options;
			uri = {};
			const m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
			let i = 14;

			while (i--) uri[o.key[i]] = m[i] || "";

			uri[o.q.name] = {};
			uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
				if ($1) uri[o.q.name][$1] = $2;
			});

			return uri;
		}

		parseUri.options = {
			strictMode: false,
			key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
			q:   {
				name:   "queryKey",
				parser: /(?:^|&)([^&=]*)=?([^&]*)/g
			},
			parser: {
				strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
				loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
			}
		};

		/**
		 * @typedef SetParamsOptions
		 * @property {Object<string,string|null>}    	[params={}]        		The params to set on the URL. Alternatively, just one param can be updated using the `param` and `value` options. Each value should be either a string or null; null indicates this parameter should be removed from the URL
		 * @property {string}    						[param]					Optional: you can pass just this and a value if you only need to update one param
		 * @property {string|null}    					[value='']				When updating only one param, use this as the value. If the value is NULL, the param will be deleted.
		 * @property {boolean}    						[encode=true]    		whether to encode the param and value
		 * @property {boolean}    						[removeCurrent=true]    whether to remove existing occurrences of this param in the URL
		 */

		/**
		 * Update the search params of this URL without damaging FURL paths existing in the search query. The URL is returned for optional chaining
		 *
		 * @param {SetParamsOptions|string} options			Either options to update the URL or a param and optional value to update
		 * @param {string|null}				[value]			If the first param is a string and this is set, it will use the second argument as the value.
		 *
		 * @return {URL}
		 */
		URL.prototype.updateSearchParams = function({params={}, param, value="", encode=true, removeCurrent=true}) {
			if (typeof arguments[0] !== 'object') {
				if (typeof arguments[0] !== 'string') {
					throw new TypeError('The first argument must be either an object of options or a string denoting the param');
				}
				param = arguments[0];
				if (arguments.length > 1) {
					value = arguments[1];
				}
			}

			if (typeof param === 'string') {
				params[param] = value !== null ? value : "";
			}

			const paramsToRemove = [];
			let newParamComp = '';
			for (const k of Object.keys(params)) {
				if (params[k] !== null) {
					// todo maybe include some logic to handle array params; for now it isn't needed though
					try {
						params[k] = `${params[k]}`; // use this to cast to a string. This also allows values like false and undefined to become strings, though it could lead to unintended consequences
					} catch (e) {
						Debug.warn(new TypeError(`Could not convert the value for the param ${k} into a string, so the param is being set to an empty string instead`));
						params[k] = '';
					}
				}

				if (typeof params[k] !== "string") {
					paramsToRemove.push(k);
					delete params[k];
					continue;
				} else if (removeCurrent) {
					paramsToRemove.push(k);
				}
				const key = encode ? encodeURIComponent(k) : k;
				const value = encode ? encodeURIComponent(params[k]) : params[k];
				newParamComp += `${key}=${value}&`
			}
			newParamComp = newParamComp.replace(/&$/, '');

			if (paramsToRemove.length) {
				removeParams(paramsToRemove, this);
			}

			const search = (this.search || "").replace(/^\?/, "");
			if (search || newParamComp) {
				this.search = "?" + search + (search.length && newParamComp.length ? `&` : '') + newParamComp;
			} else {
				// no remaining search params NOR new ones? remove the search
				this.search = "";
			}

			return this;
		};
	
		return {
			getPageNumber,
			getParam,
			removeParam,
			removeParams,
			getURIObject,
			getOrigin,
			rebuildUriObject,
			pageParamToPath,
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="common/utils" javascript_name="ips.utils.validate.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.utils.validate.js - A library for validating values
 *
 * Author: Rikki Tissier
 */

;( function($, _, undefined){
	"use strict";
	
	ips.createModule('ips.utils.validate', function (options) {

		/**
		 * Format object - checks data in a field matches a particular regex format
		 */
		var formats = {
			email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))){2,6}$/i,
			url: /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)/,
			alphanum: /^\w+$/,
			integer: /^\d+$/,
			number: /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/,
			creditcard: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
			hex: /^[0-9a-f]+$/i
		};

		/**
		 * Validators object - methods run to check a field meets conditions
		 */
		var validators = {
			maxlength: function (val, max) {
				return val.length <= max;
			},

			minlength: function (val, min) {
				return val.length >= min;
			},

			rangelength: function (val, min, max) {
				return validators.maxlength( val, max ) && validators.minlength( val, min );
			},

			min: function (val, min) {
				return Number( val ) >= min;
			},

			max: function (val, max) {
				return Number( val ) <= max;
			},

			range: function (val, min, max) {
				return validators.min( val, min ) && validators.max( val, max );
			},

			required: function (val) {
				return val.length > 0
			},

			regex: function (val, regex) {
				return new RegExp( regex ).test( val );
			},

			format: function (val, format) {
				return new RegExp( formats[ format ] ).test( val );
			},

			remote: function (val, url) {
				var deferred = $.Deferred();

				ips.getAjax()( url, {
					dataType: 'json',
					data: {
						input: encodeURI( val )
					}
				})
					.done( function (response) {
						if( response.result == 'ok' ){
							deferred.resolve();
						} else {
							deferred.reject( response.message || null );
						}
					})
					.fail( function (jqHXR, textStatus) {
						deferred.reject( textStatus );
					});

				return deferred.promise();
			}
		};

		// Setters
		/**
		 * Adds a custom format
		 *
		 * @param	{string} 	name 		Identifying name for this format
		 * @param	{regexp} 	format 		The format, as a regexp literal
		 * @returns {void}
		 */
		var addFormat = function (name, format) {
			formats[ name ] = format;
		},

		/**
		 * Adds a custom validator
		 *
		 * @param	{string} 	name 		Identifying name for this validator
		 * @param	{function} 	fn 			Function called when this validator is used
		 * @returns {void}
		 */
		addValidator = function (name, fn) {
			validators[ name ] = fn;
		};

		// Shortcut methods for individual validators/formats
		/**
		 * Checks whether the value is a valid URL
		 *
		 * @param	{string} 	url 		The URL to validate
		 * @returns {boolean}
		 */
		var isUrl = function (url) {
			return validators.regex( url, formats.url );
		},

		/**
		 * Checks whether the value is an allowed URL
		 *
		 * @param	{string} 	url 		The URL to validate
		 * @returns {boolean}
		 */
		isAllowedUrl = function (url) {
			var returnValue;
			returnValue	= true;

			if( ips.getSetting('blacklist') )
			{
				for( var i in ips.getSetting('blacklist') )
				{
					var blacklistUrl = ips.getSetting('blacklist')[i];
					blacklistUrl	= escapeRegExp( blacklistUrl );
					blacklistUrl	= blacklistUrl.replace( /\\\*/g, '(.+?)' );

					var index		= url.search( new RegExp( blacklistUrl, 'ig' ) );

					if( index >= 0 )
					{
						returnValue	= false;
						break;
					}
				}
			}

			if( ips.getSetting('whitelist') )
			{
				returnValue	= false;

				for( var i in ips.getSetting('whitelist') )
				{
					var whitelistUrl = ips.getSetting('whitelist')[i];
					whitelistUrl	= escapeRegExp( whitelistUrl );
					whitelistUrl	= whitelistUrl.replace( /\\\*/g, '(.+?)' );

					var index		= url.search( new RegExp( whitelistUrl, 'ig' ) );

					if( index >= 0 )
					{
						returnValue	= true;
						break;
					}
				}
			}

			return returnValue;
		},

		/**
		 * Checks whether the value is a valid email address
		 *
		 * @param	{string} 	email 		The email address to validate
		 * @returns {boolean}
		 */
		isEmail = function (email) {
			return validators.regex( email, formats.email );
		};

		/**
		 * Main validation method
		 * Combines provided conditions with HTML5 conditions gleaned from the element. Checks each condition
		 * by executing the relevant validators.
		 *
		 * @param	{element} 	field 			The element being validated
		 * @param	{object} 	conditions 		Object of conditions/values to use when validating
		 * @param 	{boolean} 	ignoreHTML5		Ignore the HTML5 validation properties?
		 * @returns {object}	
		 */
		var validate = function (field, conditions, ignoreHTML5) {
			if( !ignoreHTML5 ){
				conditions = _.extend( _getAutomaticConditions( field ), conditions || {} );
			}

			if( !_.size( conditions ) ){
				return true;
			}

			// Now work through each condition
			var validated = true;
			var messages = [];

			for( var i in conditions ) {
				if( !_.isFunction( validators[ i ] ) ){
					continue;
				}

				var value = field.val();
				var args = [];

				if( _.isObject( conditions[ i ] ) ){
					args = _.values( conditions[ i ] )
					args.splice( 0, 1 );
				} else {
					args = [ conditions[ i ] ];
				}

				args.unshift( value );

				if( validators[ i ].apply( this, args ) !== true ) {
					validated = false;
					messages.push( {
						condition: i,
						message: _getMessage( i, args )
					});
				}
			}

			return {
				result: validated,
				messages: messages
			}
		},

		/**
		 * Returns the parsed error message for the given validator type
		 *
		 * @param	{string} 	type 		The validator type
		 * @param	{object} 	args 		The values originally passed into the validator
		 * @returns {string}
		 */
		_getMessage = function (type, args) {
			return ips.pluralize( ips.getString( 'validation_' + type, { data: args } ), [ ( ( type == 'rangelength' ) ? args[2] : args[1] ) ] );
		},

		/**
		 * Builds an object of conditions for an element based on HTML5 attributes (e.g. required)
		 *
		 * @param	{element} 	field 		The element being validated
		 * @returns {object}
		 */
		_getAutomaticConditions = function (field) {
			var conditions = {};

			if( field.is('[required]') ){
				conditions.required = true;
			}

			if( field.is('input[type="number"], input[type="range"], input[type="email"], input[type="url"]') ){
				conditions.format = field.attr('type');
			}

			if( field.is('[max]') ){
				conditions.max = field.attr('max');
			}

			if( field.is('[min]') ){
				conditions.min = field.attr('min');
			}

			if( field.is('[pattern]') ){
				conditions.regex = field.attr('pattern');
			}

			return conditions;
		};

		// Expose public methods
		return {
			isUrl: isUrl,
			isEmail: isEmail,
			addFormat: addFormat,
			addValidator: addValidator,
			validate: validate,
			isAllowedUrl: isAllowedUrl
		}
	});

}(jQuery, _));

// http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
var escapeRegExp;

(function () {
  // Referring to the table here:
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
  // these characters should be escaped
  // \ ^ $ * + ? . ( ) | { } [ ]
  // These characters only have special meaning inside of brackets
  // they do not need to be escaped, but they MAY be escaped
  // without any adverse effects (to the best of my knowledge and casual testing)
  // : ! , = 
  // my test "~!@#$%^&*(){}[]`/=?+\|-_;:'\",<.>".match(/[\#]/g)

  var specials = [
        // order matters for these
          "-"
        , "["
        , "]"
        // order doesn't matter for any of these
        , "/"
        , "{"
        , "}"
        , "("
        , ")"
        , "*"
        , "+"
        , "?"
        , "."
        , "\\"
        , "^"
        , "$"
        , "|"
      ]

      // I choose to escape every character with '\'
      // even though only some strictly require it when inside of []
    , regex = RegExp('[' + specials.join('\\') + ']', 'g')
    ;

  escapeRegExp = function (str) {
    return str.replace(regex, "\\$&");
  };

  // test escapeRegExp("/path/to/res?search=this.that")
}());]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/badgepreview" javascript_name="ips.core.badgepreview.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000150"><![CDATA[;(function ($, _) {
    "use strict";

    ips.controller.register('ips.core.badgepreview', {
        /**
         * @type {HTMLDivElement}
         */
        preview: undefined,

        /**
         * @type {"custombadge"|string}
         */
        badgetype: 'custombadge',
        initialize() {
            this.preview = this.elem.querySelector('[data-role="preview"]')

            if ('badgetype' in this.elem.dataset) {
                this.badgetype = this.elem.dataset.badgetype;
            }

            // Debounce the update image method
            const _debounced = _.throttle(async () => {
                await this.updateImage();
            }, 200, {trailing: true});

            // watch the form elements
            for (const id of ['icon', 'shape', 'foreground', 'background', 'border', 'sides', 'rotation', 'number_overlay', 'icon_size'].map(i => `${this.badgetype}_${i}`))
            {
                const config = {attributes: true, childList: false, subtree:false}
                this.getForm().querySelectorAll(`#${id} input`).forEach(element => {
                    if (id.endsWith('rotation')) {
                        element.oninput = () => this.updateRotation();
                    } else if (id.match(/_number_overlay$/)) {
                        element.oninput = () => this.updateNumberOverlay();
                    } else if (!id.match(/_(foreground|border|background)$/)) {
                        element.oninput = _debounced;
                    }

                    // we use mutation observer because the icon element is not directly set by the user, so the input event never fires
                    const observer = new MutationObserver(mutationList => {
                        for (const mutationRecord of mutationList) {
                            if (mutationRecord.type === 'attributes' && ['value', 'style'].includes(mutationRecord.attributeName)) {
                                if (id.endsWith('rotation')) {
                                    this.updateRotation();
                                } else if (id.match(/_(foreground|background|border)$/)) {
                                    this.updateColor();
                                } else if (id.match(/_number_overlay$/)) {
                                    this.updateNumberOverlay();
                                } else {
                                    _debounced();
                                }
                                break
                            }
                        }
                    })
                    observer.observe(element, config)
                })
            }
        },

        /**
         * Update the image by fetching the svg xml
         *
         * @return {Promise<void>}
         */
        async updateImage() {
            let url = ipsSettings.baseURL + `/admin/?app=core&module=achievements&controller=badges&do=badgePreview`;

            /**
             * @type {XMLDocument}
             */
            const contents = await ips.fetch(url, {
                method: "POST",
                data: {
                    shape: this.getShape(),
                    icon: JSON.stringify(this.getIcon()),
                    foreground: this.getForeground(),
                    background: this.getBackground(),
                    border: this.getBorder(),
                    rotation: this.getRotation(),
                    sides: this.getSides(),
                    numberoverlay: this.getNumberOverlay(),
                    iconsize: this.getIconSize()
                }
            });
            if (contents.querySelector('svg')) {
                this.preview.innerHTML = '';
                this.preview.appendChild(contents.querySelector('svg'));
                this.updateNumberOverlay();
            }
        },

        updateColor() {
            const foreground = this.getForeground();
            const background = this.getBackground();
            const border = this.getBorder();

            const svgElement = this.preview.querySelector('svg');
            const attrMap = {
                foreground: ['fgcolor', foreground],
                background: ['bgcolor', background],
                border: ['bordercolor', border]
            }

            for (const colorField in attrMap) {
                svgElement?.querySelectorAll(`[data-${attrMap[colorField][0]}-placeholder]`).forEach(el => {
                    el.dataset[attrMap[colorField][0] + "Placeholder"].split(',').forEach(attr => {
                        el.setAttribute(attr, attrMap[colorField][1]);
                    });
                })
            }

            svgElement?.querySelectorAll('[data-embedded-fg-color][href]').forEach(img => {
                const href = img.getAttribute('href');
                const url = new URL(href);
                if (url.protocol.toLowerCase() === 'data:' && url.pathname.startsWith('image/svg+xml,')) {
                    const data = decodeURIComponent(url.pathname.split(',', 2)[1]);
                    const embeddedXML = (new DOMParser()).parseFromString(data, 'text/xml');
                    let changed = false;
                    for (const colorField in attrMap) {
                        embeddedXML.querySelectorAll(`[data-${attrMap[colorField][0]}-placeholder]`).forEach(el => {
                            el.getAttribute(`data-${attrMap[colorField][0]}-placeholder`).split(",").forEach(attr => {
                                changed = true;
                                el.setAttribute(attr, attrMap[colorField][1]);
                            })
                        });
                    }

                    if (changed) {
                        const encoded = `data:image/svg+xml,${encodeURIComponent(embeddedXML.documentElement.outerHTML)}`
                        img.setAttribute('href', encoded);
                    }
                }
            })
        },

        updateNumberOverlay() {
            const svgElement = this.preview.querySelector('svg');
            const numberInput = this.getNumberOverlay();
            if (svgElement) {
                if (numberInput) {
                    svgElement.querySelectorAll('.svg__text_overlay').forEach(overlay => {
                        overlay.innerHTML = `${numberInput}`
                    });

                    svgElement.querySelectorAll('[data-number-overlay]').forEach(overlay => {
                        overlay.style.display = ''
                    })
                } else {
                    svgElement.querySelectorAll('[data-number-overlay]').forEach(overlay => {
                        overlay.style.display = 'none'
                    })
                }
            }
        },

        isSquare: false,
        /**
         * Update the rotation
         */
        updateRotation() {
            const rotation = this.getRotation();
            const shape = this.getShape();
            if (shape === 'ngon' && rotation === 45 && this.getSides() === 4) {
                this.updateImage();
                this.isSquare = true;
            } else if (this.isSquare) {
                this.updateImage();
                this.isSquare = false;
            } else {
                if (['ngon', 'star', 'flower'].includes(shape)) {
                    this.preview.querySelectorAll('[transform]').forEach(node => {
                        if (node.getAttribute('transform').includes('rotate')) {
                            node.setAttribute('transform', `rotate(${rotation})`)
                        }
                    })
                }
            }
        },

        /**
         *
         * @return {HTMLFormElement}
         */
        getForm() {
            return this.elem.closest('form')
        },

        /**
         * Get the shape the user selected in the form
         *
         * @return {"square"|"circle"|"ngon"|"star"|"flower"|"no_shape"}
         */
        getShape() {
            for (const input of this.getForm().querySelectorAll(`#${this.badgetype}_shape input[type="radio"][name="${this.badgetype}_shape"]`)) {
                if (input.checked) {
                    return input.value
                }
            }
            return 'circle'
        },

        /**
         * Get the selected icon
         *
         * @return {null|Object}
         */
        getIcon() {
            const value = JSON.parse(this.getForm().querySelector(`input[name="${this.badgetype}_icon"]`)?.value || 'null') || null;
            if (Array.isArray(value) && value.length) {
                return value[0]
            }
            return null
        },

        /**
         * Get the foreground
         *
         * @return {string}
         */
        getForeground() {
            return this.getForm().querySelector(`input[name="${this.badgetype}_foreground"]`)?.value || "#ffffff";
        },

        /**
         * Get the background
         *
         * @return {string}
         */
        getBackground() {
            return this.getForm().querySelector(`input[name="${this.badgetype}_background"]`)?.value || "#eeb95f";
        },

        /**
         * Get the border color
         * @return {string}
         */
        getBorder() {
            return this.getForm().querySelector(`input[name="${this.badgetype}_border"]`)?.value || "#f7d36f";
        },

        /**
         * Get the selected number of sides
         * @return {number}
         */
        getSides() {
            return parseInt(this.getForm().querySelector(`input[name="${this.badgetype}_sides"]`)?.value || "5");
        },

        /**
         * Get the rotation degrees
         * @return {number}
         */
        getRotation() {
            return parseInt(this.getForm().querySelector(`input[name="${this.badgetype}_rotation"]`)?.value || "0");
        },

        /**
         * Get the number to overlay
         * @return {number}
         */
        getNumberOverlay() {
            if (this.getForm().querySelector(`input[type="checkbox"][name="${this.badgetype}_number_overlay"][data-control="unlimited"]`)?.checked) {
                return 0;
            }
            const value = parseInt(this.getForm().querySelector(`input[type="number"][name="${this.badgetype}_number_overlay"]`)?.value || this.getForm().querySelector(`input[type="number"][name="${this.badgetype}_number_overlay"]`)?.dataset.previousvalue || "0");
            return Math.min(Math.max(0,value), 999)
        },

        /**
         * Get the size of the icon or emoji inside the badge
         *
         * @return {1|2|3|4|5}      Number 1-5 as there are 5 increments. Default 3
         */
        getIconSize() {
            return Math.min(5, Math.max(1, parseInt(this.getForm().querySelector(`input[name="${this.badgetype}_icon_size"][type="range"]`)?.value) || 3));
        }
    })
}(jQuery, _))]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/clubs" javascript_name="ips.clubs.navbar.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000150"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.clubs.navbar.js - Club Navigation Manager
 *
 * Author: Daniel Fatkic
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.clubs.navbar', {

		_interval: null,
		_sortableElem: null,

		initialize: function () {
			this.on( document, 'click', '[data-action="reorderClubmenu"]', this.startReorder );
			this.on( document, 'click', '[data-action="saveClubmenu"]', this.saveOrder );
			this.setup();
		},

		setup: function () {
			this._sortableElem = this.scope.find('[data-club-menu]');
		},

		/**
		 * Starts the tab reordering interface by building drag handles for each tab
		 * and setting up sortable
		 *
		 * @returns 	{void}
		 */
		startReorder: function (e) {
			e.preventDefault();

			$('[data-action="saveClubmenu"]').removeClass('ipsHide');
			$('[data-action="reorderClubmenu"]').parent().addClass('ipsHide');

			var self = this;
			this._sortableElem.find('a')
				.addClass('i-cursor_move')
				.prepend( ips.templates.render('club.menu.dragHandle') );

			ips.loader.get( ['core/interface/jquery/jquery-ui.js'] ).then( function () {
				self._sortableElem
					.sortable({
						items: '>',
						forcePlaceholderSize: true,
						update: function () {
							self._orderChanged = true;
						}
					});

				self._reordering = true;
				self._orderChanged = false;
				self._sortableElem.find('a [data-role="clubMenuDrag"]').fadeIn();
			});
		},

		/**
		 * Finish sorting
		 *
		 * @returns 	{void}
		 */
		_finishReorder: function () {
			this._sortableElem.find('a')
				.removeClass('i-cursor_move')
				.find('[data-role="clubMenuDrag"]')
					.remove();

			$('[data-action="saveClubmenu"]').addClass('ipsHide');
			$('[data-action="reorderClubmenu"]').parent().removeClass('ipsHide');
			this._sortableElem.sortable( 'destroy' );
			this._reordering = false;
		},

		/**
		 * Saves the new order of tabs, sending an ajax request with the new order
		 *
		 * @returns 	{void}
		 */
		saveOrder: function (e) {
			e.preventDefault();
			
			var self = this;
			var tabOrder = this._sortableElem.sortable( 'toArray', { attribute: 'data-tab'} );
			if( this._orderChanged ){
				ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=clubs&controller=view&do=saveMenu', {
					data: {
						tabOrder: tabOrder,
						id: this.scope.attr('data-clubID')
					},
					dataType: 'json',
					type: 'post'
				} )
					.done( function (response) {
						ips.ui.flashMsg.show( ips.getString('tab_order_saved') );
					})
					.fail( function ( ) {
						ips.ui.alert.show( {
							type: 'alert',
							icon: 'warning',
							message: ips.getString('tab_order_not_saved'),
							callbacks: {
								ok: function () {}
							}
						});
					})
					.always( function () {
						self._finishReorder();
					});
			} else {
				this._finishReorder();
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/clubs" javascript_name="ips.clubs.requests.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000150"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.clubs.requests.js - Requests handler
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.clubs.requests', {

		_interval: null,

		initialize: function () {
			this.on( 'click', '[data-action="requestApprove"], [data-action="requestDecline"]', this.handleRequest );
			this.on( document, 'menuItemSelected', this.handleRequest );
			this.on( window, 'resize', this.resizeCovers );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			
		},

		/**
		 * Handles resizing cover divs when the window resizes
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		resizeCovers: function (e) {
			var self = this;
			var cards = this.scope.find('[data-ips-js=memberCard][data-hasCover]');

			if( cards.length ){
				$.each( cards, function () {
					var id = $( this ).identify().attr('id');
					var cover = $('body').find('.cClubRequestCover[data-cardId="' + id + '"]');
					self._positionCover( $( this ), cover );
				});
			}
		},

		/**
		 * Handles approving/declining a request
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		handleRequest: function (e, data = e.detail) {
			
			var self = this;
			if ( e.type == 'menuItemSelected' ) {
				if ( $(data.menuElem).attr('data-role') != 'acceptMenu' ) {
					return;
				}
				data.originalEvent.preventDefault();
				var url = $( data.originalEvent.target ).attr('href');
				var card = $( e.target ).closest('[data-ips-js=memberCard]');
			} else {
				e.preventDefault();
				var url = $( e.currentTarget ).attr('href');
				var card = $( e.currentTarget ).closest('[data-ips-js=memberCard]');
			}			
			var id = card.identify().attr('id');
			
			// Disable the buttons while we wait
			card.find('[data-action]').addClass('ipsButton--disabled');

			ips.getAjax()( url, {
				showLoading: true
			})
				.done( function (response) {

					card.attr('data-hasCover', true);

					// Fade out the card
					card.animate({
						opacity: "0.2"
					});

					// Build a cover
					var cover = $('<div/>').addClass('cClubRequestCover').attr('data-cardId', id);
					$('body').append( cover );

					self._positionCover( card, cover );

					cover
						.append( ips.templates.render( response.status == 'approved' ? 'club.request.approve' : 'club.request.decline' ) )
						.fadeIn();

					// Show flash message
					ips.ui.flashMsg.show( response.status == 'approved' ? ips.getString('clubMemberApproved') : ips.getString('clubMemberDeclined'), { escape: false } );

					if( !self._interval ){
						self._interval = window.setInterval( _.bind( self._checkCardsExist, self ), 200 );
					}
				})
				.fail( function () {
					window.location = url;
				});
		},

		/**
		 * Fired by an interval timer, checks whether a card still exists, and removes the cover if not
		 *
		 * @returns {void}
		 */
		_checkCardsExist: function () {
			var self = this;
			var covers = $('body').find('.cClubRequestCover');
			var cards = this.scope.find('[data-ips-js=memberCard][data-hasCover]');

			// If we have the same count, we can leave
			if( cards.length == covers.length ){
				return;
			}

			if( covers.length ){
				$.each( covers, function () {
					var cardId = $( this ).attr('data-cardId');
					var card = self.scope.find('#' + cardId);

					if( !card.length ){
						$( this ).remove();
					}
				});
			}
		},
		
		/**
		 * Position the cover over the card
		 *
		 * @param 	{element} 	card 	Card div
		 * @param 	{element} 	cover 	Cover div
		 * @returns {void}
		 */
		_positionCover: function (card, cover) {
			var elemPosition = ips.utils.position.getElemPosition( card );
			var dims = ips.utils.position.getElemDims( card );

			cover.css({
				position: 'absolute',
				top: elemPosition.absPos.top + 'px',
				left: elemPosition.absPos.left + 'px',
				width: dims.outerWidth + 'px',
				height: dims.outerHeight + 'px'
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.acpSearchKeywords.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.acpSearchKeywords.js - Faciliates editing keywords for ACP search when IN_DEV
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.core.acpSearchKeywords', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;save&quot;]', this.saveKeywords );
		},
		
		/**
		 * Save the keywords
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		saveKeywords: function (e) {			
			e.preventDefault();
			var scope = this.scope;
			
			var data = {
				url: scope.attr('data-url'),
				lang_key: scope.find( &quot;[data-role='lang_key']&quot; ).val(),
				restriction: scope.find( &quot;[data-role='restriction']&quot; ).val(),
				keywords: []
			};
			
			scope.find( &quot;[data-role='keywords']&quot; ).each(function(){
				if( $(this).val() ){
					data.keywords.push( $(this).val() );
				}
			});
						
			ips.getAjax()( scope.attr('data-action'), {
			   data: data,
			   type: 'post',
			   showLoading: true
			})
			.done( function(response) {
			   scope[0].closest(&quot;[popover]&quot;)?.hidePopover();
			   ips.ui.flashMsg.show('Keywords saved');
			});
		},
	});
}(jQuery, _));
</file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.app.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/* global ips, _, Debug */
/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.app.js - AdminCP base app controller
 * This controller is used only for items that are global event handlers. Where functionality is specific to
 * a feature or section, a new controller should be created.
 *
 * Author: Rikki Tissier
 */ 
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.app', {

		initialize: function () {
			this.on( 'click', '[data-clickshow]', this.clickShow );
			this.on( 'click', '[data-clickhide]', this.clickHide );
			this.on( 'click', '[data-clickempty]', this.clickEmpty );
			this.on( 'click', '[data-delete]', this.deleteSomething );
			this.on( 'click', 'a[data-confirm]', this.confirmSomething );
			this.on( 'click', '[data-doajax]', this.doAjaxAction );
			this.on( document, 'contentChange', this._checkAndClearAutosave );

			this.setup();
		},

		/**
		 * General app setup. Creates flashMsgs if needed, shows/hides JS elements
		 *
		 * @returns {void}
		 */
		setup: function () {
			if( ips.utils.serviceWorker.supported ) {
				ips.utils.serviceWorker.registerServiceWorker('admin', false);
			}
			// Clear any autosave stuff
			this._checkAndClearAutosave();
			if ( !ips.getSetting('memberID') && ips.utils.url.getParam('_fromLogout') ) {
				ips.utils.db.removeByType('editorSave');
			}
		},

		/**
		 * Check and clear autosave
		 *
		 * @returns {void}
		 */
		 _checkAndClearAutosave: function() {
		 	if( ips.utils.cookie.get('clearAutosave') ) {
				var autoSaveKeysToClear = ips.utils.cookie.get('clearAutosave').split(',');
				for ( var i = 0; i < autoSaveKeysToClear.length; i++ ) {
					ips.utils.db.remove( 'editorSave', autoSaveKeysToClear[i] );
				}
				ips.utils.cookie.unset('clearAutosave');
			}
		 },

		/**
		 * Sends an ajax request with the link's href, and shows a flash message on success
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		doAjaxAction: function (e) {
			e.preventDefault();

			ips.getAjax()( $( e.currentTarget ).attr('href'), { dataType: 'json' } )
				.done( function (response) {
					ips.ui.flashMsg.show( response );
				})
				.fail( function (jqXHR) {
					if( Debug.isEnabled() ){
						Debug.error( jqXHR.responseText );
					} else {
						window.location = $( e.currentTarget ).attr('href');
					}
				});
		},

		/**
		 * Prompts the user to confirm a deleting action, sends ajax request to do the delete,
		 * and removes a row if necessary
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		deleteSomething: function (e) {
			e.preventDefault();

			var elem = $( e.currentTarget );
			var deleteTitle = elem.attr('data-delete-message');
			var extraWarning = elem.attr('data-delete-warning');

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'warn',
				message: deleteTitle || ips.getString('delete_confirm'),
				subText: extraWarning || '',
				focus: 'cancel',
				callbacks: {
					ok: function () {
						// Do we not want to execute via AJAX?
						if( elem.attr('data-noajax') !== undefined ){
							window.location = elem.attr('href') + '&csrfKey=' + ips.getSetting('csrfKey') + '&wasConfirmed=1';
							return;
						}

						var row = null;

						// Check if there's any rows to delete
						if( elem.attr('data-deleterow') ){
							row = $( elem.attr('data-deleterow') );
						} else {
							row = elem.closest('tr, .row, [data-role=node]');
						}

						let bypassRedirect = !(elem.attr( 'data-accept-redirect' ));

						// Trigger ajax request to actually delete
						ips.getAjax()( elem.attr('href'), {
							showLoading: true,
							bypassRedirect: bypassRedirect,
							data: {
								form_submitted: 1,
								wasConfirmed: 1
							}
						} )
							.done( function (response) {
								if( row.hasClass('parent') ){
									row.next().remove();
								}

								ips.utils.anim.go( 'fadeOut', row );
							})
							.fail( function () {
								window.location = elem.attr('href') + '&csrfKey=' + ips.getSetting('csrfKey') + '&wasConfirmed=1';
							});
					}
				}
			});
		},
		
		/**
		 * Prompts the user to confirm an action
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		confirmSomething: function (e) {
			e.preventDefault();
			var elem = $( e.currentTarget );
			var customMessage = $( e.currentTarget ).attr('data-confirmMessage');
			var customSubMessage = $( e.currentTarget ).attr('data-confirmSubMessage');
			var type = $( e.currentTarget ).attr('data-confirmType');
			var icon = $( e.currentTarget ).attr('data-confirmIcon');
			
			var alert = {
				type: ( type ) ? type : 'confirm',
				icon: ( icon ) ? icon : 'warn',
				message: ( customMessage ) ? customMessage : ips.getString('generic_confirm'),
				subText: ( customSubMessage ) ? customSubMessage : '',
				callbacks: {
					ok: function () {
						window.location = elem.attr('href') + '&wasConfirmed=1';
					},
					yes: function () {
						window.location = elem.attr('href') + '&prompt=1';
					},
					no: function () {
						window.location = elem.attr('href') + '&prompt=0';
					}
				}
			};
			
			if ( $( e.currentTarget ).attr('data-confirmButtons') ) {
				alert.buttons = $.parseJSON( $( e.currentTarget ).attr('data-confirmButtons') );
			}
			
			ips.ui.alert.show( alert );
		},

		/**
		 * Shows elements when clicked
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		clickShow: function ( e ) {
			e.preventDefault();
			
			var elems = ips.utils.getIDsFromList( $( e.currentTarget ).attr('data-clickshow') );
			this.scope.find( elems ).show().removeClass('ipsHide');
		},

		/**
		 * Hides elements when clicked
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		clickHide: function ( e ) {
			e.preventDefault();
			
			var elems = ips.utils.getIDsFromList( $( e.currentTarget ).attr('data-clickhide') );
			this.scope.find( elems ).hide().addClass('ipsHide');
		},

		/**
		 * Empties given form elements when clicked
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		clickEmpty: function ( e ) {
			e.preventDefault();
			
			var elems = ips.utils.getIDsFromList( $( e.currentTarget ).attr('data-clickempty') );
			this.scope.find( elems ).val('');
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.changeTheme.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.changeTheme.js - ACP theme changing
 *
 * Author: Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.changeTheme', {

		initialize: function () {
			this.on( 'menuItemSelected', _.bind( this.themePreferenceSelected, this ) );
			this.on( 'click', '[data-role="mobileThemeMenu"] button', this.mobileThemePreferenceSelected );

			this.setTheme();
		},

		/**
		 * Determine if we should be using dark mode or not and set the class if so
		 *
		 * @returns {void}
		 */
		setTheme: function () {
			// If we don't have a specific preference, use the OS default
			if( _.isUndefined( ips.utils.cookie.get('acptheme') ) || ips.utils.cookie.get('acptheme') == 'undefined' )
			{
				if ( window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches )
				{
					$('html').attr('data-ips-scheme', 'dark');
					ips.utils.cookie.set( 'acpthemedefault', 'dark' );
				}
				else
				{
					$('html').attr('data-ips-scheme', 'light');
					ips.utils.cookie.set( 'acpthemedefault', 'light' );
				}
			}
			// We have a cookie preference set so make sure that's being used
			else
			{
				if(ips.utils.cookie.get('acptheme') === 'dark'){
					$('html').attr('data-ips-scheme', 'dark');
				} else {
					$('html').attr('data-ips-scheme', 'light');
				}
			}
		},

		updatePreference: function(choice){

			if( choice == 'os' )
			{
				// If we selected to use the OS preference delete the cookie (if it exists) and let the normal behavior resume
				ips.utils.cookie.unset('acptheme');
			}
			else
			{
				// Otherwise set our cookie and force the behavior we requested
				var expires = new Date();
				expires.setFullYear( expires.getFullYear() + 1 );
				ips.utils.cookie.set( 'acptheme', choice, expires.toUTCString() );
			}
		},

		/**
		 * Change our AdminCP theme
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object}	data	Event data
		 * @returns {void}
		 */
		themePreferenceSelected: function (e, data = e.detail) {
			// Make sure something was selected and this isn't a click on a different menu item
			if( _.isUndefined( data.selectedItemID ) )
			{
				return;
			}
			this.updatePreference(data.selectedItemID);
			this.setTheme();
		},

		mobileThemePreferenceSelected: function(e){
			let choice = e.currentTarget.getAttribute("data-value");
			this.updatePreference(choice);
			this.setTheme();
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.dynamicChart.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.dynamicChart.js - Dynamic chart controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.dynamicChart', {

		storedValues: {},
		identifier: '',
		
		type: '',

		initialize: function () {
			// Set up the events that will capture chart changes
			this.on( 'click', '[data-timescale]', this.changeTimescale );
			this.on( document, 'submit', '[data-role="dateForm"]', this.changeDateRange );
			document.addEventListener('ips:stats.setDateFilters', e => this.globalDateRangeSet(e));
			this.on( document, 'click', '[data-role="clearSearchTerm"]', this.resetSearch );
			this.on( document, 'submit', '[data-role="searchForm"]', this.changeSearch );
			this.on( 'menuItemSelected', '[data-action="chartFilter"]', this.changeFilter );
			this.on( 'click', '[data-type]', this.changeChartType );

			// Select all/none for filters
			this.on( 'click', '[data-role="filterMenu"] [data-role="selectAll"]', this.selectAllFilters );
			this.on( 'click', '[data-role="filterMenu"] [data-role="unselectAll"]', this.unselectAllFilters );

			// Save filters
			this.on( 'click', '[data-role="saveReport"]', _.bind( this.saveFilters, this ) );
			this.on( 'click', '[data-role="renameChart"]', _.bind( this.renameFilters, this ) );

			this.setup();
		},

		/**
		 * Select all filters
		 *
		 * @returns {void}
		 */
		selectAllFilters: function ( e ) {
			$(e.currentTarget)
				.closest('i-dropdown')
				.find('[data-ipsMenuValue]:not([aria-selected="true"])')
				.each(function() {
					this.click(); // Use native click instead of jQuery .trigger
				});
		},

		/**
		 * Un-select all filters
		 *
		 * @returns {void}
		 */
		unselectAllFilters: function ( e ) {
			$(e.currentTarget)
				.closest('i-dropdown')
				.find('[data-ipsMenuValue][aria-selected="true"]')
				.each(function() {
					this.click(); // Use native click instead of jQuery .trigger
				});
		},

		/**
		 * Setup method. Sets the default storeValues values.
		 *
		 * @returns {void}
		 */
		setup: function () {
			var self = this;
			this.identifier = this.scope.attr('data-chart-identifier');

			// Get the initial values
			// Timescale & type
			this.storedValues.timescale = this.scope.find('[data-timescale][data-selected]').attr('data-timescale');
			this.storedValues.type = this.scope.find('[data-type][data-selected]').attr('data-type');

			if( this.scope.find('[data-role="searchForm"] input') )
			{
				this.storedValues.term = null;
			}

			this.storedValues.filters = [];
			this.storedValues.dates = { start: '', end: '' };
			this.type = this.scope.attr('data-chart-type');
			this.timescale = this.scope.attr('data-chart-timescale');
			
			// Filters
			$('#el' + this.identifier + 'Filter_menu').find('[aria-selected="true"]').each( function () {
				self.storedValues.filters.push( $( this ).attr('data-ipsMenuValue') );
			});
			
			this.checkType();
			const url = new URL(window.location.href);
			const action = new URL(this.elem.dataset.chartUrl, window.location.href);
			if (parseInt(url.searchParams.get('highlight')) && url.searchParams.get('highlight') === action.searchParams.get('chartId')) {
				this.pulse();
				ips.utils.history.replaceState(window.history.state?._current?.[window.history.state?._lastKey] || {}, window.history.state?._lastKey|| "", url.updateSearchParams({params: {highlight: null}}).toString());
			}
		},

		pulse() {
			setTimeout(() => {
				requestAnimationFrame(() => {
					this.elem.animate([
						{
							boxShadow: "0 0 0px 0px color-mix(in srgb-linear, var(--i-primary) 50%, transparent)",
							// easing: 'ease-in-out',
							offset: 0
						},
						{
							boxShadow: "0 0 4px 4px color-mix(in srgb-linear, var(--i-primary) 50%, transparent)",
							// easing: 'ease',
							offset: 0.15
						},
						{
							boxShadow: "0 0 4px 4px color-mix(in srgb-linear, var(--i-primary) 50%, transparent)",
							// easing: 'ease',
							offset: 0.85
						},
						{
							boxShadow: "0 0 0px 0px color-mix(in srgb-linear, var(--i-primary) 50%, transparent)",
							// easing: 'ease-out',
							offset: 1
						},
					], 4000);
				});
			}, 1000);
		},

		/**
		 * Event handler for changing the timescale
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		changeTimescale: function (e) {
			this.timescale = $(e.currentTarget).attr('data-timescale');
			this._toggleButtonRow( e, 'timescale');
		},

		/**
		 * Event handler for changing the chart type
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		changeChartType: function (e) {
			this.type = $(e.currentTarget).attr('data-type');
			this._toggleButtonRow( e, 'type' );
			this.checkType();
		},
		
		/**
		 * Check type
		 */
		checkType: function() {
			if ( this.type == 'Table' || this.type == 'PieChart' || this.type == 'GeoChart' ) {
				$(this.scope).find('[data-role="groupingButtons"] a.ipsButton').addClass('ipsButton--disabled');
			} else {
				$(this.scope).find('[data-role="groupingButtons"] a.ipsButton').removeClass('ipsButton--disabled');
			}
		},

		/**
		 * Track whether we've bound the updateUrl method
		 */
		updateUrlBound: false,

		/**
		 * Event handler for changing the filter
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Data object from the menu widget
		 * @returns {void}
		 */
		changeFilter: function (e, data = e.detail) {

			data.originalEvent.preventDefault();

			// Reset filters
			this._resetFilters();

			if( this.updateUrlBound === false )
			{
				$('[data-action="chartFilter"]').one( 'menuClosed', _.bind( this.fetchNewResults, this ) );
				this.updateUrlBound = true;
			}
		},

		/**
		 * Wrapper method for _updateUrl() so we only send request if needed
		 *
		 * @returns {void}
		 */
		fetchNewResults: function( e ) {
			this._updateURL();

			this.updateUrlBound = false;
		},

		/**
		 * Save the current filters
		 *
		 * @returns	{void}
		 */
		 saveFilters: function( event )
		 {
		 	// Init
		 	var identifier	= this.scope.closest('.ipsTabs__panel').closest('section').attr('id');
		 	var self		= this;
		 	var pieces		= [];

			_.each( this.storedValues.filters, function (value, idx ) {
				pieces.push( "chartFilters[" + idx + "]=" + value );
			});
			
			// Work in custom form filters
			$('#el' + this.identifier + 'CustomFiltersForm input[data-role="nodeValue"]').each( function () {
				pieces.push( 'customform_' + $(this).attr('name') + "=" + $(this).val() );
			});
			$('#el' + this.identifier + 'CustomFiltersForm select').each( function(){
				pieces.push( 'customform_' + $(this).attr('name') + '=' + $(this).val() );
			})
			
		 	var newFilters	= pieces.join('&');
		 	
		 	if ( this.timescale )
		 	{
			 	newFilters = newFilters + "&timescale=" + this.timescale;
		 	}

		 	// Are we on default panel or a custom one?
		 	if( !$( event.currentTarget ).attr('data-chartId') )
		 	{
		 		// When clicking on the save button, stop the chart from updating initially
		 		this._skipUpdate = true;

		 		// Then set an event handler for the form submission where we specify the chart title
		 		$('#el' + this.identifier + 'FilterSave_menu').one( 'submit', 'form', function( e ){
					if( $(this).attr('data-bypassValidation') ){
						return false;
					}

					// Hide the menu
					$(this)[0].closest("[popover]")?.hidePopover();

					var tabTitle = $(this).find('[name="custom_chart_title"]').val();

		 			e.preventDefault();

					ips.getAjax()( $(this).attr('action'), {
						data: $(this).serialize() + '&' + newFilters,
						type: 'post'
					} )
						.done( function (response, status, jqXHR) {
							// if this as saved to a report, the tab isn't visible so we redirect
							if (response.reportURL) {
								window.location.href = response.reportURL;
								return;
							}

							// Add the tab
							$('[data-ipsTabBar-contentArea="#' + identifier + '"]').find('[role="tablist"]').append(
								"<a href='" + response.tabHref + "' id='ipsTabs_" + response.tabId + "_" + response.chartId + "' class='ipsTabs__tab' title='" + tabTitle + "' role='tab' aria-controls='ipsTabs_" + response.tabId + "_" + response.chartId + "_panel' aria-selected='false'>" + tabTitle + "</a>"
							);

							// Add the new tab content area
							$('#' + identifier ).append(
								"<div id='ipsTabs_" + response.tabId + "_" + response.chartId + "_panel' class='ipsTabs__panel' role'tabpanel' aria-labelledby='ipsTabs_" + response.tabId + "_" + response.chartId + "' hidden></div>"
							);

						 	// Make sure we update URL correctly moving forward
						 	self._skipUpdate = false;

						 	// And trigger content change event
						 	$( document ).trigger( 'contentChange', [ self.scope ] );

						 	// Clear input field
						 	$('#el' + self.identifier + 'FilterSave_menu').find('[name="custom_chart_title"]').val( '' );

						 	// And then switch to the tab
						 	$('#' + response.tabId + "_" + response.chartId ).click();
						 	
						 	// And show a confirmation message that we saved.
						 	ips.ui.flashMsg.show( ips.getString('saved') );
						})
						.fail( function () {
							$(this).attr( 'data-bypassValidation', true ).submit();
						});
		 		});
		 	}
		 	else
		 	{
			 	// Send AJAX request to save report
				ips.getAjax()( this.scope.attr('data-chart-url') + '&saveFilters=1&chartId=' + $( event.currentTarget ).attr('data-chartId'), {
					data: newFilters,
					type: 'post'
				});

			 	// And update the chart
			 	this._updateURL();
			 	
			 	// And show a confirmation message that we saved.
			 	ips.ui.flashMsg.show( ips.getString('saved') );
		 	}
		 },

		/**
		 * Rename the current filters
		 *
		 * @returns	{void}
		 */
		renameFilters() {
			// Init
			const identifier = this.scope.closest('.ipsTabs__panel').closest('section').attr('id');

			// if we have no identifier, we're probably on the overview page. Wrapping the queries in an anonymous function allows us to only query if needed
			const titlefield = () => identifier ? $(`[data-ipsTabBar-contentArea="#${identifier}"] [role="tablist"] [aria-selected="true"]`) : this.scope.find('.ipsTitle');

			// Set an event handler for the form submission where we specify the chart title
			$('#el' + this.identifier + 'FilterRename_menu').on( 'submit', 'form', async function( e ){
				if( $(this).attr('data-bypassValidation') ){
					return false;
				}

				e.preventDefault();

				// Hide the menu
				$(this)[0].closest("[popover]")?.hidePopover();

				try {
					const {title} = await ips.fetch($(this).attr('action'), {
						data: $(this).serialize(),
						type: 'post'
					});

					titlefield().text(title);
				} catch (e) {
					Debug.error(e)
					$(this).attr( 'data-bypassValidation', true ).submit();
				}
			});
		},

		/**
		 * Searches for a specific value in the graph
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeSearch: function (e) {
			e.preventDefault();

			var form = $('#el' + this.identifier + 'Search_menu');

			this.storedValues.term = form.find('[name="search"]').val();

			this.scope.find('[data-role="searchSummary"]').text( this.storedValues.term );

			form.find('[data-role="clearSearchTerm"]').prop('hidden', !this.storedValues.term);
			
			form[0].closest("[popover]")?.hidePopover();

			this._updateURL();
		},

		/**
		 * Resets our search term
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		resetSearch: function (e) {
			$('#el' + this.identifier + 'Search_menu').find('[name="search"]').val( '' );

			// The event bubbles up since this is a "submit" button, and changeSearch will be called next
		},

		/**
		 * Changes the range of the graph being shown
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeDateRange: function (e) {
			const identifier = this.elem.querySelector('[data-action="chartDate"]')?.id;
			if (identifier && !e.target?.closest(`#${identifier}_menu`)) {
				return;
			}
			e.preventDefault();

			var form = $('#el' + this.identifier + 'Date_menu');

			this.storedValues.dates.start = form.find('[name="start"]').val();
			this.storedValues.dates.end = form.find('[name="end"]').val();

			form[0].closest("[popover]")?.hidePopover();

			if( this.storedValues.dates.start && this.storedValues.dates.end )
			{
				this.scope.find('[data-role="dateSummary"]').text( '(' + ips.getString('betweenXandX', { start: ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( this.storedValues.dates.start ) ) ), end: ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( this.storedValues.dates.end ) ) ) }) + ')' );
			}
			else if( this.storedValues.dates.start )
			{
				this.scope.find('[data-role="dateSummary"]').text( '(' + ips.getString('afterX', { start: ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( this.storedValues.dates.start ) ) ) }) + ')' );
			}
			else if( this.storedValues.dates.end )
			{
				this.scope.find('[data-role="dateSummary"]').text( '(' + ips.getString('beforeX', { end: ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( this.storedValues.dates.end ) ) ) }) + ')' );
			}
			else
			{
				this.scope.find('[data-role="dateSummary"]').text( '' );
			}

			this._updateURL();
		},

		/**
		 *
		 * @param {CustomEvent<{dateFilters: {start: null|string, end: null|string, range: null|string|number}}>}e
		 */
		globalDateRangeSet(e) {
			let {start, end, range} = e?.detail?.dateFilters || {};
			if (!start && !end && !range) {
				return;
			}

			if (range) {
				const days = parseInt(range);
				if (Number.isNaN(days)) {
					throw new RangeError(`Expected range to be an integer representing a number of days`);
				} else if (days >= 0) {
					end = Math.round(Date.now() / 1000);
					start = days > 0 ? end - (86400 * days) : 0; // we get 'all time' in this case
				}
			}

			if (typeof start === 'string') {
				start = Math.round((new Date(start)).getTime() / 1000);
			}

			if (typeof end === 'string') {
				end = Math.round((new Date(end)).getTime() / 1000);
			}

			if (Number.isNaN(start) || Number.isNaN(end)) {
				throw new RangeError(`Could not determine either the start or end of the interval`);
			}

			this.storedValues.dates.start = start;
			this.storedValues.dates.end = end;
			this.storedValues.dates.range = range;
			this._updateURL();
		},

		/**
		 * Method for toggling buttons and setting new values in the store
		 *
		 * @param 	{event} 	e 		Event object from the event handler
		 * @param 	{string} 	type 	The type being handled (timescale or type)
		 * @returns {void}
		 */
		_toggleButtonRow: function (e, type) {
			e.preventDefault();

			var val = $( e.currentTarget ).attr( 'data-' + type );

			this.scope.find('[data-' + type + ']')
				.removeClass('ipsButton--active')
				.removeAttr('data-selected')
				.filter('[data-' + type + '="' + val + '"]')
					.addClass('ipsButton--active')
					.attr('data-selected', true);

			this.storedValues[ type ] = val;

			// Reset filters
			this._resetFilters();

			this._updateURL();
		},

		/**
		 * Reset our stored filters to only include what we presently have selected
		 *
		 * @return {void}
		 */
		_resetFilters: function() {
			// Reset filters
			var self = this;
			this.storedValues.filters = [];

			$('#el' + this.identifier + 'Filter_menu').find('[aria-selected="true"]').each( function () {
				self.storedValues.filters.push( $( this ).attr('data-ipsMenuValue') );
			});
		},

		_skipUpdate: false,

		/**
		 * Fetches new chart HTML from the server, then reinits the chart widget
		 *
		 * @returns {void}
		 */
		_updateURL: function () {
			// We skip updating the chart when clicking over to the save button the first time
			if( this._skipUpdate === true )
			{
				this._skipUpdate = false;
				return;
			}

			var url = this._buildURL();
			var chartArea = this.scope.find('[data-role="chart"]');
			chartArea.css( 'height', chartArea.height() ).html( '' ).addClass('ipsLoading');

			ips.getAjax()( this.scope.attr('data-chart-url'), {
				data: url,
				type: 'post'
			})
				.done( function (response) {
					chartArea.css( 'height', 'auto' ).html( response );
					$( document ).trigger( 'contentChange', [ chartArea ] );
				})
				.always( function () {
					chartArea.removeClass('ipsLoading');
				});

			// Update download button URL
			this.scope.find('[data-role="downloadChart"]').attr('href', this.scope.attr('data-chart-url') + '&' + url + '&download=1');
		},

		/**
		 * Builds a query param based on the values we have stored
		 *
		 * @returns {string}
		 */
		_buildURL: function () {
			const params = new URLSearchParams();

			// Needed for dynamic chart buttons. We can't simply rely on checking request isAjax() as it could be loaded inside tabs etc.
			params.set('noheader', '1');
			
			// Timescale
			params.set(`timescale[${this.identifier}]`, this.storedValues.timescale);

			// Type
			if ('type' in this.storedValues) {
				params.set(`type[${this.identifier}]`, this.storedValues.type);
			}

			// Term
			if (this.storedValues.term !== undefined && this.storedValues.term !== null) {
				params.set(`search[${this.identifier}]`, this.storedValues.term);
			}

			// Filters
			if (this.storedValues.filters && Symbol.iterator in this.storedValues.filters) {
				let idx = 0;
				for (const value of this.storedValues.filters) {
					params.set(`filters[${this.identifier}][${idx++}]`, value);
				}
			}

			// Dates
			if (this.storedValues.dates.start || this.storedValues.dates.end) {
				params.set(`start[${this.identifier}]`, this.storedValues.dates.start);
				params.set(`end[${this.identifier}]`, this.storedValues.dates.end);
			}

			// For the mycharts page, we handle this a bit differently as all the charts use the same date range
			if (document.body.dataset.pagecontroller === 'mycharts' && document.body.dataset.pageapp === 'core' && document.body.dataset.pagemodule === 'overview') {
				if (this.storedValues.dates.range) {
					params.set('predate', this.storedValues.dates.range);
				}

				if ((!this.storedValues.dates.range || parseInt(this.storedValues.dates.range) === -1) && (this.storedValues.dates.start || this.storedValues.dates.end)) {
					params.delete('predate');
					params.set('date[start]', this.storedValues.dates.start || null);
					params.set('date[end]', this.storedValues.dates.end || null);
				}
			}
			
			// Work in custom form filters
			$('#el' + this.identifier + 'CustomFiltersForm input[data-role="nodeValue"]').each( function () {
				params.set( 'customform_' + $(this).attr('name'), $(this).val() );
			});
			$('#el' + this.identifier + 'CustomFiltersForm select').each( function () {
				params.set( 'customform_' + $(this).attr('name'), $(this).val() );
			});

			return params.toString();
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.editable.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.editable.js - Inline editing support
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.editable', {

		_editTimeout: null,
		_editing: false,

		initialize: function () {
			this.on( 'mousedown', this.editMousedown );
			this.on( 'mouseup mouseleave', this.editMouseup );
			this.on( 'click', this.editMouseclick );
			this.on( 'click', '[data-role="edit"]', this.clickEdit );
			this.setup();
		},
		
		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			var defaultFill = this.scope.attr('data-default');
			// If this is a touch device, remove the highlight class and show the button
			if( ips.utils.events.isTouchDevice() || ( ! _.isUndefined( defaultFill ) && defaultFill == 'empty' ) ) {
				this.scope.removeClass('ipsType_editable').find('[data-role="edit"]').show();
			}
		},

		/**
		 * Handles a click on the Edit button
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		clickEdit: function (e) {
			e.preventDefault();
			this._triggerEdit();
		},

		/**
		 * Event handler called when the user clicks down an editable text area
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editMousedown: function (e) {
			var self = this;

			if( e.which !== 1 ){ // Only care if it's the left mouse button
				return;
			}

			this._editTimeout = setTimeout( _.bind( this._triggerEdit, this ), 1000);
		},
		
		/**
		 * Event handler called when the user clicks up an editable title
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editMouseup: function (e) {
			clearTimeout( this._editTimeout );
		},
		
		/**
		 * Event handler called when the user clicks up an editable title
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editMouseclick: function (e) {
			if ( this._editing ) {
				e.preventDefault();
			}
		},

		/**
		 * Transforms our scope element into an editable text field
		 *
		 * @returns {void}
		 */
		_triggerEdit: function () {
			var self = this;

			this._editing = true;
			clearTimeout( this._editTimeout );
			
			var span = this.scope;
			var url = span.attr('data-url');
			var textField = span.find('[data-role="text"]');
			var fieldName = span.find('[data-name]').attr('data-name');
			var defaultFill = span.attr('data-default');
			span.hide();
			
			var defaultText = ( _.isUndefined( defaultFill ) || defaultFill != 'empty' ) ? textField.text().trim() : '';
			var inputNode = $('<input/>').attr( { type: 'text' } ).attr( 'data-role', 'editField' ).val( defaultText );

			span.after(inputNode);
			inputNode.focus();
			
			inputNode.on('blur', function(){
				inputNode.addClass('ipsField_loading');
				if( inputNode.val() == '' ){
					inputNode.remove();
					span.show();
					self._editing = false;
				} else {
					var dataToSend = {};
					dataToSend[fieldName] = inputNode.val();

					ips.getAjax()( url, { method: 'post', data: dataToSend } )
						.done( function(response) {
							textField.text( inputNode.val() );
						})
						.fail( function(response) {
							ips.ui.alert.show( {
								type: 'alert',
								icon: 'warn',
								message: response.responseJSON,
							});
						})
						.always(function(){
							inputNode.remove();
							span.show();
							self._editing = false;
						});
				}

			});
			
			inputNode.on('keypress', function(e){
				if( e.keyCode == ips.ui.key.ENTER ){
					e.stopPropagation();
					e.preventDefault();
					inputNode.blur();
					return false;
				}
			});

			// Chrome requires checking keydown instead for escape
			inputNode.on('keydown', function(e){
				if( e.keyCode == ips.ui.key.ESCAPE ){
					inputNode.remove();
					span.show();
					self._editing = false;
					return false;
				}
			});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.editorRestrictions.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.editorRestrictions.js - AdminCP > Settings > Posting > Sandboxed and Advanced Editor Modes
 *
 * Author: Matt Finger
 */
;( function($, _){
    "use strict";


    /**
     * @typedef {{[p:number|"removed"]: string[]}} RestrictionSettings
     */
    ips.controller.register('core.admin.core.editorRestrictions', {
        /**
         * @type {string[]}
         */
        _restrictions: [],
        _restrictionDefaults: {},

        initialize() {
            if (!this._getHeader() || !this._getTextarea()) {
                return;
            }

            this.hideRealElements();
            // many extensions are registered after this event
            document.dispatchEvent(new CustomEvent('ips:editorBeforeInit', {
                detail: {
                    textarea: null,
                    elem: null,
                    content: "",
                    options: {}
                },
                bubbles: true,
            }));
            ips.ui.editorv5
                .getExtensionRestrictions(true)
                .then(
                    restrictions => this.addFormElements(restrictions)
                );

            this.elem.addEventListener('input', e => this.updateTextarea(e));
        },

        /**
         * Hide the real elements
         *
         * @returns {void}
         */
        hideRealElements() {
            this._getHeader()?.setAttribute('hidden', '');
            this._getTextarea()?.closest('.ipsFieldRow')?.setAttribute('hidden', '');
        },

        /**
         * Get the header
         * @return {HTMLElement|null}
         * @private
         */
        _getHeader() {
            return this.elem.querySelector( "#form_header_editor_extensions" );
        },

        /**
         * Get the textarea
         * @return {HTMLTextAreaElement|null}
         * @private
         */
        _getTextarea() {
            return this.elem.querySelector("textarea#el_editor_extension_restrictions_input, #el_editor_extension_restrictions_input textarea");
        },

        /**
         * Fill the form elements by loading select elements from the back end
         *
         * @param   {([string, int])[]} restrictions
         *
         * @return {Promise<void>}
         */
        async addFormElements(restrictions) {
            this._restrictions = restrictions.map(r => r[0]);
            this._restrictionDefaults = Object.fromEntries(restrictions);
            if (!restrictions.length) {
                return;
            }

            try {
                const content = await ips.fetch("/admin/?app=core&module=settings&controller=posting&do=getRestrictionInput", {
                    data: {
                        restrictionKey: this._restrictions.join(','),
                        restrictionDefault: JSON.stringify(Object.fromEntries(restrictions)),
                        restrictionLang: JSON.stringify(this._restrictions.map(restriction => ips.getString(restriction))),
                        restrictionDesc: JSON.stringify(this._restrictions.map(restriction => ips.haveString(restriction + ':description') ? ips.getString(restriction + ":description") : ""))
                    }
                });

                if (!content?.content || typeof content.content !== 'string') {
                    throw new TypeError(`content.content is not a string or is an empty string, so it cannot be added to the form`);
                }

                this._getHeader().removeAttribute('hidden');
                const clean = (new DOMParser()).parseFromString(content.content, 'text/html').body;
                let lastNode = this._getHeader();
                clean.querySelectorAll(':scope > *').forEach(node => {
                    lastNode.after(node);
                    lastNode = node;
                })
            } catch (e) {
                Debug.error(e);
            }
        },

        /**
         * Update the textarea based on an input event for an editor input
         *
         * @param {InputEvent}    e
         */
        updateTextarea(e) {
            const name = e.target.getAttribute('name');
            if (!name?.match(/^ipsCustom(?:Node|Mark|Extension)__/)) {
                return
            }

            /**
             * @type {RestrictionSettings}
             */
            const restrictionSetting = JSON.parse(this._getTextarea().innerText || '{}');
            restrictionSetting.removed = restrictionSetting.removed || []
            let value = parseInt(e.target.value);

            if ([-1,0,1,2].includes(this._restrictionDefaults[name]) && this._restrictionDefaults[name] === value) {
                // if this is just the default value, we can remove it from the list
                restrictionSetting.removed.push(name);
                value = Number.NaN;

            } else if ([0,1,2,-1].includes(value) && !(value.toString() in restrictionSetting)) {
                // there's a chance no other restrictions have this value, in which case we need to add it
                restrictionSetting[value.toString()] = [name];
            }

            for (const level in restrictionSetting) {
                if (level === 'removed') {
                    continue;
                }
                if (parseInt(level) === value && !Number.isNaN(value)) {
                    if (!restrictionSetting[level].includes(name)) {
                        restrictionSetting[level].push(name)
                    }
                } else if (restrictionSetting[level].includes(name)) {
                    restrictionSetting[level] = restrictionSetting[level].filter(restriction => restriction !== name);
                }

                // let's also filter to make sure they correspond to real settings. It's worth cleaning this up here to avoid a 10kb restriction array years down the road
                restrictionSetting[level] = restrictionSetting[level].filter(restriction => {
                    if (restriction.match(/^ipsCustom(Node|Mark|Extension)__/) && !this._restrictions.includes(restriction)) {
                        if (!restrictionSetting.removed.includes(restriction)) {
                            restrictionSetting.removed.push(restriction)
                        }
                        return false;
                    }
                    return true;
                })
            }

            this._getTextarea().innerText = JSON.stringify(restrictionSetting);
            this._getTextarea().setAttribute('value', this._getTextarea().innerText);
        }
    });
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.genericDialog.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.genericDialog.js - A controller that can be used so that forms inside dialogs submit via ajax
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.genericDialog', {

		initialize: function () {
			this.on( 'submit', 'form', this.submitAjaxForm );
			$( document ).on( 'multipleRedirectFinished', _.bind( this.dismissDialog, this ) );
		},

		/**
		 * Event handler for form submit
		 * If the form is inside a dialog widget, this method will attempt to validate the form remotely
		 * If it fails, the dialog is updated with new HTML from the server. On success, the form is submitted
		 * as normal.
		 *
		 * @returns {void}
		 */
		submitAjaxForm: function (e) {
						
			if( $( e.currentTarget ).attr('data-bypassValidation') ){
				return;
			}
			
			e.preventDefault();

			var dialog = this.scope.closest('.ipsDialog');

			if( !dialog.length ){
				return;
			}

			// Get the dialog object so we can work with it
			var elemId = dialog.attr('id').replace(/_dialog$/, '');
			var dialogObj = ips.ui.dialog.getObj( $('#' + elemId) );

			if( !dialogObj ){
				return;
			}

			// Set the loading status
			dialogObj.setLoading(true);

			ips.getAjax()( $( e.currentTarget ).attr('action') + '&ajaxValidate=1', {
				data: $( e.currentTarget ).serialize(),
				type: 'post'
			})
				.done( function (response, textStatus, jqXHR) {					
					if( jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormError: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formerror: true') !== -1 ){
						dialogObj.updateContent( jqXHR.responseText );
						$( document ).trigger( 'contentChange', [ $('#' + elemId) ] );
						dialogObj.setLoading(false);
					} else if( jqXHR.getAllResponseHeaders().indexOf('X-IPS-FormNoSubmit: true') !== -1 || jqXHR.getAllResponseHeaders().indexOf('x-ips-formnosubmit: true') !== -1 ){
						dialogObj.updateContent( jqXHR.responseText );
						$( document ).trigger( 'contentChange', [ $('#' + elemId) ] );
						dialogObj.setLoading(false);
					} else {
						$( e.currentTarget ).attr('data-bypassValidation', true).submit();
					}
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					if( Debug.isEnabled() ){
						Debug.error( "Ajax request failed (" + status + "): " + errorThrown );
						Debug.error( jqXHR.responseText );
					} else {
						// rut-roh, we'll just do a manual submit
						$( e.currentTarget ).attr('data-bypassValidation', true).submit();
					}
				});
		},
		
		/**
		 * Event to dismiss the dialog
		 *
		 */
		dismissDialog: function (e) {
			var elemId = $('.ipsDialog').attr('id').replace(/_dialog$/, '');
			
			var dialogObj = ips.ui.dialog.getObj( $('#' + elemId) );
			dialogObj.hide();
			
			$( '#' + elemId ).data('_dialog', '')

		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.langString.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.langString.js - Faciliates editing language strings in the ACP translator
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.langString', {

		_url: null,
		_hideTimeout: null,
		_currentValue: '',

		initialize: function () {
			this.on( 'input', 'textarea', this.changeTextarea );
			this.on( 'focus', 'textarea', this.focusTextarea );
			this.on( 'blur', 'textarea', this.blurTextarea );
			this.on( 'click', '[data-action="saveWords"]', this.saveWords );
			this.on( 'click', '[data-action="revertWords"]', this.revertWords );	
			this.setup();
		},
		
		/**
		 * Setup method
		 * Replaces the scope element with a textbox containing the scope's HTML
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._url = this.scope.attr('data-saveURL');

			const contentRoot = this.elem.querySelector('[data-langcontent]');
			let contents;
			if (contentRoot) {
				const getText = node => (node instanceof Text ? [node.wholeText] : (node.childNodes?.length ? [...node.childNodes].map(getText) : [])).flat();
				contents = getText(contentRoot).join('');
			} else {
				contents = this.elem.innerText;
			}

			var html = ips.templates.render( 'languages.translateString', {
				value: contents
			});

			this._currentValue = contents;

			this.scope.html( html );

			// See if the current lang string is even different
			this.changeTextarea();
		},

		/**
		 * Event handler for changing the textarea value
		 *
		 * @returns {void}
		 */
		changeTextarea: function () {
			this.elem.querySelector('[data-action="saveWords"]').disabled = this._currentValue === this.elem.querySelector('textarea').value
		},

		/**
		 * Event handler for focusing the textarea
		 *
		 * @returns {void}
		 */
		focusTextarea: function () {
			this.scope
				.addClass('cTranslateTable_field_focus')
				.find('textarea')
					.removeClass('ipsField_success')
				.end()
				.find('[data-action]')
					.show();
		},

		/**
		 * Event handler for blurring the textarea
		 * Sets a timeout which hides the buttons in 300ms
		 *
		 * @returns {void}
		 */
		blurTextarea: function () {
			this._saveWords(true);
		},

		/**
		 * Hides the buttons
		 *
		 * @returns {void}
		 */
		_hideButtons: function (e) {
			this.scope.removeClass('cTranslateTable_field_focus');
		},

		/**
		 * Event handler for clicking the save button
		 *
		 * @returns {void}
		 */
		saveWords: function (e) {
			e.preventDefault();
			this._saveWords(false);			
		},

		_saveWords: function (hideButtonsImmediately) {
			var self = this;
			var url = this._url + '&form_submitted=1&csrfKey=' + ips.getSetting('csrfKey');
			var textarea = this.scope.find('textarea');
			var value = textarea.val();

			// Don't save if the value hasn't changed
			if( this._currentValue == value ){
				this._hideButtons();
				return;
			}

			// Remove timeout for hiding buttons
			if( this._hideTimeout ){
				clearTimeout( this._hideTimeout );
			}

			this.elem.querySelector('[data-action="saveWords"]').disabled = true;

			// Send the translated string, and show flash message on success
			// On failure we'll reload the page
			ips.getAjax()( url, { type: 'post', data: { lang_word_custom: encodeURIComponent( value ) } } )
				.done( function() {
					textarea
						.removeClass('ipsField_loading')
						.addClass('ipsField_success');

					ips.ui.flashMsg.show( ips.getString('saved') );

					if( !hideButtonsImmediately ){
						self._hideTimeout = setTimeout( _.bind( self._hideButtons, self ), 300 );	
					} else {
						self._hideButtons();
					}

					self._currentValue = value;	
				})
				.fail( function () {
					window.location = url;
				});
		},

		revertWords: function (e) {

		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.liveSearch.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.liveSearch.js - ACP livesearch controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.liveSearch', {
		_textField: null,
		_searchMenu: null,
		_resultsContainer: null,
		_lastValue: '',
		_results: {},
		_modal: null,
		_activePanel: null,
		_ajax: {},
		_defaultTab: null,

		initialize: function () {
			this.setup();

			this.on( document, 'click', '.ipsModal', this.clickModal );
			this.on( document, 'click', '[data-role="closeLiveSearch"]', this.clickCloseButton );
			this.on( 'itemClicked.sideMenu', this.changeSection );
		},

		setup: function () {
			this._searchMenu = this.scope.find('[data-role="searchMenu"]');
			this._resultsContainer = this.scope.find('[data-role="searchResults"]');
			this._defaultTab = this.scope.find('[data-role="defaultTab"]').attr('data-ipsMenuValue');
			this._textField = $('#acpSearchKeyword');
			this._textField
				.prop( 'autocomplete', 'off' )
				.prop( 'spellcheck', false )
				.attr( 'aria-autocomplete', 'list' )
				.attr( 'aria-haspopup', 'true' );

			// Is there an active panel?
			this._activePanel = this._searchMenu.find('.ipsSideMenu_itemActive').attr('data-ipsMenuValue');

			this._textField.on('input', () => this.refresh());
		},

		/**
		 * Event handler for the itemClicked event fired by the sideMenu widget
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		changeSection: function (e, data) {
			this._activePanel = data.selectedItemID;

			this._showResultsInPanel( this._activePanel, this._results[ this._activePanel ] );
		},

		/**
		 * Event handler for clicking the modal
		 * We have to check this is our modal by comparing IDs. If it is, we close the results.
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		clickModal: function (e) {
			if( this._modal == null || $( e.currentTarget ).attr('id') != this._modal.attr('id') ){
				return;
			}

			this._hideResults();
		},

		/**
		 * Event handler for clicking the close icon (useful for mobiles)
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		clickCloseButton: function (e) {
			this._hideResults();
		},

		/**
		 * Timer callback from this.fieldFocus
		 * Compares current value to previous value, and shows/loads new results if it's changed
		 *
		 * @returns {void}
		 */
		refresh: function () {
			var currentValue = this._textField.val().trim();

			if (currentValue === this._lastValue || this._textField.val().trim().length < 3) {
				return;
			}

			this._lastValue = currentValue;

			this._showResults();
			this._showLoading();
			this._loadResults();
		},

		/**
		 * Hides the results and modal
		 *
		 * @returns {void}
		 */
		_hideResults: function () {
			ips.utils.anim.go( 'fadeOut fast', this._modal );
			ips.utils.anim.go( 'fadeOut', this.scope );
		},

		/**
		 * Shows the results panel and modal, setting the zIndex on them so they stay in order
		 *
		 * @returns {void}
		 */
		_showResults: function () {
			if( !this._modal ){
				this._buildModal();
			}

			// Set new z-indexes to keep everything in order
			this._modal.css( { zIndex: ips.ui.zIndex() } );
			$('#ipsLayout_header').css( { zIndex: ips.ui.zIndex() } );
			this.scope.css( { zIndex: ips.ui.zIndex() } );

			// Show the results and or modal
			if( !this.scope.is(':visible') ){
				ips.utils.anim.go( 'fadeIn fast', this.scope );
			}

			if( !this._modal.is(':visible') ){
				ips.utils.anim.go( 'fadeIn fast', this._modal );
			}
		},

		_showLoading() {
			var self = this;

			this.scope.find( '[data-ipsMenuValue] [data-role="resultCount"]' ).addClass('ipsLoading').html('&nbsp;');
			this.scope.find( '[data-ipsMenuValue] [data-role="resultCount"]' ).removeClass('ipsLoading_dark ipsSideMenu_clearCount');
			this.scope.find( '[data-ipsMenuValue].ipsSideMenu_itemActive [data-role="resultCount"]' ).addClass('ipsLoading_dark ipsSideMenu_clearCount');

			this.scope.find('[data-ipsMenuValue]').each( function() {
				const key = $( this ).attr('data-ipsMenuValue');
				self._setPanelToLoading( key );
			});
		},

		/**
		 * Load results from the server
		 *
		 * @returns {void}
		 */
		_loadResults: _.debounce(function () {
			var self = this;

			// Abort any requests running now
			if( _.size( this._ajax ) ){
				_.each( this._ajax, function (ajax) {
					try {
						if( _.isFunction( ajax.abort ) ) {
							ajax.abort();
							Debug.log('aborted ajax');
						}
					} catch (err) { }
				});
			}

			this.scope.find( '[data-ipsMenuValue] [data-role="resultCount"]' ).addClass('ipsLoading').html('&nbsp;');

			var value = this._lastValue.trim();

			this.scope.find('[data-ipsMenuValue]').each( function () {
				var tab = this;
				var key = $( this ).attr('data-ipsMenuValue');

				self._ajax[ key ] = ips.getAjax()('?app=core&module=system&controller=livesearch', {
					dataType: 'json',
					data: {
						search_key: key,
						search_term: encodeURIComponent( value )
					}
				}).done( function (response) {

					self._results[key] = response;

					$( tab )
						.find('[data-role="resultCount"]')
						.removeClass('ipsLoading')
						.text( parseInt( response.length ) )
						.end()
						.toggleClass( 'ipsSideMenu_itemDisabled', ( response.length === 0 ) ? true : false );

					if( $( tab ).attr('data-ipsMenuValue') == self._activePanel ){
						self._showResultsInPanel( self._activePanel, response, true );
					}

					if( !self._searchMenu.find('[data-ipsMenuValue].ipsSideMenu_itemActive:not( .ipsSideMenu_itemDisabled )').length ) {
						self._selectFirstResultsTab();
					}
					if ( response.length > 0 && key == self._defaultTab && self._activePanel == self._defaultTab ) {
						tab.click();
					}
					delete self._ajax[key];
				}).fail( function (err) {
					// fail gets called when it's aborted, so deliberately do nothing here
				});
			});
		}, 700),

		/**
		 * Selects the first section that has some results to show
		 *
		 * @returns {void}
		 */
		_selectFirstResultsTab: function () {
			var first = this._searchMenu.find('[data-ipsMenuValue]:not( .ipsSideMenu_itemDisabled )').first();
			first.click();
		},

		/**
		 * Sets the given panel into loading state
		 *
		 * @returns {void}
		 */
		_setPanelToLoading: function (panel) {
			var panelContainer = this._resultsContainer.find('[data-resultsSection="' + panel + '"]');
			panelContainer.addClass('ipsLoading').find('> ol').hide();
		},

		/**
		 * Shows the results in the relevant panel, building it if it doesn't exist
		 *
		 * @param 	{string}	panel 		Panel ID
		 * @param 	{object}	results 	Results object
		 * @param 	{booolean}	animate		Animate the results being shown?
		 * @returns {void}
		 */
		_showResultsInPanel: function (panel, results, animate) {

			// Hide all panels
			this._resultsContainer.find('[data-resultsSection]').hide();

			var panelContainer = this._resultsContainer.find('[data-resultsSection="' + panel + '"]');
			var panelList = panelContainer.find('> ol');

			// Build the container if needed
			if( !panelContainer.length ){
				this._buildResultsContainer( panel );
				panelContainer = this._resultsContainer.find('[data-resultsSection="' + panel + '"]');
				panelList = panelContainer.find('> ol');
			}

			panelContainer.removeClass('ipsLoading');
			panelList.hide().html('');

			// Any results to show?
			if( _.isUndefined( results ) || _.isUndefined( results ) || _.size( results ) == 0 ){
				// No results
				panelList.html( ips.templates.render('core.livesearch.noResults') ).show();
				return;
			}

			// Loop through each result to build it
			_.each( results, function (val) {
				panelList.prepend( val );
			});

			// Find all results
			var resultItems = panelList.find('[data-role="result"]').hide();
			var delay = 25;

			panelList.show();
			panelContainer.show();

			if( animate == true ){
				resultItems.each( function () {
					var item = $( this );

					setTimeout( function () {
						ips.utils.anim.go( 'fadeIn fast', item );
					}, delay);

					delay += 25;
				});
			} else {
				resultItems.show();
			}
		},

		/**
		 * Builds a results container
		 *
		 * @param 	{string} 	panel 	Panel ID
		 * @returns {void}
		 */
		_buildResultsContainer: function (panel) {
			this._resultsContainer.prepend(
				$('<div/>')
					.attr('data-resultsSection', panel )
					.addClass('ipsScrollbar')
					.append( $('<ol/>')
					)
			);
		},

		/**
		 * Builds the modal element
		 *
		 * @returns {void}
		 */
		_buildModal: function () {
			this._modal = ips.ui.getModal();
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.mobileNav.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.mobileNav.js - ACP mobile navigation
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.mobileNav', {

		initialize: function () {
			this.on( 'click', '[data-action="mobileSearch"]', this.mobileSearch );
			this.on( document, 'click', '[data-role="clearCaches"]', this.clearCaches );
		},

		/**
		 * Mobile search; simply adds a class to the body. CSS shows the search box.
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		mobileSearch: function (e) {
			e.preventDefault();

			if( $('body').hasClass('acpSearchOpen') ){
				$('body').find('.ipsModal').trigger('click');
			}

			$('body').toggleClass('acpSearchOpen');
		},

		/**
		 * Callback when we click the "clear caches" button.
		 *
		 * @returns {void}
		 */
		clearCaches: function( e ) {
			e.preventDefault();
			var button = this.scope.find('[data-role="clearCaches"]');

			if( button.hasClass( 'ipsButton--disabled' ) ) {
				return;
			}

			var self = this;
			ips.getAjax()( '?app=core&module=support&controller=support&do=clearCaches' )
				.done( function( response ) {
					ips.ui.flashMsg.show( ips.getString( 'health_caches_cleared' ) );
				})
				.always( function() {
					self.scope.find('[data-role="clearCaches"]').removeClass( 'ipsButton--disabled' );
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.nav.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.nav.js - AdminCP Nav
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.admin.core.nav', {

		_reordering: false,
		_orderChanged: false,
		_currentMenu: null,
		_menuTimer: null,

		initialize: function () {
			this.setup();

			this.on( document, 'click', '#acpMainArea', this.clickMainArea );
			this.on( 'click', '[data-action="reorder"]', this.startReorder );
			this.on( 'click', '[data-action="saveOrder"]', this.saveOrder );
		},

		setup: function () {
			const self = this;
			let activating;

			this._currentMenu = this.scope.find('.acpAppList_active');

			if( ips.utils.responsive.enabled() && ips.utils.events.isTouchDevice() && ips.utils.responsive.currentIs('tablet') ){
				this.on('click', '> li > a', this.handleTouchMenu);
			} else {
				$('#acpAppMenu').menuAim({
					rowSelector: "> #acpAppList > li:not( #elLogo )",
					enter: function (row) {
						if( $( row ).attr('id') === 'elReorderAppMenu' || $( row ).attr('id') === 'elHideMenu' ){
							activating = self.scope.find('.acpAppList_active');
						}

						if( self._menuTimer ){
							clearTimeout( self._menuTimer );
						}
					},
					activate: function (row) {
						if( $( row ).attr('id') === 'elReorderAppMenu' || $( row ).attr('id') === 'elHideMenu' ){
							activating.addClass('acpAppList_active');
						} else {
							$( row ).addClass('acpAppList_active');
						}
					},
					deactivate: function (row) {
						$( row ).removeClass('acpAppList_active');
					},
					exitMenu: function () {
						self._menuTimer = setTimeout( function () {
							self.scope.find('.acpAppList_active').removeClass('acpAppList_active');
							self._currentMenu.addClass('acpAppList_active');
						}, 2000 );

						return false;
					}
				});
			}
		},

		/**
		 * Event handler for touch devices; shows the sub menu on first tap
		 *
		 * @param {Event} e
		 *
		 * @returns 	{void}
		 */
		handleTouchMenu(e) {
			// If we've already activated it, just go to the link
			if( $( e.currentTarget ).hasClass('acpAppList_active') && $( e.currentTarget ).find('> .acpAppList__sub:visible').length ){
				return;
			}

			e.preventDefault();

			// Otherwise, deactivate other menus, show this one
			this.scope.find('.acpAppList_active').removeClass('acpAppList_active').find('> .acpAppList__sub').hide();
			$( e.currentTarget )
				.closest('li')
					.addClass('acpAppList_active')
					.find('> .acpAppList__sub').show();
		},

		/**
		 * Hides the submenu when the main body is clicked on
		 *
		 * @returns 	{void}
		 */
		clickMainArea() {
			if( ips.utils.responsive.enabled() && ips.utils.events.isTouchDevice() && ips.utils.responsive.currentIs('tablet') ){
				this.scope.find('.acpAppList_active .acpAppList__sub').hide();
			} else {
				if( !this._reordering ){
					$('#acpAppList')
					.removeClass('acpAppList_childHovering')
					.find('> li')
						.trigger('mouseleave');
				}
			}
		},

		/**
		 * Starts the tab reordering interface by building drag handles for each tab
		 * and setting up sortable
		 *
		 * @returns 	{void}
		 */
		startReorder() {
			const self = this;

			this.scope.find('> li:not( #elReorderAppMenu ):not( #elHideMenu ) > a').each( function () {
				$( this ).append( ips.templates.render('core.appMenu.reorder') );
			});

			this.scope.find('> li > ul > li h3').each( function () {
				$( this ).prepend( ips.templates.render('core.appMenu.reorder') );
			});

			ips.utils.anim.go( 'zoomIn', this.scope.find('[data-role="reorder"]') );

			this.scope
				.addClass('acpAppList_reordering')
				.sortable({
					start(e, ui) {
						ui.item.addClass('acpAppList_dragging');
					},
					stop(e, ui) {
						ui.item.removeClass('acpAppList_dragging');
					},
					update() {
						self._orderChanged = true;
					}
				})
				.find('#elReorderAppMenu')
					.find('[data-action="reorder"]')
						.addClass('ipsHide')
					.end()
					.find('[data-action="saveOrder"]')
						.removeClass('ipsHide');

			this.getSubMenus()
				.sortable({
					start(e, ui) {
						ui.item.addClass('acpAppList_dragging');
					},
					stop(e, ui) {
						ui.item.removeClass('acpAppList_dragging');
					},
					update() {
						self._orderChanged = true;
					}
				});

			this._reordering = true;
			this._orderChanged = false;
		},

		/**
		 * Gets a jquery selector containing the submenus of the tab
		 * @param {string|undefined}	[tab]	the tab to get the submenu of
		 * @return {*}
		 */
		getSubMenus(tab) {
			return this.scope.find('> li[data-tab' + (tab ? `="${tab}"` : ``) + ']').find("> ul, > .acpAppList__sub > ul");
		},

		/**
		 * Saves the new order of tabs, sending an ajax request with the new order
		 *
		 * @returns 	{void}
		 */
		saveOrder() {
			// Remove drag handles
			this.scope.find('[data-role="reorder"]').remove();

			// Get serialized list
			const tabOrder = this.scope.sortable('toArray', {attribute: 'data-tab'}).filter(i => !!i);
			const menuOrder = {};
			const self = this;

			// Get each submenu
			_.each( tabOrder, function (val) {
				if( val ){
					menuOrder[ val ] = self.getSubMenus(val).sortable( 'toArray', { attribute: 'data-menuKey' } )?.filter(i => !!i); // the first submenu item is an invisible header which is sorted as "".
					if (!Array.isArray(menuOrder[val])) {
						// delete menuOrder[val];
						ips.ui.alert.show({
							icon: 'warning',
							message: ips.getString('tab_order_not_saved')
						});
						throw new TypeError(`Couldn't get the submenu sortable`);
					}
				}
			});

			// Switch tbe buttons around
			this.scope
				.removeClass('acpAppList_reordering')
				.find('#elReorderAppMenu')
					.find('[data-action="reorder"]')
						.removeClass('ipsHide')
					.end()
					.find('[data-action="saveOrder"]')
						.addClass('ipsHide');

			if( this._orderChanged ){
				ips.getAjax()('?app=core&module=system&controller=ajax&do=saveTabs', {
					data: {
						tabOrder,
						menuOrder
					},
					dataType: 'json',
					type: 'post'
				})
				.done(function () {
					ips.ui.flashMsg.show( ips.getString('tab_order_saved') );
				})
				.fail( function ( ) {
					ips.ui.alert.show({
						icon: 'warning',
						message: ips.getString('tab_order_not_saved')
					});
				});
			}
			this.scope.sortable( 'destroy' );
			this._reordering = false;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.nodeCopySetting.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.nav.js - AdminCP Nav
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.nodeCopySetting', {

		initialize: function () {
			this.on( 'click', this.click );
		},

		/**
		 * Handles clicks
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		click: function (e) {
			/*var value = null;
			ips.getAjax()( this.scope.closest('form').attr('action') + '&massChangeValue=' + this.scope.attr('data-field'), {
				async: false,
				data: this.scope.closest('form').serialize(),
				type: 'post'
			}).done( function (response, textStatus, jqXHR) {					
				value = response;
			});*/

			e.preventDefault();
		
			if( this.scope.next().hasClass('ipsSelectTree') )
			{
				var vals = this.scope.next('.ipsSelectTree').find("input").first().val();
			}
			else
			{
				var vals = '';
				
				if( this.scope.next().hasClass('ipsField_stack') ) {
					var valArray = [];
					this.scope.next().find('input:not([type=hidden]):not([type=submit]),textarea,select').each(function(){
						if ( $(this).attr('type') == 'checkbox' ) {
							valArray.push( $(this).is(':checked') ? 1 : 0 );
						} else {
							valArray.push( $(this).val() );
						}
					})
					vals = valArray.join(',');
				}
				else if( this.scope.next().hasClass('ipsField_autocomplete') ) {
					if( $('#' + this.scope.data('field')).is( ':checked ') ) {
						vals = this.scope.nextAll("input:not([type=hidden]),textarea,select").first().val();
					}
					else {
						vals = $( 'input[name="' + this.scope.data('field') + '"]' ).val();
					}
				}
				else {
					var input = this.scope.nextAll("input:not([type=hidden]),textarea,select").first();

					// Check if there's an unlimited checkbox here
					if( $('#' + this.scope.attr('data-field') + "-unlimitedCheck:checked" ).length ){
						vals = "-1";
					} else if ( input.attr('type') == 'checkbox' ) {
						vals = input.is(':checked') ? 1 : 0;
					} else {
						vals = input.val();
					}
				}
			}
			
			var dialogRef = ips.ui.dialog.create({
				title: this.scope.attr('_title'),
				url: this.scope.attr('data-baseLink'),
				forceReload: true,
				fixed: false,
				ajax: { type: 'post', data: { value: vals } }
			});
			dialogRef.show();
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.notificationMenu.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.notificationMenu.js - Controller for the notification menu icon
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.core.notificationMenu', {

		initialize: function () {
			this.on( document, 'menuOpened', this.menuOpened );
			$('body').on( 'updateNotificationCount', this.updateNotificationCount );
			this.setup();
		},
		
		setup: function () {
			var notificationCount = parseInt( this.scope.find('[data-role="notificationCount"]').text() );
			if ( isNaN( notificationCount ) ) {
				notificationCount = 0;
			}
			
			var storedNotificationCount = parseInt( ips.utils.cookie.get('acpNotificationCount') );
			if ( isNaN( storedNotificationCount ) ) {
				storedNotificationCount = 0;
			}
									
			if ( notificationCount > storedNotificationCount ) {
				setTimeout(function(){
					$(this.scope).find('[data-role="notificationIcon"]').addClass('cAcpNotifications_animate');
				}.bind(this), 800 );
			}

			ips.utils.cookie.set( 'acpNotificationCount', notificationCount );
		},
		
		loaded: false,
		menuOpened: function (e, data = e.detail) {
			if( !this.loaded ){
				var self = this;
				var ajaxObj = ips.getAjax();
				
				$('[data-role="notificationList"]')
					.html('')
					.css( { height: '100px' } )
					.addClass('ipsLoading');

				ajaxObj( '?app=core&module=overview&controller=notifications', { dataType: 'json' } )
					.done( function (returnedData) {
	 					
	 					// Add this content to the menu
						$('[data-role="notificationList"]')
							.css( { height: 'auto' } )
							.removeClass('ipsLoading')
							.html( returnedData.data );

						// Remember we've loaded it
						self.loaded = true;

						$( document ).trigger( 'contentChange', [ $('[data-role="notificationList"]') ] );
					});
			}
		},
		
		updateNotificationCount: function () {
			ips.getAjax()( '?app=core&module=overview&controller=notifications' ).done( function(response) {
				var count = parseInt( response.count );
				if ( count ) {
					$(this).find('[data-role="notificationCount"]').removeClass('ipsHide').text( count ).closest('.cAcpNotifications').addClass('cAcpNotifications_active');
				} else {
					$(this).find('[data-role="notificationCount"]').addClass('ipsHide').closest('.cAcpNotifications').removeClass('cAcpNotifications_active');
				}
			}.bind(this));
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/core" javascript_name="ips.core.tags.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * @brief        ips.core.tags
 * @author        <a href='https://www.invisioncommunity.com'>Invision Power Services, Inc.</a>
 * @copyright    (c) Invision Power Services, Inc.
 * @license        https://www.invisioncommunity.com/legal/standards/
 * @package        Invision Community
 * @subpackage
 * @since        3/4/2025
 */

;(function ($, _, undefined) {

    "use strict";

    ips.controller.register('core.admin.core.tags',
        {
            initialize: function () {
                this.on( 'submit', this.submitForm );
            },

            submitForm: function(e){
                if( $( e.currentTarget ).attr('data-bypassValidation') ){
                    return true;
                }

                e.preventDefault();
                e.stopPropagation();

                ips.ui.alert.show({
                    type: 'confirm',
                    subText: ips.getString( 'tag_delete_confirm_detail' ),
                    icon: 'fa-solid fa-triangle-exclamation',
                    callbacks: {
                        ok: function () {
                            $( e.currentTarget ).attr('data-bypassValidation', true);
                            $( e.currentTarget ).submit();
                        },
                        cancel: function () {
                            return false;
                        }
                    }
                });
            }
        });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.announcementBanner.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.announcementBanner.js - Announcement Banners
 *
 * Author: Stuart Silvester
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.announcementBanner', {

		/**
		 * Initialise event handlers
		 *
		 * @returns		{void}
		 */
		initialize: function () {
			this.setup();
			this.on( 'click', '[data-role=&quot;dismissAnnouncement&quot;]', this.dismissAnnouncement );
		},

		/**
		 * Set up CSS for announcements
		 *
		 * @returns		{void}
		 */
		setup: function(){
			// Cycle and show announcements, the HTML will always contain the announcement HTML so that it's present
			// for guest caching, we use JS to show them based on the cookie values.
			this.scope.find('[data-announcementId]').each( function() {
				var announcement = $( this );
				if( ips.utils.cookie.get( 'announcement_' + announcement.attr('data-announcementId') ) ) {
					announcement.attr('hidden', true);
				}
			});
		},

		/**
		 * Dismiss Announcement
		 *
		 * @param		{event}		e		Event object
		 * @returns		{void}
		 */
		dismissAnnouncement: function ( e ) {

			var element = $( e.target ).closest('[data-announcementId]');
			var id = element.attr('data-announcementId');

			var date = new Date();
			date.setTime( date.getTime() + ( 7 * 86400000 ) );
			ips.utils.cookie.set( 'announcement_' + id, true, date.toUTCString() );

			element.slideUp( {
				duration: 400,
				complete: function() {
					$(this).remove();
				}
			});
		}

	});
}(jQuery, _));
</file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.app.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.app.js - Front end app controller 
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.app', {
		
		initialize: function () {
			this.on( 'click', 'a[data-confirm],button[data-confirm]', this.confirmSomething );
			this.on( document, 'contentChange', this._checkAndClearAutosave );
			this.on( document, 'contentChange', this.checkOldEmbeds );
			this.on( document, 'contentChange', this.updateExternalLinks );

			// Change colour scheme if system settings change while page is being viewed
			document.addEventListener("ips:colorScheme", this.colorScheme);
			window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', this.updatePrefersColorScheme);

			if (ips.utils.broadcastChannel.enabled) {
				ips.utils.broadcastChannel.channel.addEventListener("message", this.broadcastChannelEvent);
			}

			this.setup();
		},

		/**
		 * Setup method for the front app
		 *
		 * @returns {void}
		 */
		setup: function () {	
			if( ips.utils.serviceWorker.supported ){
				ips.utils.serviceWorker.registerServiceWorker('front', !_.isUndefined( ips.utils.cookie.get('loggedIn') ));
			}

			if ( !ips.utils.events.isTouchDevice() ) {
				this.scope.addClass('ipsApp_noTouch');
			}

			// Timezone detection
			ips.utils.cookie.set( 'ipsTimezone', new Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC" );
			
			// Clear any autosave stuff
			this._checkAndClearAutosave();
			if ( !ips.getSetting('memberID') && ips.utils.url.getParam('_fromLogout') ) {
				ips.utils.db.removeByType('editorSave');
			}

			// Inline message popup
			// Create a dialog if it exists
			if( $('#elInlineMessage').length ){
				var dialogRef = ips.ui.dialog.create({
					content: '#elInlineMessage',
					title: $('#elInlineMessage').attr('title')
				});

				// Leave a little time
				setTimeout( function () {
					dialogRef.show();
				}, 800);				
			}

			// Open external links in a new window
			ips.utils.links.updateExternalLinks( this.scope );

			// Find any embeds on the page and upgrade them.
			this._upgradeOldEmbeds( this.scope );

			// If we can't view user profiles, remove links in the comment content
			if( !ips.getSetting('viewProfiles') ){
				this._removeProfileLinks();
			}
		},

		/**
		 * Called on content change. Updates externals links to open in a new window.
		 *
		 * @returns {void}
		 */
		updateExternalLinks: function (e, data) {
			ips.utils.links.updateExternalLinks( data );
		},

		/**
		 * Called on content change. Upgrade any old embeds within this content container.
		 *
		 * @returns {void}
		 */
		checkOldEmbeds: function (e, data) {
			this._upgradeOldEmbeds( data );
		},

		/**
		 * Remove user profile links where possible if the current viewing user cannot access profiles
		 *
		 * @returns {void}
		 */
		_removeProfileLinks: function () {
			this.scope
				.find('a[data-mentionid],a[href*="controller=profile"]')
					.replaceWith( function(){ return $(this).contents(); } );
		},

		/**
		 * Upgrade old embeds so that they include the correct controller
		 *
		 * @returns {void}
		 */
		_upgradeOldEmbeds: function (element) {
			// element is not always defined
			if( _.isUndefined( element ) ){
				return;
			}

			// Apply embed controllers on old content
			var oldEmbeds = element.find('[data-embedcontent]:not([data-controller], [data-embed-src])');
			var toRefresh = [];

			if( oldEmbeds.length ){
				oldEmbeds.each( function () {
					$( this ).attr('data-controller', 'core.front.core.autoSizeIframe');
					toRefresh.push( this );
					Debug.log("Upgraded old embed");
				});
				$( document ).trigger( 'contentChange', [ jQuery([]).pushStack( toRefresh ) ] );
			}
		},

		/**
		 * Check and clear autosave
		 *
		 * @returns {void}
		 */
		 _checkAndClearAutosave: function() {
		 	if( ips.utils.cookie.get('clearAutosave') ) {
				var autoSaveKeysToClear = ips.utils.cookie.get('clearAutosave').split(',');
				for ( var i = 0; i < autoSaveKeysToClear.length; i++ ) {
					ips.utils.db.remove( 'editorSave', autoSaveKeysToClear[i] );
				}
				ips.utils.cookie.unset('clearAutosave');
			}
		 },
		
		/**
		 * Prompts the user to confirm an action
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		confirmSomething: function (e) {
			e.preventDefault();
			var elem = $( e.currentTarget );
			var customMessage = $( e.currentTarget ).attr('data-confirmMessage');
			var subMessage = $( e.currentTarget ).attr('data-confirmSubMessage');
			var icon = $( e.currentTarget ).attr('data-confirmIcon');
			
			ips.ui.alert.show( {
				type: 'confirm',
				icon: ( icon ) ? icon : 'warn',
				message: ( customMessage ) ? customMessage : ips.getString('generic_confirm'),
				subText: ( subMessage ) ? subMessage : '',
				callbacks: {
					ok: function () {
						window.location = elem.attr('href') + '&wasConfirmed=1';
					}
				}
			});
		},

		/**
		 * Keep color scheme in sync across tabs/windows
		 *
		 * @param 	{event} 	ev 	Event object
		 * @returns {void}
		 */
		broadcastChannelEvent(ev){
			if(ev.data.command === "colorScheme"){
				document.dispatchEvent(new CustomEvent("ips:colorScheme", {
					bubbles: true,
					detail: { scheme: ev.data.value }
				}));
			}
		},

		/**
		 * Change the color scheme (update data-attributes, activate the clicked button and set cookie)
		 *
		 * @param  {CustomEvent<{scheme: string}>}     ev
		 * @returns {void}
		 */
		colorScheme(ev){

			// If the color scheme toggle has been disabled, return early.
			if(document.documentElement.matches('[data-ips-scheme-toggle="false"]')){
				return;
			}

			let value = ev.detail.scheme;

			document.querySelectorAll('[data-ips-prefers-color-scheme]').forEach(el => {
				if(el.matches('[data-ips-prefers-color-scheme=' + value + ']')){
					el.setAttribute('aria-current', 'true');
				} else {
					el.removeAttribute('aria-current');
				}
			});

			document.documentElement.dataset.ipsSchemeActive = value;
			if (value === 'system'){
				document.documentElement.dataset.ipsScheme = (window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark':'light';
			} else {
				document.documentElement.dataset.ipsScheme = value;
			}

			ips.utils.cookie.set('scheme_preference', value, true);

		},

		/**
		 * This runs whenever the user changes their light/dark mode preference in their devices system settings. It updates the color scheme of the site, only if their preference was set to "System"
		 *
		 * @returns {void}
		 */
		updatePrefersColorScheme: function() {
			if (document.documentElement.getAttribute('data-ips-scheme-active') === 'system'){
				document.documentElement.setAttribute('data-ips-scheme', (window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark':'light');
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.articlePages.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.articlePages.js - Turns content using the page bbcode into paginated content
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.articlePages', {

		_currentPage: 1,
		_pages: null,
		_articleID: '',

		initialize() {
			this.on( 'paginationClicked', this.paginationClicked );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup() {
			this._articleID = this._getArticleID();

			// Primary event that watches for URL changes
			this.on( window, `historychange:article-${this._articleID}`, this.stateChange );
			this._setupPages();
		},

		/**
		 * stateChange event
		 *
		 * @returns {void}
		 */
		stateChange() {
			if (!(('article-' + this._articleID) in ips.utils.history.getState())) {
				return;
			}

			const state = ips.utils.history.getState(`article-${this._articleID}`)

			const newPage = parseInt(state?.['page' + this._articleID]);

			if (!Number.isInteger(newPage) || this._pages[newPage - 1] === undefined) {
				return;
			}

			this._pages.hide();
			this._currentPage = newPage;

			ips.utils.anim.go( 'fadeIn', $( this._pages[ newPage - 1 ] ) );

			this._checkButtons();
		},

		/**
		 * Event handler for the pagination widget being clicked
		 *
		 * @param	{Event} 	e 		Event object
		 * @param	{object} 	data 	Event data object
		 * @returns {void}
		 */
		paginationClicked(e, data) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
				data.originalEvent.stopPropagation();
			}

			// Don't allow these pagination events to bubble up to main comment feed pagination
			e.stopPropagation();

			const urlData = {
				controller: 'article-' + this._articleID
			};

			if( data.pageNo == 'next' ){
				urlData[ 'page' + this._articleID ] = this._currentPage + 1;
			} else {
				urlData[ 'page' + this._articleID ] = this._currentPage - 1;
			}

			const url = this._buildURL(urlData['page' + this._articleID]);

			ips.utils.history.pushState(urlData, `article-${this._articleID}`, url);
		},

		/**
		 * Determines an appropriate article ID for this controller
		 * If data-articleID isn't specified, it'll try and find a comment ID,
		 * or default to the sequential dom element ID.
		 *
		 * @returns {string}
		 */
		_getArticleID() {
			if( this.scope.attr('data-articleID') ){
				return this.scope.attr('data-articleID');
			} else if( this.scope.closest('[data-commentID]') ) {
				return 'comment' + this.scope.closest('[data-commentID]').attr('data-commentID');
			} else {
				// This isn't great because it'll change for each user, but if we've
				// got nothing else to go on...
				return this.scope.identify().attr('id');	
			}			
		},

		/**
		 * Builds a URL that is a link to this particular page of the document
		 *
		 * @param 	{number} 	pageNo 		Page number to include in the URL
		 * @returns {void}
		 */
		_buildURL(pageNo) {
			// Get URL object first
			var urlObj = ips.utils.url.getURIObject();
			// Build the base URL
			var url = urlObj.protocol + '://' + urlObj.host + ( urlObj.port ? ( ':' + urlObj.port ) : '' ) + urlObj.path + '?';

			// Add or replace our page number param
			urlObj.queryKey[ 'page' + this._articleID ] = pageNo;

			var params = _.clone( urlObj.queryKey );

			// If we're using index.php? urls, the keys may be /forum/forum-2/ style
			// The /../ part will have an empty value, so we add those to the URL manually first
			if( urlObj.file == 'index.php' ){
				_.each( params, function (val, key) {
					if( key.startsWith('/') ){
						url += key;
						delete params[ key ];					
					}
				});

				url += '&';
			}

			// If we still have other params, add those to the URL
			if( ! _.isEmpty( params ) ){
				url += $.param( params );
			}

			return url;
		},

		/**
		 * Checks the next/prev buttons, and shows/hides them as needed
		 *
		 * @returns {void}
		 */
		_checkButtons() {
			const indexedPage = this._currentPage - 1;

			this.scope.find('.ipsPagination__prev').toggle( !( indexedPage <= 0 ) );
			this.scope.find('.ipsPagination__next').toggle( !( indexedPage >= ( this._pages.length - 1 ) ) );
		},

		/**
		 * Sets up the content, showing pagination
		 *
		 * @returns {void}
		 */
		_setupPages() {
			// Find the pages
			this._pages = this.scope.find('[data-role="contentPage"]');

			if( this._pages.length < 2 ){
				return;
			}

			// Add pagination to the top and bottom
			this.scope.prepend( ips.templates.render('core.pagination') );
			this.scope.append( ips.templates.render('core.pagination') );

			// Hide all pages
			this._pages.hide();

			// Do we have a page in the URL?
			if( !_.isUndefined( ips.utils.url.getParam('page' + this._articleID ) ) ){
				this._currentPage = parseInt( ips.utils.url.getParam('page' + this._articleID ) );
			}

			// Show the right page
			$( this._pages[ this._currentPage - 1 ] ).show();

			// Hide the 'previous'
			this._checkButtons();

			// Hide the breaks
			this.scope.find('[data-role="contentPageBreak"]').hide();

			// And reinit content
			$( document ).trigger( 'contentChange', [ this.scope ] );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.autoSizeIframe.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.autoSizeIframe.js - Controller to automatically adjust the height of an iframe
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	const PREINITIALIZED_DIMS_FLAG = Symbol('PREINITIALIZED_DIMS_FLAG');

	// Query and set sizing before registering the controller to try to minimize load time
	if (ips?.utils?.db?.get instanceof Function) {
		document.querySelectorAll('iframe[data-controller*="core.front.core.autosizeiframe"][src]').forEach(embed => {
			if (!embed.src || embed.src === window.location.href) {
				return;
			}
			const currentDims = ips.utils.db.get("embedDimsCache", embed.src);
			if (typeof currentDims?.height === 'number' && currentDims.height > 0) {
				Debug.log(`(EMBED) - Filling in width and height before registering controller for embed ${embed.src}`);
				embed[PREINITIALIZED_DIMS_FLAG] = {
					width: typeof currentDims.width === 'number' ? currentDims.width : 0,
					height: typeof currentDims.height === 'number' ? currentDims.height : 0
				};
				if (typeof currentDims.width === 'number' && currentDims.width > 0) {
					requestAnimationFrame(() => {
						embed.style.height = currentDims.height + "px";
						embed.style.width = currentDims.style.width + "px";
					})
				} else {
					requestAnimationFrame(() => {
						embed.style.height = currentDims.height + "px";
					});
				}
			}
		})
	}

	ips.controller.register('core.front.core.autoSizeIframe', {

		_origin: ips.utils.url.getOrigin(),
		_embedId: '',
		_iframe: null,
		_border: { vertical: 0, horizontal: 0 },

		initialize() {
			if( !this.scope.is('iframe') ){
				return;
			}

			this.on( window, 'message', this.receiveMessage );
			this.on( document, 'breakpointChange', this.breakpointChange );
			this.setup();
		},

		getEmbedSrc() {
			return this.elem.src;
		},

		/**
		 * Sets some basic styles on the iframe, and sets up an interval
		 * to constantly check for any change in sizing
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		setup() {
			this._lastDims = { height: 0, width: 0 };
			let cachedDims;
			if (PREINITIALIZED_DIMS_FLAG in this.elem) {
				Object.assign(this._lastDims, this.elem[PREINITIALIZED_DIMS_FLAG]);
			} else if (this.getEmbedSrc() && (cachedDims = ips.utils.db.get('embedDimsCache', this.getEmbedSrc())) && cachedDims) {
				if (typeof cachedDims?.height === 'number' && cachedDims.height > 0) {
					Debug.log(`(EMBED) - Using cached height and width while the embed initializes`);
					if (typeof cachedDims?.width === 'number' && cachedDims.width > 0) {
						this.dims(cachedDims);
					} else {
						this.height({height: cachedDims.height});
					}
				}
			}

			var iframe = this.scope.get(0);
			iframe.style.overflow = 'hidden';

			this._getBorderAdjustment();

			// Make sure the built-in height is reasonable
			if( this.scope.height() > 800 ){
				this.scope.css({
					height: '800px'
				});
			}

			this._iframe = iframe.contentWindow;

			// Do we have an embed ID? If not, we need to generate one
			this._embedId = 'embed' + parseInt( Math.random() * (10000000000 - 1) + 1 );
			this.scope.attr('data-embedId', this._embedId );

			// Check for postMessage and JSON support
			if( !window.postMessage || !window.JSON.parse ){
				this.scope.css({
					height: '400px'
				});
				Debug.error("Can't resize embed: " + this._embedId );
				return;
			}

			// We can now tell the iframe we are ready
			this._intersectionObserver = new IntersectionObserver(entries => {
				if (entries.some(entry => entry.isIntersecting)) {
					this._intersectionObserver.disconnect();
					this._startReadyTimeout();
				}
			}, {threshold: 0});

			this._intersectionObserver.observe(iframe);
		},

		/**
		 * Sets an interval that pings the iframe with a ready message
		 * This needs to repeat because the iframe might not immediately be ready to receive messages.
		 *
		 * @returns {void}
		 */
		_startReadyTimeout() {
			this._readyTimeout = setInterval( _.bind( function () {
				this._postMessage('ready');
			}, this ), 100 );

			// We'll just give it 10 seconds, then stop trying
			setTimeout( _.bind( function () {
				this._stopReadyTimeout();
			}, this ), 10000 );
		},

		/**
		 * Stops the ready message interval from firing
		 *
		 * @returns {void}
		 */
		_stopReadyTimeout() {
			if( this._readyTimeout !== null ){
				Debug.log("Stopped posting to embed " + this._embedId);
				clearInterval( this._readyTimeout );
				this._readyTimeout = null;
			}
		},

		/**
		 * Event handler for this controller being destructed
		 *
		 * @returns {void}
		 */
		destruct() {
			Debug.log('Destruct autoSizeIframe ' + this._embedId);
			this._intersectionObserver?.disconnect();
			this._stopReadyTimeout();
			this._postMessage('stop');
		},

		/**
		 * Event handler for this controller receiving a messgae.
		 * Actually, all messages to this window are handled here, so we have to check the origin,
		 * and whether it's a message for this controller in particular (i.e. the embedIds match)
		 *
		 * @returns {void}
		 */
		receiveMessage(e) {
			if (e.originalEvent.origin !== this._origin) {
				return;
			}

			try {
				const pmData = typeof e.originalEvent.data === 'string' ? JSON.parse(e.originalEvent.data) : e.originalEvent.data;
				const method = pmData.method;

				if( pmData.embedId === undefined || pmData.embedId !== this._embedId ){
					return;
				}

				// Stop telling it we're ready now
				this._stopReadyTimeout();
				this[method]?.call( this, pmData );

			} catch (err) {
				Debug.error(err.message);
			}

		},

		/**
		 * Post a message to the iframe
		 *
		 * @returns {void}
		 */
		_postMessage(method, obj) {
			// Send to iframe
			Debug.log("Posting to iframe " + this._embedId);

			this._iframe.postMessage( JSON.stringify( _.extend( obj || {}, {
				method: method,
				embedId: this._embedId
			} ) ), this._origin );
		},

		/**
		 * Get the border widths, which we'll use to adjust the widths we set on the iframe
		 *
		 * @returns {void}
		 */
		_getBorderAdjustment() {
			this._border.vertical = parseInt( this.scope.css('border-top-width') ) + parseInt( this.scope.css('border-bottom-width') );
			this._border.horizontal = parseInt( this.scope.css('border-left-width') ) + parseInt( this.scope.css('border-right-width') );
		},

		/**
		 * Event handler for the breakpoint changing
		 *
		 * @returns {void}
		 */
		breakpointChange(e, data) {
			// Now send the frame our responsive state
			this._postMessage('responsiveState', {
				currentIs: data.curBreakName
			});
		},

		/**********************************/
		/* Events from the iframe */

		/**
		 * Display a dialog
		 *
		 * @returns {void}
		 */
		dialog(data) {
			var options = ips.ui.getAcceptedOptions('dialog');
			var dialogOptions = {};

			_.each( options, function (opt) {
				if( !_.isUndefined( data.options['data-ipsdialog-' + opt.toLowerCase() ] ) ){
					dialogOptions[ opt ] = data.options['data-ipsdialog-' + opt.toLowerCase() ];
				}
			});

			if( _.isUndefined( dialogOptions['url'] ) ){
				dialogOptions['url'] = data.url;
			}

			var dialogRef = ips.ui.dialog.create( dialogOptions );

			dialogRef.show();
		},

		/**
		 * Set the height of the iframe
		 *
		 * @returns {void}
		 */
		height(data) {
			if( this._lastDims.height !== data.height ){
				this.scope.css({
					height: parseInt( data.height ) + this._border.vertical + 'px'
				});

				// Leaving this in, just in case it's helpful, but it isn't defined in either the internal nor external embed handler we use
				// this._postMessage('setDimensions', {
				// 	height: parseInt( data.height )
				// });

				this._lastDims.height = data.height;
				if (this.getEmbedSrc()) {
					ips.utils.db.set('embedDimsCache', this.getEmbedSrc(), this._lastDims);
				}
			}
		},

		/**
		 * Set the dimensions of the iframe
		 *
		 * @returns {void}
		 */
		dims(data) {
			if( parseInt( this._lastDims.height ) !== parseInt( data.height ) || this._lastDims.width !==  data.width ){
				this.scope.css({
					height: parseInt( data.height ) + this._border.vertical + 'px',
					maxWidth: ( data.width.toString().indexOf('%') == -1 ) ? parseInt( data.width ) + this._border.horizontal + 'px' : '100%'
				});

				this._lastDims.height = data.height;
				this._lastDims.width = data.width;

				if (this.getEmbedSrc()) {
					ips.utils.db.set('embedDimsCache', this.getEmbedSrc(), this._lastDims);
				}
			}
		},

		/**
		 * The iframe received our Ready message
		 *
		 * @returns {void}
		 */
		ok() {
			this._stopReadyTimeout();
			this.scope.addClass('ipsEmbed_finishedLoading');

			// Now send the frame our responsive state
			this._postMessage('responsiveState', {
				currentIs: ips.utils.responsive.getCurrentKey()
			});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.colorScheme.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.colorScheme.js - Controller for managing the "Change color scheme" buttons
 *
 * Author: Ehren Harber
 */
;( function(){
	"use strict";

	ips.controller.register('core.front.core.colorScheme', {
		
		initialize() {
			this.menu = this.scope[0];
			this.on( this.menu, 'click', this.changeColorScheme );

			// Set aria-current on active color scheme button(s) if the attribute doesn't exist already
			if(!this.menu.querySelector("[aria-current")){
				this.schemePref = ips.utils.cookie.get('scheme_preference') || document.documentElement.dataset.ipsSchemeDefault;
				document.querySelectorAll('[data-ips-prefers-color-scheme=' + this.schemePref + ']').forEach(el => el.setAttribute('aria-current', 'true'));
			}
		},

		// Dispatch the ips:colorScheme event which changes the color scheme and saves the value as a cookie
		changeColorScheme(ev){

			let el = ev.target.closest('[data-controller="core.front.core.colorScheme"] [data-ips-prefers-color-scheme]');
			if(!el) return;

			document.dispatchEvent(new CustomEvent("ips:colorScheme", {
				bubbles: true,
				detail: { scheme: el.dataset.ipsPrefersColorScheme }
			}));

			if (ips.utils.broadcastChannel.enabled) {
				ips.utils.broadcastChannel.channel.postMessage({
					command: 'colorScheme',
					value: el.dataset.ipsPrefersColorScheme
				});
			}

		}

		
	});
}());]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.comment.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.comment.js - General controller for comments
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.comment', {

		_quoteData: null,
		_commentContents: '',
		_quotingDisabled: false,
		_quoteTimeout: null,
		_isEditing: false,
		_clickHandler: null,
		/**
		 * @type {IntersectionObserver|null|false}
		 */
		_observer: null,
		
		initialize: function () {		
			// Get the menu id from the menu link
			for(const link of this.scope.find('[popovertarget^="elcomment_"]')) {
				const menuSelector = $(link).attr('popovertarget');

				// Events from within scope
				for (const action of ['editComment', 'deleteComment', 'approveComment']) {
					this.on(document, 'click', `#${menuSelector} [data-action="${action}"]`, this[action]);
				}
			}
			for (const action of ['quoteComment', 'multiQuoteComment', 'rateReview', 'cancelEditComment']) {
				this.on( 'click', `[data-action="${action}"]`, this[action]);
			}

			this.on( 'submit', 'form', this.submitEdit );
			this.on( 'change', 'input[type="checkbox"][data-role="moderation"]', this.commentCheckbox );
			this.elem.addEventListener('ipsCalcQuote', () => this.inlineQuote())
			this.on( 'click', '[data-action="quoteSelection"]', this.quoteSelection );
			this.on( 'submitDialog', '[data-action="recommendComment"]', this.recommendComment );
			this.on( 'click', '[data-action="unrecommendComment"]', this.unrecommendComment );
			this.on( 'tabChanged', this.tabChanged );

			// Events sent down by the commentFeed controller
			this.on( 'setMultiQuoteEnabled.comment setMultiQuoteDisabled.comment', this.setMultiQuote );
			this.on( 'disableQuoting.comment', this.disableQuoting );

			// Model events that are handled all at once
			this.on( document, 'getEditFormLoading.comment saveEditCommentLoading.comment ' + 
									'deleteCommentLoading.comment', this.commentLoading );
			
			this.on( document, 'getEditFormDone.comment saveEditCommentDone.comment ' + 
									'deleteCommentDone.comment', this.commentDone );

			// Model events
			this.on( document, 'getEditFormDone.comment', this.getEditFormDone );
			this.on( document, 'getEditFormError.comment', this.getEditFormError );
			//---
			this.on( document, 'saveEditCommentDone.comment', this.saveEditCommentDone );
			this.on( document, 'saveEditCommentError.comment', this.saveEditCommentError );
			//---
			this.on( document, 'deleteCommentDone.comment', this.deleteCommentDone );
			this.on( document, 'deleteCommentError.comment', this.deleteCommentError );
			//---
			this.on( document, 'unrecommendCommentDone.comment', this.unrecommendCommentDone );
			this.on( document, 'unrecommendCommentError.comment', this.unrecommendCommentError );
			//---
			this.on( document, 'approveCommentLoading.comment', this.approveCommentLoading );
			this.on( document, 'approveCommentDone.comment', this.approveCommentDone );
			this.on( document, 'approveCommentError.comment', this.approveCommentError );

			this.setup();
		},
		
		/**
		 * Setup method for comments
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._commentID = this.scope.attr('data-commentID');
			this._clickHandler = _.bind( this._hideQuoteTooltip, this );
			this._setupIntersectionObserver();
			this._setupShareCommentDialog();


            /* Check to see if we have a findComment fragment and then handle that */
            const fragment = window.location.hash;
            const match = fragment.match( /#find(Review|Comment)-(\d+)/ ) ;

            if (match) {
                const type = match[1]
                const commentId = match[2];
                const elementId = `find${type}-${commentId}`;

                const element = document.getElementById(elementId);

                if ( ! element) {
                    // The element doesn't exist on this page. It might have been deleted or it might now be on another page or in another topic
					const currentUrl = new URL(window.location.href);
					currentUrl.updateSearchParams({
						params: {
							do: `find${type}`,
							[type.toLowerCase()]: commentId.toString()
						}
					});

                    // Update the URL and reload the page
                    window.location.href = currentUrl;
                }
            }
        },

		destroy: function () {
			// --
		},

		/**
		 * Watches for tab changes.
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from tab widget
		 * @returns 	{void}
		 */
		tabChanged: function (e, data) {
			// We have switched between comments and review, so clear cached menu data
			this._menu = undefined;
			this.getMenu();
		},

		/**
		 * Event handler for selective quoting, called on mouseup (after user has dragged/clicked)
		 * Get the selected text, then leave a short timeout before showing the tooltip
		 * @returns	{void}
		 */
		inlineQuote: function () {
			var self = this;
			var quoteButton = this.scope.find('[data-action="quoteComment"]');

			if( this._isEditing || this._quotingDisabled || !quoteButton.length ){
				return;
			}			

			clearInterval( this._quoteTimeout );

			this._quoteTimeout = setInterval( function () {
				self._checkQuoteStatus();
			}, 400 );			
		},

		/**
		 * Event handler for recommending comments. Triggered by the dialog being submitted and a successful response
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		recommendComment: function (e, data) {

			var commentHtml = $('<div>' + data.response.comment + '</div>').find('[data-controller="core.front.core.comment"]').html();

			this.scope
				.html( commentHtml )
				.closest('.ipsEntry')
					.addClass('ipsEntry--popular');

			// Let document know
			$( document ).trigger( 'contentChange', [ this.scope ] );

			// Set up multiquote in this comment
			if( ips.utils.db.isEnabled() ){
				this.scope.find('[data-action="multiQuoteComment"]').removeClass('ipsHide');
			}

			this.trigger('refreshRecommendedComments', {
				scroll: true,
				recommended: data.response.recommended
			});
		},

		/**
		 * Event handler for un-recommending comments.
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		unrecommendComment: function (e, data) {
			e.preventDefault();

			var url = $( e.currentTarget ).attr('href');

			this.trigger( 'unrecommendComment.comment', {
				url: url,
				commentID: this._commentID
			});
		},

		/**
		 * Unrecommending a comment was successful (triggered by comment model)
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		unrecommendCommentDone: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			var commentHtml = $('<div>' + data.comment + '</div>').find('[data-controller="core.front.core.comment"]').html();
			console.log(commentHtml);

			this.scope
				.html( commentHtml )
				.closest('.ipsEntry')
					.removeClass('ipsEntry--popular')
					.find('.ipsEntry__popularFlag')
						.remove();
					

			// Flash message
			ips.ui.flashMsg.show( ips.getString( 'commentUnrecommended' ) );

			// Tell the recommended overview to remove it
			this.trigger('removeRecommendation', {
				commentID: data.unrecommended
			});
		},

		/**
		 * Unrecommending a comment failed
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		unrecommendCommentError: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			window.reload();
		},

		/**
		 * Figure out if our selected text has changed
		 *
		 * @returns	{void}
		 */
		_checkQuoteStatus: function () {
			var selectedText = ips.utils.selection.getSelectedText( '[data-role="commentContent"]', this.scope.find('[data-role="commentContent"]').parent() );
			var ancestor = ips.utils.selection.getCommonAncestor();

			if( selectedText.trim() === '' ){
				this._hideQuoteTooltip();
				return;
			}

			if( ancestor && ancestor.closest('.ipsCode').length ){
				// If we've selected inside a code block, wrap our selected text too
				selectedText = "<pre class='ipsCode prettyprint'>" + selectedText + "</pre>";
			} else if( !selectedText.startsWith('<') ) {
				// If the user selects a bunch of text that contains HTML, the browser will automatically wrap it for us. But if the user
				// just selects some plain text, that's all we get. So in that case, we'll wrap it ourselves.
				selectedText = '<p>' + selectedText + '</p>';
			}

			if( this._selectedText === selectedText ){
				return;
			}
			
			this._selectedText = selectedText;
			
			this._showQuoteTooltip();
		},

		/**
		 * Builds & shows the selective quoting tooltip, displaying it just above the user's cursor
		 *
		 * @returns	{void}
		 */
		_showQuoteTooltip: function () {
			var selection = ips.utils.selection.getSelection();
			var range = ips.utils.selection.getRange( this.scope.find('[data-role="commentContent"]') );
			var tooltip = this.scope.find('[data-role="inlineQuoteTooltip"]');
			var position = {
				left: 0,
				top: 0
			};

			if( range === false || !_.isObject( range ) || _.isUndefined( range.type ) ){ // No selection found
				Debug.log("No selection found");
				return;
			}

			// Create the new tooltip if needed
			if( !tooltip.length ){
				this.scope.append( ips.templates.render('core.selection.quote', {
					direction: 'bottom'//ips.utils.events.isTouchDevice() ? 'bottom' : 'top'
				}) );	
				tooltip = this.scope.find('[data-role="inlineQuoteTooltip"]');
				$( document ).on( 'click dblclick', this._clickHandler );
			}

			if ( range.type === 'outside' ){ 
				// Selection was beyond our content area, so we need to limit it to end of the content
				// Get the bounding of the selection to use as the basis of our tooltip position
				var boundingBox = range.range.getBoundingClientRect();
				var offset = this.scope.offset();

				position.left = boundingBox.left + ( boundingBox.width / 2 ) + $( window ).scrollLeft() - offset.left;
				position.top = boundingBox.top + boundingBox.height + $( window ).scrollTop() - offset.top;
			} else { 
				// Normal selection, inside content, so we can position based on the Range directly
				// Clone the range, and insert an element containing an invisible character which we'll use
				// to fetch the position
				var cloneRange = range.range.cloneRange();
				var invisibleElement = document.createElement('span');
				invisibleElement.appendChild( document.createTextNode('\ufeff') );

				// Collapse the range so that we only care about the end position
				cloneRange.collapse( false );

				// Insert our invisible element into the range
				cloneRange.insertNode( invisibleElement );

				// Get the position of the invisible element we created
				var tmpPosition = ips.utils.position.getElemPosition( $( invisibleElement ) );

				position.left = tmpPosition.absPos.left;
				position.top = tmpPosition.absPos.top + 25;

				// Remove the invisible element (fixes #1758)
				invisibleElement.parentNode.removeChild(invisibleElement);
			}	

			tooltip[0].showPopover();
			var tooltipSize = {
				width: tooltip.outerWidth(),
				height: tooltip.outerHeight()
			};

			// Set the position. On touch devices, move it a little further to the left to avoid the OS's touch handle
			var leftAdjustment = ips.utils.events.isTouchDevice() ? tooltipSize.width : ( tooltipSize.width / 2 );

			tooltip.css({
				left: Math.round( position.left - leftAdjustment ) + 'px',
				top: Math.round( position.top ) + 'px'
			});

			// If the tooltip isn't already shown, fade it in
			tooltip[0].showPopover();
		},

		/**
		 * Hide the selective quote tooltip
		 *
		 * @returns	{void}
		 */
		_hideQuoteTooltip: function () {
			$( document ).off( 'click dblclick', this._clickHandler );
			clearInterval( this._quoteTimeout );
			this.scope.find('[data-role="inlineQuoteTooltip"]')[0]?.hidePopover();
			this._selectedText = '';
		},

		/**
		 * Get a jquery selector representing the feed of this element
		 * @return {jQuery}
		 */
		feedJQ() {
			if (this.elem.dataset.feedid) {
				// First, try to get an ancestor
				const closest = this.elem.closest(`[data-feedid=${this.elem.dataset.feedid}][data-controller*="core.front.core.commentFeed"]`);
				if (closest) {
					return $(closest);
				}

				// Now try to get one anywhere
				const feed = document.querySelector(`[data-feedid=${this.elem.dataset.feedid}][data-controller*="core.front.core.commentFeed"]`);
				if (feed) {
					return $(feed);
				}

				// Still here? Log an error
				Debug.warn(`The comment feed for a comment could not be identified. This can be prevented by ensuring the comment and its feed have macthing data-feedid attributes (comment's feedid: ${this.elem.dataset.feedid})`);
			} else {
				Debug.warn(`A comment is missing its data-feedid attribute, so its comment feed could not be identified. This can be prevented by ensuring the comment and its feed have macthing data-feedid attributes`);
			}

			// May as well make it obvious which element this is
			Debug.warn(this.elem);

			return $(this.elem.closest(`[data-controller*="core.front.core.commentFeed"]`) || this.elem);
		},

		/**
		 * Event handler for clicking 'quote this' in the selective quote tooltip
		 * Triggers an event sent to the comment feed
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns	{void}
		 */
		quoteSelection: function (e) {
			e.preventDefault();

			this._getQuoteData();

			if( this._selectedText ){
				this.feedJQ().trigger('quoteComment.comment', {
					userid: this._quoteData.userid,
					username: this._quoteData.username,
					timestamp: this._quoteData.timestamp,
					contentapp: this._quoteData.contentapp,
					contenttype: this._quoteData.contenttype,
					contentclass: this._quoteData.contentclass,
					contentid: this._quoteData.contentid,
					contentcommentid: this._quoteData.contentcommentid,
					quoteHtml: this._selectedText,
					citeurl: $(this.elem).get(0).querySelector(".ipsEntry__date[href]")?.getAttribute('href')
				});
			}

			this._hideQuoteTooltip();
		},

		/**
		 * Triggered when the moderation checkbox is changed
		 *	
		 * @param 		{event}		e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		commentCheckbox: function (e) {
			var checked = $( e.currentTarget ).is(':checked');
			this.scope.closest('.js-ipsEntry').toggleClass( 'ipsEntry--selected', checked );
			this.scope.closest('.js-ipsEntry').find('label[for=' + $( e.currentTarget ).attr('id') + ']').toggleClass( 'ipsInput--pseudoChecked', checked );

			this.feedJQ().trigger('checkedComment.comment', {
				commentID: this._commentID,
				actions: $( e.currentTarget ).attr('data-actions'),
				checked: checked
			});
		},

		/**
		 * The comment feed has told us we can't support quoting
		 *	
		 * @returns 	{void}
		 */
		disableQuoting: function () {
			this._quotingDisabled = true;
			this.scope.find('[data-ipsQuote-editor]').remove();
		},
		
		/**
		 * Event handler for the rate review buttons.
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		rateReview: function (e) {
			e.preventDefault();
			var self = this;

			ips.getAjax()( $( e.currentTarget ).attr('href') )
				.done( function (response) {
					var content = $("<div>" + response + "</div>");
					self.scope.html( content.find('[data-controller="core.front.core.comment"]').contents() );

					$( document ).trigger( 'contentChange', [ self.scope ] );
				})
				.fail( function (err) {
					window.location = $( e.currentTarget ).attr('href');
				});
		},

		_menu: undefined,

		/**
		 * Get the menu element for this comment
		 *
		 * @returns {HTMLElement|null}
		 */
		getMenu() {
			if (!this._menu) {
				// Review or comments active?
				let activeTabId = this.elem.closest(`[data-commentstype="reviews"]`) ? 'elReview' : 'elComment';

				let commentFeed = this.scope.get(0)?.closest('[data-controller]')
				while(commentFeed && !commentFeed.dataset.controller?.includes('core.front.core.commentFeed')) {
					commentFeed = commentFeed.parentElement?.closest('[data-controller]')
				}
				const menuLink = (commentFeed || document).querySelector('#' + activeTabId + `_${this.scope.get(0)?.dataset['commentid']} [popovertarget]`);
				this._menu = menuLink ? document.querySelector('#' + menuLink.getAttribute('popovertarget')) : null;
			}
			return this._menu;
		},

		/**
		 * Set up the comment dialog so that clicking the share link copies it to the clipboard
		 */
		_setupShareCommentDialog() {
			const shareButton = this.getMenu()?.querySelector('[data-role="shareComment"], [data-role="shareReview"]');
			const shareMenu = shareButton?.dataset.ipsdialogContent ? document.querySelector(shareButton.dataset.ipsdialogContent) : null;
			const copyToClipboard = shareMenu?.querySelector('[data-role="shareButton"]');
			let shared = false;
			if (window.isSecureContext && copyToClipboard) {
				copyToClipboard.onclick = e => e.preventDefault()
				copyToClipboard?.addEventListener('pointerdown', async e => {
					e.preventDefault();
					const href = copyToClipboard.getAttribute('href');
					const cb = async e => {
						copyToClipboard.removeEventListener('pointerup', cb)
						if (window.navigator?.clipboard?.writeText instanceof Function) {
							e.preventDefault()
							await window.navigator.clipboard.writeText(href);
						} else {
							const fakeElement = document.createElement('span')
							fakeElement.innerText = href;
							document.body.appendChild(fakeElement)
							const range = new Range();
							range.setStart(fakeElement, 0)
							range.setEnd(fakeElement, fakeElement.childNodes.length)
							const originalRanges = []
							for (let i = 0; i < document.getSelection().rangeCount; i++) {
								originalRanges.push(document.getSelection().getRangeAt(i))
							}
							document.getSelection().removeAllRanges()
							document.getSelection().addRange(range)
							document.execCommand('copy')
							fakeElement.remove();
							document.getSelection().removeAllRanges()
							for (const range of originalRanges) {
								document.getSelection().addRange(range)
							}
						}
						ips.ui.flashMsg.show(ilang`copied`)


						// If we're tracking post view data, we're tracking post ranking on a Cloud site and should also send this
						if (!shared && ips.utils.contentViews.enabled() && this.scope.get(0).dataset.commentapp === 'forums') {
							shared = true;
							ips.getAjax()(`${location.protocol}${ips.getSetting("baseURL")}/?app=core&module=system&controller=ajax&do=trackPostShareIntent&commentId=${this.scope.get(0).dataset.commentid}`)
								.done(() => {
									Debug.log("Sent post share intent");
								})
						}
					}

					copyToClipboard.addEventListener('pointerup', cb)
					copyToClipboard.addEventListener('pointercancel', () => copyToClipboard.removeEventListener('pointerup', cb))
					copyToClipboard.addEventListener('pointerleave', () => copyToClipboard.removeEventListener('pointerup', cb))
				})
			} else if (copyToClipboard) {
				copyToClipboard.setAttribute('hidden', '')
				const shareArea = document.createElement('span')
				const wrap = document.createElement('span')
				if (copyToClipboard.querySelector(':scope > i')) {
					const icon = copyToClipboard.querySelector(':scope > i')
					icon.dataset.ipstooltip = ''
					icon.setAttribute('title', ips.getString('core_comment_share_copy_prompt'))
					wrap.appendChild(icon)
					wrap.append(document.createTextNode('\u00a0'))
				}
				wrap.appendChild(shareArea)
				wrap.classList.add('ipsPageActions__mainLink')
				wrap.dataset.role = 'shareButton'
				shareArea.innerText = copyToClipboard.getAttribute('href')
				copyToClipboard.parentElement.insertBefore(wrap, copyToClipboard)
				wrap.onclick = () => {
					const range = new Range();
					range.setStart(shareArea, 0)
					range.setEnd(shareArea, shareArea.childNodes.length)
					document.getSelection().removeAllRanges()
					document.getSelection().addRange(range)
					try {
						if (document.execCommand instanceof Function) {
							document.execCommand?.('copy')
							ips.ui.flashMsg.show(ips.getString('copied'))
						}
					} catch (e) {}
				}
			}
		},

		/**
		 * Event fired on this controller by a core.commentFeed controller to tell us which
		 * multiquote buttons are enabled presently. Here we check whether this applies to us, and toggle
		 * the button if so.
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		setMultiQuote: function (e, data) { 
			var selector = '[data-commentApp="' + data.contentapp + '"]';
				selector += '[data-commentType="' + data.contenttype + '"]';
				selector += '[data-commentID="' + data.contentcommentid + '"]';

			if( this.scope.is( selector ) ){
				if( !_.isNull( e ) && e.type == 'setMultiQuoteEnabled') {
					
					this.scope.find('[data-action="multiQuoteComment"]')
						.removeClass('ipsButton--simple')
						.addClass('ipsButton--secondary')
						.attr( 'data-mqActive', true )
						.html( ips.templates.render('core.posts.multiQuoteOn') );

				} else if( _.isNull( e ) || e.type == 'setMultiQuoteDisabled' ) {

					this.scope.find('[data-action="multiQuoteComment"]')
						.addClass('ipsButton--simple')
						.removeClass('ipsButton--secondary')
						.removeAttr( 'data-mqActive' )
						.html( ips.templates.render('core.posts.multiQuoteOff') );

				}
			}
		},

		/**
		 * Event handler for the Quote button. Triggers a quoteComment event for the
		 * commentFeed controller to handle.
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		quoteComment: function (e) {
			e.preventDefault();
			
			if( !this._getQuoteData() ){
				Debug.error("Couldn't get quote data");
				return;
			}

			var html = this._prepareQuote( $('<div/>').html( this.scope.find('[data-role="commentContent"]').html() ) );
			
			// Send the event up the chain to the commentFeed controller for handling
			this.feedJQ().trigger( 'quoteComment.comment', {
				userid: this._quoteData.userid,
				username: this._quoteData.username,
				timestamp: this._quoteData.timestamp,
				contentapp: this._quoteData.contentapp,
				contenttype: this._quoteData.contenttype,
				contentclass: this._quoteData.contentclass,
				contentid: this._quoteData.contentid,
				contentcommentid: this._quoteData.contentcommentid,
				quoteHtml: html.html(),
				citeurl: $(this.elem).get(0).querySelector(".ipsEntry__date[href]")?.getAttribute('href')
			});
		},

		/**
		 * MultiQuote comment handler
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		multiQuoteComment: function (e) {
			e.preventDefault();

			if( !this._getQuoteData() ){
				Debug.error("Couldn't get quote data");
				return;
			}
			
			var button = $( e.currentTarget );
			var mqActive = button.attr('data-mqActive');

			var html = this._prepareQuote( $('<div/>').html( this.scope.find('[data-role="commentContent"]').html() ) );

			this.feedJQ().trigger( ( mqActive ) ? 'removeMultiQuote.comment' : 'addMultiQuote.comment', {
				userid: this._quoteData.userid,
				username: this._quoteData.username,
				timestamp: this._quoteData.timestamp,
				contentapp: this._quoteData.contentapp,
				contenttype: this._quoteData.contenttype,
				contentclass: this._quoteData.contentclass,
				contentid: this._quoteData.contentid,
				contentcommentid: this._quoteData.contentcommentid,
				quoteHtml: html.html(),
				button: button.attr('data-mqId'),
				citeurl: $(this.elem).get(0).querySelector(".ipsEntry__date[href]")?.getAttribute('href')
			});

			if( mqActive ){
				button
					.removeClass('ipsButton--secondary')
					.addClass('ipsButton--simple')
					.removeAttr('data-mqActive')
					.html( ips.templates.render('core.posts.multiQuoteOff') );
			} else {
				button
					.removeClass('ipsButton--simple')
					.addClass('ipsButton--secondary')
					.attr( 'data-mqActive', true )
					.html( ips.templates.render('core.posts.multiQuoteOn') );
			}
		},

		/**
		 * Edit comment handler
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		editComment: function (e) {
			e.preventDefault();
			
			this._commentContents = this.scope.find('[data-role="commentContent"]').html();
			
			var url = $( e.currentTarget ).attr('href');

			this.trigger( 'getEditForm.comment', {
				url: url,
				commentID: this._commentID
			});
		},
		
		/**
		 * Called when a cancel link is clicked
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		cancelEditComment: function (e) {
			e.preventDefault();
			
			var self = this;
			
			ips.ui.alert.show( {
				type: 'verify',
				icon: 'warn',
				message: ips.getString('cancel_edit_confirm'),
				subText: '',
				buttons: { yes: ips.getString('yes'), no: ips.getString('no') },
				callbacks: {
					yes: function () {
						ips.ui.editorv5.destruct( self.scope.find('[data-ipseditorv5]') );
						self.scope.find('[data-role="commentContent"]').html( self._commentContents );
						self.scope.find('[data-role="commentControls"], [data-action="expandTruncate"]').show();
						self.scope.find('[data-action="editComment"]').parent('li').show();
						self.scope.find('[data-role="commentContent"]').addClass('ipsRichText');
						$( document ).trigger( 'contentChange', [ self.scope ] );
					}
				}
			});
		},
		
		/**
		 * Called when a comment edit button is clicked
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitEdit: function (e) {
			e.preventDefault();
			e.stopPropagation(); // This is a form within a form, so we have to prevent it bubbling up otherwise IE gets confused and will try to submit the moderation actions form too

			var form = this.scope.find('form');
			var url = form.attr('action');				
			var data = form.serialize();
			
			form.find('[data-action="cancelEditComment"]').remove();
			form.find('[type="submit"]').prop( 'disabled', true ).text( ips.getString('saving') );
						
			this.trigger( 'saveEditComment.comment', {
				form: data,
				url: url,
				commentID: this._commentID
			});
		},

		/**
		 * Model event: something is loading
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		commentLoading: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			var commentLoading = this.scope.find('[data-role="commentLoading"]');
			
			commentLoading
				.removeClass('ipsHide');
		},

		/**
		 * Model event: something is done loading
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		commentDone: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}


			this.scope
				.find('[data-role="commentLoading"]')
					.addClass('ipsHide');
		},

		/**
		 * Model event: edit form has loaded
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		getEditFormDone: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			const showForm = _.once(() => {
				this._isEditing = true;
				this.scope.find('[data-action="expandTruncate"], [data-role="commentControls"]').hide();
				this.scope.find('[data-action="editComment"]').parent('li').hide();
				this.scope.find('[data-role="commentContent"]').html( data.response );

				// Remove ipsRichText so the "revert styles" don't interfere with the edit form
				this.scope.find('[data-role="commentContent"]').removeClass('ipsRichText');
				$( document ).trigger( 'contentChange', [ this.scope.find('[data-role="commentContent"]') ] );
			});

			// Scroll to the comment
			var elemPosition = ips.utils.position.getElemPosition( this.scope );
			var windowScroll = $( window ).scrollTop();
			var viewHeight = $( window ).height();

			// Only scroll if it isn't already on the screen
			if( elemPosition.absPos.top < windowScroll || elemPosition.absPos.top > ( windowScroll + viewHeight ) ){
				$('html, body').animate( { scrollTop: elemPosition.absPos.top + 'px' }, function () {
					showForm();
				});	
			} else {
				showForm();
			}
		},

		/**
		 * Model event: error loading edit form
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		getEditFormError: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			window.location = data.url;
		},

		/**
		 * Model event: saving an edit is finished
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		saveEditCommentDone: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}
			
			ips.ui.editorv5.destruct( this.scope.find('[data-ipseditorv5]') );

			this._isEditing = false;
			this.scope.find('[data-role="commentContent"]').replaceWith( $('<div>' + data.response + '</div>').find('[data-role="commentContent"]') );
			this.scope.trigger('refreshContent');
			this.scope.find('[data-action="expandTruncate"], [data-role="commentControls"]').show();
			this.scope.find('[data-action="editComment"]').parent('li').show();
			
			$( document ).trigger( 'contentChange', [ this.scope ] );

			// There might be a data layer event created for this. Actually sync it after a few ms to make sure the page wasn't redirected somehow.
			setTimeout(() => {
				document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles:true}))
			}, 10);
		},

		/**
		 * Model event: saving an edit failed
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		saveEditCommentError: function (e, data) {
			
			if( data.commentID != this._commentID ){
				return;
			}
			
			ips.ui.alert.show( {
				type: 'alert',
				icon: 'warn',
				message: ips.getString('editCommentError'),
			});
			//this.scope.find('form').submit();
		},
			
		/**
		 * Handler for approving a comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		approveComment: function (e) {
			e.preventDefault();

			var url = $( e.currentTarget ).attr('href');

			this.trigger( 'approveComment.comment', {
				url: url,
				commentID: this._commentID
			});
		},

		/**
		 * Model indicates it's starting to approve the comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Data object from model
		 * @returns 	{void}
		 */
		approveCommentLoading: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			this.scope
				.find('[data-role="commentControls"]')
					.addClass('i-opacity_4')
						.find('[data-action="approveComment"]')
							.addClass( 'ipsButton--disabled' )
							.text( ips.getString( 'commentApproving' ) );
		},

		/**
		 * Model returned success for approving the comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Data object from model
		 * @returns 	{void}
		 */
		approveCommentDone: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			var commentHtml = $('<div>' + data.response + '</div>').find('[data-controller="core.front.core.comment"]').html();

			// Remove moderated classes and update HTML
			this.scope
				.html( commentHtml )
				.removeClass('ipsModerated')
				.closest( '.ipsEntry' )
					.removeClass('ipsModerated');

			// Let document know
			$( document ).trigger( 'contentChange', [ this.scope ] );

			// Set up multiquote in this comment
			if( ips.utils.db.isEnabled() ){
				this.scope.find('[data-action="multiQuoteComment"]').removeClass('ipsHide');
			}

			// And show a flash message
			ips.ui.flashMsg.show( ips.getString( 'commentApproved' ) );
		},

		/**
		 * Model returned an error for approving the comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Data object from model
		 * @returns 	{void}
		 */
		approveCommentError: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			window.location = data.url;
		},

		/**
		 * Handler for delete comment
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		deleteComment: function (e) {
			e.preventDefault();

			var url = $( e.currentTarget ).attr('href');
			var commentData = this._getQuoteData();

			var eventData = _.extend( commentData, {
				url: url,
				commentID: this._commentID
			});
			
			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'warn',
				message: ips.getString('delete_confirm'),
				callbacks: {
					ok: () =>{
						this.feedJQ().trigger( 'deleteComment.comment', eventData );
					}
				}
			});
		},

		/**
		 * Model event: delete comment finished
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		deleteCommentDone: function (e, data) {

			if( data.commentID != this._commentID ){
				return;
			}

			var deleteLink = this.scope.find('[data-action="deleteComment"]');

			// Stuff to HIDE elements on delete
			var toHide = null;
			var toShow = null;

			if( deleteLink.attr('data-hideOnDelete') ){
				toHide = this.scope.find( deleteLink.attr('data-hideOnDelete') );
			} else {
				toHide = this.scope.closest('article');
			}

			toHide.animationComplete( function () {
				toHide.remove();
			});

			ips.utils.anim.go( 'fadeOutDown', toHide );

			// Update count
			if ( deleteLink.attr('data-updateOnDelete') ) {
				$( deleteLink.attr('data-updateOnDelete') ).text( parseInt( $( deleteLink.attr('data-updateOnDelete') ).text() ) - 1 );
			}

			// Stuff to SHOW elements on delete
			if( deleteLink.attr('data-showOnDelete') ) {
				toShow = this.scope.find( deleteLink.attr('data-showOnDelete') );
				ips.utils.anim.go( 'fadeIn', toShow );
			}

			this.feedJQ().trigger( 'deletedComment.comment', {
				commentID: this._commentID,
				response: data.response
			});
			
			setTimeout(() => document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles:true})), 10);
		},

		/**
		 * Model event: delete comment failed
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		deleteCommentError: function (e, data) {
			if( data.commentID != this._commentID ){
				return;
			}

			window.location = data.url;
		},

		/**
		 * Prepares post data for quoting
		 *	
		 * @param 		{string|element|jQuery|*} 	html 	Post contents
		 * @returns 	{jQuery|element|*} 	Transformed post contents
		 */
		_prepareQuote: function (html) {
			html = $(html);

			html.find('[data-action="expandTruncate"]').remove();
			/* Remove nested quotes */
			if (![...html.find('> :not(blockquote.ipsQuote)')].some(elem => elem.matches('img,video,iframe,audio,object,embed') || elem.innerText.trim().length || elem.querySelector(':is(img,video,iframe,audio,object,embed):not(blockquote.ipsQuote *)')) && html.find('> blockquote.ipsQuote')) {
				const self = this;
				html.find('> blockquote.ipsQuote').each(function () {
					let child = this.querySelector(':scope > .ipsQuote_contents') || this;
					child.innerHTML = self._prepareQuote($(child.innerHTML)).html();
				});
			} else {
				if (html.find('blockquote.ipsQuote')?.parent()?.get(0)?.matches('div') && html.find('blockquote.ipsQuote').siblings().length === 0) {
					var div = html.find('blockquote.ipsQuote').closest('div');
					div.next('p').find("br:first-child").remove();
					div.remove();
				} else {
					html.find('blockquote.ipsQuote').remove();
				}

				/* Expand spoilers */
				html.find('.ipsStyle_spoilerFancy,.ipsStyle_spoiler').replaceWith(ips.templates.render('core.posts.quotedSpoiler'));

				/* Remove data-excludequote (used for "edited by" byline presently, but can be used by anything) */
				html.find("[data-excludequote]").remove();

				/* Remove the citation */
				html.find('.ipsQuote_citation').remove();

				/* Set the quote value */
				html.find('[data-quote-value]').each(function () {
					$(this).replaceWith('<p>' + $(this).attr('data-quote-value') + '</p>');
				});
			}

			return html;
		},

		/**
		 * Parses the JSON object containing quote data for the comment
		 *	
		 * @returns 	{object} 	Quote data, or else an empty object
		 */
		_getQuoteData: function () {
			if( !this._quoteData ){
				try {
					this._quoteData = $.parseJSON( this.scope.attr('data-quoteData') );
					return this._quoteData;
				} catch (err) {
					Debug.log("Couldn't parse quote data");
					return {};
				}
			}

			return this._quoteData;
		},


		/**
		 * Setup an intersection observer to track when the comment's contentis visible on the page
		 *
		 * @private
		 */
		_setupIntersectionObserver() {
			const elem = this.scope.get(0);
			let observer;
			if (ips.utils.contentViews.enabled() && elem.dataset.viewHash) {
				const otherData = typeof elem.dataset.viewTrackingData === 'string' ? JSON.parse(atob(elem.dataset.viewTrackingData)) : {};
				const key = elem.dataset.viewHash;
				ips.utils.contentViews.registerEntity(key, false, otherData, true, () => {
					observer?.disconnect();
				});

				if (this._observer === null) {
					const target = this.scope.get(0);
					if (target instanceof HTMLElement) {
						this._observer = new IntersectionObserver(this.handleIntersection.bind(this), {
							rootMargin: '20px',
							threshold: 0.8
						});

						this._observer.observe(target);
						observer = this._observer;
					} else {
						this._observer = false;
					}
				}
			}
		},

		/**
		 * Handle an intersection observer event
		 *
		 * @param	{IntersectionObserverEntry[]}	entries		The entries from the observer
		 *
		 * @returns void
		 */
		handleIntersection(entries) {
			const key = this.scope?.get(0).dataset.viewHash;
			if (key) {
				ips.utils.contentViews.setIsViewing(key, entries[0].intersectionRatio >= 0.8);
			}
		},
	});

	/** @type {"down"|"up"} */
	let mouseState = 'up';

	/** @type {Set<function():void>} */
	const mouseUpResolvers = new Set();

	/**
	 * Async function which resolves as soon as the mouse is "up"
	 * @return {Promise<void>}
	 */
	function mouseUp() {
		return new Promise(resolve => {
			if (mouseState === "up") {
				resolve()
			} else {
				mouseUpResolvers.add(resolve)
			}
		})
	}

	/**
	 * Function that resolves all pending mouseUp() calls
	 */
	function clearMouseUpResolvers() {
		mouseState = 'up'
		const resolves = [...mouseUpResolvers]
		mouseUpResolvers.clear()
		resolves.forEach(resolve => resolve())
	}

	document.addEventListener('pointerdown', () => mouseState = 'down', {capture: true})
	document.addEventListener('pointerup', clearMouseUpResolvers, {capture: true})
	document.addEventListener('contextmenu', clearMouseUpResolvers, {capture: true})

	/**
	 * Selection change listener for inline quotes
	 */
	document.addEventListener('selectionchange', _.throttle(() => {
		const selection = document.getSelection();
		for (let i = 0; i < selection.rangeCount; i++) {
			const range = selection.getRangeAt(i);
			const quoteBox = range.commonAncestorContainer instanceof Text ? range.commonAncestorContainer.parentElement.closest('[data-role="commentContent"]') : range.commonAncestorContainer.closest('[data-role="commentContent"]')

			if (quoteBox instanceof Element) {
				mouseUp()
					.then(() => quoteBox.dispatchEvent(new CustomEvent('ipsCalcQuote', {bubbles: true})))
				break;
			}
		}
	}, 1000, {leading: true, trailing: true}))
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.commentFeed.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.commentFeed.js - Controller for a stream of comments (e.g. a topic, conversation, etc.)
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.commentFeed', {

		_overlay: null,
		_commentFeedID: 0,
		_newRepliesFlash: null,
		_maximumMultiQuote: 50, // Maximum number of items that can be multiquoted
		_pageParam: 'page',
		_seoPagination: false,
		_urlParams: {},
		_baseURL: '',
		_doneInitialState: false,
		_initialURL: '',

		// Polling vars
		_pollingEnabled: true, // Is polling enabled at all?
		_pollingActive: false, // Is polling running right now?
		_pollingPaused: false, // Have we paused polling?
		_initialPoll: 10000, // Our base polling frequency (1 minute)
		_currentPoll: 10000, // The current interval
		_decay: 20000, // Decay (amount added to interval on each false response)
		_maxInterval: ( 30 * 60 ) * 1000, // Maximum interval possible (30 mins)
		_pollingTimeout: null, // timeout obj
		_pollAjax: null, // ajax obj
		_pollOnUnpaused: false, // If true, when window is focused a poll will fire immediately
		_notification: null,
		_lastSeenTotal: 0,

		initialize () {
			this._containerID = this.scope.closest('[data-commentsContainer]').length ? this.scope.closest('[data-commentsContainer]').attr('data-commentsContainer') : this.scope.identify().attr('id');

			this.on( 'submit', '[data-role="replyArea"]', this.quickReply );
			this.on( 'quoteComment.comment', this.quoteComment );
			this.on( 'addMultiQuote.comment', this.addMultiQuote );
			this.on( 'removeMultiQuote.comment deleteComment.comment', this.removeMultiQuote );
			this.on( 'click', '[data-action="filterClick"]', this.filterClick );
			this.on( 'menuItemSelected', '[data-role="signatureOptions"]', this.signatureOptions );
			this.on( 'editorCompatibility', this.editorCompatibility );
			this.on( 'checkedComment.comment', this.checkedComment );
			if (this.elem?.dataset.pageParam) {
				this._pageParam = this.elem.dataset.pageParam;
			}

			this._boundMQ = _.bind( this.doMultiQuote, this );
			this._boundCMQ = _.bind( this.clearMultiQuote, this );
			
			$( document ).on( 'click', '[data-role="multiQuote_' + this._containerID + '"]', this._boundMQ );
			$( document ).on( 'click', '[data-action="clearQuoted_' + this._containerID + '"]', this._boundCMQ );
			$( document ).on( 'moderationSubmitted', this.clearLocalStorage );

			this.on( 'paginationClicked paginationJump', this.paginationClick );

			// Watch events on the document that are actually triggered from within this.quickReply
			this.on( document, 'addToCommentFeed', this.addToCommentFeed );
			this.on( 'deletedComment.comment', this.deletedComment );

			// Window events for polling purposes
			//$( window ).on( 'blur', _.bind( this.windowBlur, this ) );
			//$( window ).on( 'focus', _.bind( this.windowFocus, this ) );

			// Event we watch for on flash messages
			this.on( document, 'click', '[data-action="loadNewPosts"]', this.loadNewPosts );

			// Watch for state updates
			this.on(window, 'historychange', this.stateChange);

			// Socket events
			this.on(document, "socket.new_comment", this.handleSocketCommentTrigger);
			this.setup();
		},

		/**
		 * Setup method for comment feeds
		 *
		 * @returns {void}
		 */
		setup: function () {
			const replyForm = this.scope.find('[data-role="replyArea"] form');

			this._commentFeedID = this.scope.attr('data-feedID');
			this._urlParams = this._getUrlParams();
			this._baseURL = this.scope.attr('data-baseURL');
			this._initialURL = window.location.href;
			this._currentPage = ips.utils.url.getPageNumber( this._pageParam );
			this._urlParams[ this._pageParam ] = this._currentPage;

			if (this._baseURL.match(/\?[^?]+$/)) {
				this._baseURL += '&';
			} else {
				this._baseURL += '?';
			}

			if( replyForm.attr('data-noAjax') ){
				this._pollingEnabled = false;
			}

			if (!('commentFeed' in ips.utils.history.getState())) {
				this._updateState({})
				ips.utils.history.replaceState(this.historyState, 'commentFeed', window.location.href)
			}

			if( !_.isUndefined( this.scope.attr('data-lastPage') ) && this._pollingEnabled ){
				this._startPolling();
			}

			$(document).ready(() => {
				this._setUpMultiQuote();
				this._findCheckedComments();
			});

			if (ips.getSetting('relativeDates')) {
				this.on('updateTimestamps', this._updateTimestamps);
			}

			// Prevent empty submissions
			for (const ev of ['ips:editorUpdated', 'ips:editorAfterInit']) {
				this.elem.addEventListener(ev, _.debounce(e => {
					const {elem, instance} = e.detail;
					const submit = elem.closest(CSS.supports('selector(a:has(b))') ? 'form:has(input[type="submit"],button[type="submit"])' : 'form').querySelectorAll(':is(button, input)[type="submit"]');
					if (!submit.length) {
						return;
					}


					/**
					 * Recursively check to see if a node has actual content
					 * @param	node		A node in the Prose Mirror Document Tree
					 * @return {boolean}
					 */
					function nodeHasContent(node) {
						if (node.textContent?.trim()?.length) {
							return true;
						}

						if (node.isAtom && !node.isText) {
							return true;
						}

						if (node.children && Symbol.iterator in node.children) {
							for (const child of node.children) {
								if (nodeHasContent(child)) {
									return true;
								}
							}
						}

						return false;
					}

					const empty = !nodeHasContent(instance.state.doc);
					submit.forEach(item => {
						if (empty) {
							item.setAttribute('disabled', '');
						} else {
							item.removeAttribute('disabled');
						}
					})
				}, 100));
			}
		},

        /**
         * Clear local storage after form is submitted
         *
         * @returns {void}
         */
        clearLocalStorage: function () {
            ips.utils.db.remove( 'moderation', $( document ).find("[data-feedID]").attr('data-feedID') );
        },

		/**
		 * Destroy method
		 *
		 * @returns {void}
		 */
		destroy: function () {
			$( document ).off( 'click', '[data-role="multiQuote_' + this._containerID + '"]', this._boundMQ );
			$( document ).off( 'click', '[data-action="clearQuoted_' + this._containerID + '"]', this._boundCMQ );
			this._stopPolling();
		},

		/**
		 * Returns an object containing URL parameters
		 *
		 * @returns {object}
		 */
		_getUrlParams: function () {
			const sort = this._getSortValue();
			const obj = {
				sortby: sort.by || '',
				sortdirection: sort.order || '',
			};

			obj[ this._pageParam ] = ips.utils.url.getPageNumber( this._pageParam ) || 1;

			return obj;
		},

		/**
		 * Returns the current sort by and sort order value
		 *
		 * @returns {object}	Object containing by and order keys
		 */
		_getSortValue: function () {
			return { by: '', order: '' };
		},

		/**
		 * Responds to state changes triggered by History.js
		 *
		 * @param {CustomEvent}	e
		 *
		 * @returns {void}
		 */
		stateChange(e) {
			if (e.detail?.type === 'replace' || !('commentFeed' in ips.utils.history.getState())) {
				return;
			}

			/**
			 * @type {{data: Object, url: string}}
			 */
			const state = {
				data: ips.utils.history.getState('commentFeed'),
				url: window.location.href
			}

			if (typeof state.data !== "object") {
				return;
			}

			// If the last change was a commentFeed event directly, we handle it. Otherwise, we need to verify that the change is actually a change
			const lastChange = e.detail.type === 'pop' ? 'pop' : ips.utils.history.getLastChangeType()
			if (lastChange && lastChange !== 'commentFeed' && typeof this.historyState === "object") {
				let commentFeedChanged = false;
				if (Object.keys(this.historyState).length !== Object.keys(state.data).length) {
					commentFeedChanged = true;
				} else {
					for (const key in this.historyState) {
						if (!(key in state.data) || this.historyState[key] !== state.data[key]) {
							commentFeedChanged = true;
							break;
						}
					}
				}

				// Only return if the comment feed's data really wasn't changed. Otherwise the content still has to be updated
				if (!commentFeedChanged) {
					return
				}
			}

			// Make sure the state we're working with belongs to this controller/feed.
			if ((state.data.controller !== this.controllerID || state.data.feedID !== this._commentFeedID)) {
				if (state.data.controller === undefined && state.url === this._initialURL) {
					// If there's no controller info in the state, but the state URL matches our initial URL, we'll reload that initial page content
					Debug.log("No controller state, but state URL matched initial URL");
				} else {
					return;
				}
			}

			// Update data
			this.historyState = state.data;
			this._urlParams = state.data;

			// Register page view
			ips.utils.analytics.trackPageView( state.url );
			this._getResults();
		},

		/**
		 * Fetches new results from the server, then calls this._updateTable to update the
		 * content and pagination. Simply redirects to URL on error.
		 *
		 * @param 	{string} 	[url] 	Optional URL to fetch the results from. If omitted
		 								 the URL will be built based on the current params object
		 * @returns {void}
		 */
		_getResults(url) {
			this._setLoading( true );
			ips.getAjax()( url || this._getURL(), {
				showLoading: true
			})
				.done(response => this._getResultsDone(response))
				.fail((...args) => this._getResultsFail(...args))
				.always(() => this._getResultsAlways());
		},

		/**
		 * New results have finished loading
		 *
		 * @param 	{string}	Results HTML from ajax request
		 * @returns {void}		
		 */
		_getResultsDone (response) {
			const feed = Array.from((new DOMParser())
				.parseFromString(`<div>${response}</div>`, 'text/html')
				.querySelectorAll(`[data-feedid="${this.scope.attr('data-feedid')}"]`))
				.find(el => el.dataset.controller?.match(/core\.front\.core\.commentFeed/i))

			if (!feed) {
				this._getResultsFail(new RangeError(`The response did not include a content feed element with a feed id matching this one`))
				return;
			}

			const newContents = feed.innerHTML;

			const scrollPos = window.scrollY;
			this.cleanContents();
			this.scope.hide().html( newContents );
			window.scrollTo({top: scrollPos, behavior: 'auto'})

			// Show content and hide loading
			ips.utils.anim.go( 'fadeIn', this.scope ).done(() => {
				if (this._updateDoneCallback instanceof Function) {
					setTimeout(this._updateDoneCallback, 10);
				}
				this._updateDoneCallback = null
			});
			this._overlay.hide();

			// Last page check:
			// Check whether we're on the last page, because if we are we need to start polling (or stop if not last page)
			const currentPageNo = ips.utils.url.getPageNumber(this._pageParam, window.location.href),
				lastPageNo		= this.scope.find('li.ipsPagination__last > a').first().attr('data-page');

			if (currentPageNo !== lastPageNo) {
				this.scope.removeAttr( 'data-lastPage' );
				this._stopPolling();
			} else {
				this.scope.attr( 'data-lastPage', true );

				if( this._pollingEnabled ){
					this._currentPoll = this._initialPoll;
					this._startPolling();
				}
			}

			// Update multiquote, let document know, then highlight checked comments
			this._setUpMultiQuote();
			$( document ).trigger( 'contentChange', [ this.scope ] );
			this._findCheckedComments();
			ips.ui.tableOfContents.refreshElems();
		},

		/**
		 * Callback when the results ajax fails
		 *
		 * @param 	{object} 	jqXHR			jQuery XHR object
		 * @param	{string} 	textStatus		Error message
		 * @param 	{string}	errorThrown
		 * @returns {void}
		 */
		_getResultsFail: function (jqXHR, textStatus, errorThrown) {
			if( Debug.isEnabled() ){
				if (jqXHR instanceof RangeError) {
					Debug.error(jqXHR)
					return;
				}
				Debug.error( "Ajax request failed (" + textStatus + "): " + errorThrown );
				Debug.error( jqXHR.responseText );
			} else {
				// rut-roh, we'll just do a manual redirect
				window.location = this._getURL();
			}
		},

		/**
		 * Callback always called after ajax request to load results
		 *
		 * @returns {void}
		 */
		_getResultsAlways: function () {
			//
		},

		/**
		 * Callback always called after ajax request to load results
		 *
		 * @returns {void}
		 */
		_setLoading: function (status) {
			var commentFeed = this.scope.find('[data-role="commentFeed"]');

			if( status ){
				if( !this._overlay ){
					this._overlay = $('<div/>').addClass('ipsLoading').hide();
					ips.getContainer().append( this._overlay );
				}

				// Get dims & position			
				var dims = ips.utils.position.getElemDims( commentFeed );
				var position = ips.utils.position.getElemPosition( commentFeed );

				this._overlay.show().css({
					left: position.viewportOffset.left + 'px',
					top: position.viewportOffset.top + $( document ).scrollTop() + 'px',
					width: dims.width + 'px',
					height: dims.height + 'px',
					position: 'absolute',
					zIndex: ips.ui.zIndex()
				});

				commentFeed.animate({
					opacity: "0.5"
				});
			} else {
				// Stop loading
			}
		},

		_paginatedOnce: false,

		/**
		 * Responds to a pagination click
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		paginationClick: function (e, data) {
			data.originalEvent.preventDefault();

			if( data.pageNo !== this._urlParams[ this._pageParam ] ) {
				Debug.log("Possibly collapsing elements as the user navigated away from the first page");
				if (parseInt(`${this._urlParams[this._pageParam]}`) === 1 && !this._paginatedOnce) {
					document
						.querySelectorAll(`[data-feedid="${this._commentFeedID}"] [data-collapse-off-first-page]`)
						.forEach(toCollapse => {
							toCollapse.dispatchEvent(new CustomEvent("ips:truncateCollapse", {bubbles: true}));
						})
				}

				this._paginatedOnce = true;
				const urlObj = new URL(data.href, location.href);
				const queryKey = Object.fromEntries(urlObj.searchParams.entries());

				// If this is coming from a page jump, the page number may not be in the href passed
				// through. So check whether it exists, and manually add it to the object if needed.
				if (!(this._pageParam in queryKey)) {
					queryKey[ this._pageParam ] = data.pageNo;
				}
				
				this._seoPagination = data.seoPagination;
				this._updateURL( queryKey, () => {
					const elem = this.elem.querySelector(`.ipsButtonBar--top`)
					if (!(elem instanceof HTMLElement)) {
						Debug.warn("Couldn't find the .ipsButtonBar--top or .ipsButtonBar--bottom pagination container inside the comment feed controller. This is likely a theme error that needs to be addressed so that the content feed can be scrolled to the top or bottom after pagination")
						return;
					}
					const boundingBox = elem.getBoundingClientRect()
					if (boundingBox.top > 30 && boundingBox.bottom < window.innerHeight - 30) {
						return;
					}

					window.scrollBy({
						top: boundingBox.top - 30,
						behavior: 'smooth'
					})
				});
			}
		},

		/**
		 * Pushes a new URL state to the browser
		 *	
		 * @param 		{object} 	newParams 	Object to be added to the state
		 * @param 		{function}	[callback]	Callback to be called after this is done
		 * @returns 	{void}
		 */
		_updateURL: function (newParams, callback) {
			this._updateState(newParams)
			let newUrl= this._getURL();
			if (newUrl.slice(-1) === '?' ){
				newUrl = newUrl.substring( 0, newUrl.length - 1 );
			}

			if (this._seoPagination === true) {
				newUrl = ips.utils.url.pageParamToPath( newUrl, this._pageParam, this.historyState[ this._pageParam ] );
			}

			ips.utils.history.pushState(this.historyState, 'commentFeed', newUrl);
			this._updateDoneCallback = callback;
		},

		/**
		 * Update the state with new params
		 *
		 * @param {object}	newParams
		 * @private
		 */
		_updateState(newParams) {
			Object.assign(this._urlParams, newParams);
			this.historyState = {...this._urlParams}
			Object.assign(this.historyState, {controller: this.controllerID, feedID: this._commentFeedID})
		},

		/**
		 * Builds a param string from values in this._urlParams, excluding empty values
		 *
		 * @returns {string}	Param string
		 */
		_getURL: function () {
			const urlObj = new URL(this._baseURL);
			const skipParams = new Set(['controller', 'feedID', 'bypassState']);
			const params = {};
			for (const param in this._urlParams) {
				if (this._urlParams[param] && !skipParams.has(param)) {
					params[param] = this._urlParams[param].toString();
				}
			}
			urlObj.updateSearchParams({params});
			return urlObj.toString();
		},

		/**
		 * An editor in this feed has indicated its compatibility
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		editorCompatibility: function (e, data) {
			if( !data.compatible ){
				this.triggerOn( 'core.front.core.comment', 'disableQuoting.comment' );
			}
		},

		/**
		 * A comment controller triggered an event indicating it was selected
		 * Adds the comment ID and actions to localStorage so it can be tracked across
		 * pages of the feed
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		checkedComment: function (e, data) {
			var dataStore = ips.utils.db.get( 'moderation', this._commentFeedID ) || {};

			if( data.checked ){
				if( _.isUndefined( dataStore[ data.commentID ] ) ){
					dataStore[ data.commentID ] = data.actions;
				}
			} else {
				delete dataStore[ data.commentID ];
			}

			// Store the updated value for a day, or delete if it's empty now
			if( _.size( dataStore ) ){
				ips.utils.db.set( 'moderation', this._commentFeedID, dataStore, undefined, (Date.now() / 1000) + 86400 );
			} else {
				ips.utils.db.remove( 'moderation', this._commentFeedID );
			}			
		},

		/**
		 * Called on setup, loops through the selected comments for this feedID from localstorage,
		 * and checks any that are present on this page. For others, instructs the pageAction
		 * widget to add the ID to its store manually so that they can still be worked with.
		 *
		 * @returns {void}
		 */
		_findCheckedComments: function () {
			// Bail if there's no checkboxes anyway
			if( !this.scope.find('input[type="checkbox"]').length ){
				return;
			}

			// Fetch the checked comments for this feedID
			var dataStore = ips.utils.db.get( 'moderation', this._commentFeedID ) || {};
			var self = this;
			var pageAction = this.scope.find('[data-ipsPageAction]');

			if( _.size( dataStore ) ){
				var sizeOtherPage = 0;

				_.each( dataStore, function (val, key) {
					if( self.scope.find('[data-commentID="' + key + '"]').length ){
						self.scope
							.find('[data-commentID="' + key + '"] input[type="checkbox"][data-role="moderation"]')
							.attr( 'checked', true )
							.trigger('change');
					} else {
						sizeOtherPage++;

						pageAction.trigger('addManualItem.pageAction', {
							id: 'multimod[' + key + ']',
							actions: val
						});
					}
				});

				if( this.scope.find('[data-ipsAutoCheck]') )
				{
					this.scope.find('[data-ipsAutoCheck]').trigger( 'setInitialCount.autoCheck', { count: sizeOtherPage } );
				}
			}
		},
	
		/**
		 * Options 
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */		
		signatureOptions: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			if( data.selectedItemID == 'oneSignature' ){
				this._ignoreSingleSignature( $( e.currentTarget ).attr('data-memberID') );
			} else {
				this._ignoreAllSignatures();
			}
		},

		/**
		 * Fires a request to hide all signatures in the feed
		 *
		 * @returns 	{void}
		 */	
		_ignoreAllSignatures: function () {
			var self = this;
			var url = ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=settings&do=toggleSigs';
			var signatures = this.scope.find('[data-role="memberSignature"]');

			// Hide all signatures on the page
			signatures.slideUp();

			ips.getAjax()( url )
				.done( function (response) {
					ips.ui.flashMsg.show( ips.getString('signatures_hidden') );
					signatures.remove();
				})
				.fail( function () {
					signatures.show();

					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warn',
						message: ips.getString('signatures_error'),
						callbacks: {}
					});
				});
		},

		/**
		 * Fires a request to hide a single signature (i.e. a single member's signature)
		 *	
		 * @param 		{number} 	memberID 	Member ID's signature to hide
		 * @returns 	{void}
		 */	
		_ignoreSingleSignature: function (memberID) {
			var url = ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=ignore&do=ignoreType&type=signatures';
			var signatures = this.scope.find('[data-role="memberSignature"]').find('[data-memberID="' + memberID + '"]').closest('[data-role="memberSignature"]');

			signatures.slideUp();

			ips.getAjax()( url, {
				data: {
					member_id: parseInt( memberID )
				}
			})
				.done( function (response) {
					ips.ui.flashMsg.show( ips.getString('single_signature_hidden') );
					signatures.remove();
				})
				.fail( function () {
					signatures.show();

					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warn',
						message: ips.getString('single_signature_error'),
						callbacks: {}
					});
				});
		},

		/**
		 * Filter click
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		filterClick: function(e) {
			e.preventDefault();

			var urlObj = ips.utils.url.getURIObject( $( e.target ).attr('href') );
			var queryKey = urlObj.queryKey;

			this._updateURL( queryKey );
		},

		/**
		 * Responds to a quote event from a comment controller
		 * Finds the reply box for this feed, and triggers a new event instructing the 
		 * editor to insert the quote
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object (which should contain all of the properties necessary for a quote)
		 * @returns 	{void}
		 */
		quoteComment: function (e, data) {
			if (this.scope.find('[data-role="replyArea"] [data-ipsEditorv5]').length) {
				ips.ui.editorv5.getObjWithInit(this.scope.find('[data-role="replyArea"] [data-ipsEditorv5]'), function (editor) {
					editor.insertQuotes([data]);
				});
			}
		},

		/**
		 * If the window blurs, we will pause polling, but if a poll is skipped, we'll immediately poll on window focus
		 *	
		 * @returns 	{void}
		 */
		windowBlur: function (e) {
			if( this._pollingEnabled ){
				Debug.log( 'Window blurred, pausing polling...' );
				this._pollingPaused = true;
			}
		},

		/**
		 * Window focus - if polling was paused and a poll was skipped, trigger it immediately now
		 *	
		 * @returns 	{void}
		 */
		windowFocus: function (e) {
			if( this._pollingEnabled && this._pollingPaused ){
				Debug.log( 'Window focused...' );

				this._pollingPaused = false;

				if( this._pollOnUnpaused ){
					this._pollOnUnpaused = false;
					this.pollForNewReplies();
				}
			}
		},

		/**
		 * Socket has told us there may be new replies, so we'll trigger a manual check here
		 */
		handleSocketCommentTrigger: function () {
			if( !_.isUndefined( this.scope.attr('data-lastPage') ) && this._pollingEnabled ){
				this.pollForNewReplies();
			}
		},

		/**
		 * Set a timeout for the new post polling process
		 *	
		 * @returns 	{void}
		 */
		_startPolling: function () {
			if (ips.utils.sockets.enabled() && ips.utils.sockets.connected()) {
				if (ips.getSetting('relativeDates')) {
					if (this._timestampTimeout) {
						clearTimeout(this._timestampTimeout);
					}
					Debug.log('Setting interval to poll for relative dates');
					this._timestampTimeout = setTimeout(() => {
						this._updateTimestamps();

						// Add 20 seconds to the poll interval, up to a max of 5 minutes
						if( ( this._currentPoll + this._decay ) < this._maxInterval ){
							this._currentPoll += this._decay;
						} else {
							this._currentPoll = this._maxInterval;
						}

						this._startPolling();
					}, this._currentPoll);
				}
				return;
			}
			this._pollingActive = true;
			Debug.log('Starting polling with interval ' + ( this._currentPoll / 1000 ) + 's' );

			this._pollingTimeout = setTimeout(() => {
				this.pollForNewReplies();
			}, this._currentPoll );
		},

		/**
		 * Clear the new post poll timeout
		 *	
		 * @returns 	{void}
		 */
		_stopPolling: function () {
			this._pollingActive = false;

			if( this._pollingTimeout ){
				clearTimeout( this._pollingTimeout );
			}

			Debug.log("Stopped polling for new replies in comment feed.");
		},
		
		/**
		 * Checks for new replies since we opened the page
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		pollForNewReplies() {
			const replyForm = this.scope.find('[data-role="replyArea"] form');
			const commentsOnThisPage = document.querySelectorAll(`[data-feedid="${this.elem.dataset.feedid}"] [data-commentid]`);

			if (!commentsOnThisPage.length) {
				return;
			}

			const lastSeenId = this._getLastSeenID($(commentsOnThisPage));
			const type = $(commentsOnThisPage[commentsOnThisPage.length - 1]).attr('data-commentType');

			if (type.match(/-review$/)) {
				Debug.log("Polling disabled for reviews");
				this._stopPolling();
				return;
			}

			if (this._pollingPaused) {
				Debug.log('Window blurred, delaying poll until focused...');
				this._pollOnUnpaused = true;
				return;
			}

			// Abort any running ajax
			if (this._pollAjax && this._pollAjax.abort !== undefined) {
				this._pollAjax.abort();
			}

			this._pollAjax = ips.getAjax();
			this._pollAjax(replyForm.attr('action'), {
				dataType: 'json',
				data: 'do=checkForNewReplies&type=count&lastSeenID=' + lastSeenId + '&csrfKey=' + ips.getSetting('csrfKey'),
				type: 'post'
			})
				/**
				 * @typedef PaginationResponse
				 * @property	{number}    [count]
				 * @property	{string}    [name]
				 * @property   	{string}    [photo]
				 * @property    {string}    [title]
				 * @property    {number}    [perPage]    The amount of responses that can be stored per page
				 * @property 	{string}	[error]
				 *
				 */
				.done(
					/**
					 *
					 * @param {PaginationResponse}	response
					 */
					response => {

						// If auto-polling is now disabled, stop everything
						if (response.error && response.error === 'auto_polling_disabled') {
							this._stopPolling();
							return;
						}


						if (parseInt( response.count ) > 0) {
							// Reset the poll interval
							this._currentPoll = this._initialPoll;

							// If they'll fit on one page, import them now
							if (this.getCurrentCommentPageCount() < parseInt(response.perPage)) {
								this._importNewReplies(false);
							} else {
								this._buildFlashMsg(response);
								if (parseInt(response.totalCount) > parseInt(this._lastSeenTotal)) {
									this._buildNotifications(response);
									this._lastSeenTotal = parseInt(response.totalCount);
								}
							}
						} else {
							// Add 20 seconds to the poll interval, up to a max of 5 minutes
							if( ( this._currentPoll + this._decay ) < this._maxInterval ){
								this._currentPoll += this._decay;
							} else {
								this._currentPoll = this._maxInterval;
							}
						}

						// Start again if we're on the last page
						if (this.scope.attr('data-lastPage') !== undefined){
							this._startPolling();
						}
					});

			// lastly, update timestamps too
			if (ips.getSetting('relativeDates')) {
				this._updateTimestamps();
			}
		},

		/**
		 * Get the number of comments currently shown
		 *
		 * @returns {number}
		 */
		getCurrentCommentPageCount() {
			if (this.scope) {
				return $(this.scope).get(0).querySelectorAll(`[data-commentid]`).length
			} else {
				return 0
			}
		},

		/**
		 * Builds a flash message to alert user of new posts
		 *	
		 * @param 		{object} 	response 		Information object
		 * @returns 	{void}
		 */
		_buildFlashMsg(response) {
			const spaceForMore = parseInt(response.perPage) - this.getCurrentCommentPageCount();
			let html;

			// Build our flash message HTML
			if (parseInt(response.count) > spaceForMore) {
				html = ips.templates.render( 'core.postNotify.multipleSpillOver', {
					text: ips.pluralize( ips.getString( 'newPostMultipleSpillOver' ), [ response.totalNewCount ] ),
					canLoadNew: ( spaceForMore > 0 ),
					showFirstX: ips.pluralize( ips.getString( 'showFirstX' ), [ spaceForMore ] ),
					spillOverUrl: response.spillOverUrl
				});
			} else if( parseInt( response.count ) === 1 && !_.isUndefined( response.photo ) && !_.isUndefined( response.name ) ){
				html = ips.templates.render( 'core.postNotify.single', {
					photo: response.photo,
					text: ips.getString( 'newPostSingle', { name: response.name } )
				});
			} else {
				html = ips.templates.render( 'core.postNotify.multiple', {
					text: ips.pluralize( ips.getString( 'newPostMultiple' ), [ response.count ] )
				});
			}

			if ($('#elFlashMessage').is(':visible') && $('#elFlashMessage').find('[data-role="newPostNotification"]').length) {
				$('#elFlashMessage').find('[data-role="newPostNotification"]').replaceWith(html);
			} else {
				ips.ui.flashMsg.show( 
					html,
					{ 
						sticky: true, 
						position: 'bottom', 
						extraClasses: 'cPostFlash',
						dismissable: () => this._stopPolling(),
						escape: false
					}
				);
			}
		},

		/**
		 * Builds browser notifications to alert users of new posts
		 *	
		 * @param 		{object} 	response 		Information object
		 * @param		{number}	response.count
		 * @param	{string}		[response.name]
		 * @param	{string}		[response.photo]
		 * @param	{string}		[response.title]
		 * @param	{number}		[response.perPage]	The amount of responses that can be stored per page
		 * @returns 	{void}
		 */
		_buildNotifications(response) {
			const hiddenProp = ips.utils.events.getVisibilityProp();

			// Build our browser notification if the window isn't in focus *and* we support them
			if (hiddenProp === undefined || !document[hiddenProp] || !ips.utils.notification.hasPermission()) {
				return;
			}

			const notifyData = {
				onClick: e => {

					// Try and focus the window (security settings may prevent it, though)
					try {
						window.focus();
					} catch (err) {
					}

					// And load in those posts
					this.loadNewPosts(e);
				}
			};

			// If we already have a notification, then hide it
			if (this._notification) {
				this._notification.hide();
			}

			if (parseInt(response.count) === 1 && 'photo' in response && 'name' in response) {
				Object.apply(notifyData, {
					title: ips.getString('notificationNewPostSingleTitle', response),
					body: ips.getString('notificationNewPostSingleBody', response),
					icon: response.photo
				});
			} else {
				Object.apply(notifyData, {
					title: ips.pluralize(ips.getString('notificationNewPostMultipleTitle'), [ response.count ]),
					body: ips.pluralize(ips.getString('notificationNewPostMultipleBody', response), [ response.count ])
				});
			}

			// Create the new one
			this._notification = ips.utils.notification.create( notifyData );
			this._notification.show();
		},

		/**
		 * Adds new replies to the display
		 *
		 * @param 	{boolean}		[loadNewPage=true]		Load a new page if the latest comments won't fit on this page
		 *
		 * @returns 	{void}
		 */
		async _importNewReplies(loadNewPage=true) {
			const form = this.scope.find('[data-role="replyArea"] form');
			const commentsOnThisPage = this.scope.find('[data-commentid]');
			const _lastSeenID = this._getLastSeenID(commentsOnThisPage);

			try {
				const response = await ips.fetch(form.attr('action'), {
					data: {
						do: 'checkForNewReplies',
						type: 'fetch',
						lastSeenID: _lastSeenID,
						showing: this.getCurrentCommentPageCount()
					},
					type: 'post'
				});

				// If we have more comments to load than we allow per page, then reload the page to show them plus the pagination
				if (loadNewPage && commentsOnThisPage.length + parseInt(response.totalNewCount) > response.perPage) {
					if (response.spillOverUrl) {
						window.location = response.spillOverUrl;
					} else {
						window.location.reload();
					}
				} else {
					for (const item of [response.content].flat()) {
						this.trigger('addToCommentFeed', {
							content: item,
							feedID: this._commentFeedID,
							resetEditor: false,
							totalItems: response.totalCount
						});
					}
				}

				this._clearNotifications();
			} catch (e) {
				Debug.warn(`Could not import new replies for the comment feed!`);
				Debug.error(e);
			}
		},

		/**
		 * Close the flash message for new post notifications
		 *
		 * @returns 	{void}
		 */
		_clearNotifications: function () {
			if( this._notification && _.isFunction( this._notification.hide() ) ){
				this._notification.hide();
			}

			if( $('#elFlashMessage').find('[data-role="newPostNotification"]').length ){
				$('#elFlashMessage').find('[data-role="newPostNotification"]').trigger('closeFlashMsg.flashMsg');
			}
		},

		/**
		 * Handles quick-reply functionality for this comment feed. Post the content via ajax,
		 * and trigger events to handle showing the new post (or redirecting to a new page)
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		quickReply: function (e) {
		
			const form = this.scope.find('[data-role="replyArea"] form');
			if ( form.attr('data-noAjax') ) {
				return;
			}
			
			e.preventDefault();
			e.stopPropagation();

			const self = this;
			const replyArea = this.scope.find('[data-role="replyArea"]');
			const submit = form.find('[type="submit"]');
			const autoFollow = this.scope.find('input[name$="auto_follow_checkbox"]');
			const commentsOnThisPage = this.scope.find('[data-commentid]');
			const _lastSeenID = this._getLastSeenID(commentsOnThisPage);

			// Set the form to loading
			const submitButtons = [...submit];
			const submitRestorations = [];
			submitButtons.forEach(button => {
				if (button.closest('.ipsIconPicker')) {
					return;
				}
				const initialText = button.innerText;
				button.setAttribute('disabled', '');
				button.innerText = ips.getString('saving');
				submitRestorations.push(() => {
					button.removeAttribute('disabled');
					button.innerText = initialText;
				});
			});

			let page = ips.utils.url.getPageNumber(this._pageParam);

			if( !page ){
				page = 1;
			}
			
			this._clearNotifications();

			ips.getAjax()( form.attr('action'), {
				data: form.serialize() + '&currentPage=' + page + '&_lastSeenID=' + _lastSeenID,
				type: 'post'
			})
				.done( function (response) {
					if ( response.type == 'error' ) {
						Debug.error(response);
						Debug.error('Failed to submit content via quick reply');
						if ( response.form ) {
							if (replyArea.find('[data-ipseditorv5]')) {
								ips.ui.editorv5.getObj(replyArea.find('[data-ipseditorv5]')).destruct(false);
							}
							form.replaceWith( $(response.form) );
							$( document ).trigger( 'contentChange', [ self.scope ] );
						} else {
							ips.ui.alert.show( {
								type: 'alert',
								icon: 'warn',
								message: response.message,
								callbacks: {}
							});
						}
					}
					else if( response.type == 'redirect' ) {
						self.paginationClick( e, {
							href: response.url,
							originalEvent: e
						});
					} else if( response.type == 'merge' ) {
						var comment = $(self.findCommentInFeed(response.id));
						comment.find('[data-role="commentContent"]').html( response.content );
												
						if( comment.find('pre.prettyprint').length ){
							comment.find('pre.prettyprint').each( function () {
								$( this ).html( window.PR.prettyPrintOne( _.escape( $( this ).text() ) ) );
							});
						}
						
						self.scope.find('[data-role="replyArea"] [data-ipsEditorv5]' ).data('_editor').reset();

						if( self.scope.find('[data-role="replyArea"] input[name="guest_name"]').length )
						{
							self.scope.find('[data-role="replyArea"] input[name="guest_name"]').val('');
						}
						form.find("[data-role='commentFormError']").each(function() {
						  $( this ).remove();
						});

						const container = comment.closest('.js-ipsEntry');
						if ( container.length ) {
							ips.utils.anim.go( 'pulseOnce', container );
						} else {
							ips.utils.anim.go( 'pulseOnce', comment );
						}
						ips.ui.flashMsg.show( ips.getString('mergedConncurrentPosts') );
						
						$( document ).trigger( 'contentChange', [ self.scope ] );
					} else {

						/* add the datalayer event if we posted it */
						if ( response.postedByLoggedInMember ) {
							self.trigger( 'ipsDataLayer', { _key: 'content_comment', _properties: response.dataLayer } );
						}

						self.trigger( 'addToCommentFeed', {
							content: response.content,
							totalItems: response.total,
							feedID: self._commentFeedID,
							scrollToItem: true
						});
						
						if ( response.message ) {
							ips.ui.flashMsg.show( response.message );
						}

						// If this is a guest posting editor
						if( self.scope.find('[data-role="replyArea"] input[name="guest_name"]').length )
						{
							self.scope.find('[data-role="replyArea"] input[name="guest_name"]').val('');
							self.scope.find('[data-role="replyArea"] [data-ipsEditorv5]')
								.find('.ipsComposeArea_dummy')
									.hide()
								.end()
								.find('[data-role="mainEditorArea"]')
									.show()
								.end()
								.closest('.ipsComposeArea')
									.removeClass('ipsComposeArea_minimized')
									.find('[data-ipsEditor-toolList]')
										.show();
						}
						form.find("[data-role='commentFormError']").each(function() {
						  $( this ).remove();
						});

						// If the user is following this item, we can update the follow button too
						if( autoFollow.length ){
							self.trigger( 'followingItem', {
								feedID: self.scope.attr('data-follow-area-id') || self.scope.attr('data-feedID'),
								following: autoFollow.is(':checked')
							});
						}
					}
					
					self._clearNotifications();
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					if( Debug.isEnabled() ){
						Debug.error("Posting new reply failed: " + textStatus);
						Debug.log( jqXHR );
						Debug.log( errorThrown );
					} else {
						form.attr('data-noAjax', 'true');
						form.attr('action', form.attr('action') + ( ( ! form.attr('action').match( /\?/ ) ) ? '?failedReply=1' : '&failedReply=1' ) );
						form.submit();
					}
				})
				.always( function () {
					submitRestorations.forEach(cb => cb());
				});
		},

		/**
		 * Event handler for the 'load new posts' link in flash messages
		 *	
		 * @param 		{Event} 	[e] 		Event object
		 * @returns 	{void}
		 */
		loadNewPosts: function (e) {
			e?.preventDefault?.();
			this._importNewReplies();
		},

		/**
		 * Find a comment in this feed. Comments can occasionally be outside of the feed's DOM element, such as for featured first posts
		 * @param commentId
		 * @return {Element|null}
		 */
		findCommentInFeed(commentId) {
			const commentSelector = `[data-commentid="${commentId}"]`;
			const comment = this.elem.querySelector(`[data-role="commentFeed"] ${commentSelector}`);
			if (comment) {
				return comment;
			} else if (this.elem.dataset.feedid) {
				const feedSelector = `[data-feedid="${this.elem.dataset.feedid}"]`;
				return document.querySelector(`${feedSelector}${commentSelector}, ${feedSelector} ${commentSelector}`) || null;
			}

			return null;
		},

		/**
		 * Responds to an event (trigger within this controller) indicating a new comment has been added
		 * Show it, and reset the contents of tiptap
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		addToCommentFeed(e, data) {
			if (typeof data?.content !== "string" || data.feedID !== this._commentFeedID) {
				return;
			}

			// skip if the content is empty - in the case of guest posting
			const content = $('<div/>').append(typeof data.content === 'string' ? data.content : '');
			const comment = content.find('.js-ipsEntry');

			if( comment.length ){
				let commentFeed = this.scope.find('[data-role="commentFeed"]');

				if (commentFeed.find('[data-role="moderationTools"]').length) {
					commentFeed = commentFeed.find('[data-role="moderationTools"]');
				}

				// Hide the 'no comment' text
				this.scope.find('[data-role="noComments"]').remove();

				// If this comment is in the feed already, update what we have
				const actualContent = comment.get(0)
				const id = parseInt(actualContent?.querySelector(`[data-commentid]`)?.dataset.commentid);
				const existing = Number.isInteger(id) && this.findCommentInFeed(id);
				if (existing && existing.parentElement) {
					existing.parentElement.replaceChild(existing, actualContent);
				} else {
					// Add comment content
					commentFeed.append(comment.css({opacity: "0.001"}));
					const newItemTop = comment.offset().top;
					const windowScroll = $(window).scrollTop();
					const viewHeight = $(window).height();

					function _showComment() {
						comment.css({opacity: "1"});
						ips.utils.anim.go('fadeInDown', comment.filter(':not(.ipsHide)'));
					}

					// If needed, scroll to the correct location before showing the comment
					if (data.scrollToItem && ( newItemTop < windowScroll || newItemTop > ( windowScroll + viewHeight ))) {
						$('html, body').animate( { scrollTop: newItemTop + 'px' }, 'fast', function () {
							setTimeout( _showComment, 100 ); // Short delay before fading in comment for pleasantness
						});
					} else {
						_showComment();
					}

					if( ips.utils.db.isEnabled() ){
						const buttons = comment.find('[data-action="multiQuoteComment"]');

						buttons.hide().removeClass('ipsHide');
						ips.utils.anim.go('fadeIn', buttons);
					}
				}
			} else {
				// In theory, this could be a bug so let's log it
				Debug.log(`core.front.core.commentFeed:addToCommentFeed() - Invalid content provided to addToCommentFeed. The data.content property is supposed to contain HTML with an element that has the \`js-ipsEntry\` class. This may be expected, as in the case of posts held for approval.`);
				if (Debug.isEnabled()) {
					console.log(data); // use console.log to preserve stack trace
				}
			}

			if( !('resetEditor' in data) || data.resetEditor !== false ){
				this.scope.find('[data-role="replyArea"] [data-ipsEditorv5]').data('_editor').reset();
			}

			this._updateCount(data.totalItems);
			if (ips.getSetting('relativeDates')) {
				this._updateTimestamps();
			}
			$( document ).trigger( 'contentChange', [ this.scope ] );
		},
		
		/**
		 * Responds to an event indicating that a comment has been deleted
		 * Show it, and reset the contents of tiptap
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		deletedComment: function( e, data ) {
			data = $.parseJSON( data.response );
			var self = this;

			if( data.type == 'redirect' ) {
				window.location = data.url;
			}
			else {
				this._updateCount( data.total );
			}

		},
		
		/**
		 * Update comment count
		 *
		 * @param	{int}	newTotal	The new total
		 * @returns 	{void}
		 */
		_updateCount: function(newTotal) {
			if ( this.scope.find('[data-role="comment_count"]') ) {
				var langString = 'js_num_comments';
				if ( this.scope.find('[data-role="comment_count"]').attr('data-commentCountString') ) {
					langString = this.scope.find('[data-role="comment_count"]').attr('data-commentCountString');
				}
				this.scope.find('[data-role="comment_count"]').text( ips.pluralize( ips.getString( langString ), newTotal ) );
			}
		},

		/**
		 * Event handler for the 'Quote x posts' button in multiquote popup
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		doMultiQuote: function (e) {

			var mqData = this._getMultiQuoteData();
			var replyArea = this.scope.find('[data-role="replyArea"]');
			var output = [];
			var self = this;

			if( !_.size( mqData ) || !replyArea.is(':visible') ){
				return;
			}

			// Build quote array and trigger event for the editor widget to deal with
			_.each( mqData, function (value){
				output.push( value );
			});

			ips.ui.editorv5.getObjWithInit(this.scope.find('[data-role="replyArea"] [data-ipsEditorv5]'), function (editor) {
				editor.insertQuotes(output);
			});

			this._removeAllMultiQuoted();
		},

		/**
		 * Event handler for the 'clear' button in the multiquote popup
		 * Simply calls _removeAllMultiQuoted to do the clear
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		clearMultiQuote: function (e) {
			e.preventDefault();
			this._removeAllMultiQuoted();
		},

		/**
		 * Removes all quoted posts
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		_removeAllMultiQuoted: function () {
			var mqData = this._getMultiQuoteData();
			var self = this;
			
			// Delete all the multi-quoted posts from DB
			ips.utils.db.set( 'mq', 'data', {} );

			// Hide popup
			this._buildMultiQuote(0);

			if( !_.size( mqData ) ){
				return;
			}

			// Loop through each quoted posts and see if it exists on this page by building a selector,
			// then updating classnames on elements that match it
			_.each( mqData, function (value) {
				self.triggerOn( 'core.front.core.comment', 'setMultiQuoteDisabled.comment', {
					contentapp: value.contentapp,
					contenttype: value.contenttype,
					contentcommentid: value.contentcommentid
				});
			});
		},

		/**
		 * Responds to an addMultiQuote event
		 * Adds the provided post data to the multiquote DB entry and updates the popup
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		addMultiQuote: function (e, data) {
			var mqData = this._getMultiQuoteData();
			var key = data.contentapp + '-' + data.contenttype + '-' + data.contentcommentid;
			
			// Have we hit a limit?
			if( _.size( mqData ) == this._maximumMultiQuote )
			{
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: ips.pluralize( ips.getString( 'maxmultiquote' ), this._maximumMultiQuote ),
					callbacks: {
						ok: function () {
							$("button[data-mqId='" + data.button + "']").removeClass('ipsButton--secondary')
								.addClass('ipsButton--simple')
								.removeAttr('data-mqActive')
								.html( ips.templates.render('core.posts.multiQuoteOff') );
						}
					}
				});
				return false;
			}

			mqData[ key ] = data;

			ips.utils.db.set( 'mq', 'data', mqData );

			this._buildMultiQuote( _.size( mqData ) );
		},

		/**
		 * Responds to a removeMultiQuote event
		 * Removes the provided post data from the multiquote DB entry and updates the popup
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		removeMultiQuote: function (e, data) {
			var mqData = this._getMultiQuoteData();
			var key = data.contentapp + '-' + data.contenttype + '-' + data.contentcommentid;

			if( !_.isUndefined( mqData[ key ] ) ){
				mqData = _.omit( mqData, key );

				ips.utils.db.set( 'mq', 'data', mqData );

				this._buildMultiQuote( _.size( mqData ) );
			}
		},

		/**
		 * Returns the current multiquote data from the localStorage
		 *	
		 * @returns 	{object} 	Multiquote data from localStorage
		 */
		_getMultiQuoteData: function () {
			// Get the IDs we already have saved
			var mqData = ips.utils.db.get('mq', 'data');

			if( _.isUndefined( mqData ) || !_.isObject( mqData ) ){
				return {};
			}

			return mqData;
		},

		/**
		 * Called when the controller is initialized
		 * Checks whether there's any mq data, and shows the popup if so
		 *	
		 * @returns 	{void}
		 */
		_setUpMultiQuote: function () {

			if( !ips.utils.db.isEnabled() ){
				return;
			}

			var buttons = this.scope.find('[data-action="multiQuoteComment"]');
			var self = this;
			var mqData = this._getMultiQuoteData();

			buttons.show();

			if( _.size( mqData ) ){
				this._buildMultiQuote( _.size( mqData ) );

				// Loop through each quoted posts and see if it exists on this page by building a selector,
				// then updating classnames on elements that match it
				_.each( mqData, function (value) {
					self.triggerOn( 'core.front.core.comment', 'setMultiQuoteEnabled.comment', {
						contentapp: value.contentapp,
						contenttype: value.contenttype,
						contentcommentid: value.contentcommentid
					});
				});
			}			
		},

		/**
		 * Builds the multiquote popup, either from a template if this is the first time,
		 * or updates the value if it already exists.
		 *	
		 * @param 		{number} 	count 		Count of quoted posts
		 * @returns 	{void}
		 */
		_buildMultiQuote: function (count) {
			var quoterElem = $('#ipsMultiQuoter');

			if( !quoterElem.length && count ){
				ips.getContainer().append( ips.templates.render('core.posts.multiQuoter', {
					count: ips.getString('multiquote_count', {
						count: ips.pluralize( ips.getString( 'multiquote_count_plural' ), [ count ] )
					}),
					commentFeedId: this._containerID
				}));

				ips.utils.anim.go( 'zoomIn fast', $('#ipsMultiQuoter') );
			} else {

				// Since we only show one global multiquote button (not per-feed), the existing button
				// might have been created/shown by another feed on the same page. We'll assume the latest 
				// comment feed to show is the one the user cares about, and update the button attributes 
				// so that this controller properly handles clicks on it.
				if( quoterElem.attr('data-commentsContainer') !== this._containerID ){
					quoterElem
						.attr('data-commentsContainer', this._containerID )
						.find('[data-role^="multiQuote_"]')
							.attr('data-role', 'multiQuote_' + this._containerID)
						.end()
						.find('[data-action^="clearQuoted_"]')
							.attr('data-action', 'clearQuoted_' + this._containerID);
				}

				quoterElem.find('[data-role="quotingTotal"]').text( 
					ips.pluralize( ips.getString( 'multiquote_count_plural' ), [ count ] )
				);

				if( count && quoterElem.is(':visible') ){
					ips.utils.anim.go( 'pulseOnce fast', quoterElem );	
				} else if( count && !quoterElem.is(':visible') ){
					ips.utils.anim.go( 'zoomIn fast', quoterElem );
				} else {
					ips.utils.anim.go( 'zoomOut fast', quoterElem );
				}
				
			}
		},

		/**
		 * Returns the largest ID number on the page, taking into account the fact that the topic
		 * wrapper may specify a higher ID (in cases where a question's answer is on a different page)
		 *	
		 * @param 		{array} 	commentsOnThisPage 		Array of comments on this page, based on having the [data-commentid] attribute
		 * @returns 	{number}
		 */
		_getLastSeenID: function (commentsOnThisPage) {
			var commentFeed = this.scope.find('[data-role="commentFeed"]');
			var maxComment = _.max( commentsOnThisPage, function (comment) {
				return parseInt( $( comment ).attr('data-commentid') );
			});
			var max = $( maxComment ).attr('data-commentid');

			// If the topic feed 
			if( commentFeed.attr('data-topicAnswerID') && parseInt( commentFeed.attr('data-topicAnswerID') ) > max ){
				max = parseInt( commentFeed.attr('data-topicAnswerID') );
			}

			Debug.log("Max comment ID is " + max);
			return max;
		},

		/**
		 * Update timestamps in this
		 *
		 * @returns {Promise<void>}
		 * @private
		 */
		async _updateTimestamps() {
			if (!ips.getSetting('relativeDates')) {
				return;
			}

			Debug.log('Updating the comment feed timestamps')

			/** @type {Map<HTMLTimeElement, number>} */
			const timestampMap = new Map();
			/** @type {Set<HTMLElement>} */
			const roots = new Set([this.elem]);

			// first, make sure that if there are comments outside the feed's HTML element, like the first post in simplified mode, we include those in the query
			if (this.elem.dataset.feedid) {
				for (const el of document.querySelectorAll(`[data-feedid="${this.elem.dataset.feedid}"]`)) {
					roots.add(el);
				}
			}

			// Collect all time elements
			roots.forEach(root => {
				for (const el of root.querySelectorAll('time.ipsTime[datetime]:not(.ipsTime .ipsTime, time time)')) {
					if (OLD_TIME_ELEMENTS.has(el)) {
						continue;
					}

					if (el instanceof HTMLTimeElement) {
						// we don't care if it was over a day ago. This code is just to prevent new posts from having a later time than old ones
						const unixts = Math.round((new Date(el.dateTime)).getTime() / 1000);
						if (unixts <= Math.round(Date.now() / 1000) - 86400) {
							OLD_TIME_ELEMENTS.add(el);
							continue;
						}
						timestampMap.set(el, unixts);
					}
				}
			})


			const parsedResults = {};
			// get the ajax content
			const timestamps = Array.from(new Set(timestampMap.values()));
			if (!timestamps.length) {
				return;
			}

			// get what we have locally
			const timestampCacheKeys = {};
			const unknownTimestamps = [];
			for (const timestamp of timestamps) {
				const deltaMinutes = Math.round(((Date.now() / 1000) - timestamp) / 60);
				timestampCacheKeys[timestamp.toString()] = `time_${deltaMinutes < 0 ? 'neg' : 'pos'}_${Math.abs(deltaMinutes)}`;
				const cached = ips.utils.db.get('formatted_timestamps', timestampCacheKeys[timestamp.toString()])
				if (cached) {
					// Debug.log(`Using known formatted timestamp for ${deltaMinutes} minutes`);
					const cachedEl = (new DOMParser()).parseFromString(cached, "text/html").querySelector("body > time");
					if (cachedEl instanceof HTMLTimeElement) {
						parsedResults[`time_${timestamp}`] = cachedEl;
						continue;
					}
				}
				unknownTimestamps.push(timestamp);
			}

			// fetch whatever we don't know
			if (unknownTimestamps.length) {
				const result = await ips.fetch(ips.getSetting('baseURL'), {
					data: {
						app: 'core',
						module: 'system',
						controller: 'ajax',
						do: "getFormattedTimes",
						timestamps: unknownTimestamps.join(',')
					}
				});

				// now convert to html elements
				if (typeof result?.timestamps !== 'object') {
					Debug.warn("Unexpected response from ajax timestamps!");
				} else {
					for (const ts in result.timestamps) {
						const timeEl = (new DOMParser()).parseFromString(result.timestamps[ts], 'text/html').querySelector("body > time");
						if (timeEl instanceof HTMLTimeElement) {
							if (ts.match(/time_(\d+)/)?.[1] in timestampCacheKeys) {
								ips.utils.db.set('formatted_timestamps', timestampCacheKeys[ts.match(/time_(\d+)/)?.[1]], timeEl.outerHTML);
							}
							parsedResults[ts] = timeEl;
						}
					}
				}
			}

			// actually update the time elements in the page
			for (const [timeEl, timeStamp] of timestampMap.entries()) {
				const key = "time_" + timeStamp;
				if (key in parsedResults) {
					timeEl.innerHTML = parsedResults[key].innerHTML;
					timeEl.dataset.short = parsedResults[key].dataset.short;
				} else {
					Debug.warn(`Didn't get a formatted time for the timestamp ${timeStamp}.`)
				}
			}
		}
	});

	/** @type {WeakSet<HTMLTimeElement>} */
	const OLD_TIME_ELEMENTS = new WeakSet();
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.commentsWrapper.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.commentWrapper.js
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.commentsWrapper', {
		
		initialize: function () {
			this.on( document, 'addToCommentFeed', this.addToCommentFeed );
			this.on( 'deletedComment.comment', this.deletedComment );
		},
		
		/**
		 * Responds to an event (trigger within this controller) indicating a new comment has been added
		 * Show it, and reset the contents of tiptap
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		addToCommentFeed: function(e, data) {
			this._updateCount( $(e.target).attr('data-commentsType'), data.totalItems );
		},
		
		/**
		 * Responds to an event indicating that a comment has been deleted
		 * Show it, and reset the contents of tiptap
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		deletedComment: function(e, data) {
			try {
				var newTotal = $.parseJSON( data.response ).total;
			} catch (err) {
				var newTotal = 0;
			}

			this._updateCount( $(e.target).closest('[data-commentsType]').attr('data-commentsType'), newTotal );
		},
		
		/**
		 * Update comment count
		 *
		 * @param	{int}	newTotal	The new total
		 * @returns 	{void}
		 */		
		_updateCount: function( type, number ) {
			var langString = 'js_num_' + type;
			var elem = $( '#' + $(this.scope).attr('data-tabsId') + '_tab_' + type );
			elem.text( ips.pluralize( ips.getString( langString ), number ) );
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.contentMessage.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200">/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.contentMessage
 *
 * Author: Matt Mecham
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.contentMessage', {

		initialize: function () {
			this.on( 'change', '#check_message_is_public', this.updateEditorBorder );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			this.scope.find('.ipsComposeArea_editor').addClass('cContentMessageEditor');
			this.updateEditorBorder();
		},

		/**
		 * Add a context sensitive border around the editor
		 *
		 * @returns {void}
		 */
		updateEditorBorder: function () {
			if ( $('#check_message_is_public').is(&quot;:checked&quot;) ) {
				this.scope.find('.ipsComposeArea_editor').removeClass('cContentMessageEditor--private').addClass('cContentMessageEditor--public');
			} else {
				this.scope.find('.ipsComposeArea_editor').removeClass('cContentMessageEditor--public').addClass('cContentMessageEditor--private');
			}
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.dataLayer.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community v4+
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.dataLayer.js - dataLayer support.
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
    "use strict";

    ips.controller.register('core.front.core.dataLayer', {
        eventHandlers: [],
        propertiesHandlers: [],

        initialize: function () {
            if ( this.verify() ) {
                // Subscribe our closure to handle events
                this.on('ipsDataLayer', this.handleEvent);

                // Subscribe our closure to handle properties
                this.on('ipsDataLayerProperties', this.handleProperties);

                this.setup();
                Debug.log( 'Pushing events to the dataLayer' );
            }
        },

        setup: function() {
            // Get our event handlers
            for ( let i in IpsDataLayerEventHandlers ) {
                let handler = IpsDataLayerEventHandlers[i];
                if ( handler instanceof Function ) {
                    try {
                        let callback = handler();
                        if ( callback instanceof Function ) {
                            this.eventHandlers.push( callback );
                        } else {
                            Debug.error( `Invalid Handler Callback Found: Returned value of type '${typeof (callback || undefined)}', expected a callback Function!` );
                        }
                    } catch (e) {
                        Debug.error(e);
                    }
                }
            }

            // Get our property handlers
            for ( let i in IpsDataLayerPropertiesHandlers ) {
                let handler = IpsDataLayerPropertiesHandlers[i];
                if ( handler instanceof Function ) {
                    try {
                        let callback = handler();
                        if ( callback instanceof Function ) {
                            this.propertiesHandlers.push( callback );
                        } else {
                            Debug.error( `Invalid Handler Callback Found: Returned value of type '${typeof (callback || undefined)}', expected a callback Function!` );
                        }
                    } catch (e) {
                        Debug.error(e);
                    }
                }
            }

            this.unsetOldUniqueKeys();

            // Our login/logout event. Delay slightly to prevent collisions with the handler's head script (events pushed to GTM before GTM is loaded might not be recognized properly)
            setTimeout( _.bind( this.loginLogout, this ), 200 );

            //Events included in the page. Delay slightly to prevent collisions with the handler's head script (events pushed to GTM before GTM is loaded might not be recognized properly)
            setTimeout( _.bind( this.handleInitialEvents, this ), 202 );

            // Some interactions (like downloading a file) need to be verified a second or so after they occur
            this.on( 'ipsDataLayerSync', _.debounce(this.remoteFetchEvents, 1000) );

            this.scope.find('[data-datalayer-postfetch]').on( 'click', function(e) {
                setTimeout( function() { $(e.currentTarget).trigger( 'ipsDataLayerSync' ); }, 1500 );
            } );
        },

        /**
         * Handle events
         *
         * @return  void
         */
        handleEvent: function(evt, event) {
            let Events = IpsDataLayerConfig._events;
            let Properties = IpsDataLayerConfig._properties;
            let PII = IpsDataLayerConfig._pii;

            // This method will do nothing if we don't recognize events OR have no handlers to use
            if (!Object.keys(Events).length || !this.eventHandlers.length) {
                return;
            }

            try {
                if (event._key && event._properties instanceof Object) {
                    // Make sure its enabled
                    if (!Events[event._key] || !Events[event._key].enabled) return;

                    // Check for duplicate keys
                    if (event._uniquekeys && event._uniquekeys instanceof Object) {
                        try {
                            let same = true;
                            let saved = ips.utils.db.get('ipsDataLayer', event._key) || {};
                            saved.exp = saved.exp || 0;
                            event._uniquekeys.exp = event._uniquekeys.exp || (Math.floor(Date.now() / 1000) + 300);

                            // If the saved keys to check are expired, this is not a duplicate
                            if ((saved.exp) <= Math.floor(Date.now() / 1000)) {
                                same = false;
                            }

                            // Not expired, compare each key
                            if (same) {
                                for (let savedKey in saved) {
                                    if (savedKey === 'exp') {
                                        continue;
                                    }
                                    if (saved[savedKey] !== event._uniquekeys[savedKey]) {
                                        same = false;
                                        break;
                                    }
                                }
                            }

                            // If this is the same as a previous one, update the expiration and stop processing
                            if (same) {
                                saved.exp = Math.max(event._uniquekeys.exp, saved.exp);
                                ips.utils.db.set('ipsDataLayer', event._key, saved, false);
                                return;
                            }

                            // Otherwise save now
                            ips.utils.db.set('ipsDataLayer', event._key, event._uniquekeys, false);
                        } catch (e) {
                            Debug.error(e);
                        }
                    }

                    // Create the event
                    let _event = {
                        '_key': Events[event._key].formatted_name,
                        '_properties': {}
                    };

                    // Go through all properties we know
                    for (let propertyKey in Properties) {

                        // We don't care if it's disabled or it has pii and pii is not allowed
                        let property = Properties[propertyKey];
                        if (property.enabled && !(!PII && property.pii)) {

                            // Skip if this property shouldn't be used with this event
                            let validForEvent = false;
                            for (let j in property.event_keys) {
                                let pattern = property.event_keys[j].replaceAll('*', '.*');
                                if (event._key.match(pattern)) {
                                    validForEvent = true;
                                    break;
                                }
                            }
                            if (!validForEvent) {
                                continue;
                            }

                            // What value should we use?
                            let formatted = property.formatted_name;
                            let value = '';

                            // This must be unique so we generate it client side to avoid using a cached key
                            if (propertyKey === 'ips_key') {
                                value = this.uniqueId();
                            } else if ( propertyKey in event._properties ) {
                                value = event._properties[propertyKey];
                            } else if (property.custom) {
                                value = (property.value === null || property.value === undefined) ? undefined : property.value;
                            } else if (propertyKey === 'ips_time') { // Add the time if needed
                                value = Math.floor(Date.now() / 1000);
                            } else if (IpsDataLayerContext[formatted]) {
                                value = IpsDataLayerContext[formatted];
                            } else {
                                value = property.default;
                            }

                            // Some shallow type-checking, set to undefined if its type isn't allowed
                            if (value !== null && value !== undefined) {
                                let types = property.type.toLowerCase().split(' ');
                                if (!types.includes('array') && types.some(type => type.endsWith('[]'))) {
                                    types.push('array');
                                }

                                if (types.includes('number')) {
                                    try {
                                        if (!isNaN(value)) {
                                            value = Number(value);
                                        }
                                    } catch (e) {
                                    }
                                }

                                // If this type an array but we got an empty object, there's a chance PHP JSON encoded an empty array as associative, so make it an empty array
                                if (typeof value === 'object' &&
                                    Object.keys(value).length === 0 &&
                                    Object.getPrototypeOf(value) === Object.prototype &&
                                    types.includes('array')) {
                                    value = [];
                                } else if (!( // If this is not instanceof array and arrays are allowed nor any other type specified, make it undefined
                                    (types.includes('array') && value instanceof Array) || types.includes(typeof value)
                                )) {
                                    Debug.error(`Invalid Data Layer Property Type: Event property "${propertyKey}" was overridden to undefined because it could not be cast from "${typeof value}" to an allowed type`);
                                    value = property.default !== null ? property.default : undefined;
                                }
                            } else {
                                value = property.default !== null ? property.default : undefined;
                            }

                            // Actually set the property
                            _event._properties[formatted] = value;
                        }
                    }

                    // Call each handler on this event
                    Debug.log('Pushing an event to the Data Layer Event Handlers');
                    Debug.log(_event)
                    for (let i in this.eventHandlers) {
                        try {
                            this.eventHandlers[i](_event);
                        } catch (e) {
                            Debug.error('Bad Data Layer Event Handler: An event handler failed to handle an event!');
                        }
                    }
                }
            } catch (e) {
                Debug.log(e);
            }
        },

        /**
         * Handle our properties using the callbacks
         *
         * @return Function
         */
        handleProperties: function(evt, event) {
            let Properties  = IpsDataLayerConfig._properties;
            let PII         = IpsDataLayerConfig._pii;

            if ( this.propertiesHandlers.length && event._properties instanceof Object) {
                let properties = {};
                for ( let propertyKey in event._properties ) {
                    let property = Properties[propertyKey];

                    // Filter out properties if we don't know them, the have to be tied to an event, or contain PII and pii is not allowed
                    if ( !( property || property === null ) || !property.enabled || !property.page_level || (!PII && property.pii) ) {
                        continue;
                    }

                    // Some shallow type-checking, set to undefined if its type isn't allowed
                    let value = event._properties[propertyKey];
                    if ( value !== null && value !== undefined ) {
                        let types = property.type.toLowerCase().split(' ');
                        if (!types.includes('array') && types.some(type => type.endsWith('[]'))) {
                            types.push('array');
                        }
                        if ( types.includes('number') ) {
                            try {
                                if ( !isNaN(value) ) {
                                    value = Number(value);
                                }
                            } catch (e) {}
                        }

                        // If this type an array but we got an empty object, there's a chance PHP JSON encoded an empty array as associative, so make it an empty array here
                        if (typeof value === 'object' &&
                            Object.keys(value).length === 0 &&
                            Object.getPrototypeOf(value) === Object.prototype &&
                            types.includes('array')) {
                            value = [];
                        } else if (!( // If this is not instanceof array and arrays are allowed nor any other type specified, make it undefined
                            (types.includes('array') && value instanceof Array) || types.includes(typeof value)
                        )) {
                            Debug.error(`Invalid Data Layer Property Type: Property "${propertyKey}" was overridden to undefined because it could not be cast from "${typeof value}" to an allowed type`);
                            value = property.default !== null ? property.default : undefined;
                        }
                    } else {
                        value = property.default !== null ? property.default : undefined;
                    }

                    properties[propertyKey] = value;
                }

                if ( Object.keys( properties ).length ) {
                    Debug.log( 'Pushing properties to the Data Layer Properties Handlers' );
                    Debug.log( properties );
                    for ( let i in this.propertiesHandlers ) {
                        try {
                            this.propertiesHandlers[i](properties);
                        } catch (e) {
                            Debug.error( 'Bad Data Layer Properties Handler: A properties handler failed to handle a collection (object) of properties' );
                        }
                    }
                }
            }
        },

        handleInitialEvents: function() {
            let self = this;
            IpsDataLayerEvents.forEach( function ( event ) {
                self.handleEvent( {}, event );
            } );
        },

        /**
         *  Verify the correct constants exist with the appropriate properties, does not validate them though
         */
        verify: function() {
            try {
                return (
                    // If these are const, then they will exist but not as a property of window
                    (!window.IpsDataLayerContext && IpsDataLayerContext) &&
                    (!window.IpsDataLayerConfig && IpsDataLayerConfig) &&
                    (!window.IpsDataLayerEventHandlers && IpsDataLayerEventHandlers) &&
                    (!window.IpsDataLayerPropertiesHandlers && IpsDataLayerPropertiesHandlers) &&
                    IpsDataLayerContext instanceof Object &&
                    IpsDataLayerEvents instanceof Array &&
                    IpsDataLayerEventHandlers instanceof Array &&
                    IpsDataLayerPropertiesHandlers instanceof Array &&
                    IpsDataLayerConfig instanceof Object &&
                    IpsDataLayerConfig._properties instanceof Object &&
                    IpsDataLayerConfig._events instanceof Object &&
                    IpsDataLayerConfig._pii !== undefined
                );
            } catch (e) {
                return false;
            }
        },

        /**
         * Add a login/logout event if needed. This checks local storage to see if they just logged in, or if they were just logged in
         */
        loginLogout: function() {
            // What is stored in local storage
            let stored = ips.utils.db.get( 'ipsDataLayer', 'login' ) || {};

            if ( ipsSettings.memberID ) {
                // If this is 0, not null, we know the current use viewed a page as a guest
                if ( stored.logged_in === 0 ) {
                    this.scope.trigger('ipsDataLayer', { _key: 'account_login', _properties: {} });
                }

                // Flag they visited logged in
                ips.utils.db.set( 'ipsDataLayer', 'login', {logged_in : 1}, false )
            } else {
                // If this is 1, we know they viewed a page as a logged in member
                if ( stored.logged_in === 1 ) {
                    this.scope.trigger('ipsDataLayer', {_key: 'account_logout', _properties: {} });
                }

                // Flag they visited logged out
                ips.utils.db.set( 'ipsDataLayer', 'login', {logged_in: 0}, false );
            }
        },

        /**
         * Create a pseudo-random (practically unique) id similar to php's uniqueid() method
         */
        uniqueId: function() {
            let s = i => {
                return Math.floor((1 + Math.random()) * Math.pow(16, i))
                    .toString(16)
                    .substring(1);
            };

            let time = Date.now();
            let sec = Math.floor(time / 1000);
            let secString = sec.toString(16);
            secString = secString.substring( secString.length - 8 );
            let ms  = ( time - ( sec * 1000 ) ) * 1000; // micro
            let msString = (ms + 0x100000).toString(16).substring(1);

            return secString + msString + s(1) + '.' + s(4) + s(4);
        },

        /**
         * Unsets the out-dated event keys so they don't remain in persistent user storage indefinitely
         */
        unsetOldUniqueKeys: function() {
            let Events = IpsDataLayerConfig._events;
            for( let eventKey in Events ) {
                let saved = ips.utils.db.get('ipsDataLayer', eventKey) || {};
                if ( Object.keys(saved).length ) {
                    Debug.log( `Found stored unique keys for the event '${eventKey}'` );
                    Debug.log( saved );

                    if ( !saved.exp || saved.exp <= (Date.now() / 1000) ) {
                        Debug.log( `Removing expired stored unique keys for the event '${eventKey}'` );
                        ips.utils.db.set('ipsDataLayer', eventKey, 0, false);
                    }
                }
            }
        },

        /**
         * Get events from the ajax endpoint
         */
        remoteFetchEvents: function() {
            let self = this;
            ips.getAjax()( '?app=core&module=system&controller=ajax&do=getDataLayerEvents')
                .done( function(response) {
                    for ( let i in response ) {
                        self.handleEvent( {}, response[i] );
                    }
                } );
        },

    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.followButton.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.followButton.js - Controller for follow button
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.followButton', {

		initialize: function () {
			this.setup();
			this.on( document, 'followingItem', this.followingItemChange );
		},

		setup: function () {
			this._app = this.scope.attr('data-followApp');
			this._area = this.scope.attr('data-followArea');
			this._id = this.scope.attr('data-followID');
			this._feedID = this._area + '-' + this._id;
			this._button = this.scope.find('[data-role="followButton"]');
		},

		/**
		 * Responds to events indicating the follow status has changed. We want to reload the button HTML and fetch any data layer events if there are any
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		followingItemChange: function (e, data) {
			if( data.feedID === this._feedID ){
				document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles:true}));
				this._reloadButton();
			}
		},

		/**
		 * Gets a new follow button from the server and replaces the current one with the response
		 *
		 * @returns 	{void}
		 */
		_reloadButton: function () {
			// Show button as loading
			this._button.addClass('i-opacity_3');
			
			var self = this;
			var pos = ips.utils.position.getElemPosition( this._button );
			var dims = ips.utils.position.getElemDims( this._button );

			this.scope.append( ips.templates.render('core.follow.loading') );

			// Adjust sizing
			this.scope
				.find('.ipsLoading')
					.css({
						width: dims.outerWidth + 'px',
						height: dims.outerHeight + 'px',
						top: "0",
						left: "0",
						position: 'absolute',
						zIndex: ips.ui.zIndex()
					});

			// Load new contents
			ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=notifications&do=button', {
				data: _.extend({
					follow_app: this._app,
					follow_area: this._area,
					follow_id: this._id,
				},
					( this.scope.attr('data-buttonType') ) ? { button_type: this.scope.attr('data-buttonType') } : {},
					( this.scope.attr('data-buttonSize') ) ? { button_size: this.scope.attr('data-buttonSize') } : {}
				)
			})
				.done( function (response) {
					self.scope.html( response );
					$( document ).trigger( 'contentChange', [ self.scope ] );
					
					/* Any auto follow toggles on the page? */
					if ( $('input[data-toggle-id="auto_follow_toggle"]').length ) {
						var val = self.scope.find('[data-role="followButton"]').attr('data-following');
						if ( val == 'false' && $('input[data-toggle-id="auto_follow_toggle"]').is(':checked') ) {
							$('input[data-toggle-id="auto_follow_toggle"]').prop('checked', false).change();
						} else if (val == 'true' && ! $('input[data-toggle-id="auto_follow_toggle"]').is(':checked') ){
							$('input[data-toggle-id="auto_follow_toggle"]').prop('checked', true).change();
						}
					}
				})
				.fail( function () {
					self._button.removeClass('i-opacity_3');
				})
				.always( function () {
					self.scope.find('.ipsLoading').remove();
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.followForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.followButton.js - Controller for follow button
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.followForm', {

		initialize: function () {
			this.on( 'submit', this.submitForm );
			this.on( 'click', '[data-action=&quot;unfollow&quot;]', this.unfollow );
			this.on( 'click', '[data-action=&quot;followSettings&quot;]', this.notificationSettings );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			this._app = this.scope.attr('data-followApp');
			this._area = this.scope.attr('data-followArea');
			this._id = this.scope.attr('data-followID');
		},

		/**
		 * Event handler when the notification settings button is clicked
		 *
		 * @param 		{event} 	e 		Event object
		 */
		notificationSettings: function (e) {
			$(this.scope.parents('.ipsHovercard')[0]).hide();
		},

		/**
		 * Event handler for unfollowing an item
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		unfollow: function (e) {
			e.preventDefault();
			this._doFollowAction( $( e.currentTarget ).attr('href'), {}, true );
		},

		/**
		 * Event handler for submitting the follow form
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitForm: function (e) {
			e.preventDefault();
			this._doFollowAction( this.scope.attr('action'), this.scope.serialize(), false );
		},

		/**
		 * Performs an ajax action. Shows the hovercard as loading, and calls the URL
		 *
		 * @param 		{string} 	url		URL to call
		 * @param 		{object} 	data 	Object of data to include in the request
		 * @returns 	{void}
		 */
		_doFollowAction: function (url, data, unfollow) {
			var self = this;
			var dims = ips.utils.position.getElemDims( this.scope.parent('div') );

			// Set it to loading
			this.scope
				.hide()
				.parent('div')
					.css({
						width: dims.outerWidth + 'px',
						height: dims.outerHeight + 'px'
					})
					.addClass('ipsLoading');

			// Update follow preference via ajax
			ips.getAjax()( url, {
				data: data,
				type: 'post'
			})
				.done( function (response) {
					// Success, so trigger event to update button
					if( unfollow ){
						self.trigger('followingItem', {
							feedID: self._area + '-' + self._id,
							unfollow: true
						});	
					} else {
						self.trigger('followingItem', {
							feedID: self._area + '-' + self._id,
							notificationType: self.scope.find('[name=&quot;follow_type&quot;]:checked').val(),
							anonymous: !self.scope.find('[name=&quot;follow_public_checkbox&quot;]').is(':checked')
						});
					}				

					ips.ui.flashMsg.show( ips.getString('followUpdated') ); 
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					window.location = url;
				})
				.always( function () {
					// If we're in a hovercard, remove it
					self.scope.parents('.ipsHovercard').remove();
				});
		}
	});
}(jQuery, _));
</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.guestTerms.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.guestTerms.js - Guest terms bar
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.guestTerms', {

		initialize: function () {
			this.setup();
			this.on( 'click', '[data-action="dismissTerms"]', this.dismissTerms );
		},

		setup: function () {
			// If guest caching is enabled, the bar HTML will exist in the page even if this
			// user has accepted terms or rejected optional cookies. We'll hide it with JS if that happens.
			let hide = false;
			if( this.scope.attr('data-role') == 'cookieConsentBar' && ips.utils.cookie.get('cookie_consent') )
			{
				hide = true;
			}
			else if( this.scope.attr('data-role') == 'guestTermsBar' && ips.utils.cookie.get('guestTermsDismissed') )
			{
				hide = true;
			}

			/* Hide things like theme selector because we cannot change it as a guest */
			if( this.scope.attr('data-role') == 'cookieConsentBar' && ( !ips.getSetting( 'memberID' ) && !ips.utils.cookie.get( 'cookie_consent_optional' ) ) )
			{
				$('#elNavTheme').hide();
			}
			/* Hide announcement dismiss if optional cookies are not enabled in browser or account */
			if( this.scope.attr('data-role') == 'cookieConsentBar' && !ips.utils.cookie.get( 'cookie_consent_optional' ) )
			{
				$('[data-role="dismissAnnouncement"]').hide();
			}

			this.scope.toggle( !hide );
			$('body').toggleClass('cWithGuestTerms', !hide );
		},

		dismissTerms: function ( e ) {
			e.preventDefault();
			ips.utils.cookie.set('guestTermsDismissed', 1 ); // intentionally only a session cookie
			this.hideGuestBar();
		},

		hideGuestBar: function() {
			this.scope.toggle( false );
			$('body').toggleClass('cWithGuestTerms', false );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.ignoredComments.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.ignoredComments.js - Controller to handle ignored comments
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.ignoredComments', {

		initialize: function () {
			this.on( 'menuItemSelected', '[data-action="ignoreOptions"]', this.commentIgnore );
		},

		/**
		 * Ignore options
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		commentIgnore: function (e, data = e.detail) {
			switch( data.selectedItemID ){
				case 'showPost':
					data.originalEvent.preventDefault();
					this._showHiddenPost( e, data );
				break;
				case 'stopIgnoring':
					data.originalEvent.preventDefault();
					this._stopIgnoringFromComment( e, data );
				break;
			}
		},
		
		/**
		 * Shows a hidden post
		 *	
		 * @param 		{event} 	e 		Event object from the event handler
		 * @param 		{object}	data 	Event data object from the event handler
		 * @returns 	{void}
		 */
		_showHiddenPost: function (e, data) {
			// Hide the ignore row
			var ignoreRow = $( data.triggerElem ).closest('.ipsEntry--ignored');
			var commentID = ignoreRow.attr('data-ignoreCommentID');
			var comment = this.scope.find( '#' + commentID );

			ignoreRow.remove();
			comment.removeClass('ipsHide');
		},

		/**
		 * Stops ignoring posts by a user
		 *	
		 * @param 		{event} 	e 		Event object from the event handler
		 * @param 		{object}	data 	Event data object from the event handler
		 * @returns 	{void}
		 */
		_stopIgnoringFromComment: function (e, data) {
			var ignoreRow = $( data.triggerElem ).closest('.ipsEntry--ignored');
			var userID = ignoreRow.attr('data-ignoreUserID');
			var self = this;
			var posts = this.scope.find('[data-ignoreUserID="' + userID + '"]');

			posts.each( function () {
				self.scope.find( '#' + $( this ).attr('data-ignoreCommentID') ).removeClass('ipsHide');
				$( this ).remove();
			});

			var url = ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=ignore&do=ignoreType&type=topics&off=1';

			ips.getAjax()( url, {
				data: {
					member_id: parseInt( userID )
				}
			})
				.done( function () {
					ips.ui.flashMsg.show( ips.getString('ignore_prefs_updated') );
				})
				.fail( function () {
					window.location = ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=ignore&do=ignoreType&off=1type=topics&member_id=' + userID;
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.instantNotifications.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.instantNotifications.js - Instant notifications controller
 *
 * Explanation of logic
 * ---------------------------
 * Every 20 seconds, this controller will check localStorage and determine if the last poll was > 20s ago.
 * If it was, it will fire an ajax request to get any new notifcations, and presnt those to the user. It will
 * then store this as the latest result in localStorage. We use localStorage so that multiple browser tabs
 * aren't all doing their own poll.
 * When the user first loads the page, we'll also compare the current message/notification count to what's in
 * localStorage. If there's new notifications, we'll fetch them and show them, to make it feel 'instanty'.
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.core.instantNotifications', {

		_pollTimeout: 60, // Seconds
		_windowInactivePoll: 0,
		_pollMultiplier: 1, // multiplier for decay
		_messagesEnabled: null,
		_ajaxObj: null,
		_debugPolling: true,
		_browserNotifications: {},
		_paused: false,
		_interval: null,
		_usingRealtime:false,

		initialize () {
			this.on( document, ips.utils.events.getVisibilityEvent(), this.windowVisibilityChange );
			this.on( window, 'storage', this.storageChange );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup () {
			if( !ips.utils.db.isEnabled() || !(window.JSON?.parse instanceof Function) ){
				Debug.warn("Sorry, your browser doesn't support localStorage or JSON so we can't load instant notifications for you.");
				return;
			}

			if (ips.utils.sockets.enabled()) {
				// once we're connected to the websocket, don't poll
				if (ips.utils.sockets.connected()) {
					this._useRealtime();
				} else {
					this.on(document, 'socket.connected', this._useRealtime)
				}
			}

			this.on(document, `socket.notifications_available`, () => {
				Debug.log('Notifications: fetching the latest notification counts');
				this._useRealtime();
				this._doAjaxRequest(this._getCurrentCounts());
			})

			this._messagesEnabled = this.scope.find('[data-notificationType="inbox"]').length;
			this._setInterval( this._pollTimeout);

			this._doInitialCheck();
		},

		/**
		 * Switch over to using realtime notifications (via the websocket)
		 * @private
		 */
		_useRealtime() {
			if (!this._usingRealtime) {
				this._stopPolling();
				this._usingRealtime = true;
			}
		},

		/**
		 * Responds to window storage event so we can update instantly if any other tab
		 * changes our data
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void} 
		 */
		storageChange (e) {
			var event = e.originalEvent;

			if( event.key !== 'notifications.' + ips.getSetting('baseURL') ){
				return;
			}

			if( this._debugPolling ){
				Debug.log('Notifications: updating instantly from storage event');
			}			

			try {
				var data = JSON.parse( event.newValue );
				var counts = this._getCurrentCounts();

				this._updateIcons( {
					messages: parseInt( data.messages ),
					notifications: parseInt( data.notifications )
				}, counts );
			} catch(err) {}
		},

		/**
		 * Handles window visibiliy changes; removes count from title bar
		 *
		 * @returns {void} 
		 */
		windowVisibilityChange () {
			var hiddenProp = ips.utils.events.getVisibilityProp();

			if( !_.isUndefined( hiddenProp ) && !document[ hiddenProp] ){
				// Document is now in focus
				this._updateBrowserTitle( 0 );

				if ( !this._usingRealtime ) {
					this._pollMultiplier = 1;
					this._windowInactivePoll = 0;

					if (this._paused) {
						this._checkNotifications(); // Do an immediate check
						this._setInterval(this._pollTimeout);
					}

					if (this._debugPolling) {
						Debug.log("Notifications: Resetting inactive poll.");
					}
				}
			}
		},

		/**
		 * Handles setting up our interval poll
		 *
		 * @param 	{number} 	timeoutInSecs 	Seconds between polls
		 * @returns {void} 
		 */
		_setInterval (timeoutInSecs) {
			clearInterval( this._interval );
			if (this._usingRealtime) {
				return;
			}
			this._interval = setInterval( _.bind( this._checkNotifications, this ), timeoutInSecs * 1000 );
		},

		/**
		 * On page load, does an initial check based on the counts in the bubbles (in the page source) to see if we need to call the server
		 *
		 * @returns {void} 
		 */
		_doInitialCheck () {
			// Fetch the latest poll from localStorage
			const storage = ips.utils.db.get('notifications', ips.getSetting('baseURL'));
			const counts = this._getCurrentCounts();

			if (!storage || typeof storage !== "object") {
				return;
			}

			// If our bubble is reporting more notifications or messages than we have in storage,
			// we'll fetch them immediately
			if ((this._messagesEnabled && counts.messages > storage.messages) || counts.notifications > storage.notifications) {
				if (this._debugPolling) {
					Debug.log("Notifications: bubbles reporting higher counts for notifications or messages.");
				}

				const dataToSend = {notifications: storage.notifications};
				if (this._messagesEnabled) dataToSend.messages = storage.message

				this._doAjaxRequest(dataToSend);
			}
		},		

		/**
		 * The main method to check notification status
		 * Checks in localstorage to see if the last poll was < 20s ago
		 *
		 * @returns {void}
		 */
		_checkNotifications () {
			// Fetch the latest poll from localStorage
			const storage = ips.utils.db.get('notifications', ips.getSetting('baseURL'));
			const timestamp = ips.utils.time.timestamp();
			const counts = this._getCurrentCounts();
			const currentTimeout = this._pollTimeout * this._pollMultiplier;

			// If our window is inactive, increase the count
			if( document[ ips.utils.events.getVisibilityProp() ] ){
				if( this._windowInactivePoll >= 3 && this._pollMultiplier === 1 ){ // 0-3 minutes @ 60s poll
					if( this._debugPolling ){
						Debug.log( "Notifications: Polled over 3 minutes, increasing multiplier to 2");
					}
					this._pollMultiplier = 2;
					this._setInterval( this._pollTimeout * this._pollMultiplier );
				} else if( this._windowInactivePoll >= 7 && this._pollMultiplier === 2 ) { // 4-11 minutes @ 120s poll
					if( this._debugPolling ){
						Debug.log( "Notifications: Polled over 10 minutes, increasing multiplier to 3");
					}
					this._pollMultiplier = 3;
					this._setInterval( this._pollTimeout * this._pollMultiplier );
				} else if( this._windowInactivePoll >= 25 && this._pollMultiplier === 3 ) { // > 60 mins stop
					if( this._debugPolling ){
						Debug.log( "Notifications: Polled over 60 mins, stopping polling");
					}
					this._stopPolling();
					return;
				}

				this._windowInactivePoll++;
			}

			// Do we need to poll?
			// the -1 in the below logic gives us a little fuzziness to account for the delay in processing the script
			if (storage !== null && typeof storage === 'object' && parseInt(storage.timestamp) > (timestamp - (( currentTimeout - 1 ) * 1000 ))) {
				// We *don't* need to poll, it has been less than 20s
				this._updateIcons(storage, counts);

				if (this._debugPolling) {
					Debug.log("Notifications: fetching from localStorage");
				}
			} else {
				// We send our currently-displayed bubble count to the backend
				// to find out if there's any change in number
				if (!this._messagesEnabled) {
					delete counts.messages;
				}

				this._doAjaxRequest(counts);
			}
		},

		/**
		 * Calls the backend to get new notification data
		 *
		 * @param	{object} 	data 	 	Object containing current message and notification counts
		 * @returns {void} 
		 */
		async _doAjaxRequest (data) {
			const url = ips.getSetting('baseURL') + '?app=core&module=system&controller=ajax&do=instantNotifications';
			if (this._debugPolling) {
				Debug.log("Notifications: sending ajax request");
			}

			// We'll update the timestamp before polling so that other windows
			// don't start polling before this one is finished
			this._updateTimestamp();
			try {
				this._handleResponse(await ips.fetch(url, {data}));
			} catch (e) {
				this._stopPolling();
				Debug.error("Problem polling for new notifications; stopping.");
			}
		},

		/**
		 * Processes an ajax response
		 *
		 * @param	{object} 	response 	 	Server response
		 * @returns {void} 
		 */
		_handleResponse(response) {
			const total = response.messages.data.length + response.notifications.data.length;
			try {
				// If auto-polling is now disabled, stop everything
				if (response.error && response.error === 'auto_polling_disabled') {
					this._stopPolling();
					return;
				}

				const counts = this._getCurrentCounts();

				if (response.notifications.count > counts.notifications && this._debugPolling) {
					Debug.log("Notifications: I'm the winner! I found there's " + response.notifications.count + " new notifications");
				}

				this._updateIcons( {
					messages: response.messages.count,
					notifications: response.notifications.count
				}, counts );

				// Update localStorage with the new count
				ips.utils.db.set( 'notifications', ips.getSetting('baseURL'), {
					timestamp: ips.utils.time.timestamp(),
					messages: response.messages.count,
					notifications: response.notifications.count
				});


				// How many NOTIFICATIONS do we have to show?
				if( response.notifications.data.length ){
					this._showNotification( this._buildNotifyData( response.notifications.data, 'notification' ), 'notification' );
				}

				// How many MESSAGES do we have to show?
				if( response.messages.data.length ){
					this._showNotification( this._buildNotifyData( response.messages.data, 'message' ), 'message' );
				}
			} catch (err) {
				this._stopPolling();
				return;
			}


			if( total > 0 ){
				// Do we need to update the browser title?
				if( document[ ips.utils.events.getVisibilityProp() ] ){
					this._updateBrowserTitle( total );
				}
			}		
		},

		/**
		 * Updates the browser title bar with a new count (or removes it if 0)
		 *
		 * @param 	{number} 	count 		Count to show in the browser title bar
		 * @returns {void}
		 */
		_updateBrowserTitle (count) {
			const cleanTitle = document.title.replace(/^\(\d+\)/, '').trim();

			if( count ){
				document.title = "(" + count + ") " + cleanTitle;	
			} else {
				document.title = cleanTitle;
			}
		},

		/**
		 * Builds notification data for the given items based on type
		 *
		 * @param 	{array} 	items 			Array of items from the backend
		 * @param	{string} 	type 	 		Type of notification being build (message or notification)
		 * @returns {object}	Object of notification data 
		 */
		_buildNotifyData (items, type) {
			const self = this;
			let notifyData = {
				count: items.length
			};

			if( items.length === 1 ){
				notifyData = _.extend( notifyData, {
					title: ips.getString( type + 'GeneralSingle'),
					icon: items[0].author_photo,
					body: items[0].title,
					url: items[0].url,
					onClick: function () {
						// Try and focus the window (security settings may prevent it, though)
						try {
							window.focus();
						} catch (err) {}

						window.location = items[0].url;
					}
				});
			} else {
				notifyData = _.extend( notifyData, {
					title: ips.pluralize( ips.getString( type + 'GeneralMultiple'), [ items.length ] ),
					body: items[0].title,
					icon: ips.getSetting( type + '_imgURL'),
					onClick: function () {
						// Try and focus the window (security settings may prevent it, though)
						try {
							window.focus();
						} catch (err) {}

						self._getIcon( ( type === 'message' ) ? 'inbox' : 'notify' ).click();
					}
				});
			}

			return notifyData;
		},

		/**
		 * Determines which is the appropriate notification method to use to let the user know about new data
		 *
		 * @param 	{object} 	notifyData 		Notification data to use when building the notification
		 * @param	{string} 	type 	 		Type of notification being build (message or notification)
		 * @returns {void}
		 */
		_showNotification (notifyData, type) {
			if( !document[ ips.utils.events.getVisibilityProp() ] ){
				// When the window is ACTIVE
				// Show a flash message
				this._showFlashMessage( notifyData, type );
			}
		},

		/**
		 * Shows a flash message at the bottom of the user's window
		 *
		 * @param 	{object} 	notifyData 		Object containing notification data
		 * @param 	{string}	type 			Type of notification (notification or message)
		 * @returns {void}
		 */
		_showFlashMessage (notifyData, type) {
			let html = '';
			const self = this;

			if( notifyData.count === 1 ){
				notifyData = _.extend( notifyData, { text: ips.getString( type + 'FlashSingle') } );
				html = ips.templates.render( 'core.notification.flashSingle', notifyData );	
			} else {
				notifyData = _.extend( notifyData, { text: ips.pluralize( ips.getString( type + 'FlashMultiple'), [ notifyData.count ] ) } );
				html = ips.templates.render( 'core.notification.flashMultiple', notifyData );
			}						

			if( $('#elFlashMessage').is(':visible') && $('#elFlashMessage').find('[data-role="newNotification"]').length ){
				$('#elFlashMessage').find('[data-role="newNotification"]').replaceWith( html );
			} else {
				ips.ui.flashMsg.show( html, { 
					timeout: 8,
					position: 'bottom',
					extraClasses: 'cNotificationFlash',
					dismissable: function () {
						self._stopPolling();
					},
					escape: false
				});
			}
		},

		/**
		 * Updates our storage timestamp to now
		 *
		 * @returns {void}
		 */
		_updateTimestamp () {
			let storage = ips.utils.db.get('notifications', ips.getSetting('baseURL'));

			storage = _.extend( storage, {
				timestamp: ips.utils.time.timestamp()
			});

			ips.utils.db.set( 'notifications', ips.getSetting('baseURL'), storage );
		},

		/**
		 * Updates the bubble on both icons if the count differs from what's alrady displayed
		 *
		 * @param	{object} 	newData 	 	The latest counts (either from storage or ajax response)
		 * @param 	{object} 	oldData 		Existing counts from the bubbles
		 * @returns {void}
		 */
		_updateIcons (newData, oldData) {
			const reportBadge = this.scope.find('[data-notificationType="reports"]');
			const reportCount = reportBadge.length ? parseInt(reportBadge.text()) : 0;

			// Some data we'll pass in an event
			const notifyData = {
				notifications: parseInt(newData.notifications),
				reports: reportCount
			};

			// The ips core userbar controller listens to this so that the menu content will refresh when it's opened next
			if (parseInt(newData.notifications) !== oldData.notifications)  {
				this._updateIcon( 'notify', newData.notifications );
				this.scope.trigger( 'clearUserbarCache', { type: 'notify' } );
			}

			if (this._messagesEnabled) {
				if( parseInt( newData.messages ) !== oldData.messages ){
					this._updateIcon( 'inbox', newData.messages );
					this.scope.trigger( 'clearUserbarCache', { type: 'inbox' } );
				}

				notifyData.messages = parseInt( newData.messages );
			}
		},

		/**
		 * Updates a bubble on an icon, and uses the appropriate animation to show it
		 *
		 * @param	{string} 	type 	 	notify or inbox
		 * @param 	{number} 	count 		The new count to show
		 * @returns {void}
		 */
		_updateIcon (type, count) {
			const icon = this._getIcon(type);

			icon.attr( 'data-currentCount', count ).text( count );

			if( parseInt( count ) ){
				ips.utils.anim.go( ( !icon.is(':visible') ) ? 'zoomIn' : 'pulseOnce', $(icon).each(function() {this.ipsShow()}) );
			} else {
				icon.fadeOut();
			}
		},

		/**
		 * Returns a reference to the icon of the given type
		 *
		 * @param	{string} 	type 	 	notify or inbox
		 * @returns {element} 	jQuery element
		 */
		_getIcon(type) {
			return $('body').find('[data-notificationType="' + type + '"]');
		},

		/**
		 * Gets the current counts from the bubbles on-screen
		 *
		 * @returns {{notifications: number, messages: number|null}} 	Contains two keys, messages & notifications, containing the currently-displayed counts
		 */
		_getCurrentCounts() {
			const messages = this.scope.find('[data-notificationType="inbox"]');
			const notifications = this.scope.find('[data-notificationType="notify"]');

			return {
				notifications: parseInt( notifications.attr('data-currentCount') ),
				messages: ( messages.length ) ? parseInt( messages.attr('data-currentCount') ) : null
			};
		},

		/**
		 * Stops our internal loop from polling for any more notifications
		 *
		 * @returns {void}
		 */
		_stopPolling() {
			Debug.info("Stopping instant notification polling");
			clearInterval( this._interval );
			this._paused = true;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.lightboxedImages.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.lightboxedImages.js
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	const IMAGE_EXTENSIONS = new Set(['gif', 'jpeg', 'jpe', 'jpg', 'png', 'svg', 'webp', 'avif'])
	const DISABLE_LIGHTBOX_ROTATE = true;

	ips.controller.register('core.front.core.lightboxedImages', {

		_random: null,

		initialize() {
			this.on( 'initializeImages', this.refreshContent );
			this.on( 'refreshContent', this.refreshContent );
			this.on( document, 'imageRotated', (e, data)=> {
				const attachment = this.elem.querySelector( '.ipsAttachLink_image img[data-fileId=' + data.fileId + ']' );
				this._updateAttachmentImage( attachment, data );
			});
			this.setup();
		},

		/**
		 * Setup method
		 *	
		 * @returns 	{void}
		 */
		setup() {
			this._random = 'g' + ( Math.round( Math.random() * 100000 ) );
			this._initializeAttachments();
			this._initializeImages();
		},

		/**
		 * Refresh the content in this container
		 *
		 * @param {Event}		e
		 *
		 * @returns 	{Promise<void>}
		 */
		async refreshContent(e) {
			Debug.log("Refreshing content in lightboxedImages");
			delete this.elem.dataset.loaded;
			e.stopPropagation();
			await Promise.allSettled([
				this._initializeAttachments(),
				this._initializeImages()
			]);
		},

		/**
		 * Build the attachment display inside content
		 *	
		 * @returns 	{Promise<void>}
		 */
		async _initializeAttachments() {
			const fileIDsToFetch = {};
			const attachments = this.elem.querySelectorAll('[data-fileid]:not([data-loaded], audio, source, video, :has(audio, source, video))')
			if( !attachments.length ){
				return;
			}

			/** @type {WeakMap<HTMLElement, boolean>}*/
			const isInlineCache = new WeakMap();
			/**
			 * To prevent multiple redundant calculations, cache the result per parent block node
			 * @param {HTMLElement}	attachment
			 */
			const calcIsInline = attachment => {
				// we need to see if this is inside a list
				const listAncestor = attachment.closest('li');
				if (listAncestor && (this.elem.contains(listAncestor) || this.elem === listAncestor)) {
					return true;
				}

				let parent = attachment;
				const ancestors = [attachment];
				while (parent && this.elem.contains(parent) && (parent === attachment || parent.matches('[data-fileid]:not([data-loaded], audio, source, video, :has(audio, source, video)), a, span, b, i, u, strong, strike'))) {
					if (isInlineCache.has(parent)) {
						return isInlineCache.get(parent);
					}
					ancestors.push(parent)
					parent = parent.parentElement;
				}

				// no inline parent? This shouldn't really happen in theory, but return
				if (!parent) {
					ancestors.forEach(ancestor => isInlineCache.set(ancestor, false));
					return false;
				}

				// Is there 'innerText' for the closest block-level parent beyond other attachments? In this case, the attachment is inline
				const clone = parent.cloneNode(true);
				clone.querySelectorAll('[data-fileid]').forEach(cloneAttachment => cloneAttachment.remove());

				const hasText = !!clone.innerText.trim();
				ancestors.forEach(ancestor => isInlineCache.set(ancestor, hasText));
				return hasText;
			}

			// Loop through each attachment and build the initial HTML for it
			attachments.forEach((attachment) => {
				// we can skip all of this for images because we are not loading metadata here
				if (attachment.matches( ':not(img, .ipsAttachLink_image)')) {
					// If this attachment is part of a list
					if (!calcIsInline(attachment)) {
						// This is a BLOCK attachment
						attachment.classList.add('ipsAttachLink_block');
						if (attachment.children.length) {
							return;
						}

						attachment.innerHTML = ips.templates.render('core.attachments.attachmentPreview', {
							title: attachment.textContent
						});
					} else {
						// This is an INLINE attachment
						attachment.classList.add('ipsAttachLink_inline');
						attachment.setAttribute('title', ips.getString('attachmentPending'));
						attachment.dataset.ipstooltip = "true";
					}
				}

				fileIDsToFetch[attachment.dataset.fileid] = true;
			});

			// If we have no files to fetch, we can bail
			if (![...Object.keys(fileIDsToFetch)].length) {
				return;
			}

			try {
				// Get the file info for each block attachment in this post
				/** @type {Object<string, ({rotate: *}|object)>} response */
				const response = await ips.fetch(ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=ajax&do=attachmentInfo', {
					dataType: 'json',
					data: {
						attachIDs: fileIDsToFetch
					}
				});

				if (typeof response !== 'object' || response instanceof Array) {
					throw new RangeError("Expected response to be an object mapping file ids to details");
				}

				attachments.forEach(attachment => {
					const attachmentID = attachment.dataset.fileid;
					if (!(attachmentID in response) || typeof response[attachmentID] !== 'object' || response[attachmentID] instanceof Array) {
						this._updateAttachmentMetaDataError(attachment);
					} else if ('rotate' in response[attachmentID]) {
						this._updateAttachmentImage(attachment, response[attachmentID]);
					} else {
						this._updateAttachmentMetaData(attachment, response[attachmentID]);
					}
				});
			} catch (e) {
				Debug.warn("Failed to get attachment info for one or more lightboxed attachments on the page");
				attachments.forEach(attachment => this._updateAttachmentMetaDataError(attachment));
			}
		},

		/**
		 * Update an attachment with the provided metadata
		 *
		 * @param {HTMLElement}		attachment
		 * @param {object|{size?:number, downloads?:number, rotate?:*}}			response
		 *	
		 * @returns 	{void}
		 */
		_updateAttachmentMetaData(attachment, response) {
			if (attachment.classList.contains('ipsAttachLink_block')) {
				const infoEl = attachment.querySelector('.ipsAttachLink_metaInfo')
				if (infoEl) {
					infoEl.innerHTML = ips.templates.render('core.attachments.metaInfo', {
						size: response.size,
						downloads: ips.pluralize(ips.getString('attachmentDownloads'), response.downloads)
					});
				}
			} else {
				attachment.setAttribute('title', response.size + ' - ' + ips.pluralize( ips.getString('attachmentDownloads'), response.downloads ));
			}
			attachment.dataset.loaded = 'true';
		},

		/**
		 * Update an image attachment with provided info
		 *
		 * @param {HTMLElement}		attachment
		 * @param {object|{size?:number, downloads?:number, rotate?:*}}			response
		 *
		 * @return 		{void}
		 */
		_updateAttachmentImage(attachment, response){
			if (DISABLE_LIGHTBOX_ROTATE) {
				return;
			}

			//todo if this is ever needed, convert the logic to use native JS DOM instead of jquery. The provided attachment element should always be a native HTMLElement
			attachment = $(attachment);
			if( ! ( attachment.is( 'img' ) ) ){
				return;
			}

			if( !_.isUndefined(response.rotate) && response.rotate !== null ){
				attachment.attr( 'data-rotate', response.rotate )
					.css( 'transform', '' );
				attachment.parents( 'a.ipsAttachLink_image' ).css( {
					'transform': 'rotate(' + response.rotate + 'deg)',
					'position': 'absolute',
					'top': 0
				} );

				if( response.rotate == 90 || response.rotate == -270 ){
					if( attachment.width() > attachment.height() ){
						attachment.parents( 'a.ipsAttachLink_image' ).css({
							'right': '40%',
							'height': '100%'
						});
					} else {
						attachment.parents( 'a.ipsAttachLink_image' ).css({
							'left': '5%',
							'transform-origin': 'right'
						});
					}
				} else if( response.rotate == -90 || response.rotate == 270 ){
					if( attachment.width() > attachment.height() ){
						attachment.parents('a.ipsAttachLink_image').css({
							'right': '40%',
							'height': '100%'
						} );
					} else {
						attachment.parents( 'a.ipsAttachLink_image' ).css({
							'left': '40%',
							'transform-origin': 'left'
						});
					}
				}

				/* get the current height of the parent and adjust if necessary */
				var containerHeight = attachment.height();
				if( response.rotate != 0 && response.rotate != 180 && response.rotate != -180 ){
					containerHeight = attachment.width();
				}
				var parent = attachment.parents( 'p:first' );
				if( $( parent ).height() < containerHeight ){
					$( parent ).css( { 'height': parseInt( containerHeight + 5 ).toString() + 'px', 'position': 'relative' } );
				}
			}
		},

		/**
		 * Update an attachment with an 'unavailable' message
		 *
		 * @param {HTMLElement}		attachment
		 *	
		 * @returns 	{void}
		 */
		_updateAttachmentMetaDataError(attachment) {
			if (attachment.classList.contains('ipsAttachLink_block')) {
				attachment.querySelector('.ipsAttachLink_metaInfo').innerHTML = ips.getString('attachmentUnavailable');
			} else {
				attachment.setAttribute('title', ips.getString('attachmentUnavailable') );
			}

			attachment.dataset.loaded = 'true';
		},
		
		/**
		 * Given an image, either updates the wrapping link or adds one, before adding lightbox attrs
		 *
		 * @param {HTMLImageElement}		image
		 *
		 * @returns 	{Promise<void>}
		 */
		async _addOrUpdateWrappingLink(image) {
			const closestLink = image.closest(':is(a, i-lightbox):is([data-wrapped-link], .ipsAttachLink.ipsAttachLink_image)');
			const imageSrc = 'fullImage' in image.dataset ? image.dataset.fullImage : image.getAttribute('src');
			const fileId = image.dataset.fileid;

			if (closestLink) {
				const href = closestLink.getAttribute('href');
				const ext = href?.includes('.') ? href.split('.').pop() : '';

				if (IMAGE_EXTENSIONS.has(ext) || (await ips.ui.lightbox.getImageDimensions(imageSrc)).solid) {
					closestLink.dataset.fileid = fileId;
					closestLink.dataset.ipslightbox = '';
					closestLink.dataset.ipslightboxGroup = this._random;

					if (href) {
						closestLink.dataset.fullurl = href;
					}
				}
			} else {
				const link = document.createElement('i-lightbox');
				link.dataset.wrappedlink = '';
				link.dataset.ipslightbox = '';
				link.setAttribute('href', imageSrc )
				if (image.hasAttribute('title')) {
					image.setAttribute('data-original-title', image.getAttribute('title'));
				}
				image.setAttribute('title', ips.getString('enlargeImage') )
				link.dataset.fileid = fileId
				link.dataset.ipslightboxGroup = this._random;
				image.parentElement.insertBefore(link,image)
				link.append(image);
			}
		},

		/**
		 * Event handler for main event
		 *	
		 * @returns 	{Promise<void>}
		 */
		async _initializeImages() {
			const images = this.elem.querySelectorAll('img:not(.ipsEmoji *, .tiptap *, [data-emoticon] *, .ipsEmoji, [data-emoticon], [data-ipslightbox] *, a *)');
			const promises = [];
			if (images.length) {
				images.forEach(image => {
					// open up a lightboxed preview for link preview images
					const embedAncestor = image?.closest('.ipsEmbedded_og[data-og-url]')
					if (embedAncestor) {
						if (!('linkified' in embedAncestor.dataset)) {
							const toLink = embedAncestor.querySelector(`.ipsEmbedded_og__title`) || image
							const toWrap = document.createElement('a')
							toWrap.href = embedAncestor.dataset.ogUrl
							toWrap.target = "_blank"
							toWrap.classList.add('ipsEmbedded_og__link')
							toLink.parentElement.insertBefore(toWrap, toLink)
							toWrap.append(toLink)
							embedAncestor.dataset.linkified = ''
						}
						return;
					}

					// Wrap image in a link
					promises.push(this._addOrUpdateWrappingLink(image));
				});
			}
			await Promise.allSettled(promises);
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.markRead.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.markRead.js - Controller for moderation actions in content listings
 *
 * Author: Matt Mecham; Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.markRead', {

		initialize: function () {
			this.on( 'click', this.markSiteRead );
		},

		/**
		 * Event handler for marking site as read
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		markSiteRead: function (e) {
			e.preventDefault();
			
			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('markAsReadConfirm'),
				subText: '',
				callbacks: {
					ok: function () {
						var url = $( e.currentTarget ).attr('href');

						ips.getAjax()( url, {
							showLoading: true
						})
							.done( function () {
								$( document ).trigger( 'markAllRead' );
							})
							.fail( function (jqXHR, textStatus, errorThrown) {
								window.location = url;
							});
					}
				}
			});
			
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.moderation.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.moderation.js - Controller for moderation actions in content listings
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.moderation', {
		
		_editTimeout: 0,
		_editingTitle: false,

		initialize: function () {
			this.on( 'submit', '[data-role="moderationTools"]', this.moderationSubmit );
			this.on( 'mousedown', '[data-role="editableTitle"]', this.editTitleMousedown );
			this.on( 'mouseup mouseleave', '[data-role="editableTitle"]', this.editTitleMouseup );
			this.on( 'click', '[data-role="editableTitle"]', this.editTitleMouseclick );
		},
		
		/**
		 * Event handler called when the user clicks down an editable title
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editTitleMousedown: function(e) {
			var self = this;

			if( e.which !== 1 ){ // Only care if it's the left mouse button
				return;
			}

			this._editTimeout = setTimeout(function(){
				self._editingTitle = true;
				clearTimeout( this._editTimeout );
				
				var anchor = $( e.currentTarget );
				anchor.hide();
				var inputNode = $('<input/>').attr( { type: 'text' } ).attr( 'data-role', 'editTitleField' ).val( anchor.text().trim() );
				anchor.after(inputNode);
				inputNode.focus();

				let params = { do: 'ajaxEditTitle' };
				if ( anchor.attr('data-params') !== undefined ) {
					params = Object.assign( {}, params, JSON.parse( anchor.attr('data-params') ) );
				}
				inputNode.on('blur', function(){
					inputNode.addClass('ipsField_loading');
					const oldTitle = anchor.text().trim();
					const newTitle = inputNode.val().trim();
					if (newTitle === '' || newTitle === oldTitle)
					{
                        inputNode.remove();
                        anchor.show();
                        self._editingTitle = false;
					}
					else
					{
						params = { ...params, ...{ "newTitle": newTitle } };
						ips.getAjax()( anchor.attr('href'), { method: 'post', data: params } )
                            .done(function(response){
                                anchor.text( response );
                            })
                            .fail(function(response){
                                ips.ui.alert.show( {
                                    type: 'alert',
                                    icon: 'warn',
                                    message: response.responseJSON,
                                });
                            })
                            .always(function(){
                                inputNode.remove();
                                anchor.show();
                                self._editingTitle = false;
                            });
					}
				});
				
				inputNode.on('keypress', function(e){
					if( e.keyCode == ips.ui.key.ENTER ){
						e.stopPropagation();
						e.preventDefault();
						inputNode.blur();
						return false;
					}
				});

				// Chrome requires checking keydown instead for escape
				inputNode.on('keydown', function(e){
					if( e.keyCode == ips.ui.key.ESCAPE ){
						inputNode.remove();
						anchor.show();
						self._editingTitle = false;
						return false;
					}
				});
			}, 1000);
		},
		
		/**
		 * Event handler called when the user clicks up an editable title
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editTitleMouseup: function(e) {
 			clearTimeout( this._editTimeout );
		},
		
		/**
		 * Event handler called when the user clicks up an editable title
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		editTitleMouseclick: function(e) {
 			if ( this._editingTitle ) {
	 			e.preventDefault();
	 		}
		},
				
		/**
		 * Event handler called when the moderation bar submits
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		moderationSubmit: function (e) {
			
			if ( this._editingTitle ) {
				e.preventDefault();
			}

			var action = this.scope.find('[data-role="moderationAction"]').val();

			switch (action) {
				case 'delete':
					this._modActionDelete(e);
				break;
				case 'move':
					this._modActionDialog(e, 'move', 'narrow');
				break;
				case 'hide':
					this._modActionDialog(e, 'hide', 'narrow');
				break;
				case 'split':
					this._modActionDialog(e, 'split', 'wide');
				break;
				case 'merge':
					this._modActionDialog(e, 'merge', 'medium');
				break;
				case 'tag':
					this._modActionDialog(e, 'tag', 'narrow');
					break;
				case 'untag':
					this._modActionDialog(e, 'untag', 'narrow');
					break;
				default:
					 $( document ).trigger('moderationSubmitted');
				break;
			}
		},

		/**
		 * Handles a delete action from the moderation bar
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		_modActionDelete: function (e) {
			var self = this;
			var form = this.scope.find('[data-role="moderationTools"]');

			if( self._bypassDeleteCheck ){
				return;
			}

			e.preventDefault();

			// How many are we deleting?
			let count = parseInt(this.elem.querySelector('[data-role="moderationTools"][data-ipspageaction][data-ipspageaction-selected-count]')?.dataset.ipspageactionSelectedCount);

			if (Number.isNaN(count)) {
				count = (parseInt(this.scope.find('[data-role="moderation"]:checked').length) + parseInt(this.scope.find('[data-role="moderation"]:hidden').length));
			}

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'warn',
				message: ( count > 1 ) ? ips.pluralize( ips.getString( 'delete_confirm_many' ), count ) : ips.getString('delete_confirm'),
				callbacks: {
					ok: function () {
                        $( document ).trigger('moderationSubmitted');
						self._bypassDeleteCheck = true;
						self.scope.find('[data-role="moderationTools"]').submit();
					}
				}
			});
		},

		/**
		 * Handles a move/split action from the moderation bar
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		_modActionDialog: function (e, title, size) {
			e.preventDefault();
			
			var form = this.scope.find('[data-role="moderationTools"]');
			
			// Create dialog to show the form
			var moveDialog = ips.ui.dialog.create({
				url: form.attr('action') + '&' + form.serialize().replace( /%5B/g, '[' ).replace( /%5D/g, ']' ),
				modal: true,
				title: ips.getString(title),
				forceReload: true,
				size: size
			});

			moveDialog.show();
			$( document ).trigger('moderationSubmitted');
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.navigationPanel.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.navigationPanel.js - Save the scroll position and collapsed state of the side navigation panel
 *
 * Author: Ehren Harber
 */
;( function(_){
	"use strict";

	ips.controller.register('core.front.core.navigationPanel', {
		
		/**
		* Initializes the controller
		* @returns {void}
		*/
		initialize() {
			let collapsedPanels = [];
			try {
				collapsedPanels = JSON.parse(ips.utils.cookie.get('collapsedNavigationPanels') || '[]');
				if (!Array.isArray(collapsedPanels)) throw new TypeError();
			} catch (e) {
				// Log if this is a critical error
				collapsedPanels = []
				ips.utils.cookie.set('collapsedNavigationPanels', '[]');
			}
			this.collapsed = new Set(collapsedPanels);
			this.on( 'ips:toggleSidePanelNav', this.toggleBlock );
			this.on( 'scrollend', this.saveScroll );
			
			// A polyfill for browsers which don't support scrollend (Safari)
			if (!('onscrollend' in window)){
				this.on('scroll', _.debounce(() => this.saveScroll(), 300));
			}
		},

		/**
		 * Event handler for storing toggle status
		 * Hidden categories are stored localDB
		 *
		 * @param 	{ipsUiHiddenToggleEvent} 	e 	Event object
		 * @returns {void}
		 */
		toggleBlock(e){

			const block = e.target;
			const blockId = block?.getAttribute("data-id");

			if (!block || typeof blockId !== 'string') {
				Debug.warn(`The navigation panel received an event indicating a block was expanded or collapsed, but the block couldn't be determined`);
				return;
			}

			if (block.hidden){
				this.collapsed.add(blockId);
			} else {
				this.collapsed.delete(blockId);
			}

			ips.utils.cookie.set('collapsedNavigationPanels', JSON.stringify(Array.from(this.collapsed)), true);
			
			this.saveScroll();
		},

		/**
		 * Scroll event handler for storing scroll position
		 * Saved as sessionStorage
		 *
		 * @returns {void}
		 */
		saveScroll(){
			sessionStorage.setItem("navigationPanelScroll", this.scope[0].scrollTop);
		}
		
	});
}(_));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.notifications.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.notifications.js - Browser notifications prompt
 *
 * Author: Stuart Silvester
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.notifications', {

		initialize: function () {
			this.on( document, 'menuOpened', this.menuOpened );
			this.on( document, 'permissionDenied.notifications', this.hideNotice );
			this.on( document, 'subscribePending.notifications', this.subscribePending );
			this.on( document, 'subscribeSuccess.notifications', this.subscribeSuccess );
			this.on( document, 'subscribeFail.notifications', this.subscribeFail );
			this.on( 'click', '[data-action=browserNotificationPrompt]', this.requestPermission );
			this.on( 'click', '[data-role=dismissNotification]', this.dismissNotification );
			this.on( 'click', '[data-action="rejectPush"]', this.rejectPush );

			if( ips.getSetting('memberID') && ips.utils.notification.supported && ips.utils.serviceWorker.supported ){
				this.setup();
			}
		},

		setup: function() {
			this._timeout = null;
			this._buttonText = '';
			this._missingSubscription = false;

			if( ips.utils.notification.needsPermission() && _.isUndefined( ips.utils.cookie.get('browserNotificationDismiss') ) ) {
				this.scope.html( ips.templates.render( 'core.browserNotification.prompt' ) ).hide();
			} else if( ips.utils.notification.hasPermission() && _.isUndefined( ips.utils.cookie.get('notificationPushRejected') ) ) {
				// If we have permission but no subscription, prompt the user - likely an upgrade where they've granted permission
				// but we haven't received a push subscription token yet
				ips.utils.notification.getSubscription()
					.then( subscription => {
						if( subscription ){
							return; // They already have a subscription, so no need to do anything here
						}
						
						this._missingSubscription = true;
						this.scope.html( ips.templates.render( 'core.browserNotification.missingSubscription' ) ).hide();
					})
					.catch( err => {
						Debug.log("getSubscription failed - browser may not support pushManager");
						Debug.log(err);
						return;
					});
			}
		},

		destroy: function () {
			clearTimeout( this._timeout );
		},

		/**
		 * Called when the notifications menu is opened
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data
		 * @returns {void}
		 */
		menuOpened: function (e, data = e.detail) {
			let date;
			const showPrompt = () => {
				this._timeout = setTimeout( () => {
					this.scope.slideDown('fast');
					ips.utils.cookie.unset('notificationMenuShown');
				}, 750 );
			};

			if (data.elemID === 'elFullNotifications') {
				if (this._missingSubscription) {
					showPrompt(); // In cases where they've given permission but not yet subscribed, just show immediately
				} else {
					// To prevent annoyance for new users, we'll only show the callout after 2+ days
					if (ips.utils.cookie.get('notificationMenuShown') === undefined) {
						date = parseInt(ips.utils.cookie.get('notificationMenuShown'));
						if (date && Date.now() >= date) {
							showPrompt();
						}
					} else {
						date = new Date();
						date.setDate( date.getDate() + 2 );
						ips.utils.cookie.set('notificationMenuShown', date.getTime(), true );
					}
				}
			}
		},

		/**
		 * Event handler for a pending subscription - update button to show something is happening
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data
		 * @returns {void}
		 */
		subscribePending: function (e, data) {
			// Save current button text so we can switch it back later
			const button = this.scope.find('[data-action="browserNotificationPrompt"]');
			this._buttonText = button.text();
			button.prop('disabled', true).text( ips.getString('notificationsEnabling') );
		},

		/**
		 * Event handler for a successful subscription - let the user know
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data
		 * @returns {void}
		 */
		subscribeSuccess: function (e, data) {
			const button = this.scope.find('[data-action="browserNotificationPrompt"]');
			button.prop('disabled', true).text( ips.getString('notificationsSubscribed') );
		},

		/**
		 * Event handler for a failed subscription - let the user know
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data
		 * @returns {void}
		 */
		subscribeFail: function (e, data) {
			this.scope
				.find('[data-action="browserNotificationPrompt"]')
				.prop( 'disabled', false )
				.text( this._buttonText );

			this.scope.find('[data-role="promptMessage"]').text( ips.getString('notificationsSubscribeFailed') ).slideDown();	
		},

		/**
		 * Called when the user clicks the button to init the notification popup
		 *
		 * @returns {void}
		 */
		requestPermission: function() {
			this.scope.find( '[data-role="promptMessage"]').text( ips.getString('notificationsAllowPrompt') ).slideDown();
			$(document).trigger('requestPermission.notifications');
		},

		/**
		 * User does not 
		 *
		 * @returns {void}
		 */
		rejectPush: function (e) {
			e.preventDefault();
			ips.utils.cookie.set('notificationPushRejected', true, true );
			this.hideNotice();
		},

		/**
		 * Event handler called when the browser (via ips.utils.notifications) changes notification status
		 * Whatever the user decides, hide the message now so we arent annoying
		 *
		 * @returns {void}
		 */
		hideNotice: function() {
			this.scope.slideUp('fast');
		},

		/**
		 * Allows the user to dismiss the callout in the notifications menu
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		dismissNotification: function(e) {
			if( e ) {
				e.preventDefault();
			}

			var date = new Date();
			date.setDate( date.getDate() + 100 );
			ips.utils.cookie.set( 'browserNotificationDismiss', true, date.toUTCString() );

			this.scope.slideUp( {
				duration: 400,
				complete: function() {
					$(this).remove();
				}
			});
		}

	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.notificationsMenu.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200">/**
 * Invision Community 5
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.notificationsMenu.js - Handles the notifications menu in the mobile footer menu. ips.core.userBar.js handles the desktop/tablet userbar notifications menu.
 *
 * Author: Matt Mecham
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.notificationsMenu', {

		initialize: function () {
			this.on( document, 'menuOpened', this.menuOpened );
		},


		/**
		 * Called when the notifications menu is opened
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data
		 * @returns {void}
		 */
		menuOpened: function (e, data) {
			/* Clear any badges */
			ips.utils.notification.clearBadgeCount();
		}
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.pagination.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.pagination.js - Pagination controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.pagination', {

		initialize: function () {
			this.on( 'paginationClicked paginationJump', this.paginationClick );
		},
		
		paginationClick: function (e, data) {
			var self = this;

			if( !data.href ){
				return;
			}

			ips.getAjax()( data.href )
				.done( function (response) {
					self.scope.hide().html( response );
					ips.utils.links.updateExternalLinks();
					ips.utils.anim.go('fadeIn', self.scope);
				})
				.fail( function () {
					window.location = data.href;
				});
		}

	});
}(jQuery, _));
</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.poll.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.poll.js - Poll controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.poll', {

		initialize: function () {
			this.on( 'submit', 'form', this.submitPoll );
			this.on( 'click', '[data-action="viewResults"]', this.viewResults );
		},

		/**
		 * Event handler for clicking a link to view results
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		viewResults: function (e) {
			e.preventDefault();
						
			var url = $( e.currentTarget ).attr('href') + '&fetchPoll=1&viewResults=1';
			if ( $(e.currentTarget).attr('data-viewResults-confirm') ) {
				var self = this;
				ips.ui.alert.show( {
					type: 'confirm',
					icon: 'warn',
					message: ips.getString('generic_confirm'),
					subText: ips.getString('warn_allow_result_view'),
					callbacks: {
						ok: function () {
							self._viewResults( url + '&nullVote=1' );
						}
					}
				});
			} else {
				this._viewResults( url );
			}
		},
		
		_viewResults: function( url ) {
			var self = this;
			self._setContentsLoading();
			ips.getAjax()( url )
				.done( function (response) {
					self.cleanContents();
					self.scope.html( response );
					
					$( document ).trigger( 'contentChange', [ self.scope ] );
				});
		},

		/**
		 * Sets the poll container to loading state
		 *
		 * @returns 	{void}
		 */
		_setContentsLoading: function () {
			var container = this.scope.find('[data-role="pollContents"]');
			var height = container.outerHeight();

			container
				.css({
					height: height + 'px'
				})
				.html('')
				.addClass('ipsLoading');
		},

		/**
		 * Event handler for submitting the poll form to vote
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitPoll: function (e) {
			var form = $( e.currentTarget );

			if( form.attr('data-bypassAjax') ){
				return
			}
			
			e.preventDefault();
			var url = form.attr('action');
			var self = this;

			// Set button to voting
			this.scope.find('button[type="submit"]').prop( 'disabled', true ).text( ips.getString('votingNow') );

			if ( url.match(/\?/) ) {
				url += '&';
			} else {
				url += '?';
			}
			
			ips.getAjax()( url + 'fetchPoll=1', {
				data: form.serialize(),
				type: 'POST'
			})
				.done( function (response) {
					self.cleanContents();
					self.scope.html( response );

					$( document ).trigger( 'contentChange', [ self.scope ] );
					ips.ui.flashMsg.show( ips.getString('thanksForVoting') );
				})
				.fail( function () {
					form
						.attr( 'data-bypassAjax', true )
						.submit();	
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.pollEditor.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.pollEditor.js - Controller for follow button
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.pollEditor', {

		initialize: function () {
			this.on( 'click', '[data-action="removeChoice"]', this.removeChoice );
			this.on( 'click', '[data-action="addChoice"]', this.addChoice );
			this.on( 'click', '[data-action="addQuestion"]', this.addQuestion );
			this.on( 'click', '[data-action="removeQuestion"]', this.removeQuestion );

			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			this._maxQuestions = this.scope.attr('data-maxQuestions');
			this._maxChoices = this.scope.attr('data-maxChoices');
			this._name = this.scope.attr('data-pollName');

			var pollData = ips.getSetting('pollData');

			// Build the existing options
			if( _.isArray( pollData ) && pollData.length ){
				for( var i = 0; i < pollData.length; i++ ){
					this._buildQuestion( pollData[ i ], i + 1 );
				}
			} else if ( _.isObject( pollData ) && ! _.isEmpty( pollData ) ) {
				for( var i in pollData ){
					this._buildQuestion( pollData[ i ], i );
				}
			} else {
				this._addQuestion( 1 );
				this._checkQuestionButton();
				this._checkChoiceButton( this.scope.find('[data-questionID="1"]') );
			}
		},

		/**
		 * Event handler for the Add Question button
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		addQuestion: function (e) {
			e.preventDefault();

			// Get maximum question ID
			var maxQid = _.max( this.scope.find('[data-questionID]'), function (item) {
				return parseInt( $( item ).attr('data-questionID') );
			});

			maxQid = parseInt( $( maxQid ).attr('data-questionID') );

			if( !_.isNumber( maxQid ) || _.isNaN( maxQid ) ){
				maxQid = 0;
			}

			var questions = this.scope.find('[data-questionID]');
			if( questions.length >= this._maxQuestions ){
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: ips.getString('noMoreQuestionsMlord'),
					callbacks: {
						ok: $.noop
					}
				});

				return;
			}

			this._addQuestion( maxQid + 1 );

			ips.utils.anim.go( 'fadeIn', this.scope.find('[data-questionID="' + ( maxQid + 1 ) + '"]') );

			this._checkQuestionButton();
		},

		/**
		 * Event handler for the Remove Question button
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		removeQuestion: function (e) {
			e.preventDefault();
			var self = this;
			var question = $( e.currentTarget ).closest('[data-questionid]');
			var removeQuestion = function () {
				question.remove();
				self._checkQuestionButton();
			};

			if( question.find('[data-role="questionTitle"]').val() !== '' ){
				ips.ui.alert.show( {
					type: 'confirm',
					icon: 'question',
					message: ips.getString('removeQuestionConfirm'),
					callbacks: {
						ok: removeQuestion
					}
				});	
			} else {
				removeQuestion();
			}			
		},

		/**
		 * Event handler for adding a new choice to a question
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		addChoice: function (e) {
			e.preventDefault();

			var question = $( e.currentTarget ).closest('[data-questionID]');

			// How many choices?
			var maxCid = _.max( question.find('[data-choiceID]'), function (item) {
				return parseInt( $( item ).attr('data-choiceID') );
			});

			maxCid = parseInt( $( maxCid ).attr('data-choiceID') );

			if( !_.isNumber( maxCid ) || _.isNaN( maxCid ) ){
				maxCid = 0;
			}

			if( maxCid >= this._maxChoices ){
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: ips.getString('noMoreChoices'),
					callbacks: {
						ok: $.noop
					}
				});

				return;
			}

			this._addChoice( question, maxCid + 1 );

			ips.utils.anim.go( 'fadeIn', question.find('[data-choiceID="' + ( maxCid + 1 ) + '"]') );

			this._checkChoiceButton( question );
		},

		/**
		 * Event handler for removing a choice
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		removeChoice: function (e) {
			e.preventDefault();

			var self = this;
			var choice = $( e.currentTarget ).closest('[data-choiceID]');
			var question = choice.closest( '[data-questionID]' );

			// Check this isn't the only choice left
			if( question.find('[data-choiceID]').length <= 2 ){
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: ips.getString('cantRemoveOnlyChoice'),
					callbacks: {
						ok: $.noop
					}
				});

				return;
			}

			// Animation complete handler to remove the choice
			choice.animationComplete( function () {
				choice.remove();

				// Need to readjust all the choice numbers for this question
				_.each( question.find('[data-choiceID]'), function (item, idx) {
					$( item )
						.attr( 'data-choiceID', idx + 1 )
						.find('[data-role="choiceNumber"]')
							.text( idx + 1 );
				});

				self._checkChoiceButton( question );
			});

			ips.utils.anim.go( 'fadeOut fast', choice );
		},

		/**
		 * Builds a question based on existing data
		 *
		 * @param 		{object} 	data 		Data object containing title, multiple choice, etc
		 * @param 		{number} 	qid 		Question ID
		 * @returns 	{void}
		 */
		_buildQuestion: function (data, qid) {
			var choices = [];

			if( _.isArray( data.choices ) && data.choices.length ){
				for( var i = 0; i < data.choices.length; i++ ){
					choices.push( this._getChoiceHTML( i + 1, qid, data.choices[ i ].title ) );
				}
			} else if ( _.isObject( data.choices ) ) {
				for( var i in data.choices ){
					choices.push( this._getChoiceHTML( i, qid, data.choices[ i ].title ) );
				}
			}

			this.scope.find('[data-role="pollContainer"]').append( ips.templates.render('core.pollEditor.question', {
				pollName: this._name,
				multiChoice: data.multiChoice,
				questionID: qid,
				question: data.title,
				choices: choices.join(''),
				removeQuestion: !( qid === 1 )
			}));
		},

		/**
		 * Adds an empty question block to the form
		 *
		 * @param 		{object} 	data 		Message data
		 * @returns 	{void}
		 */
		_addQuestion: function (qid) {
			var choices = [];

			choices.push( this._getChoiceHTML( 1, qid ) );
			choices.push( this._getChoiceHTML( 2, qid ) );

			this.scope.find('[data-role="pollContainer"]').append( ips.templates.render('core.pollEditor.question', {
				pollName: this._name,
				questionTitle: ips.getString( 'questionTitle', { id: qid } ),
				questionID: qid,
				choices: choices.join(''),
				removeQuestion: !( qid === 1 )
			}));
		},

		/**
		 * Adds a new choice to the given question
		 *
		 * @param 		{element} 	question 		Question block we're adding to
		 * @param 		{number} 	cid 			ID of new choice
		 * @returns 	{void}
		 */
		_addChoice: function (question, cid) {
			var html = this._getChoiceHTML( cid, question.attr('data-questionID'), '' );
			question.find('[data-role="choices"]').append( html );
		},

		/**
		 * Returns the HTML for a choice row
		 *
		 * @param 		{object} 	data 		Message data
		 * @returns 	{void}
		 */
		_getChoiceHTML: function (cid, qid, name) {
			return ips.templates.render('core.pollEditor.choice', {
				choiceID: cid,
				questionID: qid,
				pollName: this._name,
				choiceTitle: name
			});
		},

		/**
		 * Enables or disables the Add Question button depending on current number of questions
		 *
		 * @returns 	{void}
		 */
		_checkQuestionButton: function () {
			var questions = this.scope.find('[data-questionID]');
			this.scope.find('[data-action="addQuestion"]').toggleClass( 'ipsButton--disabled', ( questions.length >= this._maxQuestions ) );
		},

		/**
		 * Enables or disables the Add Choice button depending on current number of choices in the given question
		 *
		 * @param 		{element} 	questionScope 		The question being worked with
		 * @returns 	{void}
		 */
		_checkChoiceButton: function (questionScope) {
			var choices = questionScope.find('[data-choiceID]');

			questionScope.find('[data-action="addChoice"]').toggleClass( 'ipsButton--disabled', ( choices.length >= this._maxChoices ) );
			questionScope.find('[data-choiceID] [data-action="removeChoice"]').toggleClass( 'ipsButton--disabled', ( choices.length === 2 ) );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.profileCompletion.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.profileCompletion.js - Controller for profile completion sidebar widget
 *
 * Author: Ryan Ashbrook
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.profileCompletion', {
	
		initialize: function () {
			this.on( 'click', '[data-role="dismissProfile"]', this.dismissProfile );
		},

		dismissProfile: function(e) {
			e.preventDefault();

			var self = this;
			
			ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=settings&do=dismissProfile' )
				.done( function(response) {
					self.scope.animate({
						opacity: "0"
					}, 'fast', function() {
						self.scope.hide();
					} );
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.quickSearch.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.quickSearch.js - Controller for search in header
 *
 * Author: Ehren Harber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.quickSearch', {
		
		initialize: function () {
			this.on( 'mouseup', '.cSearchFilter__menu', this.updateAndClose );
			this.on( 'change', 'input[name="type"]', this.updateFilter );
			this.on( 'focus', '.cSearchSubmit', this.a11yFocusSubmit );
			this.on( 'keypress', '.cSearchFilter__text', this.a11yOpenDetails );
			this.setup();
		},

		/* Populate the search filter with the default filter */
		setup: function () {
			document.querySelector('.cSearchFilter__text').innerText = document.querySelector('.cSearchFilter__menu input:checked + .cSearchFilter__menuText').innerHTML;
		},
		
		/* Update the search filter when a new filter is selected */
		updateFilter: function(e){
			document.querySelector('.cSearchFilter__text').innerText = e.target.nextElementSibling.innerHTML;
		},

		/* Close the menu and add focus back to the search form when a new filter is selected */
		updateAndClose: function(e){
			setTimeout(() => {
				document.querySelector('.cSearchFilter').open = false;
				document.querySelector('#elSearchField').focus();
			}, "500");
		},

		/* Automatically focus the selected filter when opened using keyboard */
		a11yOpenDetails: function(e){
			if(e.key === "Enter"){
				e.preventDefault();
				document.querySelector('.cSearchFilter').open = true;
				document.querySelector('.cSearchFilter__menu input:checked').focus();
			}
		},

		/* Hide the dropdown menu when the submit button is focused using keyboard */
		a11yFocusSubmit: function(e){
			document.querySelector('.cSearchFilter').open = false;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.rating.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.quickSearch.js - Controller for search in header
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.rating', {
	
		initialize: function () {
			this.on( 'ratingSaved', '[data-ipsRating]', this.ratingClick );
			var scope = this.scope;
		},
		
		ratingClick: function(e, data){
			var scope = $(this.scope);
			ips.getAjax()( scope.attr('action'), {
				data: scope.serialize(),
				type: 'post'
			})
				.done( function (response, textStatus, jqXHR) {	
					// Don't need to actually do anything here
				})
				.fail(function(){
					scope.submit();
				});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.reaction.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.reaction.js - Reaction handler HAHA THANKS
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.reaction', {

		_reactTypeContainer: null,
		_reactButton: null,
		_reactTypes: null,
		_reactClose: null,
		_ajaxObj: null,

		initialize() {
			this.on( 'click', '[data-role="reactionInteraction"]', this.clickLaunchReaction );
			this.on( 'mouseenter', '[data-role="reactionInteraction"]', this.launchReaction ); 
			this.on( 'mouseleave', '[data-role="reactionInteraction"]', this.unlaunchReaction );
			this.on( 'click', '[data-role="reaction"]', this.clickReaction );
			this.on( 'click', '[data-action="unreact"]', this.unreact );
			this.on( document, 'socket.reaction-count', this._updateReactionCountsFromSocket);

			this._reactTypeContainer = this.scope.find('[data-role="reactionInteraction"]');
			this._reactTypes = this._reactTypeContainer.find('[data-role="reactTypes"]');
			this._reactButton = this._reactTypeContainer.find('[data-action="reactLaunch"]');
			this._reactClose = this._reactTypeContainer.find('[data-action="unreact"]');
			this._reactBlurb = this.scope.find('[data-role="reactionBlurb"]');
			this._reactCount = this.scope.find('[data-role="reactCount"]');
			this._singleReaction = !this._reactTypes.length ;
		},

		/**
		 * Update the reaction based on an event from the socket
		 *
		 * @param {Event}	event		The event being fired
		 * @param {Object}	payload		The data from the socket event
		 * @param {string}	payload.blurb		 The blurb (html) to show
		 * @param {number}	payload.score		The number of reactions
		 * @param {number}	payload.count		The 'reaction count', refer to the \IPS\Content\Reactable PHP Source to see the difference
		 * @param {object}	payload.content	Information about the content item/comment being reacted to
		 * @param {number}	payload.memberReacted	The memberID of the member that reacted
		 *
		 * @returns {Promise<void>}
		 */
		async _updateReactionCountsFromSocket(event, {payload:data}) {
			if (data.memberReacted === ips.getSetting('memberID')) {
				return;
			}

			if (!data.content?.content_id || parseInt(data.content.content_id) !== this._getItemId()) {
				return;
			}

			if ((data?.content?.comment_id || null) !== this._getCommentId()) {
				return;
			}

			if ('count' in data && 'score' in data) {
				// If we've reacted to this content, fetch the blurb again
				if (typeof data.blurb !== "string" || this.scope.get(0).querySelector(`[data-action='reactLaunch'].ipsReact_reacted`)) {
					data.blurb = await this._fetchBlurb();
				}

				if (typeof data.blurb !== "string") {
					return;
				}

				this._updateReaction(data);
			}
		},

		/**
		 * Get the blurb for this comment/item
		 *
		 * @return {Promise<null|string>}
		 *
		 * @private
		 */
		async _fetchBlurb() {
			try {
				const reactionUrl = this.scope.get(0).querySelector(`[data-role='reaction'][href]`)?.getAttribute('href');
				if (!reactionUrl) return null;
				let url = new URL(reactionUrl);
				url.updateSearchParams({
					params: {
						csrfKey: null,
						reaction: null,
						do: `reactionBlurb${this._getCommentId() ? "Comment" : ""}`,
					}
				});
				const response = await ips.fetch(url.toString())
				if (typeof response?.blurb === 'string') {
					return response.blurb;
				}
			} catch (e) {}

			return null;
		},

		/**
		 * Get the comment id for this reaction element; It fetches from a bit of content controlled by ips.core.comment.js
		 *
		 * @returns {number|null}
		 */
		_getCommentId() {
			if ($(this.scope).get(0)?.closest(`[data-commentid]`)) {
				return parseInt($(this.scope).get(0)?.closest(`[data-commentid]`).dataset.commentid) || null
			}
			return null;
		},

		/**
		 * Get the id of the item this reaction controller's element belongs to
		 *
		 * @returns {number|null}
		 */
		_getItemId() {
			return parseInt($(this.scope).get(0)?.closest('[data-feedid]')?.dataset.feedid.match(/(\d+)$/)?.[1]) || parseInt(document.body.dataset?.pageid) || null
		},
		
		/**
		 * Click handler for the react button - only relevant on mobile
		 *
		 * @returns 	{void}
		 */
		clickLaunchReaction() {
			if( !ips.utils.events.isTouchDevice() || this._singleReaction ){
				return;
			}
			
			this._reactTypeContainer.addClass('ipsReact_types_active');
			this._launchReaction();
		},

		/**
		 * Launch event handler for mouseenter event
		 *
		 * @returns 	{void}
		 */
		launchReaction() {
			// Ignore these on mobile
			if (ips.utils.events.isTouchDevice()) {
				return;
			}

			this._launchReaction();
		},

		/**
		 * Handler for clickLaunchReaction and launchReaction to open the flyout
		 *
		 * @returns 	{void}
		 */
		_launchReaction() {
			this._reactTypes.attr('hidden', false).removeClass('ipsReact_hoverOut').addClass('ipsReact_hover');
		},

		/**
		 * Handler for hiding the reaction flyout
		 *
		 * @returns 	{void}
		 */
		unlaunchReaction() {
			this._reactTypes.animationComplete( () => {
				if( this._reactTypes.hasClass('ipsReact_hoverOut') ){
					this._reactTypes.removeClass('ipsReact_hoverOut').attr('hidden', true);
				}
			});

			this._reactTypes.removeClass('ipsReact_hover').addClass('ipsReact_hoverOut');
			this._reactTypeContainer.removeClass('ipsReact_types_active');
		},

		/**
		 * Handler for unreacting to a post
		 *
		 * @param 		{Event} 	[e] 	Event object
		 * @returns 	{void}
		 */
		async unreact(e) {
			e?.preventDefault();
			e?.stopPropagation();

			const defaultReaction = this.scope.find('[data-defaultReaction]');
			const url = this._reactTypeContainer.attr('data-unreact');

			// If the user's reaction isn't the default one, we need to swap them around
			if (!defaultReaction.closest('[data-action="reactLaunch"]').length) {
				// We need to swap the buttons
				const currentReaction = this._reactButton.find('[data-role="reaction"]');
				const defaultReactionCopy = defaultReaction.clone();
				const currentReactionCopy = currentReaction.clone();

				currentReaction.replaceWith( defaultReactionCopy.removeClass('ipsReact_active') );
				defaultReaction.replaceWith( currentReactionCopy.removeClass('ipsReact_active') );
			}

			// Remove the reacted class
			this._reactButton.removeClass('ipsReact_reacted');

			// Hide the close button
			this._reactClose.fadeOut();

			// And trigger the close event
			this.unlaunchReaction();

			// Fire the ajax request
			const response = await ips.fetch(url);
			this._updateReaction(response, ips.getString('removedReaction'));
		},

		_updateReaction(response, flashMsg) {
			// Are we only showing the score?
			if (this._reactCount.hasClass('ipsReact_reactCountOnly')) {
				this._reactCount.find('[data-role="reactCountText"]').text( response.score ).removeClass('i-background_positive i-background_negative i-background_2');

				if (parseInt(response.score) >= 1) {
					this._reactCount.addClass('i-background_positive');
				} else if (parseInt(response.score) < 0) {
					this._reactCount.addClass('i-background_negative');
				} else {
					this._reactCount.addClass('i-background_2');
				}

				// Hide the count if there's no reactions; otherwise show
				if (parseInt(response.count) === 0) {
					this._reactCount.attr('hidden', true);
				} else {
					this._reactCount.attr('hidden', false);
				}
			} else {	
				this._reactBlurb.html(response.blurb);
				this._reactCount.text(response.count);

				if (parseInt(response.count) > 0) {
					this._reactBlurb.removeClass('ipsHide').fadeIn();
				} else {
					this._reactBlurb.fadeOut();
				}
			}

			this._reactTypeContainer.removeClass('ipsReact_types_active');

			// Let the user know
			if (flashMsg) {
				ips.ui.flashMsg.show(flashMsg);
			}
		},

		/**
		 * Handler for clicking a reaction
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		async clickReaction(e) {
			e?.preventDefault();

			// If this is a single reaction, and we're active, then we'll treat it as an 'unreact' action
			if (this._singleReaction && this._reactButton.hasClass('ipsReact_reacted')) {
				this.unreact(null);
				return;
			}

			// Mobile support - check whether we've activated the flyout first
			// Or, if this is a single reaction, ignore the flyout and just proceed with reacting
			if (ips.utils.events.isTouchDevice() && !this._singleReaction && !this._reactTypeContainer.hasClass('ipsReact_types_active')) {
				return;
			}

			const reaction = $(e.currentTarget);
			const url = reaction.attr('href');
			const currentButton = this.scope.find('[data-action="reactLaunch"] > [data-role="reaction"]');
			const newReaction = (!$(e.currentTarget).closest('[data-action="reactLaunch"]').length || !this._reactButton.hasClass('ipsReact_reacted'));

			// Remove all 'active' classes to reset their states
			this._removeActiveReaction();

			// Trigger a pulse animation on the selected reaction
			reaction.addClass('ipsReact_active');

			// Add 'reacted' class to button
			this._reactButton.addClass('ipsReact_reacted');

			// Use a timeout here to allow time for the 'pulse' animation to finish
			setTimeout(() => {
				if (reaction.closest('[data-action="reactLaunch"]').length === 0) {
					// Clone and swap the current/new reaction
					const currentButtonCopy = currentButton.clone(),
						reactionCopy = reaction.clone();

					currentButton.replaceWith( reactionCopy.removeClass('ipsReact_active') );
					reaction.replaceWith( currentButtonCopy.removeClass('ipsReact_active') );

					// Show the x button, hide the flyout and remove active styles
					setTimeout(() => this._reactClose.fadeIn(), 400);
					this.unlaunchReaction();
					this._removeActiveReaction();
				} else {
					// Show the x button, hide the flyout and remove active styles
					setTimeout(() => this._reactClose.fadeIn(), 400);
					this.unlaunchReaction();
					this._removeActiveReaction();
				}
			}, 400);

			// Only bother with an ajax request if we're updating the reaction
			if (newReaction) {
				let reactionTitle = reaction.innerText;
				let reactionIcon = reaction.find('img[data-ipsTooltip]');
				if (reactionIcon && reactionIcon.attr('_title')) {
					reactionTitle = reactionIcon.attr('_title');
				}
				reactionTitle = reactionTitle || undefined;
				try {
					const response = await ips.fetch(url)
					this._updateReaction(response);

					/* Data Layer Event */
					try {
						if (IpsDataLayerConfig && IpsDataLayerConfig._events.content_react.enabled) {
							let context = IpsDataLayerContext || {};

							$('body').trigger('ipsDataLayer', {
								_key: 'content_react',
								_properties: {
									...context,
									'reaction_type': reactionTitle, ...(response.datalayer || {})
								},
							});
						}
					} catch (e) {}
				} catch (jqXHR) {
					Debug.log('Failed to send a reaction to the server');
					if ('responseJSON' in jqXHR && jqXHR.responseJSON.error === 'react_daily_exceeded') {
						ips.ui.alert.show({
							type: 'alert',
							icon: 'warn',
							message: ips.getString('reactDailyExceeded'),
							callbacks: {}
						});
					} else {
						ips.ui.alert.show({
							type: 'alert',
							icon: 'warn',
							message: ips.getString('reactError'),
							callbacks: {}
						});
					}

					// Undo all the hard work we did to make the reaction active :(
					this._reactButton.removeClass('ipsReact_reacted');
					this._reactClose.remove();
				}
			}
		},

		/**
		 * Removes the active classname from all reactions to reset the animation
		 *
		 * @returns 	{void}
		 */
		_removeActiveReaction() {
			this._reactTypeContainer.find('.ipsReact_active').removeClass('ipsReact_active');
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.recommendedComments.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.recommendedComments.js - Controller for recommended comments
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.recommendedComments', {
	
		initialize: function () {
			this.on( document, 'refreshRecommendedComments', this.refresh );
			this.on( document, 'removeRecommendation', this.removeRecommendation );
		},
		
		/**
		 * Refresh the recommended comments area (primary to add a new comment). Can optionally scroll to the
		 * recommended comments area firat
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		refresh: function (e, data){
			var self = this;

			if( data.scroll ){
				if( !this.scope.is(':visible') ){
					this.scope.show();
				}

				var once = _.bind( _.once( self._doRefresh ), this );

				$('html, body').animate({
					scrollTop: this.scope.offset().top + 'px'
				}, function () {
					once( data.recommended );
				});
			} else {
				self._doRefresh( data.recommended );
			}
		},

		/**
		 * Removes a recommended comment
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns	{void}
		 */
		removeRecommendation: function (e, data) {
			var self = this;
			var comment = this.scope.find('[data-commentID="' + data.commentID + '"]');

			if( comment.length ){
				comment.fadeOut().slideUp( function () {
					comment.remove();
					
					if( !self.scope.find('[data-commentID]').length ){
						self.scope.hide();
					}
				});
			}
		},

		/**
		 * Fires the ajax request to get the recommended comments
		 *
		 * @param 	{string} 	newId 	The ID of the new comment that was recommended
		 * @returns	{void}
		 */
		_doRefresh: function (newId) {
			var self = this;

			// Fetch the recommended comments
			ips.getAjax()( this.scope.attr('data-url') )
				.done( function (response) {
					self._handleResponse( response, newId );
				})
				.fail( function () {
					window.reload();
				});
		},

		/**
		 * Handles the server response when adding a new comment recommendation
		 *
		 * @param 	{object} 	response 		JSON returned from server
		 * @param 	{string} 	newId 			New comment ID recommendation
		 * @returns	{void}
		 */
		_handleResponse: function (response, newId ) {
			var content = $('<div>' + response.html + '</div>').find('[data-controller="core.front.core.recommendedComments"]');
			
			// Show/hide if needed
			if( parseInt( response.count ) > 0 ){
				this.scope.show();
			} else {
				this.scope.hide();
			}

			if( !response.count ){
				return;
			}

			// If we have a new ID, we don't need to replace the whole lot - we can insert it inline
			// Do we have an ID to hide and show?
			if( newId ){
				var newComment = content.find('[data-commentID="' + newId + '"]');
				newComment.hide();

				if( newComment.is(':last-child') ){
					this.scope.find('[data-role="recommendedComments"]').append( newComment );
				} else if( newComment.is(':first-child') ){
					this.scope.find('[data-role="recommendedComments"]').prepend( newComment );
				} else {
					var prev = newComment.prev('[data-commentID]');
					prev.after( newComment );
				}

				$( document ).trigger( 'contentChange', [ newComment ] );
				newComment.fadeIn().slideDown();
			} else {
				this.scope.html( content );
				$( document ).trigger( 'contentChange', [ this.scope ] );
			}			
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.reputation.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.reputation.js - Controller for reputation controls
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.reputation', {

		initialize: function () {
			this.on( 'click', '[data-action="giveReputation"]', this.giveReputation ); 
		},
		
		/**
		 * Event handler for the reputation buttons.
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		giveReputation: function (e) {
			e.preventDefault();
			
			var self = this;
			var url = $( e.currentTarget ).attr('href');
			var thisParent = this.scope.parent();

			this.scope.css({ opacity: "0.5" });
			
			ips.getAjax()( url )
				.done( function (response) {
					var newHTML = $('<div>' + response + '</div>').find('[data-controller="core.front.core.reputation"]').html();
					self.scope
						.html( newHTML )
						.css({
							opacity: "1"
						});
				})
				.fail( function ( jqXHR, textStatus, errorThrown ) {
					if ( jqXHR.responseJSON['error'] ) {
						ips.ui.alert.show( {
							type: 'alert',
							icon: 'warn',
							message: jqXHR.responseJSON['error'],
							callbacks: {}
						});
					} else {
						window.location = url;
					}
				});
		}

	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.reviewForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.reviewForm.js - Review form controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.reviewForm', {
		initialize: function () {
			this.on( 'click', '[data-action=&quot;writeReview&quot;]', this.toggleReview );
		},

		toggleReview: function (e) {
			this.scope.find('[data-role=&quot;reviewIntro&quot;]').attr('hidden', '');
			this.scope.find('[data-role=&quot;reviewForm&quot;]').removeAttr('hidden');
		}
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.sharelink.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.sharelink.js - Controller to launch link in small window
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.sharelink', {

		/**
		 * Initialize the events that this controller will respond to
		 *
		 * @returns 	{void}
		 */
		initialize: function () {
			this.on( 'click', '[data-role="shareLink"]', this.launchWindow );
		},
		
		/**
		 * Filter click
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		launchWindow: function(e) {
			e.preventDefault();
			var url = $( e.currentTarget ).attr('href');
			if ( !ips.utils.url.getParam( 'url', url ) )
			{
				url += "&url=" + encodeURIComponent( location.href );
			}
			if ( !ips.utils.url.getParam( 'title', url ) )
			{
				url += "&title=" + encodeURIComponent( document.title );
			}
			
			window.open( url, 'delicious','toolbar=no,width=550,height=550' );
		},
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.tagEditor.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.tagEditor.js - Quick tag editing
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.tagEditor', {

		_minTags: null,
		_maxTags: null,
		_count: 0,
		_tagEditID: '',

		initialize: function () {
			this.on( 'click', '[data-action="removeTag"]', this.removeTag );
			this.on( document, 'tagsUpdated', this.tagsUpdated );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._tagEditID = this.scope.attr('data-tagEditID');

			// How many tags do we have?
			this._minTags = this.scope.attr('data-minTags') || null;
			this._maxTags = this.scope.attr('data-maxTags') || null;
			this._setCount();
			this._checkMinMax();
		},

		/**
		 * If this instance is benig destroyed, see if we have already shown a menu for it, and if so remove it
		 * This is necessary in situtions where a tag editor might be shown more than once on the page, e.g. gallery lightbox
		 *
		 * @returns {void}
		 */
		_destroy: function () {
			if( $('#elTagEditor_' + this._tagEditID + '_menu').length ){
				$('#elTagEditor_' + this._tagEditID + '_menu').remove();
			}
		},

		/**
		 * Event handler for tagsUpdated method, triggered by the tagEditorForm controller inside the dropdown menu
		 * Lets us know that tags have changed so that we can update the UI
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		tagsUpdated: function (e, data) {
			if( data.tagEditID !== this._tagEditID ){
				return;
			}

			// Remove existing tags, and then reapply with new HTML
			this.scope.find('.ipsTags__item:not(.ipsTags__item--edit)').remove();
			this.scope.prepend( data.tags );

			// Is there an editable prefix?
			var editablePrefix = $('body').find('[data-editablePrefix]');

			if( editablePrefix.length ){
				if( data.prefix ){
					editablePrefix.html( data.prefix ).removeClass('ipsHide');
				} else {
					editablePrefix.html('').addClass('ipsHide');
				}
			} else if( data.prefix.length ){
				this.scope.prepend( data.prefix );
			}

			// Count tags
			this._setCount();
			this._checkMinMax();

			// Show flash message - only if nothing has changed
			if(data.tagsChanged == 1){
				ips.ui.flashMsg.show( ips.getString('tagsUpdated') );
			}
		},

		/**
		 * Event handler for clicking the 'x' on a tag to remove it
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		removeTag: function (e) {
			e.preventDefault();

			var self = this;
			var remove = $( e.currentTarget );
			var url = remove.attr('href');
			var tagContainer = remove.closest('.ipsTags__item');
			var tag = tagContainer.find('.ipsTags__tag');

			// Fade it out since we'll assume we can remove it
			tagContainer.fadeOut('fast');

			// Adjust count
			this._count--;
			this._checkMinMax();

			ips.getAjax()( url, {
				bypassRedirect: true
			})
				.done( function () {
					ips.ui.flashMsg.show( ips.getString('tagRemoved') );

					// Add a small timeout on actually removing it from the dom to allow animation to finish
					setTimeout( function () {
						tagContainer.remove();
					}, 200 );
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					tagContainer
						.stop()
						.show()
						.css({
							opacity: "1"
						});

					self._count++;

					// Error will indicate what happened, e.g. minimum number of tags required
					if( jqXHR.responseJSON ){
						ips.ui.alert.show( {
							type: 'alert',
							icon: 'warn',
							message: jqXHR.responseJSON,
							callbacks: {}
						});
					}
				});
		},

		/**
		 * Hides the 'x' or add tag button appropriately depending on the current status of tags
		 *
		 * @returns {void}
		 */
		_checkMinMax: function () {
			var allowRemove = !( this._minTags && this._count <= this._minTags );

			// Hide the remove links if needed			
			this.scope
				.find('[data-action="removeTag"]')
					.toggle( allowRemove )
				.end()
				.find('.ipsTags__item--deletable')
					.toggleClass( 'ipsTags__item--deletable', allowRemove );

			// Hide the add link if needed
			this.scope.find('.ipsTags__item--edit').toggle( !( this._maxTags && this._count >= this._maxTags ) );
		},

		_setCount: function () {
			var prefix = this._getPrefix();
			var count = this.scope.find('.ipsTags__item').length;

			if( prefix.length && prefix.is(':visible') ){
				count++;
			}

			this._count = count;
		},

		_getPrefix: function () {
			return $('body').find('[data-editablePrefix]');
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.tagEditorForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.tagEditorForm.js - Controller for the tag editing form within a content item
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.core.tagEditorForm', {
		_placeholder: null,
		_menuID: '',
		_tagEditID: '',

		initialize: function () {
			this.on( document, 'menuOpened', this.menuOpened );
			this.on( document, 'menuClosed', this.menuClosed );
			this.on( 'submit', 'form', this.submitForm );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._menuID = this.scope.closest('i-dropdown').attr('id').replace('_menu', '');
			this._tagEditID = this._menuID.replace('elTagEditor_', '');
		},

		/**
		 * Event handler for 'menuClosed' event. We'll check this is the menu we care about and 
		 * then clear the tag edit HTML
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		menuClosed: function (e, data = e.detail) {
			if( data.elemID !== this._menuID ){
				return;
			}

			// Destroy the widgets and controllers inside the form, cheifly the autocomplete widget
			ips.cleanContentsOf(this.elem);

			// Wipe out the HTML
			this.scope.html( ips.templates.render('core.edittags.default') );
			this._buildPlaceholder();
		},

		/**
		 * Event handler for 'menuOpened' event. We'll check this is the menu we care about and 
		 * then load the tag editor form if so.
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object
		 * @returns {void}
		 */
		menuOpened: function (e, data = e.detail) {
			if( data.elemID != this._menuID ){
				return;
			}

			var self = this;
			var url = $( e.target ).attr('data-href');

			ips.getAjax()( url )
				.done( function (response) {
					self._setLoading( false );
					self.scope.html( response );
					$( document ).trigger('contentChange', [ self.scope ] );
				})
				.fail( function () {
					window.location = url;
				});
		},

		/**
		 * Event handler for submitting the tag edit form.
		 * On success trigger an event to which the tagEditor controller will respond
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		submitForm: function (e) {
			e.preventDefault();

			// Submit the form
			var self = this;
			var form = $( e.currentTarget );
			var autoComplete = this.scope.find('[data-ipsAutocomplete]');

			// Trigger blur on the autocomplete box
			autoComplete.trigger('blur');

			// This isn't ideal, but to prevent a race condition with the autocomplete where
			// it doesn't tokenify a typed tag in time before this form submits, we need to add
			// a delay.
			setTimeout( function () {
				if( ips.ui.autocomplete.getObj( autoComplete ).hasErrors() ){
					e.preventDefault();
					return;
				}

				self._setLoading( true );

				ips.getAjax()( form.attr('action'), {
					type: 'post',
					data: form.serialize(),
					dataType: 'json'
				})
					.done( function (response) {
						self.scope.trigger('tagsUpdated', {
							tagEditID: self._tagEditID,
							tags: response.tags,
							prefix: response.prefix,
							tagsChanged: response.tagsChanged
						});
						self.scope[0].closest("[popover]")?.hidePopover();
					})
					.fail( function (jqXHR, textStatus, errorThrown) {
						// Error will indicate what happened, e.g. minimum number of tags required
						if( jqXHR.responseJSON ){
							ips.ui.alert.show( {
								type: 'alert',
								icon: 'warn',
								message: jqXHR.responseJSON,
								callbacks: {}
							});
						}
					});
				}, 500);			
		},

		/**
		 * Set the menu into loading state (i.e. show a spinner)
		 *
		 * @param	{boolean} 	loading 		Are we loading?
		 * @returns {void}
		 */
		_setLoading: function (loading) {
			if( loading ){
				if( !this._placeholder ){
					this._buildPlaceholder();
				}	

				// Measure size of form
				var width = this.scope.outerWidth();
				var height = this.scope.outerHeight();

				this.scope.hide();

				this._placeholder
					.show()
					.css({
						width: width + 'px',
						height: height + 'px'
					});
			} else {
				if( this._placeholder ){
					this._placeholder.hide();
					this.scope.show();	
				}				
			}
		},

		/**
		 * Builds an element that will cover the menu contents to show the loading state
		 *
		 * @returns {void}
		 */
		_buildPlaceholder: function () {
			this._placeholder?.remove?.();
			this._placeholder = $('<div/>').addClass('ipsLoading').hide();
			this.scope.after( this._placeholder );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.userbar.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.userbar.js - Controller for userbar (inbox, notifications, etc.)
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.core.userbar', {

		loaded: {
			inbox: false,
			notify: false,
			reports: false
		},

		/**
		 * Initialize controller events
		 * Sets up the events from the view that this controller will handle
		 *
		 * @returns 	{void}
		 */
		initialize() {
			// Events initiated here
			this.on( document, 'menuOpened', (...args) => this.menuOpened(...args) );
			this.on( document, 'clearUserbarCache', (...args) => this.clearUserbarCache(...args) );
		},

		/**
		 * Event handler for menus being opened. Pass off to the correct method to handle
		 *
		 * @param 		{event} 	e 		Event
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		menuOpened (e, data = e.detail) {
			if (data.elemID === 'elFullInbox' || data.elemID === 'ipsOffCanvas--messenger') {
				this._loadMenu('inbox', ips.getSetting('baseURL') + 'index.php?app=core&module=messaging&controller=messenger&overview=1&_fromMenu=1');
			} else if (data.elemID === 'elFullNotifications' || data.elemID === 'ipsOffCanvas--notifications') {
				this._loadMenu('notify', ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=notifications');
			} else if (data.elemID === 'elFullReports' || data.elemID === 'elMobReports') {
				this._loadMenu('reports', ips.getSetting('baseURL') + 'index.php?app=core&module=modcp&controller=modcp&tab=reports&overview=1');
			}
		},
		
		/**
		 * Event handler to clear the cache of loaded windows
		 *
		 * @param 		{event} 	e 		Event
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		clearUserbarCache(e, data) {
			this.loaded[data.type] = false;
		},

		/**
		 * Loads one of the nav bar menus
		 *
		 * @param 		{string} 	type		Type of content being loaded
		 * @param 		{string} 	url 		URL to fetch the content
		 *
		 * @returns 	{void}
		 */
		async _loadMenu(type, url) {
			if (!this.loaded[type]) {
				const list = $(`[data-role="${type}List"]`);
				list
					.html('')
					.css( { height: '100px' } )
					.addClass('ipsLoading');

				try {
					const returnedData = await ips.fetch(url, {dataType: 'json'});

					// Add this content to the menu
					list
						.css({height: 'auto'})
						.removeClass('ipsLoading')
						.html(returnedData.data);

					// Remember we've loaded it
					this.loaded[type] = true;

					// Remove the notification count
					if (type !== 'reports') {
						const thisBubble = $(`[data-notificationtype="${type}"]`);
						const thisTotal = Math.max(0, parseInt(thisBubble.html())) || 0;

						const globalBubble = $(`[data-notificationtype="total"]`);
						const globalCount = Math.max(0, parseInt(globalBubble.html())) || 0;

						ips.utils.anim.go('fadeOut', thisBubble);
						if (globalCount - thisTotal <= 0) {
							ips.utils.anim.go('fadeOut', globalBubble);
						} else {
							globalBubble.html(globalCount - thisTotal)
						}
					}

					if ( type === 'notify' ) {
						/* Clear out any PWA badges now the menu has been opened */
						ips.utils.notification.clearBadgeCount();
					}

					$(document).trigger('contentChange', [list]);
				} catch (e) {
					Debug.log("Failed to load a userbar menu")
				}
			}
		}
	});

}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="controllers/core" javascript_name="ips.core.webshare.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.webshare.js - Controller for WebShare API
 *
 * Author: Ryan Ashbrook
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.core.webshare', {
		/**
		 * Initialize controller events
		 * Sets up the events from the view that this controller will handle
		 *
		 * @returns 	{void}
		 */
		initialize: function () {
			if ( navigator.share ){
				this._render();
				this.on( 'click', this.initShare );
			}
		},
		
		/**
		 * Render share API
		 *
		 * @returns	{void}
		 */
		_render: function() {
			$('[data-role=&quot;webShare&quot;]').removeClass( 'ipsHide' );
		},
		
		/**
		 * Event handler for WebShare
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		initShare: function (e) {
			try {
				//var data = $.parseJSON( this.scope.attr( 'data-webShareData' ) );
				navigator.share( {
					title: this.scope.attr( 'data-webShareTitle' ),
					text: this.scope.attr( 'data-webShareText' ),
					url: this.scope.attr( 'data-webShareUrl' )
				} );
			} catch (err) {
				Debug.log(&quot;Failed to use web share API: &quot;, err);
			}
		}

	});

}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.2fa.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.2fa.js - Two-factor authentication controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.2fa', {

		initialize: function () {
			this.on( 'tabShown', this.tabShown );
			this.on( 'tabChanged', this.tabChanged );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			// Give ourselves an appropriate z-index
			this.scope.css({
				zIndex: ips.ui.zIndex()
			});

			// Move this element to the end of the page
			//$('body').append(this.scope);

			// Focus into the first visible text box
			this.scope.find('input[type=&quot;text&quot;]:visible').first().focus();
		},

		/**
		 * Event handler for tab being toggled. Used to focus first text field in the current tab.
		 *
		 * @returns {void}
		 */
		tabShown: function (e, data) {
			this.scope.find('input[type=&quot;text&quot;]:visible').first().focus();
		},

		/**
		 * Event handler for tab being changed.
		 * Allows us to check the correct radio button for the method
		 *
		 * @returns {void}
		 */
		tabChanged: function (e, data) {
			if( data.tab ){
				data.tab.find('input[name=&quot;mfa_method&quot;]').prop('checked', true);
			}
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.authyOneTouch.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.authyOneTouch.js - Authy OneTouch controller
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.authyOneTouch', {
		initialize: function () {
			var scope = $(this.scope);
			setInterval( function(){
				ips.getAjax()( scope.closest('form').attr('action'), { data: { 'onetouchCheck': scope.find('[data-role=&quot;onetouchCode&quot;]').val() } } )
					.done(function( response ) {
						if ( response.status == 1 ) {
							scope.closest('form').submit();
						}
					});
			}, 3000 );
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.coverPhoto.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.coverPhoto.js - Controller for cover photos
 *
 * Author: Rikki Tissier and Ehren Harber
 */
;( function($, undefined){
	"use strict";

	ips.controller.register('core.global.core.coverPhoto', {

		_image: null,
		_existingPosition: 0,
		_tooltip: null,
		_expandedCover: false,
		_newPosition: 0,
		_container: null,
		_editingPosScroll: 0,
		_editingPosMouse: 0,

		initialize: function () {
			var self = this;
			this.on( 'menuItemSelected', function(e){
				var button = $( e.detail.originalEvent.target ).closest( '[data-action]' );
				switch( $( button ).attr( 'data-action' ) ){
					case 'removeCoverPhoto':
						self.removePhoto(e.detail);
						break;
					case 'positionCoverPhoto':
						self.positionPhoto(e.detail.originalEvent);
						break;
				}
			});
			
			this.on( 'click', '[data-action="savePosition"]', this.savePosition );
			this.on( 'click', '[data-action="cancelPosition"]', this.cancelPosition );
			this.on( 'click', '[data-action="toggleCoverPhoto"]', this.toggleCoverPhoto );

			this.setup();
		},

		/**
		 * Setup method.
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			this._image = this.scope.find('.ipsCoverPhoto__image');

			// Get the URL bits and see if we're immediately going into position mode
			var doPosition = ips.utils.url.getParam('_position');

			if(doPosition != undefined) this.positionPhoto();

		},

		/**
		 * Removes the cover photo
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		removePhoto: function (data) {
			data.originalEvent.preventDefault();
			var self = this;
			var target = $( data.originalEvent.target ).closest( '[data-action="removeCoverPhoto"]' );

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'warn',
				message: ips.getString('confirmRemoveCover'),
				callbacks: {
					ok: function () {
						ips.getAjax()( $( target ).attr('href') + '&wasConfirmed=1' )
							.done( function () {

								ips.utils.anim.go( 'fadeOut', self._image )
									.done( function () {
										ips.ui.flashMsg.show( ips.getString('removeCoverDone') );
									});

								$(data.menuElem).find('[data-role="photoEditOption"]').prop('hidden', true);
								document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles: true}));
							})
							.fail( function (err) {
								window.location = $( target ).attr( 'href' );
							});
					}
				}
			});
		},

		/**
		 * Save a new position of the cover photo
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		savePosition: function (e) {
			e.preventDefault();

			let newPos = ((this._container.scrollTop / (this._container.scrollHeight - this._container.clientHeight)) * 100);

			newPos = newPos || 0;

			this._newPosition = newPos;

			this.scope.attr( 'data-coverOffset', this._newPosition );
			this.scope.css({
				'--offset': this._newPosition
			});
			
			ips.getAjax()( this.scope.attr('data-url') + '&do=coverPhotoPosition' + '&offset=' + this._newPosition )
				.done(() => {
					document.body.dispatchEvent(new CustomEvent('ipsDataLayerSync', {bubbles: true}));
				})
				.fail( function (err) {
					this.scope.attr('data-url') + '&do=coverPhotoPosition' + '&offset=' + this._newPosition;
				});
							
			this._resetImage();
		},

		/**
		 * Cancels changing the position of the image
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		cancelPosition: function (e) {
			e.preventDefault();

			this._resetImage();
		},

		/**
		 * Starts the 'editing' state of the cover photo
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		positionPhoto: function (e) {

			if(e != undefined) e.preventDefault();
			
			this.scope.addClass('ipsCoverPhoto--editing');

			this._existingPosition = parseInt( this.scope.attr('data-coveroffset') ) || 0;

			this._container = this.scope.find('.ipsCoverPhoto__container')[0];

			// Bind this to event listener function so it can be removed later with removeEventListener
			this._mouseDownHandler = this._mouseDownHandler.bind(this);
			this._container.addEventListener('mousedown', this._mouseDownHandler);
		    this._mouseUpHandler = this._mouseUpHandler.bind(this);
		    this._container.addEventListener('mouseup', this._mouseUpHandler);
		    this._mouseOutHandler = this._mouseOutHandler.bind(this);
		    this._container.addEventListener('mouseout', this._mouseOutHandler);

			this._container.scrollTop = (this._container.scrollHeight - this._container.clientHeight) * (this._existingPosition / 100);

			this.scope.find('.ipsCoverPhoto__container').after( ips.templates.render('core.coverPhoto.controls') );
			this._showTooltip();
		},

		_mouseDownHandler: function (e) {
			e.preventDefault();
			this._editingPosMouse = e.clientY;
			this._editingPosScroll = this._container.scrollTop;

		    this._mouseMoveHandler = this._mouseMoveHandler.bind(this);
		    this._container.addEventListener('mousemove', this._mouseMoveHandler);
		},

		_mouseMoveHandler: function(e){
			let dy = (e.clientY - this._editingPosMouse) * 2.3;
			this._container.scrollTop = this._editingPosScroll - dy;
		},

		_mouseUpHandler: function(e){
			this._container.removeEventListener('mousemove', this._mouseMoveHandler);
		},

		_mouseOutHandler: function(e){
			this._container.removeEventListener('mousemove', this._mouseMoveHandler);
		},

		/**
		 * Cancels the 'editing' state of the cover photo
		 *
		 * @returns 	{void}
		 */
		_resetImage: function () {

			this._container.removeEventListener('mousedown', this._mouseDownHandler);

			this.scope.removeClass('ipsCoverPhoto--editing');

			this.scope.find('[data-role="reposition"]').remove();
			this.scope.find('[data-role="coverPhotoControls"]').remove();

			this._hideTooltip();

			// Reset the URL so refreshing the page does not re-trigger repositioning
			ips.utils.history.pushState({}, 'core.global.core.coverPhoto', ips.utils.url.removeParam( 'csrfKey', this.scope.attr('data-url') ) );
		},

		/**
 		 * Shows a tooltip on the autocomplete with the provided message
		 *
		 * @param 	{string} 	msg 	Message to show
		 * @returns {void}
		 */
		_showTooltip: function (msg) {
			if( !this._tooltip ){
				this._buildTooltip();
			}

			this._tooltip[0].hidePopover();
			this._tooltip.text( ips.getString('dragCoverPhoto') );

			this._positionTooltip();
		},

		/**
 		 * Hides the tooltip
		 *
		 * @returns {void}
		 */
		_hideTooltip: function () {
			if( this._tooltip && this._tooltip.is(':visible') ){
				this._tooltip[0].hidePopover();
			}
		},

		/**
 		 * Positions the tooltip over the autocomplete
		 *
		 * @returns {void}
		 */
		_positionTooltip: function () {
			var positionInfo = {
				trigger: this.scope.find('.ipsCoverPhoto__container'),
				target: this._tooltip,
				center: true,
				above: true
			};

			var tooltipPosition = ips.utils.position.positionElem( positionInfo );

			this._tooltip.css({
				left: tooltipPosition.left + 'px',
				top: tooltipPosition.top + 'px'
			});

			if( tooltipPosition.location.vertical == 'top' ){
				this._tooltip.addClass('ipsTooltip_top');
			} else {
				this._tooltip.addClass('ipsTooltip_bottom');
			}

			this._tooltip[0].showPopover();
		},

		/**
 		 * Builds the tooltip element
		 *
		 * @param 	{string} 	msg 	Message to show
		 * @returns {void}
		 */
		_buildTooltip: function () {
			// Build it from a template
			var tooltipHTML = ips.templates.render( 'core.tooltip', {
				id: 'elCoverPhotoTooltip'
			});

			// Append to body
			ips.getContainer().append( tooltipHTML );

			this._tooltip = $('#elCoverPhotoTooltip');
		},

		/**
		 * Toggles cover photo to full height
		 *
		 * @returns 	{void}
		 */
		toggleCoverPhoto: function () {
			if( this._expandedCover == false ) {

				let naturalImage = this.scope.find('.ipsCoverPhoto__image')[0],
					// containerHeight = naturalImage.offsetWidth / naturalImage.naturalWidth * naturalImage.naturalHeight,
					ratio = naturalImage.naturalWidth / naturalImage.naturalHeight;

					this.scope.find('.ipsCoverPhoto__container').css(
						// 	"--coverPhoto--height", containerHeight + 'px'
						"--coverPhoto--ratio", ratio
					);

				this._expandedCover = true;
				this.scope.addClass('ipsCoverPhoto--expanded');
			} else {
				this._expandedCover = false;
				this.scope.removeClass('ipsCoverPhoto--expanded');
			}			
		},
	});
}(jQuery));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.cropper.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.cropper.js - Cropping controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.cropper', {

		_image: null,
		_coords: {},

		initialize: function () {
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			var self = this;

			this._image = this.scope.find('[data-role=&quot;profilePhoto&quot;]');
			this._coords = {
				topLeftX: this.scope.find('[data-role=&quot;topLeftX&quot;]'),
				topLeftY: this.scope.find('[data-role=&quot;topLeftY&quot;]'),
				bottomRightX: this.scope.find('[data-role=&quot;bottomRightX&quot;]'),
				bottomRightY: this.scope.find('[data-role=&quot;bottomRightY&quot;]'),
			};

			this._image.css({
				maxWidth: '100%'
			});

			ips.loader.getStatic( ['applications/core/interface/static/cropper/cropper.min.js'] ).then( function () {
				self._image.imagesLoaded( _.bind( self._startCropper, self ) );
 			});
		},

		/**
		 * Starts the cropping function, called after the image has loaded
		 *
		 * @returns {void}
		 */
		_startCropper: function () {
			var self = this;

			var width = this._image.width();
			var height = this._image.height();

			// Resize the wrapper
			this._image.closest('[data-role=&quot;cropper&quot;]').css({
				width: width + 'px',
				height: height + 'px'
			});

			// Initialize cropper
			var cropper = new Cropper( this._image.get(0), {
				aspectRatio: 1 / 1,
				autoCropArea: 0.9,
				responsive: true,
				zoomOnWheel: false,
				crop: function ( e ) {					
					self._coords.topLeftX.val( e.detail.x );
					self._coords.topLeftY.val( e.detail.y );
					self._coords.bottomRightX.val( e.detail.width + e.detail.x );
					self._coords.bottomRightY.val( e.detail.height + e.detail.y );
				}
			});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.datetime.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.datetime.js - Controller to update the contents of cached <time> tags with the appropriate timezone
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.datetime', {

		initialize: function () {
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			var formatObject = { format: $(this.scope).attr('data-format') };
			
			var localeTimeFormat = ips.utils.time.localeTimeFormat( $('html').attr('lang') );
			if ( localeTimeFormat.meridiem ) {
				formatObject.meridiem = localeTimeFormat.meridiem;
			}
			
			$(this.scope).text( ips.utils.time.formatTime( new Date( $(this.scope).attr('data-time') ), formatObject ) );
		}
		
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.embeddedvideo.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * IPS Social Suite 4
 * (c) 2018 Invision Power Services - http://www.invisionpower.com
 *
 * ips.core.embeddedVideo.js - Simple controller to swap an embedded video out for the link if the source is not supported
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.embeddedvideo', {
		
		initialize: function () {
			// Normally, videos will be lazy loaded automatically in content. However,
			// we need to retain this controller for legacy content, as well as saved
			// editor content which won't yet have the lazy load attributes applied.

			// The code here is slightly different, since we dealing directly with the src 
			// attribute here rather than our data-video-src lazyload attributes. Be sure
			// any future functionality changes are applied in both areas.
			var video = this.scope.get(0);
			var canPlay = false;
			
			this.scope.find('source').each( function () {
				if( video.canPlayType( $(this).attr('type') ) ){
					canPlay = true;
				}
			});	
			
			if( !canPlay ) {
				if( this.scope.find('embed').length ){
					this.scope.replaceWith( this.scope.find('embed') );
				} else {
					this.scope.replaceWith( $(this.scope).find('a') );
				}
			}
		}		
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.framebust.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * IPS Social Suite 4
 * (c) 2013 Invision Power Services - http://www.invisionpower.com
 *
 * ips.core.framebust.js - Frame Busting
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.framebust', {

		initialize: function () {
			if ( top != self ) {
				$(this.scope).html('');
			}
		}
		
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.genericTable.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.genericTable.js - Controller for ACP tables that can be filtered and live-searched
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.genericTable', {

		_curSearchValue: '',
		_urlParams: {},
		_baseURL: '',
		_searchField: null,
		_timer: null,
		_currentValue: '',

		initialize: function () {
			this.on( 'paginationClicked paginationJump', this.paginationClicked );
			this.on( 'click', '[data-action="tableFilter"]', this.changeFiltering );
			this.on( 'menuItemSelected', '[data-role="tableFilterMenu"]', this.changeFilteringFromMenu );
			this.on( 'focus', '[data-role="tableSearch"]', this.startLiveSearch );
			this.on( 'blur', '[data-role="tableSearch"]', this.endLiveSearch );
			this.on( 'click', '[data-action="tableSort"]', this.changeSorting );
			this.on( 'menuItemSelected', '#elSortMenu', this.sortByMenu );
			this.on( 'menuItemSelected', '#elOrderMenu', this.orderByMenu );
			this.on( 'refreshResults', this._getResults );
			this.on( 'buttonAction', this.buttonAction );

			this.on(window, 'historychange:genericTable', this.stateChange);

			this.setup();
		},

		/**
		 * Setup method
		 * Builds the initial page parameters, and replaces the current state with these initial
		 * values.
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._baseURL = this.scope.attr('data-baseurl');
			if ( this.scope.attr('data-baseurl').match(/\?/) ) {
				this._baseURL += '&';
			} else {
				this._baseURL += '?';
			}


			this._searchField = this.scope.find('[data-role="tableSearch"]');

			// Get the initial page parameters
			var sort = this._getSortValue();

			this._urlParams = {
				filter: this._getFilterValue() || '',
				sortby: sort.by || '',
				sortdirection: sort.order || '',
				quicksearch: this._getSearchValue() || '',
				page: ips.utils.url.getParam('page') || 1
			};

			// Replace the current state to store our params object
			ips.utils.history.replaceState({...this._urlParams, controller: this.controllerID}, 'genericTable', window.location.href);

			// Show the search box
			this.scope.find('[data-role="tableSearch"]').removeClass('ipsHide').show();
		},

		buttonAction: function (e, data) {
			this._getResults();
		},

		/**
		 * Handles events from the sort menu (shown only on mobile)
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		sortByMenu: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			this._updateSort( {
				by: data.selectedItemID
			});
		},

		/**
		 * Handles events from the order menu (shown only on mobile)
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		orderByMenu: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			this._updateSort( {
				order: data.selectedItemID
			});
		},

		/**
		 * Responds to historychange events
		 *
		 * @returns {void}
		 */
		stateChange: function () {
			const state = {
				data: ips.utils.history.getState('genericTable'),
				url: window.location.href
			};

			// Because tables can exist alongside other widgets that manage the URL, we use the controller property
			// of the state data to identify states set by this controller only.
			// If that property doesn't exist, or if it doesn't match us, just ignore it.
			if (state.data?.controller !== this.controllerID) {
				return;
			}

			// See what's changed so we can update the display
			if( !_.isUndefined( state.data.filter ) && state.data.filter !== this._urlParams.filter ){
				this._updateFilter( state.data.filter );
			}

			if( ( !_.isUndefined( state.data.sortby ) && !_.isUndefined( state.data.sortdirection ) ) &&
				( state.data.sortby !== this._urlParams.sortby || state.data.sortdirection !== this._urlParams.sortdirection ) ){
				this._updateSort( {
					by: state.data.sortby,
					order: state.data.sortdirection
				});
			}

			if( !_.isUndefined( state.data.quicksearch ) && state.data.quicksearch !== this._urlParams.quicksearch ){
				this._updateSearch( state.data.quicksearch );
			}

			if( !_.isUndefined( state.data.page ) && state.data.page !== this._urlParams.page ){
				this._updatePage( state.data.page );
			}

			// Update data
			this._urlParams = state.data;

			// Get le new results
			this._getResults();
		},

		/**
		 * Update the current URL
		 *
		 * @param	{object} 	newParams 		New values to use in the search
		 * @returns {void}
		 */
		updateURL: function (newParams) {
			_.extend( this._urlParams, newParams );

			const tmpStateData = {...this._urlParams, ...newParams, controller: this.controllerID};
			const newUrlParams = this._getURL();

			if ( newUrlParams.match( /page=\d/ ) ){
				this._baseURL = this._baseURL.replace( /page=\d+?(&|\s)/, '' );
			}

			let newUrl = this._baseURL + newUrlParams;

			if (newUrl.endsWith('?')) {
				newUrl = newUrl.substring( 0, newUrl.length - 1 );
			}

			ips.utils.history.pushState(tmpStateData, 'genericTable', newUrl);
		},

		/**
		 * Builds a param string from values in this._urlParams, excluding empty values
		 *
		 * @returns {string}	Param string
		 */
		_getURL: function () {
			var tmpUrlParams = {};

			for( var i in this._urlParams ){
				if( this._urlParams[ i ] != '' && i != 'controller' && ( i != 'page' || ( i == 'page' && this._urlParams[ i ] != 1 ) ) ){
					tmpUrlParams[ i ] = this._urlParams[ i ];
				}
			}

			return $.param( tmpUrlParams );
		},

		/**
		 * Event handler for pagination widget
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		paginationClicked: function (e, data) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			if( data.pageNo != this._urlParams.page ){
				this.updateURL( { page: data.pageNo } );
			}
		},

		/**
		 * Update classname on new active page. Pagination actually gets overwritten
		 * by the ajax response, but by updating the class here, it feels more immediate
		 * for the user.
		 *
		 * @param	{number} 	newPage 		New active page number
		 * @returns {void}
		 */
		_updatePage: function (newPage) {
			this.scope
				.find('[data-role="tablePagination"] [data-page]')
				.removeClass('ipsPagination_pageActive')
				.end()
				.find('[data-page="' + newPage + '"]')
				.addClass('ipsPagination_pageActive');
		},

		/**
		 * Event handler for choosing a new filter
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeFiltering: function (e) {
			e.preventDefault();
			var newFilter = $( e.currentTarget ).attr('data-filter');

			// Select the one that was clicked, unselect others
			this._updateFilter( newFilter );

			if( newFilter != this._urlParams.filter ){
				this.updateURL( {
					filter: newFilter,
					page: 1
				});
			}
		},

		/**
		 * Event handler for choosing a new filter from a dropdown menu
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeFilteringFromMenu: function (e,data = e.detail) {
			var newFilter = $( data.originalEvent.target ).closest('[data-filter]').attr('data-filter');

			// Select the one that was clicked, unselect others
			this._updateFilter( newFilter );

			if( newFilter != this._urlParams.filter ){
				this.updateURL( {
					filter: newFilter,
					page: 1
				});
			}
		},

		/**
		 * Updates element classnames for filtering
		 *
		 * @param	{string} 	newFilter 		Filter ID of new filter to select
		 * @returns {void}
		 */
		_updateFilter: function (newFilter) {
			this.scope
				.find('[data-role="tableSortBar"] [data-action="tableFilter"] a')
				.removeClass('ipsButtonRow_active')
				.end()
				.find('[data-action="tableFilter"][data-filter="' + newFilter + '"] a')
				.addClass('ipsButtonRow_active');
		},

		/**
		 * Focus event handler for live search box
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		startLiveSearch: function (e) {
			this._timer = setInterval( _.bind( this._checkSearchValue, this ), 500 );
		},

		/**
		 * Blur event handler for live search box
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		endLiveSearch: function (e) {
			clearInterval( this._timer );
		},

		/**
		 * Determines whether the search field value has changed from the last loop run,
		 * and updates the URL if it has
		 *
		 * @returns {void}
		 */
		_checkSearchValue: function () {
			var val = this._searchField.val();

			if( this._currentValue != val ){
				this.updateURL({
					quicksearch: val,
					page: 1
				});

				this._currentValue = val;
			}
		},

		/**
		 * Updates the search field with a provided value
		 *
		 * @param	{string} 	searchValue 		Value to update
		 * @returns {void}
		 */
		_updateSearch: function (searchValue) {
			this._searchField.val( searchValue );
		},

		/**
		 * Event handler for choosing new sort column/order
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeSorting: function (e) {
			e.preventDefault();
			var cell = $( e.currentTarget );
			var order = '';

			// Apply asc or desc classnames to the cell, depending on its current state
			if( cell.hasClass('ipsTable_sortableActive') ){
				order = ( cell.hasClass('ipsTable_sortableDesc') ) ? 'asc' : 'desc';
			} else {
				order = ( cell.hasClass('ipsTable_sortableDesc') ) ? 'desc' : 'asc';
			}

			this._updateSort( {
				by: cell.attr('data-key'),
				order: order
			});
		},

		/**
		 * Updates the sorting order classnames
		 *
		 * @param 	{string} 	by 			Key name of sort by value
		 * @param 	{string} 	direction	asc or desc order value
		 * @returns {void}
		 */
		_updateSort: function ( data ) {
			var directions = 'ipsTable_sortableAsc ipsTable_sortableDesc';
			var current = this._getSortValue();

			if( !data.by ){
				data.by = current.by;
			}

			if( !data.order ){
				data.order = current.order;
			}

			// Do the cell headers
			this.scope
				.find('[data-role="table"] [data-action="tableSort"]')
				.removeClass('ipsTable_sortableActive')
				.removeAttr('aria-sort')
				.end()
				.find('[data-action="tableSort"][data-key="' + data.by + '"]')
				.addClass('ipsTable_sortableActive')
				.removeClass( directions )
				.addClass( 'ipsTable_sortable' + data.order.charAt(0).toUpperCase() + data.order.slice(1) )
				.attr( 'aria-sort', ( data.order == 'asc' ) ? 'ascending' : 'descending' );

			// Do the menus
			$('#elSortMenu_menu, #elOrderMenu_menu')
				.find('[aria-selected="true"]')
				.removeAttr('aria-selected')
				.end()
				.find('[data-ipsMenuValue="' + data.by + '"], [data-ipsMenuValue="' + data.order + '"]')
				.attr('aria-selected', 'true');

			this.updateURL( {
				sortby: data.by,
				sortdirection: data.order,
				page: 1
			});
		},

		/**
		 * Fetches new results from the server, then calls this._updateTable to update the
		 * content and pagination. Simply redirects to URL on error.
		 *
		 * @returns {void}
		 */
		_getResults: function () {
			var self = this;

			ips.getAjax()( this._baseURL + this._getURL() + '&' + this.scope.attr('data-resort') + '=1', {
				dataType: 'json',
				showLoading: true
			})
				.done( function (response) {
					self._updateTable( response );
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					if( Debug.isEnabled() ){
						Debug.error( "Ajax request failed (" + status + "): " + errorThrown );
						Debug.error( jqXHR.responseText );
					} else {
						// rut-roh, we'll just do a manual redirect
						window.location = self._baseURL + self._getURL();
					}
				});
		},

		/**
		 * Update the content and pagination elements
		 *
		 * @param	{object} 	response 		JSON object containing new HTML pieces
		 * @returns {void}
		 */
		_updateTable: function (response) {
			// Table body
			this.scope.find('[data-role="tableRows"]').html( response.rows );
			// Pagination
			this.scope.find('[data-role="tablePagination"]')
				.toggle( ( response.pagination && response.pagination.trim() !== "" ) || !_.isUndefined( this.scope.find('[data-role="tablePagination"]').attr('data-showEmpty') ) )
				.html( response.pagination || "" );

			// New content loaded, so trigger contentChange event
			$( document ).trigger( 'contentChange', [ this.scope ] );
		},

		/**
		 * Returns the current filter value
		 *
		 * @returns {string}
		 */
		_getFilterValue: function () {
			var sortBar = this.scope.find('[data-role="tableSortBar"]');

			if( !sortBar.length ){
				return '';
			}

			return sortBar.find('.ipsButtonRow_active').closest('[data-filter]').attr('data-filter');
		},

		/**
		 * Returns the current sort by and sort order value
		 *
		 * @returns {object}	Object containing by and order keys
		 */
		_getSortValue: function () {
			var sortBy = this.scope.find('[data-role="table"] thead .ipsTable_sortable.ipsTable_sortableActive');
			var sortOrder = 'desc';

			if( sortBy.hasClass('ipsTable_sortableAsc') ){
				sortOrder = 'asc';
			}

			return { by: sortBy.attr('data-key'), order: sortOrder };
		},

		/**
		 * Gets the current search value, either from the URL or contents of the search box
		 *
		 * @returns {string}
		 */
		_getSearchValue: function () {
			if( ips.utils.url.getParam('quicksearch') ){
				return ips.utils.url.getParam('quicksearch');
			}

			return this.scope.find('[data-role="tableSearch"]').val();
		},

		/**
		 * Replaces a row in the table with the provided contents
		 *
		 * @param 	{element} 	target 		The element used as our reference inside the row we're replacing, or the row itself
		 * @param 	{string}	contents 	The HTML with which the row will be replaced
		 * @returns {void}
		 */
		_actionReplace: function (target, contents) {
			// Find the table row this applies to
			var tr = $( target ).closest( 'tr' );
			var prevElem = tr.prev();

			tr.replaceWith( contents );

			// Let document know. We can't use our tr variable here, because that references the old (removed) row.
			// So trigger it on prevElem.next() instead
			$( document ).trigger( 'contentChange', [ prevElem.next() ] );
		}
	});
}(jQuery, _));	]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.googleAuth.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.googleAuth.js - Google Authenticator controller
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.googleAuth', {
		initialize: function () {
			this.on( 'click', '[data-action="showManual"]', this.showManual );
			this.on( 'click', '[data-action="showBarcode"]', this.showBarcode );
			
			var waitUntil = $(this.scope).attr('data-waitUntil');
			if ( waitUntil > Math.floor( Date.now() / 1000 ) ) {
				this.showWait();
			}
		},

		/**
		 * Show the manual instructions for Google Auth
		 *
		 * @returns {void}
		 */
		showManual: function () {
			this.scope.find('[data-role="barcode"]').hide();
			this.scope.find('[data-role="manual"]').show();
		},
		
		/**
		 * Show the barcode for for Google Auth
		 *
		 * @returns {void}
		 */
		showBarcode: function () {
			this.scope.find('[data-role="barcode"]').show();
			this.scope.find('[data-role="manual"]').hide();
		},
		
		/**
		 * Show the waiting bar
		 *
		 * @returns {void}
		 */
		showWait: function () {
			this.scope.find('[data-role="codeWaiting"]').show();
			this.scope.find('[data-role="codeInput"]').hide();
			
			var waitUntil = $(this.scope).attr('data-waitUntil') * 1000;
			var start = Date.now();
			
			var progressBar = $(this.scope).find('[data-role="codeWaitingProgress"]');
			var interval = setInterval( function(){
				if ( Date.now() >= waitUntil ) {
					clearInterval(interval);
					this.showInput();
				}
				
				progressBar.css( 'width', ( ( 100 - ( 100 / ( waitUntil - start ) * ( waitUntil - Date.now() ) ) ) ) + '%' );
			}.bind(this), 100 );
		},
		
		/**
		 * Show the input box
		 *
		 * @returns {void}
		 */
		showInput: function () {
			this.scope.find('[data-role="codeWaiting"]').hide();
			this.scope.find('[data-role="codeInput"]').show();
			this.scope.find('input').focus();
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.googlemap.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.overview.nearMe.js - Controller for near me
 *
 * Author: Rikki Tissier
 */
;( function($, _) {
    "use strict";

    ips.controller.register('ips.core.map.googlemap', {
        initialize() {
            let mapData = this.scope.data().mapData;
            if (typeof mapData === 'string') {
                mapData = JSON.parse(mapData);
            }

            if ('key' in mapData) {
                this._mapData = mapData;
                ips.ui.map.afterGoogleMapsLoaded(() => this.setupGoogleMaps())
            }
        },

        setupGoogleMaps() {
            let position = { lat: this._mapData.lat, lng: this._mapData.long };
            let elem = this.scope.find('[data-role="mapContainer"]').get(0);
            let maptype = 'ROADMAP';
            if (this._mapData.maptype && window.google.maps.MapTypeId[this._mapData.maptype.toUpperCase()]) {
                maptype = this._mapData.maptype.toUpperCase();
            }

            let map = new window.google.maps.Map( elem, {
                center: position,
                zoom: this._mapData.zoom ? this._mapData.zoom * 8 : 15,
                scale: this._mapData.scale || undefined,
                mapTypeId: window.google.maps.MapTypeId[maptype.toUpperCase()]
            });

            let marker = new window.google.maps.Marker({
                position,
                map
            });
        }
    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.licenseRenewal.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.global.licenseRenewal.js - License Renewal message
 *
 * Author: Stuart Silvester
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.licenseRenewal', {
				
		initialize: function () {
			this.on( 'click', '[data-action=&quot;notNow&quot;]', this.renewalPrompt );
			this.on(document, 'click', '[data-action=&quot;closeLicenseRenewal&quot;]', this.close);
		},

		renewalPrompt: function(e) {
			e.preventDefault();
			
			this._modal = ips.ui.getModal();
			
			if ( !$('body').find('[data-role=&quot;licenseRenewal&quot;]').length ) {
				$('body').append( ips.templates.render('licenseRenewal.wrapper') );
			}
			this._container = $('body').find('[data-role=&quot;licenseRenewal&quot;]').css({ opacity: &quot;0.001&quot; });
			
			// Set the survey URL
			$('body').find( '[data-role=&quot;survey&quot;]').attr( 'href', $( this.scope ).attr( 'data-surveyUrl' ) );

			this._modal.css( { zIndex: ips.ui.zIndex() } );
			var self = this;

			// Animate the modal in
			self._container.css( { zIndex: ips.ui.zIndex() } );
			self._container.animate({
				opacity: &quot;1&quot;,
			}, 'fast');
			
			ips.utils.anim.go('fadeIn', this._modal);

		},

		/**
		 * Close the popup
		 *
		 * @returns {void}
		 */
		close: function (e) {
						
			if( $('body').find('[data-role=&quot;licenseRenewal&quot;]').find( 'input[type=checkbox][name=hideRenewalNotice]' ).is(':checked') )
			{
				var notification = $(this.scope).closest('.cNotification,.cAcpNotificationBanner');
				
				ips.getAjax()( $(this.scope).find('[data-action=&quot;notNow&quot;]').attr('href') ).done( function(response) {
					ips.utils.anim.go( 'fadeOut', notification );
					
					if ( !notification.closest('.cNotificationList').children().count ) {
						ips.utils.anim.go( 'fadeIn',  notification.closest('.cNotificationList').find('[data-role=&quot;empty&quot;]').removeClass('ipsHide') );
					}
					
					$('body').trigger('updateNotificationCount');
				});
			}

			$('body').find('[data-role=&quot;licenseRenewal&quot;]').animate({
				transform: &quot;scale(0.7)&quot;,
				opacity: &quot;0&quot;
			}, 'fast');

			ips.utils.anim.go('fadeOut', this._modal);
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.multipleRedirect.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.multipleRedirect.js - Facilitates multiple redirects
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.multipleRedirect', {
		_iterator: 0,
		
		initialize: function () {
			var self = this;
			this.setup();
		},

		setup: function () {
			this.scope.find('.ipsRedirect').removeClass('ipsHide');
			$('.ipsRedirect_manualButton').hide();
			this.step( this.scope.attr('data-url') + '&mr=0&_mrReset=1' );
		},
		
		step: function (url) {		
			this._iterator++;	
			var elem = this.scope;
			var self = this;
			ips.getAjax()( url )
				.done(function( response ) {
																									
					if( _.isObject( response ) && response.custom ){
						var originalContent = $( elem.html() ).removeClass('ipsHide');
						var newContent = elem.html(response.custom);
						newContent.find( '[data-action="redirectContinue"]' ).click(function(e){
							e.preventDefault();
							elem.html( originalContent );
							self.step( $(this).attr('href') );
						});
						$( document ).trigger( 'contentChange', [ elem ] );
						return;
					}

					// If a json object is returned with a redirect key, send the user there
					if( _.isObject( response ) && response.redirect ){
						window.location = response.redirect;
						return;
					}
					
					elem.find('[data-loading-text]').attr( 'data-loading-text', response[1] );

					/* The percent completion doesn't make logical sense if it exceeds 100% */
					if ( response[2] && response[2] < 100 ) {
						elem.find('[data-role="progressBarContainer"]').removeClass('ipsHide');
						elem.find('[data-role="loadingIcon"]').addClass('ipsHide');
						elem.find('[data-role="progressBar"]').css({ width: ( response[2] + '%' ) }).attr('data-progress', +( Math.round( response[2] + "e+2" )  + "e-2") + '%' );
					} else {
						elem.find('[data-role="progressBarContainer"]').addClass('ipsHide');
						elem.find('[data-role="loadingIcon"]').removeClass('ipsHide');
						elem.find('[data-role="progressBar"]').removeAttr('data-progress');
					}
										
					var newurl = elem.attr('data-url') + '&mr=' + self._iterator;

					if ( response.done && response.done == true ) {
						window.location = newurl;	
					} else if ( response.close && response.close == true ) {
						self.trigger( 'closeDialog' );
					} else {
						self.step( newurl );
					}
				})
				.fail(function(err){
					window.location = url;
				});
		}		
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.notificationList.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.notificationList.js - Controller for the notification list
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.notificationList', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;dismiss&quot;]', this.dismiss );
		},
		
		dismiss: function (e) {
			e.preventDefault();
			var notification = $(e.target).closest('[data-role=&quot;notificationBlock&quot;],.cAcpNotificationBanner, .ipsMessage--acp');
			ips.ui.alert.show({
				type: 'confirm',
				message: ips.getString('acp_notification_hide_confirm'),
				icon: 'question',
				callbacks: {
					ok: function(){
						ips.getAjax()( notification.find('[data-action=&quot;dismiss&quot;]').attr('href') ).done( function(response) {
							notification.hide();
							ips.utils.anim.go( 'fadeOut', notification ).done(function(){
								if ( !notification.closest('.cNotificationList').children('[data-role=&quot;notificationBlock&quot;]:not(.cNotification_hidden)').length ) {
									ips.utils.anim.go( 'fadeIn',  notification.closest('.cNotificationList').find('[data-role=&quot;empty&quot;]').removeClass('ipsHide') );
								}
							});
							$('body').trigger('updateNotificationCount');
						});
					}
				}
			});
		}
	});
}(jQuery, _));
</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.optionalAutocomplete.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.prefixedAutocomplete.js - Controller for prefix functionality
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.optionalAutocomplete', {

		_autoComplete: null,
		_closedTagging: false,

		initialize: function () {
			this.setup();
			this.on('click', '[data-action="showAutocomplete"]', this.showAutocomplete);
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			this._autoComplete = this.scope.find('[data-ipsAutocomplete]');

			if( !_.isUndefined( this._autoComplete.attr('data-ipsAutocomplete-minimized') ) ){
				return;
			}

			// Wrap the contents of the row so that we can hide it, and show on demand
			var div = $('<div data-role="autoCompleteWrapper" />').html( this.scope.contents() ).hide();
			this.scope.html( div );
			this.scope.append( ips.templates.render('core.autocomplete.optional', { langString: ips.getString( this._autoComplete.attr('data-ipsAutocomplete-lang') ) } ) );
			this.scope.closest('.ipsFieldRow').find('.ipsFieldRow__label').hide();

			// Get the options the autocomplete uses
			this._closedTagging = this._autoComplete.attr('data-ipsAutocomplete-freeChoice') === 'false';
		},

		/**
		 * Toggles showing the autocomplete field
		 *
		 * @returns 	{void}
		 */
		showAutocomplete: function (e) {
			if( e ){
				e.preventDefault();
				e.stopPropagation();
			}
			
			var self = this;
			var autoCompleteObj = ips.ui.autocomplete.getObj( this._autoComplete );

			this.scope.find('[data-action="showAutocomplete"]').hide();
			this.scope.find('[data-role="autoCompleteWrapper"]').show();
			this.scope.closest('.ipsFieldRow').find('.ipsFieldRow__label').show();

			setTimeout( function () {
				if( self._closedTagging ){
					self.scope.find('[data-action="addToken"]').click();
				} else {
					autoCompleteObj.focus();
				}
			}, 100);
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.prefixedAutocomplete.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.prefixedAutocomplete.js - Controller for prefix functionality
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.prefixedAutocomplete', {

		initialize: function () {
			this.setup();

			this.on( 'autoCompleteReady', this.autoCompleteReady );
			this.on( 'tokenAdded', this.tokensChanged );
			this.on( 'tokenDeleted', this.tokensChanged );
			this.on( 'menuItemSelected', '[data-role="prefixButton"]', this.prefixSelected );

			// In case the UI module already issued the ready command, reissue it
			this.scope.find('[data-ipsAutocomplete]').trigger('reissueReady');
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			this._prefixRow = this.scope.find('[data-role="prefixRow"]');
			this._prefixValue = this.scope.find('[data-role="prefixValue"]');
			this._prefixButton = this.scope.find('[data-role="prefixButton"]');
			this._prefixMenu = this.scope.find('[data-role="prefixMenu"]');
		},

		/**
		 * Event handler called when autocomplete is ready and has generated all existing tokens
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Data object from the autocomplete widget
		 * @returns 	{void}
		 */
		autoCompleteReady: function (e, data) {
			var tokens = data.currentValues;

			// Do we need to show the prefix menu immediately?
			if( this._prefixValue && tokens.length ){
				this._prefixMenu.html( this._buildTokenList( tokens, this._prefixValue.val() ) );
				this._prefixButton.find('span').html( this._getPrefixText( _.escape( this._prefixValue.val() ) ) );
				this._prefixRow.show();
			}
		},
		
		/**
		 * Event handler for the autocomplete adding/removing tokens. Updates the menu, and shows the row if needed
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Data object from the menu widget
		 * @returns 	{void}
		 */
		tokensChanged: function (e, data) {			
			if( data.totalTokens > 0 && !this._prefixRow.is(':visible') ){
				ips.utils.anim.go( 'fadeIn', this._prefixRow );
			} else if( data.totalTokens === 0 && this._prefixRow.is(':visible') ){
				ips.utils.anim.go( 'fadeOut', this._prefixRow );
				this._prefixRow.find('input[type="checkbox"]').prop( 'checked', false );
			}

			// Update button
			if( e && e.type == 'tokenDeleted' && data.token == this._prefixValue.val() ){
				this._prefixButton.find('span').html( ips.getString('selectPrefix') );
				this._prefixValue.val('');
			}

			// Get current value
			var value = this._prefixValue.val();
			var list = this._buildTokenList( data.tokenList, value );

			// Update list contents
			this._prefixMenu.html( list );
		},

		/**
		 * Event handler for when a prefix menu item is selected
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Data object from the menu widget
		 * @returns 	{void}
		 */
		prefixSelected: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			var itemValue = ( data.selectedItemID == '-' ) ? '' : data.selectedItemID;
			var selectedText = this._getPrefixText( data.selectedItemID );

			this._prefixButton.find('span').html( selectedText );
			this._prefixValue.val( itemValue );

			this._prefixRow.find('input[type="checkbox"]').prop( 'checked', true );
		},

		/**
		 * Loops through provided tokens, building menu items for each
		 *
		 * @param 		{array} 	tokens 		Tokens array from the autocomplete widget
		 * @param		{string}	value 		Currently-selected item
		 * @returns 	{string}	Menu HTML
		 */
		_buildTokenList: function (tokens, value) {
			var output = '';
			
			output += ips.templates.render('core.menus.menuItem', {
				value: '',
				title: ips.getString('selectedNone'),
				checked: ( value == '' )
			});

			output += ips.templates.render('core.menus.menuSep');

			$.each( tokens, function (i, item) {
				output += ips.templates.render('core.menus.menuItem', {
					value: item,
					title: _.unescape( item ),
					checked: ( item == value )
				});
			});
			
			// Debug.log( output );

			return output;
		},

		/**
		 * Gets the string for the prefix selector
		 *
		 * @param 		{string} 	prefix 		A selected prefix
		 * @returns 	{string}	
		 */
		_getPrefixText: function (prefix) {
			var selectedText = '';

			if( prefix && prefix != '-' ){
				selectedText = ips.getString( 'selectedPrefix', { tag: prefix } );
			} else {
				selectedText = ips.getString( 'selectedPrefix', { tag: ips.getString('selectedNone') } );
			}

			return selectedText;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.table.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.table.js - Basic table controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.table', {

		_urlParams: {},
		_baseURL: '',
		_otherParams: [],
		_pageParam: 'page',
		_updateURL: true,
		_currentPage: 1,
		_seoPagination: false,
		_initialURL: '',
		_ajax: null,

		initialize: function () {
			this.on( 'paginationClicked paginationJump', this.paginationClicked );
			this.on( 'refreshResults', this.refreshResults );
			this.on( 'buttonAction', this.buttonAction );
			this.on( 'click', '[data-action="tableFilter"]', this.changeFiltering );
			this.on( 'menuItemSelected', '[data-role="tableFilterMenu"]', this.changeFilteringFromMenu );
			this.on( 'click', 'tr[data-tableClickTarget]', this.rowClick );

			this.setup();
		},

		setup: function () {
			if( this.scope.attr('data-pageParam') && this.scope.attr('data-pageParam') != 'page' ){
				this._pageParam = this.scope.attr('data-pageParam');
			}

			this._otherParams.push( this._pageParam );
			this._baseURL = this.scope.attr('data-baseurl');
			const safeURL = [...(new TextEncoder()).encode(this.scope.attr('data-baseurl') ? ips.utils.url.pageParamToPath(this._cleanUpURL(this.scope.attr('data-baseurl')), this._pageParam, 1) : '')]
				.map(char => String.fromCodePoint(char))
				.join('');

			this._stateKey = `table${btoa(safeURL)}`;
			this._originalBaseURL = this._baseURL;
			this._currentPage = ips.utils.url.getPageNumber( this._pageParam, window.location.href );
			this._cleanUpBaseURL();

			if( this._baseURL.match(/\?/) ) {
				if( this._baseURL.slice(-1) != '?' ){
					this._baseURL += '&';
				}
			} else {
				this._baseURL += '?';
			}

			this._urlParams = this._getUrlParams();
			this._urlParams[ this._pageParam ] = parseInt(this._currentPage);
			this._initialURL = window.location.href;

			if( this.scope.closest('[data-disableTableUpdates]').length ){
				this._updateURL = false;
			}

			// Replace the current state to store our params object. Probably redundant at this point but may as well cover our bases
			if (!(this._stateKey in ips.utils.history.getState())) {
				ips.utils.history.replaceState({...this._urlParams, controller: this.controllerID}, this._stateKey, window.location.href);
			}

			this.on( window, `historychange:${this._stateKey}`, this.stateChange );

			/* Data Layer Stuff */
			try {
				if ( IpsDataLayerConfig && !window.IpsDataLayerConfig ) {
					/* Data Layer Page Number Property */
					this.scope.find( '[data-role="tablePagination"] [data-page]' ).click( function (e) {
						let target = e.currentTarget;
						if ( target.parentNode.classList.contains('ipsPagination_active') ) {
							return;
						}
						let page = Number( e.currentTarget.dataset['page'] );

						if ( isNaN(page) ) return;

						$('body').trigger('ipsDataLayerProperties', { _properties: {page_number: page} });
					});
				}
			} catch (e) {}
		},

		/**
		 * Responds to state changes triggered by user navigation OR by programmatically pushing a new state (URL changes without redirecting)
		 *
		 * @returns {void}
		 */
		stateChange(e) {
			if (e.detail?.type === 'replace') {
				return
			}

			const data = {
				...this._urlParams,
				...(ips.utils.history.getState(this._stateKey) || {})
			}

			// make sure there are actual changes
			if (!Object.keys(this._filterParamsForChanges(data)).length) {
				return;
			}

			e.stopImmediatePropagation?.()
			e.stopPropagation?.()

			// This must be called BEFORE the state changes are applied to the current url params
			this._handleStateChanges({data, url: window.location.href, title: document.title});

			// Update data
			this._urlParams = {...data}
			delete this._urlParams.bypassStateAdjustment

			// Gallery for instance stores a state change when closing the lightbox to adjust the URL, but this should not cause the table to reload
			if (data.bypassStateAdjustment) {
				return;
			}
			this._getResults();
		},

		/**
		 * Refresh table contents
		 *
		 * @returns {void}
		 */
		buttonAction: function () {
			this._getResults();
		},

		/**
		 * Refresh table contents
		 *
		 * @returns {void}
		 */
		refreshResults: function () {
			this._getResults();
		},

		_filterParamsForChanges(params) {
			const out = {};
			for (const k in params) {
				if (['controller'].includes(k)) {
					continue
				}

				if (!(params[k] || this._urlParams[k])) {
					continue;
				}

				if (k === this._pageParam && parseInt(params[k]) !== parseInt(this._urlParams[k])) {
					out[this._pageParam] = parseInt(params[k])
				} else if (params[k] != this._urlParams[k]) {
					out[k] = params[k]
				}
			}
			return out;
		},

		/**
		 * Update the current URL
		 *
		 * @param	{Object} 	newParams 		New values to use in the search
		 * @returns {void}
		 */
		updateURL(newParams) {
			// Only update if there are actual changes
			newParams = this._filterParamsForChanges(newParams)
			if (!Object.keys(newParams).length) {
				return;
			}

			const tmpStateData = {...this._urlParams, ...newParams, controller: this.controllerID};
			let newUrl			= (this._baseURL + this._getURL(tmpStateData)).replace(/^([^?]*)?$/, '$1').replace(/&$/, '');

			if (this._seoPagination) {
				newUrl = ips.utils.url.pageParamToPath( newUrl, this._pageParam, newParams[ this._pageParam ] );
			}
			ips.utils.history.pushState(tmpStateData, this._stateKey, newUrl);
		},

		/**
		 * Event handler for pagination widget
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		paginationClicked (e, data) {
			e.stopPropagation?.();
			e.stopImmediatePropagation?.();

			data.originalEvent?.preventDefault()

			this._seoPagination = data.seoPagination;
			this.updateURL({
				[this._pageParam]: parseInt(data.pageNo)
			});
		},

		/**
		 * Event handler for choosing a new filter
		 *
		 * @param	{Event} 	e 		Event object
		 * @returns {void}
		 */
		changeFiltering(e) {
			e.preventDefault();

			let newTableFilter = $(e.currentTarget).attr('data-filter');

			if(newTableFilter){
				this.updateURL( {
					filter: newTableFilter,
					[this._pageParam]: 1
				});
			}
		},


		/**
		 * Updates element classnames for filtering
		 *
		 * @param	{string} 	newFilter 		Filter ID of new filter to select
		 * @returns {void}
		 */
		_updateFilter(newFilter) {
			// This space left intentionally blank, is overridden by the admin mixin, data layer mixin, and possibly 3rd party mixins
		},

		/**
		 * Updates the sorting order classnames
		 *
		 * @param 	{Object}	data
		 * @param 	{string} 			data.by 			Key name of sort by value
		 * @param 	{'asc'|'desc'} 		data.direction		asc or desc order value
		 *
		 * @returns {void}
		 */
		_updateSort(data) {
			// left intentionally blank, used by mixins and 3rd party code to do things
		},

		/**
		 * Called after the page is updated
		 *
		 * @param	{number} 	newPage 		New active page number
		 * @returns {void}
		 */
		_updatePage(newPage) {
			if (newPage === this._currentPage) {
				return;
			}
			// scroll to the top of the box
			const boundingBox = this.scope.get(0).getBoundingClientRect();
			let padding = parseInt(ips.getSetting('tableScrollTopPadding'));
			if (!Number.isInteger(padding)) {
				padding = 30;
			}

			if (boundingBox.top < padding) {
				window.scrollBy({top: boundingBox.top - padding, behavior: 'smooth'});
			}

			this._currentPage = newPage;
		},

		/**
		 * Event handler for choosing a new filter from a dropdown menu
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		changeFilteringFromMenu(e,data = e.detail) {
			data.originalEvent?.preventDefault();
			if (!('selectedItemID' in data)) {
				return;
			}

			this.updateURL( {
				filter: data.selectedItemID,
				[this._pageParam]: 1
			});
		},

		/**
		 *
		 * @param url
		 * @return {string}
		 * @private
		 */
		_cleanUpURL(url) {
			const urlObj = ips.utils.url.getURIObject(url);
			const params = _.clone( urlObj.queryKey );

			url = urlObj.protocol + '://' + urlObj.host + ( urlObj.port ? ( ':' + urlObj.port ) : '' ) + urlObj.path + '?';

			// If we're using friendly URLs *without* rewriting, we need to
			if( urlObj.file === 'index.php' ){
				let hasFURL = false;
				for (const key of Object.keys(params)) {
					if (key.startsWith('/') ) {
						hasFURL = true;
						url += encodeURIComponent( key ).replace( /%2f/ig, '/' ); // We don't want '/' being encoded or it breaks URLs
						delete params[ key ];
					}
				}

				if (hasFURL) {
					url += '&';
				}
			}

			// Remove our default URL params
			for (const param of ['sortby', 'sortdirection', 'filter', ...this._otherParams]) {
				delete params[param]
			}

			// Decode params as $.param() will encode it again (double encode)
			_.each( params, function( v, k ){
				delete params[k];
				params[ decodeURIComponent( k ).replace( /\+/g, ' ') ] = v.replace(/\+/g, ' ');
			});

			// When using index.php? URLs, a param key is the path /forums/2-forum/ but as the value is empty, params.length returns false
			if( ! _.isEmpty( params ) ){
				url += decodeURIComponent( $.param( params ) );
			}

			// If the last character is & or ?, we can remove that because it'll be added back later
			url = url.replace(/[?&]$/, '')

			return url;
		},

		/**
		 * Cleans the base url of our default params
		 *
		 * @returns {void}
		 */
		_cleanUpBaseURL() {
			this._baseURL = this._cleanUpURL(this._baseURL);
		},

		/**
		 * Checks whether any values in the provided state are different and need updating; called by stateChange before the new state is applied
		 *
		 * @param 	{Object} 	state 	State from ips history
		 * @param 	{Object}	state.data	 	The state actually stored in the history object
		 * @param 	{string}	state.url		The URL of the table, in almost all cases, it should be the same as window.location.href
		 * @param 	{string}	state.title		The title of the document. Like the url, it is virtually always the same as window.location.href
		 * @returns {void}
		 */
		_handleStateChanges(state) {
			// See what's changed so we can update the display
			if ('filter' in state.data && state.data.filter != this._urlParams.filter) {
				this._updateFilter(state.data.filter);
			}

			for (const field of ['sortby', 'sortdirection']) {
				if (field in state.data && state.data[field] != this._urlParams[field]) {
					this._updateSort({
						by: state.data.sortby,
						order: state.data.sortdirection
					})
					break;
				}
			}

			if (this._pageParam in state.data && state.data[this._pageParam] != this._urlParams[this._pageParam]) {
				this._updatePage(parseInt(state.data[this._pageParam]))
			}
		},

		/**
		 * Fetches new results from the server, then calls this._updateTable to update the
		 * content and pagination. Simply redirects to URL on error.
		 *
		 * @param {string|undefined}		[forceURL]		Optional: A url to get the table contents from
		 *
		 * @returns {void}
		 */
		_getResults(forceURL) {
			const urlBits = this._getURL();
			let url = '';

			try {
				if( this._ajax && _.isFunction( this._ajax.abort ) ){
					this._ajax.abort();
					this._ajax = null;
				}
			} catch(err) {}

			// Figure out which URL we should be using
			if( forceURL ){
				url = forceURL;
			} else {
				if(urlBits) {
					url = this._baseURL + this._getURL() + '&';
				} else {
					url = this._baseURL;
				}

				// If SEO pagination is enabled, we need to include the page in the URL and then
				// append other URL bits.
				if ( this._seoPagination ) {
					url = ips.utils.url.pageParamToPath( url, this._pageParam, this._urlParams[ this._pageParam ] );
				}
			}

			if (this.scope.attr('data-resort') !== undefined) {
				url += `${url.includes('?') ? '&' : '?'}${this.scope.attr('data-resort')}=1`;
			}
			url = url.replaceAll( /\+/g, '%20');

			this._ajax = ips.getAjax()( url , {
				dataType: 'json',
				showLoading: this._showLoading()
			})
				.done(response => this._getResultsDone(response))
				.fail((jqXHR, textStatus, errorThrown) => this._getResultsFail(jqXHR, textStatus, errorThrown, url))
				.always((...args) => this._getResultsAlways(...args));
		},

		/**
		 * Should the default loading throbber be used?
		 *
		 * @returns {boolean}
		 */
		_showLoading() {
			return true;
		},

		/**
		 * Callback when the results ajax is successful
		 *
		 * This is intentionally just a wrapper, but it is overridden by third party code and other mixins
		 *
		 * @param	{Object} 	response 		JSON object containing new HTML pieces
		 * @returns {void}
		 */
		_getResultsDone(response) {
			this._updateTable( response );
		},

		/**
		 * Callback when the results ajax fails
		 *
		 * @param 	{object} 	jqXHR			jQuery XHR object
		 * @param	{string} 	textStatus		Error message
		 * @param 	{string}	errorThrown
		 * @returns {void}
		 */
		_getResultsFail: function (jqXHR, textStatus, errorThrown, url) {
			if( Debug.isEnabled() || textStatus == 'abort' ){
				Debug.error( `Ajax request to '${url}' failed (` + textStatus + "): " + errorThrown );
				Debug.error( jqXHR.responseText );
			} else {
				// rut-roh, we'll just do a manual redirect
				window.location = this._baseURL + this._getURL();
			}
		},

		/**
		 * Update the content and pagination elements
		 *
		 * @param	{object} 	response 		JSON object containing new HTML pieces
		 * @returns {void}
		 */
		_updateTable (response) {
			const rows = this.scope.find('[data-role="tableRows"]');
			const pagination = this.scope.find('[data-role="tablePagination"]');
			const extra = this.scope.find('[data-role="extraHtml"]');
			const autoCheck = this.scope.find('[data-ipsAutoCheck]');

			// Check the required elements are in the page
			if (!rows.length) {
				const url = this._baseURL + this._getURL();
				if (url === window.location.href) {
					window.location.reload();
				} else {
					window.location.href = url;
				}
				return;
			}

			// Table body
			ips.cleanContentsOf(rows)
			rows.html( response.rows ).trigger('tableRowsUpdated');

			// Pagination
			// If there's pagination content to show, make sure pagination container is shown
			pagination
				.toggle( ( response.pagination && response.pagination.trim() !== "" ) || !_.isUndefined( pagination.attr('data-showEmpty') ) )
				.html( response.pagination || "" )
				.trigger('tablePaginationUpdated');

			// Extra
			extra.html( response.extraHtml );
			// Autocheck
			autoCheck.trigger('refresh.autoCheck');

			// New content loaded, so trigger contentChange event
			this.scope.get(0)
				.querySelectorAll(':scope > *')
				.forEach(
					child => $(document).trigger('contentChange', [$(child)])
				)

			/* Data Layer page property */
			try {
				if ( IpsDataLayerConfig && !window.IpsDataLayerConfig ) {
					this.scope.find( '[data-role="tablePagination"] [data-page]' ).click( function (e) {
						let target = e.currentTarget;
						if ( target.parentNode.classList.contains('ipsPagination_active') ) {
							return;
						}
						let page = Number( e.currentTarget.dataset['page'] );

						if ( isNaN(page) ) return;

						$('body').trigger('ipsDataLayerProperties', { _properties: {page_number: page} });
					});
				}
			} catch (e) {}
		},

		/**
		 * Builds a param string from values in this._urlParams, excluding empty values
		 *
		 * @returns {object}	[params]	Param object
		 */
		_getURL(params) {

			params = params || this._urlParams

			const tmpUrlParams = {};

			for (const i in params) {
				if (['', 'controller', 'app', 'module', 'bypassState'].includes(i) || (i === this._pageParam && parseInt(params[i]) === 1) || !params[i]) {
					continue
				}
				tmpUrlParams[ i ] = params[i];
			}

			return $.param(tmpUrlParams);
		},

		/**
		 * Returns current parameters to be used in URLs
		 *
		 * @returns {object}
		 */
		_getUrlParams: function () {
			var sort = this._getSortValue();
			var obj = {
				filter: this._getFilterValue() || '',
				sortby: sort.by || '',
				sortdirection: sort.order || '',
			};

			obj[ this._pageParam ] = ips.utils.url.getParam( this._pageParam ) || 1

			return obj;
		},

		/**
		 * Event handler for clicking a clickable row
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		rowClick: function (e) {
			var target = $( e.target );

			// Ignore if we clicked something clickable (besides the row)
			if ( target.is('a') || target.is('button') || target.is('i') || target.is('input') || target.is('textarea') || target.is('code') || target.closest('a').length || target.closest('.ipsMenu').length ) {
				return;
			}

			// Ignore if we didn't use the left mouse button. 1 is left mouse button, 2 is middle
			// We allow 2 through here because we'll treat it differently shortly
			if( e.which !== 1 && e.which !== 2 ){
				return;
			}

			// Ignore if special keys are pressed
			if( e.altKey || e.shiftKey ){
				return;
			}

			// If we clicked into a cell with a checkbox, check that checkbox rather than redirect
			if ( target.is('td') ) {
				var checkbox = target.find('input[type="checkbox"]');
				if ( checkbox.length ) {
					checkbox.prop( 'checked', !checkbox.prop( 'checked' ) );
					return;
				}
			}

			var link = $( e.currentTarget )
				.find('[data-ipscontrolstrip]').parent()
				.find( '[data-controlStrip-action="' + $( e.currentTarget ).attr('data-tableClickTarget') + '"]' );

			// If we are using the meta key or middle mouse button, we're going to adjust the link
			// to include _blank, so that it opens in a new tab
			if( e.metaKey || e.ctrlKey || e.which == 2 ){
				link.attr('target', '_blank');
				link.get(0).click();
				link.attr('target', '');
			} else {
				// Okay, we can go...
				link.get(0).click();
			}
		},


		/**
		 * Abstract
		 */
		_getSortValue: $.noop,
		_getFilterValue: $.noop,
		_getResultsAlways: $.noop
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.core.updateBanner.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.license.js - License message
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.global.core.updateBanner', {
		initialize: function () {
			this.on( 'click', '[data-role=&quot;closeMessage&quot;]', this.hideMessage );
		},

		hideMessage: function () {
			var date = new Date();
			date.setTime( date.getTime() + ( 7 * 86400000 ) );
			ips.utils.cookie.set( 'updateBannerDismiss', true, date.toUTCString() );
			this.scope.slideUp();
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/core" javascript_name="ips.forms.ftp.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.forms.ftp.js
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.core.ftp', {
		
		/**
		 * Init
		 */
		initialize: function () {
			var scope = $(this.scope);
			scope.find('[data-role="portToggle"]').change(function(){
				scope.find('[data-role="portInput"]').val( $(this).attr('data-port') );
			});
			
			scope.find('[data-role="serverInput"]').keyup(function(){				
				var matches = $(this).val().match( /^((.+?):\/\/)?((.+?)(:(.+?)?)@)?(.+?\..+?)(:(\d+)?)?(\/.*)?$/ );
				if ( matches && ( matches[1] || matches[3] || matches[8] || matches[10] ) ) {
					if ( matches[2] ) {
						scope.find('[data-role="portToggle"][value="' + matches[2] + '"]').prop( 'checked', true );
					}
					if ( matches[3] ) {
						if ( matches[4] ) {
							scope.find('[data-role="usernameInput"]').val( matches[4] );
							scope.find('[data-role="usernameInput"]').focus();
						}
						if ( matches[6] ) {
							scope.find('[data-role="passwordInput"]').val( matches[6] );
							scope.find('[data-role="passwordInput"]').focus();
						}
					}
					if ( matches[8] ) {
						scope.find('[data-role="portInput"]').val( matches[9] );
						scope.find('[data-role="portInput"]').focus();
					}
					if ( matches[10] ) {
						scope.find('[data-role="pathInput"]').val( matches[10] );
						scope.find('[data-role="pathInput"]').focus();
					}
					$(this).val( matches[7] );
				}
				
			});
		},
				
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/customization" javascript_name="ips.customization.customTemplatesForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * There are a lot of toggles that the form toggles just can't manage.
 * app = value of the select[name=template_hookapp]
 * path = value of the select[name=template_path_{app}]
 * hookpoint = value of the select[name=template_hookpoint_{app}_{path}] (this is the name of the {template}.phtml )
 *
 * The select values must use _ as path separators and : as hookpoint separators (eg: forums_front_forums_table:row )
 * The PHP code will convert these to / and : respectively (eg: forums/front/forums/table:row )
 *
 * Author: Matt Mecham
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.customization.customTemplatesForm', {

		currentHookPoint: null,

		initialize: function () {
			this.on( 'change', 'input[name=template_type]', this.typeChanged );
			this.on( 'change', 'select[name=template_hookapp]', this.hookAppChanged );
			this.on( 'change', 'select[name^=template_path_]', this.hookPathChanged );
			this.on( 'change', 'select[name^=template_hookpoint_]', this.hookPointChanged );
			this.on( 'click', '[data-role=viewTemplate]', this.viewTemplate );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			// Hide all app paths
			$('li[id^=template_path_]').hide();

			// Hide all selectors
			$('#template_hookapp').hide();
			$('li[id^=template_hookpoint_]').hide();
			$('#template_hookpoint_type').hide();

			$('#template_key').hide();

			this.typeChanged();
		},

		/**
		 * View a template. As the title of the method suggests.
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		viewTemplate: function (e) {
			let currentApp = $('select[name=template_hookapp]').val();
			let currentPath = $('select[name=template_path_' + currentApp + ']').val();

			let dialogRef = ips.ui.dialog.create({
				title: ips.getString('custom_theme_template_title'),
				url: '?app=core&module=customization&controller=customtemplates&do=ajaxGetTemplate&hookpoint=' + currentApp + '/' + currentPath.replace( /_/g, '/',) + ':' + this.currentHookPoint,
				forceReload: true,
				remoteSubmit: true
			});

			dialogRef.show();
		},

		/**
		 * Event handler for when the template type has changed
		 * Fixes an issue with our toggles where a toggle of a toggle doesn't toggle
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		typeChanged: function (e, data) {
			if ( $('input[name="template_type"]:checked').val() === 'hook' ) {
				/* This is a hook type */
				$('#template_key').hide();
				$('#template_hookapp').show();
				this.hookAppChanged(e, data);
			} else {
				// Hide all hook fields
				$('#template_hookapp').hide();
				$('li[id^=template_path_]').hide();
				$('li[id^=template_hookpoint_]').hide();

				// Show custom template key
				$('#template_key').show();
			}
		},

		/**
		 * Event handler for when the hook app has changed
		 * Fixes an issue with our toggles where a toggle of a toggle doesn't toggle
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		hookAppChanged: function (e, data) {
			// We need all rows that are template_path_{template_hookapp} to show and others to be hidden
			$('li[id^=template_path_]').hide();
			$('li[id^=template_hookpoint_]').hide();

			$('#template_path_' + $('select[name=template_hookapp]').val() ).show();

			// Make sure the actions for the default item in the select that is now showing takes place
			this.hookPathChanged( e, data );
		},

		/**
		 * Event handler for when the hook path has changed
		 * Fixes an issue with our toggles where a toggle of a toggle doesn't toggle
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		hookPathChanged: function (e, data) {
			let currentApp = $('select[name=template_hookapp]').val();

			// Hide all open hookpoints
			$('li[id^=template_hookpoint_' + currentApp + '_]').hide();

			// Show the selected hookpoint
			$('#template_hookpoint_' + currentApp + '_' + $('select[name=template_path_' + currentApp + ']').val() ).show();

			// Make sure the actions for the default item in the select that is now showing takes place
			this.hookPointChanged( e, data );
		},

		/**
		 * Event handler for when the hook point is loaded
		 * Fixes an issue with our toggles where a toggle of a toggle doesn't toggle
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		hookPointChanged: function (e, data) {
			let currentApp = $('select[name=template_hookapp]').val();
			let currentPath = $('select[name=template_path_' + currentApp + ']').val();
			this.currentHookPoint = $('select[name=template_hookpoint_' + currentApp + '_' + currentPath + ']').val();

			$('#template_hookpoint_type').show();

			/* Now check the params */
			this.getTemplateParams( e, data );
		},

		/**
		 * Event handler for when the hook point is loaded
		 * Fixes an issue with our toggles where a toggle of a toggle doesn't toggle
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		*/
		getTemplateParams: function( e, data ) {
			let currentApp = $('select[name=template_hookapp]').val();
			let currentPath = $('select[name=template_path_' + currentApp + ']').val();

			ips.getAjax()( '?app=core&module=customization&controller=customtemplates&do=ajaxGetAvailableParams', {
				data: {
					hookpoint: currentApp + '/' + currentPath.replace( /_/g, '/',) + ':' + this.currentHookPoint,
					hookpoint_type: $('#template_hookpoint_type').val(),
				}
			} )
				.done( function (response) {
					$('span[data-template-params]').html( response );
				});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/customization" javascript_name="ips.customization.designerCore.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.customization.designerCore.js - Templates: controller for the simple editor
 *
 * Author: Matt "Oops I did it again" Mecham
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.customization.designerCore', {
		
		_cmInstances: {},
		isSaving: false,
		
		initialize: function () {
			this.on( 'click', 'button[type="submit"]', this.save );
			this.on( 'tabChanged', this.changedTab );
			const debounce = _.debounce( _.bind( this._recalculatePanelWrapper, this ), 100 );
			this.on( window, 'resize', debounce );

			const disableSubmit = () => {
				this.isSaving = true
			}
			const debouncedEnableSubmit = _.debounce(() => {
				this.isSaving = false
			}, 500)

			this.elem.addEventListener('ips:codebox#update', () => {
				disableSubmit();
				debouncedEnableSubmit();
			})
		},

		/**
		 * Tab widget has indicated that the user has changed tab
		 * If there's a file ID, trigger a new event with it, to enable the file listing to highlight it
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data 	Event data object
		 * @returns {void}
		 */
		changedTab: function (e, data) {
			this._recalculatePanelWrapper();
		},
		
		/**
		 * Saves the contents of the editor
		 *
		 * @param	{Event} 	e 		Event object
		 * @returns {Promise<void>}
		 */
		async save(e) {
			e.preventDefault();
			const form = this.scope.find('form[data-formid="form"]');

			if (this.isSaving) {
				await new Promise(resolve => setTimeout(resolve, 500));
			}

			const save = Object.fromEntries(new FormData(form.get(0)).entries());
			
			Debug.log( save );
			
			this.scope.find('button[type="submit"]').addClass('ipsButton_disabled').removeClass('ipsButton_primary');
			try {
				await ips.fetch( form.attr('action'), {
					dataType: 'json',
					data: save,
					type: 'post'
				});
				ips.ui.flashMsg.show(ips.getString('saved'));
			} catch (jqXHR) {
				let message = ips.getString('saveThemeError');
				try {
					message = JSON.parse( jqXHR.responseText );
				}
				catch (e) {}

				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message
				});
			}

			this.scope.find('button[type="submit"]').removeClass('ipsButton_disabled').addClass('ipsButton_primary');
		},
		
		/**
		 * Returns the current height of the tab panel wrapper
		 *
		 * @returns {number}
		 */
		_getContentHeight: function () {
			return $( window ).height() - this.scope.find('#tabs_form').offset().top - 250;
		},
		
		/**
		 * Calculates whether the tab bar has wrapped, and if so, resizes the panel wrapper and updates
		 * CodeMirror instances with the new height
		 *
		 * @returns {void}
		 */
		_recalculatePanelWrapper: function () {
			// Get the height of it
			var self = this;

			_.each( this._cmInstances, function(key, cm)
			{
				key.setSize( null, self._getContentHeight() );
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/customization" javascript_name="ips.customization.emoticons.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.customization.emoticons.js - Emoticons controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.customization.emoticons', {

		initialize: function () {
			this.on( 'blur', '[data-role="emoticonTyped"]', this.checkTypedValue );
			this.on( 'submit', this.submit );
			this.setup();
		},

		/**
		 * Setup method
		 * Makes the emoticon list sortable and sets an event handler for saving the order
		 *
		 * @returns {void}
		 */
		setup: function () {
			this.scope.find('[data-role="setList"]').sortable({
				update: _.bind( this._saveSetOrder, this )
			});
			this.scope.find('[data-role="emoticonsList"]').sortable({
				connectWith: this.scope.find('[data-role="emoticonsList"]'),
				handle: '[data-role="dragHandle"]',
				update: _.bind( this._saveOrder, this )
			});
		},

		/**
		 * Submit form handler; squash values into a single param
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		submit: function (e) {
			if( !window.JSON ){
				return;
			}

			var formElements = this.scope.find(':input:enabled:not([name="csrfKey"])');
			var output = ips.utils.form.serializeAsObject( formElements );
			var newInput = $('<input />').attr('type', 'hidden').attr('name', 'emoticons_squashed');

			// JSON encode the data
			Debug.log("Before encoding, emoticon data is:");
			Debug.log( output );
			output = JSON.stringify( output );

			this.scope.prepend( newInput.val( output ) );

			// Disable all of the elements we squashed so that they don't get sent
			formElements.prop('disabled', true);
		},
		
		/**
		 * Checks typed entry to ensure it is valid (no spaces)
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkTypedValue: function (e) {
			var elem = $( e.currentTarget );
			var val = elem.val();
			
			elem.val( val.replace( /\s/g, '' ) );
			
			if ( val.match( /\s/ ) ) {
				ips.ui.alert.show({
					type: 'alert',
					message: ips.getString('emoticon_no_spaces'),
					icon: 'warn'
				});
			}
		},
		
		/**
		 * Saves the new emoticon order
		 *
		 * @returns {void}
		 */
		_saveSetOrder: function () {
			var setOrder = [];

			this.scope.find('[data-emoticonSet]').each( function () {
				setOrder.push( $( this ).attr('data-emoticonSet') );
			});

			ips.getAjax()( this.scope.attr('action'), {
				type: 'post',
				data: { setOrder: setOrder }
			});
		},
		
		/**
		 * Saves the new emoticon order
		 *
		 * @returns {void}
		 */
		_saveOrder: function (e, ui) {
			var output = {};
			var item = ui.item;

			// Update the group key for this item after it has been moved
			var group = ui.item.closest('[data-emoticonSet]').attr('data-emoticonSet');
			ui.item.find('.cEmoticons_input > input[type="hidden"]').val( group );

			// Build the array of ordering
			this.scope.find('[data-emoticonGroup]').each( function () {
				var itemOrder = [];

				$( this ).find('[data-emoticonID]').each( function () {
					itemOrder.push( parseInt( $( this ).attr('data-emoticonID') ) );
				});

				output[ $( this ).attr('data-emoticonGroup') ] = itemOrder;
			});

			ips.getAjax()( this.scope.attr('action'), {
				type: 'post',
				data: output
			});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/customization" javascript_name="ips.customization.media.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * Author: Matt Mecham (Rikki Tissier)
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.customization.media', {

		_fileListing: null,
		_sidebar: null,
		_cachedFileInfo: {},
		_searchTimer: null,
		_uploadURL: '',

		initialize: function () {
			this.on( 'click', '[data-role="mediaItem"]', this.clickItem );
			this.on( 'click', '[data-action="deleteSelected"]', this.deleteSelected );
			this.on( 'keyup', '[data-role="mediaSearch"]', this.doSearch );
			this.on( 'submitDialog', '[data-role="uploadButton"]', this.dialogSubmitted );
			this.on( 'submitDialog', '[data-role="replaceFile"]', this.replaceDialogSubmitted );
			this.on( 'click', '[data-role="replaceFile"]', this.uploadNewFile );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			this._fileListing = this.scope.find('[data-role="fileListing"]');
			this._searchResults = this.scope.find('[data-role="searchResults"]');
			this._sidebar = this.scope.find('[data-role="mediaSidebar"]');
			this._uploadURL = this.scope.find('[data-role="uploadButton"]').attr('href');
			this._searchStyleTag = this.scope.find('[data-role="searchStyleTag"]');
			
			this.scope.find('[data-role="uploadButton"]').attr('href', this._uploadURL );

			this._unselectAll();
			this._updatePreview();
			this._checkDeleteButton();

		},

		/**
		 * Dialog submit handler from uploading process
		 * The dialog response will include an array of media items. We'll use
		 * this data to rebuild the file listing, thereby showing the new files immediately.
		 * 
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data 	Event data object
		 * @returns {void}
		 */
		dialogSubmitted: function (e, data) {
			var newHTML = [];

			_.each( data.response.rows, function (file, key) {
				newHTML.push( file );
			});

			this._buildFileListing( newHTML );

			ips.ui.flashMsg.show( ips.pluralize( ips.getString('mediaUploadedCount'), data.response.count ) );
		},

		/**
		 * Dialog submit handler from uploading process
		 * The dialog response will include an array of media items. We'll use
		 * this data to rebuild the file listing, thereby showing the new files immediately.
		 * 
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data 	Event data object
		 * @returns {void}
		 */
		replaceDialogSubmitted: function (e, data) {
			var newHTML = [];

			_.each( data.response.rows, function (file, key) {
				newHTML.push( file );
			});

			this._buildFileListing( newHTML );
			delete this._cachedFileInfo[ data.response.fileID ];

			ips.ui.flashMsg.show( ips.getString('mediaUploadedReplace') );

			this._fileListing.find('[data-fileid="' + data.response.fileID + '"]').click();
		},

		/**
		 * Prompts and deletes selected files
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		deleteSelected: function (e) {

			e.preventDefault();
			
			var self = this;
			var selected = this._getSelected().closest('[data-role="mediaItem"]');
			var selectedIDs = [];

			$.each( selected, function () {
				selectedIDs.push( $( this ).attr('data-fileid') );
			});

			// Confirm with user
			ips.ui.alert.show({
				type: 'confirm',
				message: ips.pluralize( ips.getString('mediaConfirmDelete'), selected.length ),
				icon: 'warn',
				callbacks: {
					ok: function () {
						selected.find('.cMedia_itemSelected').removeClass('cMedia_itemSelected')

						// Hide and remove them
						ips.utils.anim.go( 'fadeOutDown', selected )
							.done( function () {
								selected.remove();
								self._updatePreview();
								self._checkDeleteButton();
							});

						// Delete them on the server
						ips.getAjax()( '?app=core&module=customization&controller=media&do=deleteByFileIds&set_id=' + self.scope.attr('data-theme-id'), {
							data: {
								fileIds: selectedIDs
							}
						})
							.fail( function () {
								ips.ui.alert.show({
									type: 'alert',
									message: ips.pluralize( ips.getString('mediaErrorDeleting'), selected.length )
								});
							})
					}
				}
			});
		},

		/**
		 * Event handler for clicking a file in the file listing
		 * Modifier keys change how we handle the selection in order to mimic file managers
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		clickItem: function (e) {
			var item = $( e.currentTarget ).find('> .cMedia_item');
			var metaPressed = e.metaKey;

			if( !metaPressed  ){
				// If no special keys are pressed, unhighlight all and highlight this one
				this._unselectAll();
				item.addClass('cMedia_itemSelected');
			} else if( metaPressed ) {

				// If meta key is pressed, toggle the state of the clicked image
				item.toggleClass( 'cMedia_itemSelected', ( !item.hasClass('cMedia_itemSelected') ) );
			}

			this._updatePreview();
			this._checkDeleteButton();
		},

		/**
		 * Show the dialog to replace the current file we are viewing
		 *
		 * @returns {void}
		 */
		 uploadNewFile: function( e ) {
		 	if( e ){
		 		e.preventDefault();
		 	}
		 	
		 	var itemId = this._getSelected().closest('[data-role="mediaItem"]').attr('data-fileid');
		 	
			$( e.currentTarget ).ipsDialog( {
				remoteSubmit: true,
				forceReload: true,
				url: $( e.currentTarget ).attr('data-baseUrl') + itemId,
                destructOnClose : true,
				title: ips.getString('replaceMediaFile')
			});
		 },

		/**
		 * Checks whether any files are selected and displays the delete button if so
		 *
		 * @returns {void}
		 */
		_checkDeleteButton: function () {
			var selected = this._getSelected().closest('[data-role="mediaItem"]');

			if( selected.length == 0 ){
				this.scope.find('[data-action="deleteSelected"]').addClass('ipsHide');
			} else {
				this.scope.find('[data-action="deleteSelected"]').removeClass('ipsHide');
			}
		},

		/**
		 * Builds the file listing HTML from the given data
		 *
		 * @param	{array} 	data 		Array of file item HTML fragments
		 * @returns {void}
		 */
		_buildFileListing: function (data) {
			var output;

			if( !data.length ){
				output = ips.templates.render('templates.customizationMedia.noItems');
			} else {
				output = ips.templates.render( 'templates.customizationMedia.grid', {
					contents: data.join('')
				});
			}
			console.log( output );
			this._fileListing.html( output );
			$( document ).trigger( 'contentChange', [ this._fileListing ] );
		},

		/**
		 * Updates the preview panel in the sidebar by finding the selected item and extracting
		 * relevant information about it to display
		 *
		 * @returns {void}
		 */
		_updatePreview: function () {
			// How many selected?
			var self = this;
			var selected = this._getSelected().closest('[data-role="mediaItem"]');

			if( selected.length == 0 || selected.length > 1 ){
				// Build the string
				var language = ( selected.length == 0 ) ? ips.getString('mediaNoneSelected') : ips.pluralize( ips.getString('mediaMultipleSelected'), selected.length );
				// Insert it
				this._sidebar.find('[data-role="multipleItemsMessage"]').html( language );
				// Show the message box
				this._sidebar.find('[data-role="itemInformation"]').hide().end().find('[data-role="multipleItems"]').show();
				this._sidebar.find('[data-role="replaceFile"]').hide();
			} else {

				// Build the file info
				var info = {
					itemFilename: selected.attr('data-filename'),
					itemUploaded: selected.attr('data-uploaded'),
					itemTag: '{resource="' + selected.attr('data-path').replace(/^\/|\/$/g, '') + '/' + selected.attr('data-filename') + '" app="core" location="front"}',
					itemUrl: selected.attr('data-url'),
					itemID: selected.attr('data-fileid'),
					itemShowDimensions:  selected.is('[data-filename$=".jpg"], [data-filename$=".png"], [data-filename$=".gif"], [data-filename$=".webp"], [data-filename$=".jpeg"], [data-filename$=".tiff"], [data-filename$=".avif"]'),
					itemFilesize: null,
					itemDimensions: null
				};

				// Dimensions & filesize
				var cache = this._cachedFileInfo[ info.itemID ];

				if( !_.isUndefined( cache ) ){
					info.itemFilesize = cache['itemFilesize'];
					info.itemDimensions = cache['itemDimensions'];
				} else {
					// Do ajax
					this._infoAjax = ips.getAjax()( '?app=core&module=customization&controller=media&set_id=' + this.scope.attr('data-theme-id') + '&do=getFileInfo&id=' + info.itemID )
						.done( function (response) {
							self._cachedFileInfo[ info.itemID ] = {
								itemFilesize: response.fileSize,
								itemDimensions: response.dimensions
							};

							self._sidebar.find('[data-role="itemFilesize"]').text( response.fileSize );
							self._sidebar.find('[data-role="itemDimensions"]').text( response.dimensions );
						});
				}

				// Build thumbnail
				/* if( info.itemShowDimensions ){
					info.itemPreview = $('<img/>').attr( 'src', selected.attr('data-url') ).attr('data-ipsLightbox', true );
				} else {
					info.itemPreview = '';
				} */
				// Update the easy info
				_.each( info, function (value, key) {
					var elem = self._sidebar.find('[data-role="' + key + '"]');

					if( elem.is('input') ){
						elem.val( value );
					} else if( key == 'itemPreview' ) {
						elem.html( value );
					} else if ( key == 'itemUrl' ) {
						elem.html( $('<a/>').attr('href', value).text( value ).attr('target', '_blank') );
					}
					else if( value === null ){
						elem.html( $('<span/>').addClass('i-color_soft').text('Loading...') );
					} else {
						elem.text( value );
					}
				});

				// If this is an image, show the dimensions row
				this._sidebar.find('[data-role="itemDimensionsRow"]').toggle( info.itemShowDimensions );

				// Pre-select the tag box
				this._sidebar.find('[data-role="itemTag"]').get(0).select();

				// Hide the 'multiple items selected' div and show our info div
				this._sidebar.find('[data-role="itemInformation"]').show().end().find('[data-role="multipleItems"]').hide();
				this._sidebar.find('[data-role="replaceFile"]').show();

				$( document ).trigger( 'contentChange', [ this._sidebar ] );
			}
		},

		/**
		 * Hides all files which don't match the file name from the search input
		 *
		 * @returns {void}
		 */
		doSearch: function () {
			
			var value = this.scope.find('[data-role="mediaSearch"]').val();

			if( !_.isEmpty( value ) ){

				// Add value to CSS selector, stripping quotes
				this._searchStyleTag.html('[data-role="mediaItem"]:not([data-filename*="' + value.replace(/['"]+/g, '') + '" i]){ display: none; }');
				this._unselectAll();

			} else {

				this._searchStyleTag.html('');
			}

			this._updatePreview();
			this._checkDeleteButton();
		},

		/**
		 * Returns selected files, from the file listing or search results panels depending
		 * on which is active
		 *
		 * @returns {object}	jQuery collection of selected files
		 */
		_getSelected: function () {
			if( this._fileListing.is(':visible') ){
				return this._fileListing.find('.cMedia_itemSelected');
			} else {
				return this._searchResults.find('.cMedia_itemSelected');
			}
		},

		/**
		 * Resets the search box, hiding the results in the process
		 *
		 * @returns {void}
		 */
		_resetSearch: function () {
			this.scope.find('[data-role="mediaSearch"]').val('');
			this._searchResults.hide();
			this._fileListing.show();
			this._unselectAll();
			this._updatePreview();
			this._checkDeleteButton();
		},

		/**
		 * Unselects all files
		 *
		 * @returns {void}
		 */
		_unselectAll: function () {
			this._fileListing.find('.cMedia_item').removeClass('cMedia_itemSelected');	
			this._searchResults.find('.cMedia_item').removeClass('cMedia_itemSelected');	
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/customization" javascript_name="ips.customization.themeForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * Author: Matt Mecham
 */

;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.customization.themeForm', {

		initialize: function () {
			this.headerFooterCssFieldSetUp();
		},

		
		/**
		 * Tweaks the form
		 *
		 */
		headerFooterCssFieldSetUp: function () {
			$('#theme_header').addClass('ipsFieldRow--fullWidth');
			$('#theme_footer').addClass('ipsFieldRow--fullWidth');
			$('#theme_css').addClass('ipsFieldRow--fullWidth');
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="global" javascript_path="controllers/customization" javascript_name="ips.customization.visualLang.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.customization.visualLang.js - Visual language editor controller
 *
 * Author: Mark Wade & Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.customization.visualLang', {

		timeout: null,

		initialize: function () {
			this.on( document, 'mousedown', 'span[data-vle]', this.mouseDownLang );
			this.on( document, 'mouseup mouseleave', 'span[data-vle]', this.mouseUpLang );
			this.on( document, 'keypress', 'input[type="text"][data-role="vle"]', this.keyPressEditBox );
			this.on( document, 'blur', 'input[type="text"][data-role="vle"]', this.blurEditBox );
			this.on( document, 'contentChange', this.contentChange );
			this.setup();
		},

		/**
		 * Set up visual editor
		 * Prepares text nodes for editing, and removes any stragglers
		 *
		 * @returns {void}
		 */
		setup: function () {
			var self = this;

			this._boundHandler = _.bind( this._preventDefaultHandler, this );

			// Remove the VLE tag from the title
			this._removeLangTag('title');

			$( document ).ready( function () {
				self._setUpTextNodes('body');
				self._removeLangTag('body');
				self.scope.trigger('vleDone');
			});
		},

		/**
		 * Inits VLE on a changed dom element
		 *
		 * @returns {void}
		 */
		contentChange: function (e, data) {
			this._setUpTextNodes( data );
			this._removeLangTag( data );
		},

		/**
		 * Event handler for mousedown on document
		 * Sets a timeout so that editing only happens after 1 second
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		mouseDownLang: function (e) {
			this.timeout = setTimeout( _.partial( this._enableLangEditing, e), 1000 );
		},

		/**
		 * Event handler for mouseup on document
		 * Clears timeout
		 *
		 * @returns {void}
		 */
		mouseUpLang: function () {
			clearTimeout( this.timeout );
		},

		/**
		 * Event handler for keypress in an editing input box
		 * Blurs input if enter is pressed
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		keyPressEditBox: function (e) {
			if( e.keyCode == ips.ui.key.ENTER ){
				e.stopPropagation();
				$( e.currentTarget ).blur();
				return false;
			}
		},

		/**
		 * Event handler for blur on editing input box
		 * Sends the new value via ajax, and removes the editing box
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		blurEditBox: function (e) {
			var inputNode = $( e.currentTarget );
			var value = inputNode.val();
			var safeValue = encodeURIComponent( value );
			var elem = inputNode.closest('[data-vle]');
			var url = '?app=core&module=system&controller=vle&do=set';

			if( value == elem.attr('data-original') || value == '' ){
				elem.html( elem.attr('data-original') );				
			} else {
				inputNode
					.val('')
					.addClass('ipsField_loading');
								
				ips.getAjax()( url + '&key=' + elem.attr('data-vle') + '&value=' + safeValue )
					.done( function (response) {
						// Update the original value
						ipsVle[ elem.attr('data-vle') ] = response;
						elem.attr('data-original', response);
						$(document).find('[data-vle="' + elem.attr('data-vle') + '"]').html( response );
					})
					.fail( function () {
						Debug.log( url + '&key=' + elem.attr('data-vle') + '&value=' + safeValue );
					 	
					 	elem.html( inputNode.attr('data-original') );

						ips.ui.alert.show( {
							type: 'alert',
							icon: 'warn',
							message: ips.getString('js_login_both'),
						});
					});
			}

			var parentLink = elem.closest('a');

			if( parentLink.length ){
				parentLink.off( 'click', this._boundHandler );

				if( parentLink.attr('data-vleHref') ){
					parentLink.attr('href', parentLink.attr('data-vleHref') ).removeAttr('data-vleHref');
				}
			}
		},

		/**
		 * Event handler we can assign to prevent links from navigating
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_preventDefaultHandler: function (e) {
			e.preventDefault();
		},

		/**
		 * Called when mouse has clicked on a string for 1 second
		 * Replaces the elem with a textbox containing the value to allow editing
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_enableLangEditing: function (e) {
			var elem = $( e.currentTarget );
			var parentLink = elem.closest('a');

			if( parentLink.length ){
				parentLink
					.on( 'click', this._boundHandler )
					.attr( 'data-vleHref', parentLink.attr('href') )
					.attr( 'href', '#' );
			}

			var inputNode = $('<input/>')
								.attr( { type: 'text' } )
								.addClass( 'ipsField_loading ipsField_vle' )
								.attr( 'data-role', 'vle' );

			elem.html('').append( inputNode );

			// Fire an ajax request to get the raw language string, then update the text box with the returned value
			ips.getAjax()( '?app=core&module=system&controller=vle&do=get&key=' + elem.attr('data-vle') )
				.done( function (response) {
					console.log( elem.attr('data-vle') );
					inputNode
						.val( response )
						.attr( { 'data-original': response } )
			 			.removeClass('ipsField_loading')
			 			.focus()
			 			.select()
				})
				.fail( function () {
					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warn',
						message: ips.getString('js_login_both'),
					});
				});

		},

		/**
		 * Removes stray language tags from the provided element
		 *
		 * @param 	{element} 	element 	Element from which to remove tags
		 * @returns {void}
		 */
		_removeLangTag: function (element) {
			// element may be undefined
			if( _.isUndefined( element ) )
			{
				return;
			}

			var elem = $( element );
			elem.contents().filter(function() { return this.nodeType === 3 || this.tagName === "LABEL" || this.tagName === "SPAN"; }).each(function(){
				$(this).replaceWith( $(this).text().replace( /#VLE#(.+?)#!#/gm, function(match, key) {
					return ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) ? ipsVle[key] : '';
				} ) );
			});
			elem.find('i[class]').each(function(){
				$(this).attr( 'class', $(this).attr('class').replace( /#VLE#(.+?)#!#/gm, function(match, key) {
					return ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) ? ipsVle[key] : '';
				} ) );
			});
			elem.find('[placeholder]').each(function(){
				$(this).attr( 'placeholder', $(this).attr('placeholder').replace( /#VLE#(.+?)#!#/gm, function(match, key) {
					return ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) ? ipsVle[key] : '';
				} ) );
			});
			elem.find('[title]').each(function(){
				$(this).attr( 'title', $(this).attr('title').replace( /#VLE#(.+?)#!#/gm, function(match, key) {
					return ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) ? ipsVle[key] : '';
				} ) );
			});
			elem.find('[aria-label]').each(function(){
				$(this).attr( 'aria-label', $(this).attr('aria-label').replace( /#VLE#(.+?)#!#/gm, function(match, key) {
					return ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) ? ipsVle[key] : '';
				} ) );
			});
		},

		/**
		 * Turns strings into editable spans in the provided element
		 *
		 * @param 	{element} 	element 	Element in which to replace language strings
		 * @returns {void}
		 */
		_setUpTextNodes: function ( element ) {
			// element may be undefined
			if( _.isUndefined( element ) )
			{
				return;
			}

			var regex = /#VLE#([0-9a-z_-]+?)#!#/igm;

			$( element )
				.find('*')
				.contents()
				.filter( function () {
					var elem = $( this );
					return !elem.is('iframe') && !elem.closest('[data-ipsEditor]').length && !elem.is('textarea') && ( elem.is('[value]') || this.nodeType == 3 );
				})
				.each( function (idx, elem) {
					var elem = $( elem );
					if( elem.get(0).nodeType === 3 ){
						// Text inputs
						elem.replaceWith( elem.text().replace( regex, function(match, key) {
							// Only replace if we know this key exists and isn't something made up
							if ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) {
								return '<span data-vle="' + key + '" data-original="' + ipsVle[key] + '">' + ipsVle[key] + '</span>';
							} else {
								return Debug.isEnabled() ? key : '';
							}
						} ) );
					} else if( elem.is('[value]') ){
						// Inputs
						if( elem.val() !== '' && elem.val().length){
							elem.attr( 'data-vle', elem.val().replace( regex, '$1' ) ).val( elem.val().replace( regex, function(match, key) {
								// Only replace if we know this key exists and isn't something made up
								if ( ipsVle.hasOwnProperty(key) && ipsVle[key] !== undefined ) {
									return ipsVle[key];
								} else {
									return Debug.isEnabled() ? key : '';
								}
							} ) );
						}
					}
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/dashboard" javascript_name="ips.dashboard.adminNotes.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.dashboard.adminNotes.js - Admin notes controller for the admin notes widget
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.dashboard.adminNotes', {

		initialize: function () {
			this.on( 'submit', 'form', this.saveNotes );
		},

		saveNotes: function (e) {
			e.preventDefault();

			var url = $( e.currentTarget ).attr('action');
			var self = this;

			// Show loading
			this.scope.find('[data-role=&quot;notesInfo&quot;]').hide();
			this.scope.find('[data-role=&quot;notesLoading&quot;]').removeClass('ipsHide');

			ips.getAjax()( url, { type: 'post', data: $('#admin_notes').serialize() } )
				.done( function (response) {
					self.scope.find('[data-role=&quot;notesInfo&quot;]').html( response );
				})
				.fail( function () {

				})
				.always( function () {
					self.scope.find('[data-role=&quot;notesInfo&quot;]').show();
					self.scope.find('[data-role=&quot;notesLoading&quot;]').addClass('ipsHide');
				});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/dashboard" javascript_name="ips.dashboard.main.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.dashboard.main.js - Admin dashboard controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.dashboard.main', {

		_managing: false,

		initialize: function () {
			this.on( 'click', '.acpWidget_close', this.closeWidget );
			this.on( 'click', '[data-widgetCollapse]', this.collapseWidget );
			this.on( document, 'menuItemSelected', '#elAddWidgets:not( .ipsButton--disabled )', this.addWidget );
			this.on( 'refreshWidget', '[data-widgetKey]', this.refreshWidget );
			this.setup();
		},

		/**
		 * Setup method
		 * Adds sortable functionality to our two columns
		 *
		 * @returns {void}
		 */
		setup: function () {
			this.mainColumn = this.scope.find('[data-role="mainColumn"]');
			this.sideColumn = this.scope.find('[data-role="sideColumn"]');

			// Set up our sortables
			this.scope.find('[data-role="sideColumn"]').sortable({
				handle: '.acpWidget_reorder',
				forcePlaceholderSize: true,
				placeholder: 'acpWidget_emptyHover',
				connectWith: '[data-role="mainColumn"]',
				tolerance: 'pointer',
				start: this.startDrag,
				stop: _.bind( this.stopDrag, this ),
				update: _.bind( this.update, this )
			});

			this.scope.find('[data-role="mainColumn"]').sortable({
				handle: '.acpWidget_reorder',
				forcePlaceholderSize: true,
				placeholder: 'acpWidget_emptyHover',
				connectWith: '[data-role="sideColumn"]',
				tolerance: 'pointer',
				start: this.startDrag,
				stop: _.bind( this.stopDrag, this ),
				update: _.bind( this.update, this )
			});

			// Go through collapsed/not collapsed
			this.scope.find('[data-widgetCollapsed="true"][data-widgetCollapse-content]').hide();
		},

		/**
		 * start method for jquery UI
		 * Stops the tooltip from showing while we drag
		 *
		 * @returns {void}
		 */
		startDrag: function (e, ui) {
			$('body')
				.attr('data-dragging', true)
				.css({
					overflow: 'scroll'
				});

			ui.item.css({
				zIndex: ips.ui.zIndex()
			});
		},

		/**
		 * stop method for jquery UI
		 * Lets the tooltip show agian
		 *
		 * @param 	{event} 	e 		Event object
		 * @param	{object} 	ui 		jQuery UI data object
		 * @returns {void}
		 */
		stopDrag: function (e, ui) {
			
			$('body')
				.removeAttr('data-dragging')
				.css({
					overflow: 'auto'
				});

			// Let the widget know it has been sorted
			$( ui.item ).trigger( 'sorted.dashboard', {
				ui: ui
			});
						
			this._loadWidget( $( ui.item ).attr('data-widgetkey') );

			$('#ipsTooltip')[0].hidePopover();
		},

		/**
		 * update method for jquery UI
		 *
		 * @returns {void}
		 */
		update: function () {
			this._savePositions();
		},

		/**
		 * Handler for the close widget button
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		closeWidget: function (e) {
			e.preventDefault();

			var self = this;
			var widget = $( e.currentTarget ).closest('[data-widgetKey]');

			// Get widget info
			var key = widget.attr('data-widgetKey');
			var name = widget.attr('data-widgetName');

			widget.animationComplete( function () {
				widget.remove();
				self.mainColumn.sortable('refresh');
				self.sideColumn.sortable('refresh');
				self._savePositions();
			});

			widget.animate({ height: "0" });
			ips.utils.anim.go( 'zoomOut fast', widget );

			$('#elAddWidgets_menu').find('[data-ipsMenuValue="' + key + '"]').removeClass('ipsHide');

			this.scope
				.find('#elAddWidgets_button')
					.removeClass('ipsButton--disabled')
					.removeAttr('data-disabled');
		},

		/**
		 * Handler for the collapse widget button
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		collapseWidget: function (e) {
			e.preventDefault();
			
			// If we clicked on one of the anchors, just return
			if( $( e.target ).is('.acpWidget_tools *') )
			{
				return;
			}

			var self = this;
			var widget = $( e.currentTarget ).closest('[data-widgetKey]');

			// Figure out if we are hidden or showing to start with
			var collapsed = widget.find('[data-role="widgetContent"]').attr('data-widgetCollapsed');

			// Toggle the data flag
			widget.find('[data-role="widgetContent"]').attr( 'data-widgetCollapsed', ( collapsed == 'true' ) ? 'false' : 'true' );

			// Toggle the divs
			widget.find('[data-widgetCollapse-content]').slideToggle();

			// Save position/collapse data
			this._savePositions();
		},

		/**
		 * Event handler for clicking an item in the 'add widget' menu
		 * Finds an available gap for the new widget, then inserts it into the page
		 *
		 * @param	{event} 	e 		Event object
		 * @param 	{object} 	data 	Event data object from the menu widget
		 * @returns {void}
		 */
		addWidget: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			// Find menu item
			var item = $(data.menuElem).find('[data-ipsMenuValue="' + data.selectedItemID + '"]');
			var key = item.attr('data-ipsMenuValue');
			var name = item.attr('data-widgetName');

			// Build widget template
			var newWidget = ips.templates.render('dashboard.widget', {
				key: key,
				name: name
			});

			// Insert it into the main column
			this.mainColumn.prepend( newWidget );
			var newWidgetElem = this.mainColumn.find( '#elWidget_' + key );
			ips.utils.anim.go( 'fadeIn', newWidgetElem );

			// Load it
			this._loadWidget( key );

			// Save it
			this._savePositions();

			// Hide it in the main menu
			setTimeout( function () {
				item.addClass('ipsHide');	
			}, 500);
			

			if( !$(data.menuElem).find('[data-ipsMenuValue]:not( .ipsHide ):not( [data-ipsMenuValue="' + data.selectedItemID + '"] )').length ){
				this.scope
					.find('#elAddWidgets_button')
						.addClass('ipsButton--disabled')
						.attr( 'data-disabled', true );
			}
		},

		/**
		 * Fetches the contents of a widget from the backend
		 *
		 * @param 	{string} 	key 		Key of widget to load
		 * @returns {void}
		 */
		_loadWidget: function (key) {			
			var widget = this.scope.find( '[data-widgetKey="' + key + '"]' );

			if( !widget.length ){
				return;
			}

			widget.find('[data-role="widgetContent"]')
				.css({
					height: widget.find('[data-role="widgetContent"]').outerHeight() + 'px',
				})
				.html('')
				.addClass('ipsLoading');

			// Start the request
			ips.getAjax()( '?app=core&module=overview&controller=dashboard&do=getBlock', {
				data: {
					appKey: key.substr( 0, key.indexOf( '_' ) ),
					blockKey: key
				}
			})
				.done( function (response) {
					widget.find('[data-role="widgetContent"]')
						.css({
							height: 'auto'
						})
						.html( response )
						.removeClass('ipsLoading');

					// Inform the document
					$( document ).trigger( 'contentChange', [ widget ] );
				});
		},

		/**
		 * Refreshes the contents of a widget
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		refreshWidget: function (e) {
			var key = $( e.currentTarget ).attr('data-widgetKey');
			this._loadWidget( key );
		},

		/**
		 * Saves the widget positions back to the backend
		 *
		 * @returns {void}
		 */
		_savePositions: function () {
			// Get the serialized positions for both columns
			var main = this.mainColumn.sortable( 'toArray', { attribute: 'data-widgetKey' } );
			var side = this.sideColumn.sortable( 'toArray', { attribute: 'data-widgetKey' } );

			// Get list of collapsed blocks
			var collapsed = _.map( this.scope.find('[data-widgetCollapsed="true"]'), function( elem ){
				return $(elem).closest('[data-widgetKey]').attr('data-widgetKey');
			});

			/*Debug.log("Current widget list:");
			Debug.log( main );
			Debug.log( side );*/

			ips.getAjax()( '?app=core&module=overview&controller=dashboard&do=update', {
				data: {
					blocks: { 'main': main, 'side': side, 'collapsed': collapsed }
				}
			})
				.done( function () {
					// No need to do anything
				})
				.fail( function () {
					ips.ui.alert.show( {
						type: 'alert',
						icon: 'warn',
						message: ips.getString('dashboard_cant_save'),
						callbacks: {}
					});
				});
		}

	});
}(jQuery, _));


]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/dashboard" javascript_name="ips.dashboard.onboard.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.dashboard.onboard.js - Onboarding setup controller
 *
 * Author: Brandon Farber
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.dashboard.onboard', {

		initialize: function () {
			this.on( 'click', '[data-role=&quot;sectionToggle&quot;]', this.toggleSection );
			this.on( 'click', '[data-action=&quot;nextStep&quot;]', this.nextStep );
			this.on( 'click', '[data-action=&quot;skipStep&quot;]', this.skipStep );

			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
		
		},

		/**
		 * Toggle a section open and closed
		 *
		 * @param	{event}		e	Event
		 * @returns	{void}
		 */
		toggleSection: function( e ) {
			e.preventDefault();

			this.scope.find('[data-role=&quot;sectionWrap&quot;]').addClass('cOnboard__section--closed');
			$( e.currentTarget ).closest('.cOnboard__section').toggleClass('cOnboard__section--closed');
			$(document).trigger( 'contentChange', [ $( e.currentTarget ).closest('.cOnboard__section') ] );
		},

		nextStep: function (e) {
			e.preventDefault();

			var wrap = $( e.currentTarget ).closest('.cOnboard__section');
			var nextWrap = wrap.next('.cOnboard__section');

			if( nextWrap.length ){
				$('html, body').animate({ scrollTop: String(wrap.position().top - 70) }, function () {
					setTimeout( function () {
						wrap.addClass('cOnboard__section--closed cOnboard__section--done');
						nextWrap.removeClass('cOnboard__section--closed');
						$(document).trigger( 'contentChange', [ nextWrap ] );
					}, 200);
				});
			} else {
				wrap.addClass('cOnboard__section--closed cOnboard__section--done');
			}
		}

	});
}(jQuery, _));


</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/dashboard" javascript_name="ips.dashboard.validation.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.dashboard.validation.js - AdminCP users awaiting validation widget
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.dashboard.validation', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;approve&quot;], [data-action=&quot;ban&quot;]', this.validateUser );
		},

		/**
		 * Event handler for the approve/ban buttons
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		validateUser: function (e) {
			e.preventDefault();
			var self = this;
			var button = $( e.currentTarget );
			var url = button.attr('href');
			var type = button.attr('data-action');
			var row = button.closest('[data-role=&quot;validatingRow&quot;]');
			var name = row.find('[data-role=&quot;userName&quot;]').text();
			var toggles = button.closest('[data-role=&quot;validateToggles&quot;]');
						
			ips.ui.alert.show({
				type: 'confirm',
				callbacks: {
					'ok': function() {
						toggles.find('a').addClass('ipsButton--disabled');
						
						ips.getAjax()( url )
							.done( function ( response ) {
								
								// Show flash msg
								ips.ui.flashMsg.show( ips.getString( type == 'approve' ? 'userApproved' : 'userBanned', {
									name: name
								}));
								
								// Update HTML
								if ( response ) {
									var newElement = $(response);
									$(self.scope).replaceWith( newElement );
									$( document ).trigger( 'contentChange', [ newElement ] );
								} else {
									ips.utils.anim.go( 'fadeOut', $(self.scope).closest('.cNotification') );
									$('body').trigger('updateNotificationCount');
								}
							});
					}
				}
			});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/developer" javascript_name="ips.developer.details.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000200"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.developer.details.js
 *
 * Author: Esther Eisner
 */
;(function ($, _, undefined) {

    "use strict";

    ips.controller.register('core.admin.developer.details',
        {
            initialize: function () {
                this.setup();
            },

            setup: function () {
                var self = this;
                _.each( $(this.scope).find('[data-role="devCenterIssues"]'), function( elem ) {
                    $(elem).find('[data-role="devCenterIssues_content"]').html('').addClass( 'ipsLoading' );
                    $(elem).find('[data-iconType]').hide();
                    $(elem).removeClass( 'elCritical' );
                    self.loadDevCenterIssues();
                });
            },

            loadDevCenterIssues: function(){
                var self = this;

                ips.getAjax()( '?app=core&module=developer&controller=details&appKey=' + ips.getSetting( 'devAppKey' ) + '&do=scan' )
                    .done( function( response ) {
                        self.scope.find('[data-role="devCenterIssues_content"]').html( response.html ).removeClass( 'ipsLoading' );

                        $( document ).trigger( 'contentChange', [ self.scope.find('[data-role="devCenterIssues"]') ] );

                        self.scope.find( '[data-role="devCenterIssues"] [data-iconType]' ).hide();

                        if( parseInt( response.criticalIssues ) )
                        {
                            ips.utils.anim.go( 'fadeIn slow', self.scope.find('[data-role="devCenterIssues"] [data-iconType="critical"]') );
                            self.scope.find('[data-role="devCenterIssues"]').addClass( 'elCritical' );
                        }
                        else if( parseInt( response.recommendedIssues ) )
                        {
                            ips.utils.anim.go( 'fadeIn slow', self.scope.find('[data-role="devCenterIssues"] [data-iconType="recommended"]') );
                        }
                    })
                    .fail( function(response)
                    {
                        self.scope.find('[data-role="devCenterIssues_content"]').removeClass( "ipsLoading" );
                        self.scope.find('[data-role="devCenterIssues"]').addClass( 'elCritical' );
                        $( document ).trigger( 'contentChange', [ self.scope.find('[data-role="devCenterIssues"]') ] );
                    });
            }
        });
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.censorBlock.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.censorBlock.js - Controller for the censor block feature
 *
 * Author: Matt Mecham, improved by Matt Finger
 */
;(function($, _){
	"use strict";

	ips.controller.register('core.global.editor.censorBlock', {

		initialize() {
			this._words = JSON.parse( this.scope.attr('data-censorblockwords') );
			this._editorId = $(this.scope).data('editorid');
			this.setup();
		},

		_editorId: null,
		_editor: null,
		
		/**
		 * Perform some set up after the editor has initialized
		 */
		setup() {
			Debug.log('setup the censorblock')
			this.scope.parent().find('[data-ipseditorv5]').on('editorWidgetInitialized', () => {
				this._editor = this.scope.parent().find('[data-ipseditorv5]').data('_editor').getInstance();
				this._form = this.scope.closest('form');

				/* Add submit listener */
				this.on($(this._form).get(0), 'submit', this.checkCensorBlock);
			})
		},
		
		/**
		 * On form submit, check the contents for any words we want to block
		 *
		 * @param {Event} e
		 *
		 * @return {boolean}
		 */
		checkCensorBlock(e) {
			let value = this._editor.getHTML();
			const tempElement = document.createElement('div');
			tempElement.innerHTML = value;
			const valueText = tempElement.innerText.toLowerCase();
			let found = false;

			let display = this.scope.find('[data-role="editorCensorBlockMessageInternal"]').get(0);
			display.innerHTML = value

			if ( this._words.length ) {
				/* Knock out quote/code blocks so we effectively ignore them then force into text to remove everything else */
				display.querySelectorAll('blockquote, pre').forEach(child => child.remove())
				let index = 0;
				const words = [];
				for (const {word, type} of this._words) {
					if (valueText.includes(word.toLowerCase())) {
						words.push(type==='exact' ? word : `[^\\b]*(?:${word})[^\\b]*`);
					}
				}

				const reggie = new RegExp(`(?:\\b|\\s|^)(?:${ words.join('|') })(?:\\b|\\s|$)`, 'ig')

				Debug.log(reggie);
				if (words.length && $(value).text().match(reggie)) {
					$(display).contents()
						.filter(function() {return this.nodeType === 3})
						.each(function(){
							const mark = '<mark class="ipsMatchWarning i-font-weight_bold i-font-size_2 ipsMatch${index}">'
							$(this).replaceWith(
								_.escape(
									$(this).text().replace(reggie, `${mark}$1</mark>`)
								)
									.replace(new RegExp(_.escape(mark), 'ig'), mark)
									.replace(/&lt;\/mark&gt;/ig, "</mark>")
									.trim()
							);
						});
					found = true;
				}
			}

			if (found) {
				e.preventDefault();
				e.stopPropagation();
				this._form.find('input[type="submit"],button[type="submit"]').prop( 'disabled', false );
				display.innerHTML = display.innerHTML.replace(/((\s+?)?(\r\n|\r|\n)(\s+?)?)+/g, '<br><br>')
				this.scope.show();
				this._editor?.commands?.focus();
			} else {
				this.scope.find('[data-role="editorCensorBlockMessage"]').html('<div data-role="editorCensorBlockMessageInternal"></div>');
				this.scope.hide();
			}

			return !found
		},
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.customtags.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.customtags.js - Controller for inserting custom tags into a text/editor element
 *
 * Author: Rikki Tissier & Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.editor.customtags', {

		editorWrap: null,
		editorSidebar: null,
		editorSidebarHeader: null,
		editorSidebarList: null,

		initialize: function () {
			this.on( 'click', '[data-tagKey]', this.insertTag );
			//this.on( 'click', '[data-action="tagsToggle"]', this.toggleSidebar );
			this.setup();
		},

		/**
		 * Setup method. Sets an interval that checks the height of the editor and sets the sidebar
		 * to the same height
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		setup: function () {
			this.editorWrap = this.scope.find('[data-role="editor"]');
			this.editorSidebar = this.scope.find('.ipsComposeArea_sidebar');
			this.editorSidebarList = this.editorSidebar.find('[data-role="tagsList"]');
			this.editorSidebarHeader = this.editorSidebar.find('[data-role="tagsHeader"]');
			
			this.reloadTags();

			// setInterval( function () {
			// 	var editorHeight = self.editorWrap.outerHeight();
			// 	var headerHeight = self.editorSidebarHeader.outerHeight();
			//
			// 	self.editorSidebarList.css({
			// 		height: ( editorHeight - headerHeight ) + 'px'
			// 	});
			// }, 300);
		},

		/**
		 * Event handler for toggling the sidebar on and off
		 * Also set a cookie so that the choice is remembered
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		/*
		toggleSidebar: function (e) {
			e.preventDefault();

			if( this.editorSidebar.hasClass('ipsComposeArea_sidebarOpen') ) {
				this.editorSidebar
					.removeClass('ipsComposeArea_sidebarOpen')
					.addClass('ipsComposeArea_sidebarClosed');

				ips.utils.cookie.unset('tagSidebar');
			} else {
				this.editorSidebar
					.removeClass('ipsComposeArea_sidebarClosed')
					.addClass('ipsComposeArea_sidebarOpen');

				ips.utils.cookie.set('tagSidebar', true, true);
			}
		},
		*/

		/**
		 * Event handler for inserting custom tags defined on the page
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		insertTag: function (e) {
			const content = $( e.currentTarget ).attr('data-tagKey');

			if (this.scope.attr('data-tagFieldType') === 'editor') {
				$('textarea[name="' + this.scope.attr('data-tagFieldID') + '"]')
					.closest('[data-ipsEditorv5]')
					.data('_editor')
					.insertHtml( content );

			} else if (this.scope.attr('data-tagFieldType') === 'codemirror') {
				this.scope.trigger('codeMirrorInsert', {
					elemID: $( e.currentTarget ).closest('[data-codemirrorid]').attr('data-codemirrorid'),
					tag: content
				});
			} else if (this.scope.attr('data-tagfieldtype') === 'codebox') {
				this.scope.find('[data-ipscodebox]').get(0).dispatchEvent(new CustomEvent('insertCode', {detail: {content}}))
			} else {
				/** @type {HTMLTextAreaElement} */
				const textField = $('#' + this.scope.attr('data-tagFieldID') ).get(0);
				const focused = document.activeElement === textField
				if (!focused) {
					textField.setSelectionRange(textField.value.length, textField.value.length)
				}
				textField.setRangeText(content)
				textField.focus()
			}
		},
		
		/**
		 * Reload tags list from source
		 *
		 * @return	{void}
		 */
		reloadTags: function() {
			if ( this.scope.attr('data-tagSource' ) )
			{
				ips.getAjax()( this.scope.attr('data-tagSource') )
					.done((response, status, jqXHR) => {
						this.scope.find('ul[data-role="tagsList"]').html( response )
						$(document).trigger('contentChange', [this.scope.find('ul[data-role="tagsList"]')])

						this.elem.querySelectorAll('[data-customtags-dialog]').forEach(el => {
							el.addEventListener('dialogSubmission', (e) => {
								this.reloadTags()
							})
						});
					});
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.icon.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * IPS Social Suite 5
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.icon.js - Controller for the icon picker form element
 *
 * @todo this should be moved to where the rest of the form input controllers are, rather than in the editor module.
 *
 * Author: Matt Finger
 */
;(function($,_) {
    "use strict";

    ips.controller.register('core.global.editor.icon', {
        /**
         * @type {Element}
         */
        elem: undefined,

        /**
         * @type {null|string[]}
         */
        _allowedTypes: null,

        /**
         * @type {null|Object[]}
         */
        _currentValue: undefined,

        /**
         * @type {null|Number}
         */
        _maxIcons: undefined,

        /**
         * Setup the element
         */
        initialize() {
            // This loads fontawesome when the page loads rather than when the button is clicked
            ips.utils.iconpicker.faIconsEnabled();

            this.elem.querySelector('button[data-role="launcher"]').onclick = async () => {
                this.setCurrentValue(await ips.utils.iconpicker.pick({defaultValue: this.getCurrentValue(), allowedTypes: this.getAllowedTypes(), maxIcons: this.getMaxIcons(), svgIcons: 'svgIcons' in this.elem.dataset}))
            }

            this.setCurrentValue(this.getCurrentValue())

            this.elem.querySelectorAll('[data-role="clear"]').forEach(element => {
                if (!(Array.isArray(this._currentValue) && this._currentValue.length)) {
                    element.ipsHide()
                }
                element.onclick = () => {
                    this.setCurrentValue(null)
                }
            });

            this.fillIcons();
        },

        /**
         * @return {HTMLInputElement}
         */
        getInputEl() {
            return this.elem.querySelector('input[data-ips-icon-picker-input]')
        },

        /**
         * Get the current value
         * @returns {null|Object[]}
         */
        getCurrentValue() {
            if (this._currentValue === undefined) {
                this._currentValue = JSON.parse(this.getInputEl().value);
            }

            return this._currentValue;
        },

        /**
         *
         * @return {string[]}
         */
        getAllowedTypes() {
            if (!Array.isArray(this._allowedTypes)) {
                this._allowedTypes = this.elem.dataset.allowedIconTypes?.split(",").map(i => i.trim().toLowerCase()) || [];
            }
            return this._allowedTypes
        },

        /**
         * Get the max icons allowed
         *
         * @return {Number|null}
         */
        getMaxIcons() {
            if (this._maxIcons === undefined) {
                this._maxIcons = parseInt(this.elem.dataset.maxIcons || '');
                if (!(Number.isInteger(this._maxIcons) && this._maxIcons > 0)) {
                    this._maxIcons = null;
                }
            }
            return this._maxIcons;
        },


        /**
         * Set the current value for the input (and this controller)
         *
         * @param {IconType[] | null}    value
         */
        setCurrentValue(value) {
            try {
                if (value === null || (Array.isArray(value) && !value.length)) {
                    this.elem.querySelectorAll('[data-role="clear"]').ipsHide()
                    this._currentValue = null;
                } else if (Array.isArray(value)) {
                    this.elem.querySelectorAll('[data-role="clear"]').ipsShow()
                    // we iterate to make sure the values are acceptable
                    for (const item of value) {
                        if (typeof item !== 'object') {
                            throw new Error();
                        }
                        if (!this.getAllowedTypes().includes(item.type)) {
                            throw new Error()
                        }

                        // some additional validation for fa icons
                        if (typeof item.raw !== 'string' || typeof item.title !== 'string') {
                            throw new Error()
                        }
                    }
                    this._currentValue = value;
                } else {
                    throw new Error();
                }
            } catch (e) {
                e.message += '\n\t(An error occurred while setting the input value.)'
                Debug.error(e);
                return;
            }

            this.getInputEl().setAttribute('value', JSON.stringify(value));
            this.fillIcons();
        },

        fillIcons() {
            const fillArea = this.elem.querySelector('[data-role="selectedicons"]');
            if (!(Array.isArray(this._currentValue) && this._currentValue.length)) {
                fillArea.ipsHide();
            } else {
                fillArea.innerHTML = "";
                fillArea.ipsShow();

                for (const iconData of this._currentValue) {
                    fillArea.innerHTML += ips.templates.render('core.iconpicker.selectedicon', iconData)
                }
            }
        }
    })

}(jQuery, _))]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.insertable.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.insertable.js - Allows items to be inserted into the editor
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	/**
	 * @closure
	 * @type {Object.<string, HTMLImageElement|false>}
	 */
	const IMAGE_CACHE = {};
	ips.controller.register('core.global.editor.insertable', {

		_editorID: '',
		_selectedItems: {},
		_tooltip: null,
		_tooltipTimer: null,

		initialize: function () {
			this.on( 'click', '[data-action="insertFile"]', this.insertFile );
			this.on( 'click', '[data-action="selectFile"]', this.selectFile );
			this.on( 'click', '[data-action="insertSelected"]', this.insertSelected );
			this.on( 'click', '[data-action="clearAll"]', this.clearSelection );
			this.on( 'fileInjected', this.fileInjected );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns	{void}
		 */
		setup: function () {
			this._editorID = this.scope.attr('data-editorID');
			this._selectedItems = {};
		},

		destruct: function () {
			Debug.log('destruct insertable');
		},

		/**
		 * Toggle a file selection
		 *
		 * @param	{Event}		e	Event Object
		 * @returns	{void}
		 */
		selectFile: function (e) {
			e.preventDefault();

			const thisAttach = $(e.currentTarget);
			const thisDataRow = thisAttach.closest('.ipsData__item');

			if (thisAttach.hasClass('ipsAttach_selectionOn')) {
				
				thisAttach.removeClass('ipsAttach_selectionOn');

				if (thisDataRow.length) {
					thisDataRow.removeClass('ipsData__item--selected');
				} else {
					thisAttach.removeClass('ipsAttach_selected');
				}

				this._removeSelectedItem( thisAttach );

			} else {
				thisAttach.addClass('ipsAttach_selectionOn');
				
				if (thisDataRow.length) {
					thisDataRow.addClass('ipsData__item--selected');
				} else {
					thisAttach.addClass('ipsAttach_selected');
				}

				this._addSelectedItem(thisAttach);
			}
		},
		
		/**
		 * Clears currently-selected items
		 *
		 * @param	{Event}		e	Event data
		 * @returns	{void}
		 */
		clearSelection (e) {
			e?.preventDefault?.();
			if (!Object.keys(this._selectedItems).length) {
				return;
			}

			// Empty object
			this._selectedItems = {};

			// Remove class from all elements in the dom
			this.scope
				.find('.ipsAttach_selectionOn')
					.removeClass('ipsAttach_selectionOn')
					.closest('.ipsAttach')
						.removeClass('ipsAttach_selected')
					.end()
					.closest('.ipsData__item')
						.removeClass('ipsData__item--selected');

			// Update buttons
			this._checkSelectedButton();
		},

		/**
		 * Inserts selected files into the editor
		 *
		 * @param	{Event}		e	Event data
		 *
		 * @returns	{void}
		 */
		insertSelected(e) {
			e.preventDefault();
			if (!Object.keys(this._selectedItems).length) {
				return;
			}
			
			if (!this.scope.get(0).closest('[data-role="attachmentArea"]')) {
				this.trigger('closeDialog');
			}

			const editor = $(document.querySelector(`textarea[name="${this._editorID}"]`).closest('[data-ipsEditorv5]')).data('_editor');
			for (const item of Object.values(this._selectedItems)) {
				editor.insertHtml( this._buildInsert( item ) );
			}

			this.clearSelection(e);
		},

		/**
		 * Allows attachments to be inserted into the editor individually
		 *
		 * @param	{Event}		[e]	Event Object
		 *
		 * @returns	{void}
		 */
		async insertFile(e) {
			e?.preventDefault?.();
			
			const editor = $( `textarea[name="${this._editorID}"]` ).closest('[data-ipsEditorV5]').data('_editor');
			const insertData = await this._buildInsertData( $( e.target ) );
			const insertHtml = this._buildInsert(insertData);

			editor.insertHtml( insertHtml );

			if( !this.scope.closest('[data-role="attachmentArea"]').length ){
				this.trigger('closeDialog');
			}
		},
				
		/**
		 * File injected, this fires an event which the uploader uses to actually insert a file if it was pasted in
		 *
		 * @param	{Event}		e		Event Object
		 * @param	{Object}	data	Event data object
		 *
		 * @returns	{void}
		 */
		async fileInjected(e, data) {
			const insertData = await this._buildInsertData(data.fileElem)
			const content = this._buildInsert(insertData)
			data.data?.ready?.(content, insertData)
			$(this.scope).get(0).dispatchEvent(
				new CustomEvent(
					'injectedFileReadyForInsert',
					{
						detail: {
							content,
							data: data.data
						}
					}
				)
			);
		},

		/**
		 * Adds an item to the selected items list
		 *
		 * @param	{jQuery|Element}	element		The file element to be added
		 *
		 * @returns	{void}
		 */
		_addSelectedItem: async function (element) {
			const fileID = $(element).attr('data-fileid');
			this._selectedItems[ fileID ] = await this._buildInsertData( element );
			this._checkSelectedButton();
		},

		/**
		 * Removes an item from the selected items list
		 *
		 * @param	{element}	element		The file element to be removed
		 * @returns	{void}
		 */
		_removeSelectedItem: function (element) {
			var fileID = element.attr('data-fileid');

			if( !_.isUndefined( this._selectedItems[ fileID ] ) ){
				delete this._selectedItems[ fileID ];
			}

			this._checkSelectedButton();
		},

		/**
		 * Enables the 'clear selection' and 'insert selected files' buttons if there's any selected items
		 *
		 * @returns	{void}
		 */
		_checkSelectedButton: function () {
			const button = this.scope.find('[data-action="insertSelected"]');

			this.scope.find('[data-action="clearAll"]').toggleClass('ipsButton--disabled', !( _.size( this._selectedItems ) > 0 ) );
			button.toggleClass('ipsButton--disabled', !( _.size( this._selectedItems ) > 0 ) );

			if( !_.size( this._selectedItems ) ){
				button.text( ips.getString('insertSelected') );
			} else {
				button.text( ips.pluralize( ips.getString('insertSelectedNum'), _.size( this._selectedItems ) ) );
			}
		},

		/**
		 * Builds insertable element data based on the provided attached file element
		 *
		 * @param	{jQuery|Element}	_element		The element on which the insert is based
		 * @returns	{Promise.<{
				fileID: string,
				fileKey: string,
				type: string,
				title: string,
				link: string,
				fullImage: string,
				extension: string,
				mimeType: string
			}>}
		 */
		async _buildInsertData (_element) {
			const element = $(_element).get(0).closest('.ipsAttach');
			if (!element) {
				return {
					fileID: '',
					fileKey: '',
					type: 'file',
					title: '',
					link: '',
					fullImage: '',
					extension: '',
					naturalWidth: null,
					naturalHeight: null,
				}
			}
			const fileID = element.getAttribute('data-fileid') || '';
			const fileKey = element.getAttribute('data-filekey') || '';
			const type = element.getAttribute('data-fileType') || 'file';
			let url = '',
				image = '',
				mimeType = '',
				naturalWidth = '',
				naturalHeight = '';

			switch (type) {
				case 'image':
					url = element.getAttribute('data-thumbnailurl') || element.getAttribute('data-fullsizeurl') || url;
					if (url !== element.getAttribute('data-fullsizeurl')) {
						image = element.getAttribute('data-fullsizeurl') || '';
					}
					break

				case 'video':
					image = element.getAttribute('data-fullsizeurl');
					mimeType = element.getAttribute('data-mimeType');
					break

				case 'audio':
					mimeType = element.getAttribute('data-mimeType');
					break;

				default:
					url = element.getAttribute('data-filelink') || '';
			}

			return {
				fileID: fileID,
				fileKey: fileKey,
				type: type,
				title: ( type !== 'image' ) ? element.querySelector('[data-role="title"]')?.innerHTML : '',
				link: url,
				fullImage: image,
				extension: element.closest('[data-extension]')?.getAttribute('data-extension') || '',
				mimeType: mimeType,
				naturalWidth,
				naturalHeight
			};
		},

		/**
		 * Builds an element that can be inserted into the editor
		 *
		 * @param	{Object}	item		Item data used to build element
		 *
		 * @returns	{string} The HTML to be inserted
		 */
		_buildInsert: function (item) {
			let element;

			switch (item.type) {
				case 'image':
					// Give the img a unique ID, otherwise removing image in editor when added more than once will only remove one

					element = $('<img/>')
						.attr({
							'data-fileid'	: item.fileID,
							'src'			: item.link,
							'data-unique'	: Math.random().toString(36).substr(2, 9),
						})
						.addClass('ipsImage ipsImage_thumbnailed');

					if (item.fullImage) {
						const link = $('<a>').attr('href', item.fullImage).addClass('ipsAttachLink ipsAttachLink_image');
						element.addClass('ipsImage_thumbnailed');
						link.append(element);
						element = link;
					}


					break;

				case 'video':
					element = $('<video controls>').attr({
						'class': 'ipsEmbeddedVideo',
						'data-controller': 'core.global.core.embeddedvideo',
						'data-fileid': item.fileID,
						'data-unique': Math.random().toString(36).substr(2, 9)
					});

					const sourceElement = $('<source>').attr({
						'src': item.fullImage,
						'type': item.mimeType
					});

					element.append(sourceElement);
					element.append(
						$('<a>')
							.addClass('ipsAttachLink')
							.attr('href', `${ips.getSetting('baseURL')}applications/core/interface/file/attachment.php?id=${item.fileID}${item.fileKey ? `&key=${item.fileKey}` : ''}`)
							.html(item.title)
					);
					break;

				case 'audio':
					element = $('<audio controls>').attr({
						'data-controller': 'core.global.core.embeddedaudio',
						'src': `${ips.getSetting('baseURL')}applications/core/interface/file/attachment.php?id=${item.fileID}${item.fileKey ? `&key=${item.fileKey}` : ''}`,
						'data-fileid': item.fileID,
						'data-unique': Math.random().toString(36).substring(2, 9),
						'type': item.mimeType
					});

					element.append(
						$('<a>')
							.addClass('ipsAttachLink')
							.attr('href', `${ips.getSetting('baseURL')}applications/core/interface/file/attachment.php?id=${item.fileID}${item.fileKey ? `&key=${item.fileKey}` : ''}`)
							.html(item.title)
					);
					break;

				default:
					element = $('<a>')
						.addClass('ipsAttachLink')
						.html(item.title)
						.attr({
							'data-fileid': item.fileID,
							'data-fileext': item.extension,
							'href': item.link ? item.link : `${ips.getSetting('baseURL')}applications/core/interface/file/attachment.php?id=${item.fileID}${item.fileKey ? `&key=${item.fileKey}` : ''}`
						});
			}
			
			if (item.extension) {
				element.attr('data-extension', item.extension);
			}

			return $('<div/>').append( element ).html();
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.mymediasection.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.mymediasection.js - My media section
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.editor.mymediasection', {

		_timer: null,
		_ajax: null,
		_value: '',

		initialize: function () {
			//this.on( 'input', '[data-role="myMediaSearch"]', this.myMediaSearch );
			this.on( 'focus', '[data-role="myMediaSearch"]', this.focusMediaSearch );
			this.on( 'blur', '[data-role="myMediaSearch"]', this.blurMediaSearch );
			this.on( 'paginationClicked paginationJump', this.paginationClicked );
		},

		paginationClicked: function (e, data) {
			var results = this.scope.find('[data-role="myMediaResults"]');

			data.originalEvent.preventDefault();

			const urlObj = new URL(data.paginationElem.find('[data-role="pageJump"]').attr('action') || "", location.href);
			urlObj.updateSearchParams({param: 'page', value: data.pageNo});
			const url = urlObj.toString();

			// Load another page
			this._ajax = ips.getAjax()( url, {
				showLoading: true,
				data: {
					search: this._value
				}
			} )
				.done( function (response) {
					results.html( response );
					$( document ).trigger( 'contentChange', [ results ] );
				});
		},

		/**
		 * Event handler for focusing the search box
		 *
		 * @returns	{void}
		 */
		focusMediaSearch: function () {
			// Start the timer going
			this._timer = setInterval( _.bind( this._checkValue, this ), 700 );
		},

		/**
		 * Event handler for blurring the search box
		 *
		 * @returns	{void}
		 */
		blurMediaSearch: function () {
			clearInterval( this._timer );
		},

		/**
		 * If the current value is different to the previous value, run the search
		 *
		 * @returns	{void}
		 */
		_checkValue: function () {
			var value = this.scope.find('[data-role="myMediaSearch"]').val();

			if( value == this._value ){
				return;
			}

			this._value = value;
			this._loadResults();
		},

		/**
		 * Runs a search
		 *
		 * @returns	{void}
		 */
		_loadResults: function () {
			var self = this;
			var url = this.scope.attr('data-url');
			
			// Abort any requests running now
			if( this._ajax && this._ajax.abort ){
				this._ajax.abort();
			}

			this.scope.find('[data-role="myMediaSearch"]').addClass('ipsField_loading');

			this._ajax = ips.getAjax()( url, {
				data: {
					search: this._value
				}
			})
				.done( function (response) {
					self.scope.find('[data-role="myMediaResults"]').html( response );
					$( document ).trigger( 'contentChange', [ self.scope.find('[data-role="myMediaResults"]') ] );
				})
				.always( function () {
					self.scope.find('[data-role="myMediaSearch"]').removeClass('ipsField_loading');
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/editor" javascript_name="ips.editor.uploader.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.editor.uploader.js - Editor uploader controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.editor.uploader', {

		initialize: function () {
			this.on( 'addUploaderFile', this.addUploaderFile );
			this.on( 'removeAllFiles', this.removeAllFiles );
			this.on( 'fileDeleted', this.fileDeleted );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns	{void}
		 */
		setup: function () {
			this.scope.find('[data-role="fileContainer"]').each( function(){
				if( $( this ).children().length > 0 ){
					$( this ).parent().removeClass('ipsHide');
				}
			});
		},

		/**
		 * Intercepts the addUploaderFile event from ips.ui.uploader, so that we can show
		 * the attachment differently depending on whether it's a file or image.
		 *
		 * @param	{event}		e		Event Object
		 * @param	{event}		data	Event data object
		 * @returns	{void}
		 */
		removeAllFiles: function (e, data) {
			this.scope.find('[data-role="files"], [data-role="images"], [data-role="videos"], [data-role="audio"]').hide();
			this.scope.find('[data-role="fileList"]').hide();
		},

		/**
		 * Intercepts the addUploaderFile event from ips.ui.uploader, so that we can show
		 * the attachment differently depending on whether it's a file or image.
		 *
		 * @param	{event}		e		Event Object
		 * @param	{event}		data	Event data object
		 * @returns	{void}
		 */
		addUploaderFile: function (e, data) {
			e.stopPropagation();

			var container = null;
			var template = 'core.attachments.';

			this.scope.find('[data-role="fileList"]').show();
			
			// Show the appropriate container for this kind of file
			if( data.isImage ){
				container = this.scope.find('[data-role="images"]');
				template += 'imageItem';
			} else if( data.isVideo ){
				container = this.scope.find('[data-role="videos"]');
				template += 'videoItem';
			} else if ( data.isAudio ) {
				container = this.scope.find('[data-role="audio"]');
				template += 'audioItem';
		    } else {
				container = this.scope.find('[data-role="files"]');
				template += 'fileItem';
			}

			data.extIcon = ips.ui.uploader.getExtensionIcon( data.title );
			
			container
				.show()
				.find('[data-role="fileContainer"]')
					.append( ips.templates.render( template, data ) );
		},

		/**
		 * Event handler for the fileDeleted event from ips.ui.uploader. Hides our
		 * attachment container if no more files exist.
		 *
		 * @param	{event}		e		Event Object
		 * @param	{event}		data	Event data object
		 * @returns	{void}
		 */
		fileDeleted: function (e, data) {
			var count = 0;

			// See if we need to hide either of the containers
			this.scope.find('[data-role="fileContainer"]').each( function () {
				if( !$( this ).find('.ipsAttach').length ){
					$( this ).closest('[data-role="files"], [data-role="images"], [data-role="videos"], [data-role="audio"]').hide();
					count++;
				}
			});
			
			if( count == 4 ){
				this.scope.find('[data-role="fileList"]').hide();
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/files" javascript_name="ips.files.multimod.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.support.multimod.js - Controller for moderation actions for the attachments list
 *
 * Author: Daniel Fatkic
 */
;( function($, _, undefined){
    "use strict";

    ips.controller.register('ips.admin.files.multimod', {

        initialize: function () {
            this.on( 'submit', '[data-role="moderationTools"]', this.moderationSubmit );
            this.on( 'menuItemSelected', this.itemSelected );
        },

        /**
         * Event handler called when the moderation bar submits
         *
         * @param	{event} 	e 		Event object
         * @returns {void}
         */
        moderationSubmit: function (e) {
            var action = this.scope.find('[data-role="moderationAction"]').val();

            switch (action) {
                case 'delete':
                    this._modActionDelete(e);
                    break;
                default:
                    $( document ).trigger('moderationSubmitted');
                    break;
            }
        },

        /**
         * Handles a delete action from the moderation bar
         *
         * @param	{event} 	e 		Event object
         * @returns {void}
         */
        _modActionDelete: function (e) {
            var self = this;
            var form = this.scope.find('[data-role="moderationTools"]');

            if( self._bypassDeleteCheck ){
                return;
            }

            e.preventDefault();

            // How many are we deleting?
            var count = parseInt( this.scope.find('[data-role="moderation"]:checked').length );

            ips.ui.alert.show( {
                type: 'confirm',
                icon: 'warn',
                message: ( count > 1 ) ? ips.pluralize( ips.getString( 'delete_confirm_many' ), count ) : ips.getString('delete_confirm'),
                callbacks: {
                    ok: function () {
                        $( document ).trigger('moderationSubmitted');
                        self._bypassDeleteCheck = true;
                        self.scope.find('[data-role="moderationTools"]').submit();
                    }
                }
            });
        }
    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/helpful" javascript_name="ips.helpful.helpful.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000300"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.helpful.helpful.js - General controller for marking items helpful
 *
 * Author: James Milne
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.helpful.helpful', {

		ajaxObj: null,

		/**
		 * Initialize controller events
		 *
		 * @returns 	{void}
		 */
		initialize: function () {
			this.on( 'click', '[data-action="helpful"]', this.markHelpful );
		},

		/**
		 * markHelpful
		 *
		 * @param 	{Event} 	e 	Event object
		 * @returns {void}
		 */
		async markHelpful(e) {
			e.preventDefault();

			let clicked = $( e.currentTarget );
			let showHelpfulButton = document.querySelector('[data-role="helpfulCount"]');
			let mostHelpfulBox = document.querySelector('[data-role="mostHelpful"]');
			clicked.addClass('i-opacity_3');

			/** @type {HelpfulResponse|HelpfulErrorResponse} */
			const response = await ips.fetch( clicked.attr('href') );
			if( !response.error ) {
				clicked.closest("li").replaceWith( response.button );

				if ( response.helpfulReplies === 0 ) {
					/* No helpful replies, redirect */
				}
				if ( showHelpfulButton && response.countLanguage ) {
					$(showHelpfulButton).html( response.countLanguage );
				}

				if ( mostHelpfulBox ) {
					if ( response.mostHelpfulHtml ) {
						$(mostHelpfulBox).removeClass('ipsHide');
						$(mostHelpfulBox).html(response.mostHelpful);
					}
					else
					{
						$(mostHelpfulBox).addClass('ipsHide');
					}
				}
			}
			clicked.removeClass('i-opacity_3');
		}
	});

	/**
	 * @typedef HelpfulResponse
	 * @property {number} helpfulReplies
	 * @property {string}	countLanguage
	 * @property {string}	button
	 * @property {string}	[mostHelpfulHtml]
	 */

	/**
	 * @typedef HelpfulErrorResponse
	 * @property {*} error
	 */
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/ignore" javascript_name="ips.ignore.existing.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ignore.existing.js - Controller for an ignored user on ignore preferences page
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.ignore.existing', {

		initialize: function () {
			this.on( 'menuItemSelected', '[data-action="ignoreMenu"]', this.ignoreMenu );
			this.on( 'submitDialog', this.editedUser );
		},

		/**
 		 * Event handler for edit dialog saving
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Data object from the event. Contains token information.
		 * @returns 	{void}
		 */
		editedUser: function (e, data) {
			this.trigger('refreshResults');

			ips.ui.flashMsg.show( ips.getString('editedIgnore') );
		},

		/**
 		 * Event handler for the ignore menu
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Data object from the event. Contains token information.
		 * @returns 	{void}
		 */
		ignoreMenu: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			switch (data.selectedItemID) {
				case 'remove':
					this._removeIgnore(e, data);
				break;
			}
		},

		/**
 		 * Removes the ignore from this user
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Data object from the event. Contains token information.
		 * @returns 	{void}
		 */
		_removeIgnore: function (e, data) {
			var url =  $(data.menuElem).find('[data-ipsMenuValue="remove"] a').attr('href');
			var self = this;

			Debug.log('here');

			// Confirm it
			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('confirm_unignore'),
				subText: ips.getString('confirm_unignore_desc'),
				callbacks: {
					ok: function () {
						ips.getAjax()( url + '&wasConfirmed=1' )
							.done( function (response) {
								self.trigger('refreshResults');
							});
					}
				}
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/ignore" javascript_name="ips.ignore.new.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000350">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ignore.new.js - Manage Ignored Users controller
 *
 * Author: Rikki Tissier / Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.ignore.new', {
	
		/**
 		 * Initialize controller events
		 * Sets up the events from the view that this controller will handle
		 *
		 * @returns 	{void}
		 */
		initialize: function () {
			this.on( 'submit', '#elIgnoreForm', this.addIgnoredUser );
			this.on( 'tokenAdded', this.showExtraControls );
			this.setup();
		},

		/**
 		 * Non-event-based setup
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			if ( parseInt( this.scope.attr('data-id') ) === 0 ) {
				$('#elIgnoreTypes, #elIgnoreSubmitRow').hide();
			}	
		},
				
		/**
 		 * Submit handler for add user form. Gathers the types of content to be ignored, and emits an
 		 * event allowing the model to handle it
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		addIgnoredUser: function (e) {
			var form = this.scope.find('#elIgnoreForm');
			
			if( form.attr('data-bypassValidation') ){
				return;
			}
			
			e.preventDefault();
				
			var self = this;
			var scope = this.scope;

			ips.getAjax()( form.attr('action'), {
				data: form.serialize(),
				type: 'post'
			}).done( function (response, textStatus, jqXHR) {
				if ( jqXHR.responseJSON ) {
					ips.utils.anim.go( 'fadeOut', $('#elIgnoreTypes, #elIgnoreSubmitRow') ).then( function () {
						var field = scope.find('[name=&quot;member&quot;]');
						ips.ui.autocomplete.getObj( field ).removeAll();
						form.find( &quot;[type='checkbox']&quot; ).attr( 'checked', '' ).change();
					});

					// Show confirmation
					ips.ui.flashMsg.show( 
						ips.getString('addedIgnore', {
							user: response.name
						})
					);

					// Find the table, and refresh
					self.triggerOn( 'core.global.core.table', 'refreshResults' );	
					
				} else {
					form.attr('data-bypassValidation', true).submit();
				}
			}).fail( function (jqXHR, textStatus, errorThrown) {
				form.attr('data-bypassValidation', true).submit();
			});
		},
		
		/**
 		 * Triggered when the autocomplete field has added a token. Shows the extra options
 		 * on the form.
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Data object from the event. Contains token information.
		 * @returns 	{void}
		 */
		showExtraControls: function (e, data) {
			
			var field = this.scope.find('[name=&quot;member&quot;]');
			var wrapper = $( '#' + field.attr('id') + '_wrapper' );
			wrapper.addClass('ipsField_loading');
						
			var form = this.scope.find('#elIgnoreForm');
			
			ips.getAjax()( form.attr('action'), {
				type: 'post',
				data: {
					do: 'add',
					name: this.scope.find('[name=&quot;member&quot;]').val()
				}
			} )
				.done( function( response ) {
					var i;
					for ( i in response ) {
						form.find( &quot;[name='ignore_&quot; + i + &quot;_checkbox']&quot; ).attr( 'checked', response[i] == 1 ).change();
					}
					
					ips.utils.anim.go( 'fadeIn', $('#elIgnoreTypes, #elIgnoreSubmitRow') );
				})
				.fail( function( jqXHR, textStatus, errorThrown ) {
					ips.ui.alert.show({
						message: jqXHR.responseJSON['error']
					});

					field.data('_autocomplete').removeAll();
				}).always(function(){
					wrapper.removeClass('ipsField_loading');
				});
		}		

	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.achievementRuleForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.achievementRuleForm.js - Controller for restrictions screen
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.members.achievementRuleForm', {

		initialize() {
			this.on( 'click', '[data-action="filterReveal"]', this.showFilter );
			this.on( 'click', '[data-action="filterCollapse"]', this.hideFilter );
			this.on( 'change keyup', 'input[type="number"]', this.changeNumber );
		},

		/**
		 * Show a filter when the reveal filter button was clicked
		 * @param {MouseEvent}	e
		 */
		showFilter(e) {
			const ruleWrap = e.currentTarget.closest('[data-role="ruleWrap"]');
			const toggleWrap = e.currentTarget.closest('[data-role="toggleFilter"]');
			const check = toggleWrap.querySelector('input[type="checkbox"]');
			const conditionButtons = toggleWrap.closest('[data-role="conditionButtons"]');

			check.checked = true;
			check.dispatchEvent(new Event('change', {bubbles: true}));
			toggleWrap.ipsHide();
			if (conditionButtons?.querySelector('[data-role="toggleFilter"] input[data-filter]:not(:checked)')) {
				conditionButtons?.ipsShow();
			} else {
				conditionButtons?.ipsHide();
			}

			const filterName = check.dataset.filter;
			if (filterName) {
				ruleWrap.querySelectorAll(`#${filterName}`).ipsShow();
			}
			ruleWrap.querySelectorAll('input[type="number"]').forEach(el => this._pluralizeNumber(el));
		},

		/**
		 * Hide a filter
		 * @param {MouseEvent}	e
		 */
		hideFilter(e) {
			e.preventDefault();
			const filter = e.currentTarget.closest('[data-role="filterField"]');
			const filterName = filter.id;
			const check = filter
				.closest('[data-role="ruleWrap"]') // in theory, we can just do document.querySelector, however other tabs may have an element sharing this ID. THerefore, we only find the element with this ID inside this tab
				.querySelector(`#${filterName}Checkbox`);

			const toggleWrap = check.closest('[data-role="toggleFilter"]');

			check.checked = false;
			check.dispatchEvent(new Event('change', {bubbles: true})); // todo this may be redundant
			toggleWrap.ipsShow()
			toggleWrap.closest('[data-role="conditionButtons"]')?.ipsShow();
			filter.ipsHide();
		},

		/**
		 * Change the number of a numeric input so that the lang string is pluralized properly
		 * @param {Event}	e
		 */
		changeNumber(e) {
			this._pluralizeNumber(e.currentTarget);
		},

		/**
		 *
		 * @param {HTMLInputElement} input
		 * @private
		 */
		_pluralizeNumber(input) {
			const span = input.nextElementSibling;

			if (span?.matches('[data-role="th"]')) {
				span.innerText = ips.pluralize(ips.getString('numberSuffix'), input.value);
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.allowedCharacters.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.allowedCharacters.js - Controller for setting to control which characters are allowed in usernames
 *
 * Author: Mark Eade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.members.allowedCharacters', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;easy&quot;]', this.showEasy );
			this.on( 'click', '[data-action=&quot;regex&quot;]', this.showRegex );

			this.setup();
		},
		
		showEasy: function(e){
			if (e) {
				e.preventDefault();
			}
			this.scope.find('[data-role=&quot;easy&quot;]').show();
			this.scope.find('[data-role=&quot;regex&quot;]').hide();
			this.scope.find('[data-role=&quot;easyInput&quot;]').val('1');
		},
		
		showRegex: function(e){
			if (e) {
				e.preventDefault();
			}
			this.scope.find('[data-role=&quot;regex&quot;]').show();
			this.scope.find('[data-role=&quot;easy&quot;]').hide();
			this.scope.find('[data-role=&quot;easyInput&quot;]').val('0');
		},

		setup: function () {
			this.scope.find('[data-action=&quot;easy&quot;]').show();
			this.scope.find('[data-action=&quot;regex&quot;]').show();
			if ( this.scope.attr('data-easy') == 1 ) {
				this.showEasy();
			}
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.form.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.form.js - ACP Files Form Stuffs
 *
 * Author: MTM
 */

;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.members.form', {

		initialize: function () {
			this.on( 'submit', this.submitForm );
		},
		
		/**
		 * Check if move is needed
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitForm: function (e) {
			var self = this;
			
			if( $( e.currentTarget ).attr('data-bypassValidation') ){
				return true;
			}
			
			e.preventDefault();
			e.stopPropagation();
		
			var isInAdminGroup = false;
			var mainGroup = this.scope.find('select[name=group]').val();
			var secondaryGroups = _.map( this.scope.find('select[name="secondary_groups[]"]').val(), function( val ){
				return parseInt( val );
			} );
			var adminGroups = $.parseJSON( this.scope.attr('data-adminGroups') );
			if( adminGroups.length ){
				for( var i = 0; i < adminGroups.length; i++ ) {
					var testId = adminGroups[i];
					if ( secondaryGroups != null && secondaryGroups.length && _.indexOf( secondaryGroups, testId ) != -1 ) {
						isInAdminGroup = true;
					}
					if ( testId == mainGroup ) {
						isInAdminGroup = true;
					}
					if ( $( "input#elCheckbox_secondary_groups_" + testId + ":checked" ).length ) {
						isInAdminGroup = true;
					}
				}
			}
			
			if ( isInAdminGroup ) {
				ips.ui.alert.show({
					type: 'confirm',
					message: ips.getString('member_edit_is_admin'),
					icon: 'fa-solid fa-triangle-exclamation',
					buttons: {
						ok: ips.getString('member_edit_ok'),
						cancel: ips.getString('member_edit_cancel')
					},
					callbacks: {
						ok: function () {
							$( e.currentTarget ).attr('data-bypassValidation', true);
							$( e.currentTarget ).submit();
						},
						cancel: function () {
							return false;
						}
					}
				});
			} else {
				$( e.currentTarget ).attr('data-bypassValidation', true);
				$( e.currentTarget ).submit();
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.history.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.history.js - Filters for member history log
 *
 * Author: Mark Wade
 */

;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.members.history', {

		initialize: function () {
			this.on( 'menuItemSelected', this.filterSelected );
		},
		
		/**
		 * Event handler for when a filter option is chosen
		 *
		 * @param	{event} 	e		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		filterSelected: function (e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}
												
			if( data.triggerID == 'memberHistoryFilters' ){
				$(this.scope).find('[data-role=&quot;historyTitle&quot;]').text( $(data.menuElem).find('[data-ipsMenuValue=&quot;' + data.selectedItemID + '&quot;]').text() );
				$(this.scope).find('[data-role=&quot;historyDisplay&quot;]').addClass('ipsLoading').html('');
								
				ips.getAjax()( $(data.menuElem).find('[data-ipsMenuValue=&quot;' + data.selectedItemID + '&quot;] a').attr('href') ).done(function(response){
					$(this.scope).find('[data-role=&quot;historyDisplay&quot;]').html( response ).removeClass('ipsLoading');
					$( document ).trigger( 'contentChange', [ this.scope ] );
				}.bind(this));
			}
		}
		
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.lazyLoadingProfileBlock.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.members.lazyLoadingProfileBlock.js
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.members.lazyLoadingProfileBlock', {
		
		/**
		 * Init
		 */
		initialize: function () {
			var scope = $(this.scope);
			ips.getAjax()( scope.attr('data-url') ).done(function(response){
				const doc = (new DOMParser()).parseFromString(response, 'text/html');
				scope.html(doc.body.innerHTML);
				// include scripts
				let headInserts = "";
				doc.head.querySelectorAll('script').forEach(script => {
					if (!script.hasAttribute('src') || !document.querySelector(`script[src="${script.getAttribute('src')}"]`)) {
						headInserts += script.outerHTML + '\n';
					}
				});


				doc.head.querySelectorAll('link[href]').forEach(link => {
					if (!document.querySelector(`link[href="${link.getAttribute('href')}"]`)) {
						headInserts += link.outerHTML + '\n';
					}
				});

				if (headInserts) {
					document.head.insertAdjacentHTML('beforeend', headInserts);
				}

				$( document ).trigger( 'contentChange', [ scope ] );
			});
		},
				
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.listFlagSpammer.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://invisioncommunity.com
 *
 * ips.members.listFlagSpammer.js - Member list spam flagging
 *
 * Author: Stuart Silvester
 */

;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.members.listFlagSpammer', {

		initialize: function () {
			this.on('click', this.toggleFlagSpammer  );
		},

		toggleFlagSpammer: function( e ) {
			e.preventDefault();

			var elem = $( e.currentTarget );
			var icon = elem.find( '.fa-flag' );
			var textLabel = elem.find('span');

			ips.ui.alert.show({
				'type': 'confirm',
				'icon': 'warn',
				'message': icon.hasClass( 'i-color_warning' ) ? ips.getString( 'confirmUnFlagAsSpammer' ) : ips.getString('confirmFlagAsSpammer'),
				'subText': icon.hasClass( 'i-color_warning' ) ? ips.getString( 'confirmUnFlagAsSpammerDesc' ) : '',
				callbacks: {
					ok: function () {
						ips.getAjax()( elem.attr('href'), { dataType: 'json' } )
							.done( function (response) {
								ips.ui.flashMsg.show( response );
								icon.toggleClass( 'i-color_warning');

								// adjust url
								var newStatus = ips.utils.url.getParam( 'status', elem.attr('href') ) == 1 ? 0 : 1;
								var newUrl = ips.utils.url.removeParam( 'status', elem.attr('href') );
								elem.attr( 'href', newUrl + '&status=' + newStatus );

								// Labels
								elem.attr( '_title', newStatus ? ips.getString( 'flagAsSpammer' ) : ips.getString( 'unflagAsSpammer' ) );
								elem.attr( 'aria-label', newStatus ? ips.getString( 'flagAsSpammer' ) : ips.getString( 'unflagAsSpammer' ) );
								textLabel.text(newStatus ? ips.getString( 'flagAsSpammer' ) : ips.getString( 'unflagAsSpammer' ));
							})
							.fail( function (jqXHR) {
								if( Debug.isEnabled() ){
									Debug.error( jqXHR.responseText );
								} else {
									window.location = elem.attr('href');
								}
							});
					}
				}
			});
		}

	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.moderatorPermissions.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.moderatorPermissions.js - 
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.members.moderatorPermissions', {

		initialize: function () {
			this.on( 'change', '#ipsTabs_form_modperms__core_Content_panel input[type="checkbox"]', this.toggle );
			this.on( 'click', '[data-role="checkAll"]', this.checkAll );
			this.on( 'click', '[data-role="uncheckAll"]', this.checkAll );
			this.setup();
		},

		/**
		 * Setup method; checks initial states of toggles
		 *
		 * @returns {void}
		 */
		setup: function () {
			var mainPanel = this.scope.find('#ipsTabs_form_modperms__core_Content_panel');
			var self = this;

			mainPanel.find('input[type="checkbox"]').each( function () {
				self._toggleChanged( $( this ) );
			});
			
			$(this.scope).find('.ipsTabs__panel').each(function(){
				var controls = $( ips.templates.render( 'moderatorPermissions.checkUncheckAll' ) );
				controls.find('button').attr( 'data-scope', $(this).attr('id') );
				$(this).children('ul').prepend( controls );
			});

			this._checkEachTab();
		},
		
		/**
		 * Check/uncheck all
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkAll: function (e) {
			e.preventDefault();
			var check = $(e.currentTarget).attr('data-role') == 'checkAll';
			
			if ( $(e.currentTarget).attr('data-scope') ) {
				var scope = $( '#' + $(e.currentTarget).attr('data-scope') );
			} else {
				var scope = $(this.scope);
			}

			if( check && !$(e.currentTarget).attr('data-scope') )
			{
				$('input[name="mod_use_restrictions"][value="no"]').prop( 'checked', true ).change();
			}
			
			var self = this;
			scope.find('input[type="checkbox"]').each(function(){
				if ( check && !$(this).is(':checked') ) {
					$(this).prop( 'checked', true ).change();
				} else if ( !check && $(this).is(':checked') ) {
					$(this).prop( 'checked', false ).change();
				} 
			});
		},

		/**
		 * Toggle event handler
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggle: function (e) {
			this._toggleChanged( $( e.currentTarget ) );
			this._checkEachTab();
		},

		/**
		 * Called when a toggle changes in the main panel. If checked, other toggles of this type in other panels are hidden
		 *
		 * @param	{element} 	thisToggle 		The toggle that has changed
		 * @returns {void}
		 */
		_toggleChanged: function (thisToggle) {
			var id = thisToggle.closest('.ipsFieldRow').attr('id').replace('_content', '');
			var panels = this.scope.find('.ipsTabs__panel:not( #ipsTabs_form_modperms__core_Content_panel )');
			var otherToggles =  panels.find('.ipsFieldRow[id^="' + id + '"]').not( thisToggle.closest('.ipsFieldRow') );

			if( thisToggle.is(':checked') ){
				// Find all other toggles of this type and hide them
				otherToggles.hide();
				otherToggles.find('input[type="checkbox"]').prop( 'disabled', true );
			} else {
				otherToggles.show();
				otherToggles.find('input[type="checkbox"]').prop( 'disabled', false );
			}
		},

		/**
		 * Checks each tab on the form to see whether any permissions are showing, hiding it if not
		 *
		 * @returns {void}
		 */
		_checkEachTab: function () {
			var self = this;
			var panels = this.scope.find('.ipsTabs__panel:not( #ipsTabs_form_modperms__core_Content_panel )');

			// Now check each tab to make sure there's some to show
			panels.each( function () {
				var count = $( this ).find('input[type="checkbox"]:enabled:not( [data-role="zeroVal"] )').length;
				var id = $( this ).attr('id').replace('ipsTabs_tabs_form_', '').replace('_panel', '');

				if( !count ){
					self.scope.find('#' + id).closest('li').hide();
				} else {
					self.scope.find('#' + id).closest('li').show();
				}
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/members" javascript_name="ips.members.restrictions.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.members.restrictions.js - Controller for restrictions screen
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.members.restrictions', {

		initialize: function () {
			this.on( 'click', '.acpRestrictions_subHeader h3', this.toggleSubHeader );
			this.on( 'change', '.acpRestrictions_header input[type=&quot;checkbox&quot;]', this.toggleHeader );
			this.on( 'change', '.acpAppRestrictions_header input[type=&quot;checkbox&quot;]', this.toggleAppHeader );
			this.on( 'click', '[data-action=&quot;checkAll&quot;]', this.checkAll );
			this.on( 'click', '[data-action=&quot;checkNone&quot;]', this.checkNone );
			this.on( 'click', '[data-action=&quot;expandAll&quot;], [data-action=&quot;collapseAll&quot;]', this.toggleDisplay );

			this.setup();
		},

		/**
		 * Event handler for both the expand and collapse links
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleDisplay: function (e) {
			e.preventDefault();

			var row = $( e.currentTarget ).closest('.acpRestrictions_header');
			var subHeaders = row.next().find('.acpRestrictions_subHeader');
			var self = this;
			var action = ( $( e.currentTarget ).attr('data-action') == 'expandAll' ) ? 'expand' : 'collapse';

			subHeaders.each( function () {
				if( action == 'expand') {
					self._expandSection( $( this ) );	
				} else {
					self._collapseSection( $( this ) );
				}				
			});
		},

		/**
		 * Disables all the toggles in an app when the app header is unchecked
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleAppHeader: function (e) {
			var check = $( e.currentTarget );
			var row = check.closest('.acpAppRestrictions_header');

			if( !check.is(':checked') ){
				row
					.siblings('.acpAppRestrictions_panel')
					.find('.acpRestrictions_header input[type=&quot;checkbox&quot;]')
						.each( function () {
							// Loops through each checkbox, disables it, stores the original state as an attr,
							// unchecks it, and triggers a change event to update the JS toggle widget.
							$( this )
								.prop('disabled', true)
								.attr( 'data-originalState', $( this ).is(':checked') )
								.attr( 'checked', false )
								.trigger('change');
						});
			} else {
				// Top panel rows
				row
					.siblings('.acpAppRestrictions_panel')
					.find('input[type=&quot;checkbox&quot;]')
						.each( function () {
							var thisCheck = $( this );
							thisCheck.prop( 'disabled', false );

							if( thisCheck.attr('data-originalState') == 'true' ){
								thisCheck
									.prop( 'checked', true )
									.trigger('change');
							}
						});

				// Sub panel rows
				row
					.siblings('.acpAppRestrictions_panel')
					.find('.acpRestrictions_panel input[type=&quot;checkbox&quot;]')
						.each( function () {
							var thisCheck = $( this );
							var checked = thisCheck.closest('.acpRestrictions_panel').siblings('.acpRestrictions_header').find('input[type=&quot;checkbox&quot;]').is(':checked');

							if( !checked ){
								thisCheck.prop('disabled', true);
							} else {
								thisCheck.prop('disabled', false);
							}

							if( thisCheck.attr('data-originalState') == 'true' ){
								thisCheck
									.prop( 'checked', true )
									.trigger('change');
							}
						});
			}
		},

		/**
		 * Disables all the toggles in a section when the section header is unchecked
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleHeader: function (e) {
			var check = $( e.currentTarget );
			var row = check.closest('.acpRestrictions_header');
			var unChecked = !check.is(':checked');

			row
				.next()
				.find('input[type=&quot;checkbox&quot;]')
					.each( function () {
						var thisCheck = $( this );

						if( unChecked ){
							thisCheck
								.attr( 'data-originalState', thisCheck.is(':checked') )
								.prop( 'checked', false );
						} else if ( ( thisCheck.attr('data-originalState') == 'true' ) ){
							thisCheck.prop( 'checked', true );
						}
						
						thisCheck
							.prop( 'disabled', unChecked )
							.trigger('change');
					});
		},

		/**
		 * Toggles the display of a section when a subheader is clicked
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleSubHeader: function (e) {
			var header = $( e.currentTarget ).parent();

			if( header.hasClass('acpRestrictions_open') ){
				this._collapseSection( header );
			} else {
				this._expandSection( header );
			}
		},

		/**
		 * Displays a section with animation
		 *
		 * @param	{element} 	section 	The section to show
		 * @returns {void}
		 */
		_expandSection: function (section) {
			var next = section.next('ul');

			section
				.addClass('acpRestrictions_open')
				.removeClass('acpRestrictions_closed');

			ips.utils.anim.go( 'fadeInDown fast', next );
		},

		/**
		 * Hides a section
		 *
		 * @param	{element} 	section  	The section to hide
		 * @returns {void}
		 */
		_collapseSection: function (section) {
			section
				.removeClass('acpRestrictions_open')
				.addClass('acpRestrictions_closed');
		},

		/**
		 * Checks all toggles in the section, opening the section too if necessary
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkAll: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).parents('.acpRestrictions_subHeader');
			var next = header.next('ul');

			// If the section isn't visible, do the toggling after the section has
			// animated in, so that the user can see the change happen. Otherwise, just do it immediately
			if( !next.is(':visible') ){
				next.animationComplete( function () {
					self._togglePermissions( true, next );
				});

				this._expandSection( header );	
			} else {
				this._togglePermissions( true, next );
			}
			
		},

		/**
		 * Unchecks all toggles in the section, opening the section too if necessary
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkNone: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).parents('.acpRestrictions_subHeader');
			var next = header.next('ul');

			// If the section isn't visible, do the toggling after the section has
			// animated in, so that the user can see the change happen. Otherwise, just do it immediately
			if( !next.is(':visible') ){
				next.animationComplete( function () {
					self._togglePermissions( false, next );
				});

				this._expandSection( header );	
			} else {
				this._togglePermissions( false, next );
			}
			
		},

		/**
		 * Sets all checkboxes to the given state in the given container
		 *
		 * @param	{boolean} 	state 		The state to which checkboxes will be set
		 * @param 	{element} 	container 	The container in which the checkboxes must exist
		 * @returns {void}
		 */
		_togglePermissions: function (state, container) {
			container.find('input[type=&quot;checkbox&quot;]:not( [disabled] )').prop('checked', state).change();
		},

		/**
		 * Setup method
		 * Collapses all sections initially
		 *
		 * @returns {void}
		 */
		setup: function () {
			this.scope
				.find('.acpRestrictions_open')
					.removeClass('acpRestrictions_open')
					.addClass('acpRestrictions_closed');
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/messages" javascript_name="ips.messages.folderDialog.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.folderDialog.js - Folder naming dialog controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.messages.folderDialog', {

		_events: {
			add: 'addFolder',
			rename: 'renameFolder'
		},

		initialize: function () {
			this.on( 'submit', 'form', this.submitName );
		},

		/**
		 * Responds to the model event indicating the folder has been marked as read
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitName: function (e) {
			e.preventDefault();
			e.stopPropagation();

			var type = this.scope.attr('data-type');
			var field = this.scope.find('[data-role=&quot;folderName&quot;]');
			var val = field.val();
			var folderID = field.attr('data-folderID');

			this.trigger( this._events[ type ] + '.messages', {
				folder: folderID,
				name: val
			});

			this.trigger('closeDialog');
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/messages" javascript_name="ips.messages.list.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.list.js - Messages list in messenger
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.messages.list', {

		_messageList: null,
		_searchTimer: null,
		_currentFolder: null,
		_currentMessageID: null,
		_currentOptions: {
			sortBy: 'mt_last_post_time',
			filter: 'all'
		},
		_infScrollURL: null,

		initialize() {
			// Main controller events
			this.on( document, 'messengerReady.messages', this.messengerReady );

			// Menu events
			this.on( 'menuItemSelected', '#elSortByMenu', this.changeSort );
			this.on( 'menuItemSelected', '#elFilterMenu', this.changeFilter );
			
			// Message list events
			this.on( 'click', '[data-messageid]', this.clickMessage );
			this.on( 'submit', '[data-role="moderationTools"]', this.moderationSubmit );

			// Search field
			this.on( 'input', '[data-role="messageSearchText"]', this.inputSearch );
			this.on( 'click', '[data-action="messageSearchCancel"]', this.cancelSearch );

			// Folder model events
			this.on( document, 'loadFolderDone.messages', this.loadFolderDone );
			this.on( document, 'loadFolderLoading.messages, searchFolderLoading.messages', this.loadFolderLoading );
			this.on( document, 'loadFolderFinished.messages', this.loadFolderFinished );
			this.on( document, 'searchFolderLoading.messages', this.searchFolderLoading );
			this.on( document, 'searchFolderDone.messages', this.searchFolderDone );
			this.on( document, 'searchFolderFinished.messages', this.searchFolderFinished );
			this.on( document, 'markFolderDone.messages', this.markFolderDone );
			this.on( document, 'deleteMessagesDone.messages', this.deleteMessagesDone );
			this.on( document, 'loadMessageDone.messages', this.markMessageRead );
			
			// Message model events
			this.on( document, 'deleteMessageDone.messages', this.deleteMessageDone );
			this.on( document, 'moveMessageDone.messages', this.moveMessageDone );
			this.on( document, 'addToCommentFeed', this.newMessage );
			this.on( document, 'deletedComment.comment', this.deletedMessage );

			// Primary event that watches for URL changes
			this.on( window, 'historychange:messages', this.stateChange );

			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup() {
			this._messageList = this.scope.find('[data-role="messageList"]');
			this._currentFolder = this.scope.attr('data-folderID');

			this.trigger('setInitialFolder.messages', {
				folderID: this._currentFolder
			});
		},

		/**
		 * Handles submitting the moderation form (which lets uses mass-delete messages)
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		moderationSubmit(e, data) {
			e.preventDefault();

			var self = this;
			var form = this.scope.find('[data-role="moderationTools"]');

			// How many are we deleting?
			var count = parseInt( this.scope.find('[data-role="moderation"]:checked').length );
		
			if ( this.scope.find('[data-role="pageActionOptions"]').find('select option:selected').val() == 'move' ) {
				var dialog = ips.ui.dialog.create( { remoteVerify: false, size: 'narrow', remoteSubmit: false, title: ips.getString('messagesMove'), url: form.attr('action') + '&do=moveForm&ids=' + _.map( self.scope.find('[data-role="moderation"]:checked'), function (item) {
					return $( item ).closest('[data-messageid]').attr('data-messageid');
				}).join(',') } );
				dialog.show();
			} else {
				ips.ui.alert.show( {
					type: 'confirm',
					icon: 'question',
					message: ( count > 1 ) ? ips.pluralize( ips.getString( 'messagesDeleteMany' ), count ) : ips.getString('messagesDelete'),
					subText: ( count > 1 ) ? ips.getString( 'messagesDeleteManySubText' ) : ips.getString('messagesDeleteSubText'),
					callbacks: {
						ok() {
							// Get IDs
							var ids = _.map( self.scope.find('[data-role="moderation"]:checked'), function (item) {
								return $( item ).closest('[data-messageid]').attr('data-messageid');
							});
	
							self.trigger('deleteMessages.messages', {
								id: ids
							});
						}
					}
				});
			}
		},

		/**
		 * Deleted multiple messages using the pageAction widget
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		deleteMessagesDone(e, data) {
			// Build a selector to find the messages
			var selector = _.map( data.id, function (item) {
				return '[data-messageid="' + item + '"]';
			}).join(',');

			// Get the messages
			var self = this;
			var messages = this._messageList.find( selector );

			if( messages.length ){
				messages.slideUp( {
					complete() {
						messages.remove();

						// Is our selected message one of those deleted?
						if( data.id.indexOf( self._currentMessageID ) !== -1 ){
							self._currentMessageID = null;	

							// Are there any other messages we can show?
							if( self._messageList.find('[data-messageid]').length ){
								self._messageList.find('[data-messageid]').first().click();
							} else {
								self.trigger( 'getFolder', {
									folderID: self._currentFolder 
								});
							}
						}

						// Refresh the page action so it hides
						self._resetListActions();
					},
					queue: false
				}).fadeOut({
					queue: false
				});	
			}
		},

		/**
		 * Event handler for the search box. Starts a timer so that a search happens 500ms after
		 * the user stops typing
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		inputSearch(e) {
			clearTimeout( this._searchTimer );
			this._searchTimer = setTimeout( _.bind( this._startSearch, this ), 500 );
		},

		/**
		 * Event handler for model search loading event
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		searchFolderLoading(e, data) {
			this.scope.find('[data-role="messageSearchText"]').addClass('ipsField_loading');
		},

		/**
		 * Event handler for model search done event
		 * Updates the message list, hides the filters and shows the cancel button
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		searchFolderDone(e, data) {
			//this.cleanContents();
			this._messageList
				.html( data.data )
				.show()
				.end()
				.find('[data-role="messageListPagination"]')
					.html( data.pagination )
				.end()
				.find('[data-role="loading"]')
					.attr('hidden', true)
				.end()
				.find('[data-role="messageListFilters"]')
					.attr('hidden', true);

			this.scope.find('[data-action="messageSearchCancel"]').removeAttr('hidden');

			// Update the infinite scroll URL
			if( this.scope.is('[data-ipsInfScroll]') ){
				var params = decodeURIComponent( $.param( ips.utils.form.serializeAsObject( $('[data-role="messageSearch"]') ) ) );
				var base = this.scope.find('#elMessageList > form').attr('action');

				this._infScrollURL = this.scope.attr('data-ipsInfScroll');
				this.scope.attr('data-ipsInfScroll-url', base + '&' + params + '&folder=' + this._currentFolder );
				this.scope.trigger('refresh.infScroll');
			}

			$( document ).trigger( 'contentChange', [ this._messageList ] );
			this._resetListActions();
		},

		/**
		 * Event handler for model search finished event
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		searchFolderFinished(e, data) {
			this.scope.find('[data-role="messageSearchText"]').removeClass('ipsField_loading');
		},

		/**
		 * Event handler for clicking the cancel search button
		 *
		 * @param 		{event} 	e 		Event object	
		 * @returns 	{void}
		 */
		cancelSearch(e) {
			this._resetSearch();
			this._getFolder( this._currentFolder );
		},

		/**
		 * A reply in a message was deleted
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		deletedReply(e, data) {
			var count = this._messageList.find('[data-messageid="' + data.messageID + '"] [data-role="replyCount"]').text();
			this._messageList.find('[data-messageid="' + data.messageID + '"] [data-role="replyCount"]').text( parseInt( count ) - 1 );
		},

		/**
		 * Updates the reply count for a message
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		updateReplyCount(e, data) {
			this._messageList
				.find('[data-messageid="' + data.messageID + '"] [data-role="replyCount"]')
					.text( data.count );
		},

		/**
		 * Responds to the model event indicating the folder has been marked as read
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		markFolderDone(e, data) {
			if( data.folder == this._currentFolder ){
				this._messageList
					.find('[data-messageid]')
						.removeAttr('data-ips-unread')
						.find('.ipsIndicator')
							.remove();
			}
		},

		/**
		 * Responds to the model event indicating an individual message has been deleted
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		deleteMessageDone(e, data) {
			// See if the deleted message exists in the list
			var message = this._messageList.find('[data-messageid="' + data.id + '"]');

			if( message.length ){
				ips.utils.anim.go( 'fadeOutDown', message ).done( function () {
					message.remove();
				});

				this._currentMessageID = null;
			}
		},

		/**
		 * Responds to model event indicating message has moved. If the message is in this list, we remove it.
		 * If the message is the selected message, we also select the next or previous message
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		moveMessageDone(e, data) {

			// If this message is in the list, remove it
			var message = this._messageList.find('[data-messageid="' + data.id + '"]');
			var next = null;

			if( this._currentMessageID == data.id ){
				// Get the prev or next message
				if( message.prev('[data-messageid]').length ){
					next = message.prev('[data-messageid]');
				} else if( message.next('[data-messageid]').length ){
					next = message.next('[data-messageid]');
				}
			}

			if( message.length && data.to != this._currentFolder ){
				ips.utils.anim.go( 'fadeOutDown', message ).done( function () {
					message.remove();
				});

				this._currentMessageID = null;
			}

			ips.ui.flashMsg.show( ips.getString('conversationMoved') );

			if( next ){
				next.click();
			}
		},

		/**
		 * Responds to the model event indicating a folder has been successfully loaded into the list
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		loadFolderDone(e, data) {
			//this.cleanContents();
			this.scope
				.attr( 'data-ipsInfScroll-url', data.listBaseUrl )
				.find('#elMessageList')
					.scrollTop(0);

			this._messageList
					.html( data.data )
					.show()
				.end()
				.find('[data-role="messageListPagination"]')
					.html( data.pagination )
				.end()
				.find('[data-role="loading"]')
					.attr('hidden', true);

			this.scope.trigger('refresh.infScroll');
			$( document ).trigger( 'contentChange', [ this._messageList ] );

			this._resetListActions();
		},

		/**
		 * Responds to the model indicating new results are loading
		 * Shows a loading thingy in place of the list
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		loadFolderLoading(e, data) {
			if( !this.scope.find('[data-role="loading"]').length ){
				this._messageList.after( 
					$('<div/>')
						.addClass('ipsLoading')
						.html('&nbsp;')
						.css( { minHeight: '150px' } )
						.attr('data-role', 'loading')
				);
			}

			this._messageList.hide();
			this._hideEmpty();
			this.scope.find('[data-role="loading"]').removeAttr('hidden');
		},

		/**
		 * Responds to the model indicating loading a folder has finished
		 * Shows the list again
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		loadFolderFinished(e, data) {
			this._messageList.show();
			this._resetSearch();
		},

		/**
		 * Responds when all messenger setup is complete.
		 * Triggers an event that lets the main and view controllers know which is the current message
		 *	
		 * @returns 	{void}
		 */
		messengerReady() {
			this._currentMessageID = this._messageList.find('.ipsData__item--active').attr('data-messageid');
			this.trigger( 'setInitialMessage.messages', {
				messageID: this._currentMessageID
			});
		},

		/**
		 * Event handler for clicking on a message in the list
		 * If it's a single message, we trigger an event to load it, and highlight it
		 * If a meta key is pressed, we select multiple messages, as well as triggering the event
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		clickMessage(e) {
			if( $( e.target ).is('input[type="checkbox"]') ){
				return;
			}

			e.preventDefault();

			var messageID = $( e.currentTarget ).attr('data-messageid');
			var messageURL = $( e.currentTarget ).find('[data-role="messageURL"]').attr('href');
			var messageTitle = $( e.currentTarget ).find('[data-role="messageURL"]').text();

			// Selecting one message

			this.trigger( 'selectedMessage.messages', {
				messageID: messageID,
				messageURL: messageURL,
				messageTitle: messageTitle
			});

			this.trigger('switchTo.filterBar', {
				switchTo: 'filterContent'
			});

			this._selectMessage( messageID );
		},
		
		/**
		 * Event handler for when a new message is sent
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		newMessage(e, data) {
			this._updateRow( data.feedID.substr( data.feedID.indexOf('-') + 1 ) );
		},
		
		/**
		 * Event handler for when a message is deleted
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		deletedMessage(e, data) {
			var feedId = $(e.target).closest('[data-feedid]').attr('data-feedid');	
			this._updateRow( feedId.substr( feedId.indexOf('-') + 1 ) );
		},
		
		/**
		 * Refresh row in list
		 *
		 * @param	{int}	conversationId	The conversation ID
		 * @returns	{void}
		 */
		_updateRow: function(conversationId) {
			var scope = $(this.scope);
			ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=messaging&controller=messenger&id=' + conversationId + '&getRow=1' ).done(function(response){
				scope.find('[data-messageid="'+conversationId+'"]').replaceWith( response );
				$( document ).trigger( 'contentChange', [ scope ] );
			});
		},

		/**
		 * Event handler for the 'sort' menu
		 * Triggers an event which loads new items into the list based on new sort order
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		changeSort(e, data = e.detail) {
			e.preventDefault();
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var sort = data.selectedItemID;

			if( sort ){
				/*this.trigger('loadFolder.messages', {
					sortBy: sort,
					folder: this._currentFolder,
					filterBy: this._currentOptions.filter,
				});*/

				this.trigger('changeSort.messages', {
					param: 'sortBy',
					value: sort
				});
			}
		},

		/**
		 * Event handler for the 'filter' menu
		 * Triggers an event which loads new items into the list based on the new filter
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		changeFilter(e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}
			
			var filter = data.selectedItemID;

			if( filter ){
				/*this.trigger('loadFolder.messages', {
					sortBy: this._currentOptions.sort,
					folder: this._currentFolder,
					filterBy: filter
				});*/

				this.trigger('changeFilter.messages', {
					param: 'filter',
					value: filter
				});
			}
		},

		/**
		 * Responds to URL state changes
		 * Checks whether the folder or current message ID has changed
		 *
		 * @returns 	{void}
		 */
		stateChange() {
			const state = ips.utils.history.getState('messages') || {}

			if (state.controller !== 'messages') {
				return;
			}

			let newFilters = false;

			if (typeof state.params === 'object' && ( state.params.sortBy !== this._currentOptions.sortBy || state.params.filter !== this._currentOptions.filter)) {
				this._currentOptions.sortBy = state.params.sortBy;
				this._currentOptions.filter = state.params.filter;

				newFilters = true;
			}

			if (state.folder !== this._currentFolder || newFilters) {
				this._getFolder( state.folder );
			}

			if (state.mid !== this._currentMessageID){
				if (Array.isArray( state.mid )) {
					this._selectMessages( state.mid );
				} else {
					this._selectMessage( state.mid );
				}
			}
		},
		
		/**
		 * Internal method which marks the message as read
		 *
		 * @param 		{number} 	id 		ID of message to highlight
		 * @returns 	{void}
		 */
		markMessageRead: function( e, data ) {
			//this._messageList.find('[data-messageid="' + data.id + '"] a.cMessageTitle').removeClass('cMessageTitle_unread');
			this._messageList.find('[data-messageid="' + data.id + '"]').removeAttr('data-ips-unread');
		},

		/**
		 * Starts a search by triggering on the model
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		_startSearch(e) {
			var serialized = ips.utils.form.serializeAsObject( $('[data-role="messageSearch"]') );
			
			// If we deleted the search term, treat that the same as if we clicked the 'x' icon
			if( !serialized.q.length )
			{
				this.cancelSearch();
				return;
			}

			// If we deleted the search term, treat that the same as if we clicked the 'x' icon
			if( !serialized.q.length )
			{
				this.cancelSearch();
				return;
			}

			var gotSomething = false;
			_.each( [ 'topic', 'post', 'recipient', 'sender' ], function( item ) {
				if ( _.has( serialized.search, item ) ) {
					gotSomething = true;
				}
			} );
			
			if ( ! gotSomething ) {
				var self = this;
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: ips.getString('messageSearchFail'),
					subText: ips.getString('messageSearchFailSubText'),
					callbacks: {
						ok() {
							self._resetSearch();
							return false;
						}
					}
				});
			} else {
				this.trigger('searchFolder.messages', _.extend( {
					folder: this._currentFolder
				}, serialized ) );
			}
		},

		/**
		 * Resets changes made for searching
		 *
		 * @returns 	{void}
		 */
		_resetSearch() {
			// Reset the search box
			this.scope.find('[data-role="messageSearchText"]')
				.removeClass('ipsField_loading')
				.val('');

			// Hide the cancel button
			this.scope.find('[data-action="messageSearchCancel"]').attr('hidden', true);

			// Show the filter bar
			this.scope.find('[data-role="messageListFilters"]').removeAttr('hidden');

			// Reset page actions
			this._resetListActions();

			// Reset infinite scroll url
			this.scope.attr('data-ipsInfScroll', this._infScrollURL);
			this.scope.trigger('refresh.infScroll');
		},

		/**
		 * Internal method which highlights the message with the given ID
		 *
		 * @param 		{number} 	id 		ID of message to highlight
		 * @returns 	{void}
		 */
		_selectMessage(id) {
			this._messageList
				.find('[data-messageid]')
					.removeClass('ipsData__item--active')
				.end()
				.find('[data-messageid="' + id + '"]')
					.addClass('ipsData__item--active');
			
			this._currentMessageID = id;
		},

		/**
		 * Internal method which highlights multiple messages with the given IDs
		 *
		 * @param 		{array} 	IDs 	Array of IDs of messages to select
		 * @returns 	{void}
		 */
		_selectMessages(IDs) {
			var self = this;

			this._messageList
				.find('[data-messageid]')
					.removeClass('ipsData__item--active');

			_.each( IDs, function (id) {
				self._messageList
					.find('[data-messageid="' + id + '"]')
						.addClass('ipsData__item--active');
			});

			this._currentMessageID = IDs;
		},

		/**
		 * Internal handler which triggers an event to get the contents of a folder
		 *
		 * @param 		{string} 	newFolder 		ID of the new folder to get
		 * @returns 	{void}
		 */
		_getFolder( newFolder ) {
			this.trigger('loadFolder.messages', {
				folder: newFolder,
				filter: this._currentOptions.filter,
				sortBy: this._currentOptions.sortBy
			});
			
			this._currentFolder = newFolder;
		},

		/**
		 * Hides the 'no messages' text
		 *	
		 * @returns 	{void}
		 */
		_hideEmpty() {
			this.scope.find('[data-role="emptyMsg"]').hide();
		},

		/**
		 * Reset page action/auto check boxes
		 *	
		 * @returns 	{void}
		 */
		_resetListActions() {
			// Refresh the page action so it hides
			try {
				ips.ui.pageAction.getObj( this.scope.find('[data-ipsPageAction]') ).reset();
				ips.ui.autoCheck.getObj( this.scope.find('[data-ipsAutoCheck]') ).refresh();
			} catch (err) {}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/messages" javascript_name="ips.messages.main.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.main.js - Main messenger controller
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.messages.main', {

		_currentMessageID: null,
		_ready: {},
		_protectedFolders: ['myconvo'],
		_params: { 'sortBy': 'mt_last_post_time', 'filter': 'all' },
		_currentFolder: null,

		initialize() {
			// Main interface events
			this.on( 'menuItemSelected', '#elMessageFolders', this.changeFolder );
			this.on( 'menuItemSelected', '#elFolderSettings', this.folderAction );
			this.on( 'click', '[data-action="addFolder"]', this.addFolder );

			// Modal events
			this.on( document, 'addFolderLoading.messages renameFolderLoading.messages ' + 
						'markFolderLoading.messages emptyFolderLoading.messages ' +
						'deleteMessageLoading.messages deleteMessagesLoading.messages moveMessageLoading.messages ' +
						'deleteFolderLoading.messages', this.folderActionLoading );
			this.on( document, 'addFolderFinished.messages renameFolderFinished.messages ' + 
						'markFolderFinished.messages emptyFolderFinished.messages ' +
						'deleteMessageFinished.messages deleteMessagesFinished.messages moveMessageFinished.messages ' + 
						'deleteFolderFinished.messages', this.folderActionDone );

			this.on( document, 'deleteFolderDone.messages deleteMessageDone.messages deleteMessagesDone.messages ' +
						'emptyFolderDone.messages moveMessageDone.messages', this.updateCounts );
			//--
			this.on( document, 'addFolderDone.messages', this.addFolderDone );
			this.on( document, 'renameFolderDone.messages', this.renameFolderDone );
			this.on( document, 'markFolderDone.messages', this.markFolderDone );
			this.on( document, 'emptyFolderDone.messages', this.emptiedFolder );
			this.on( document, 'deleteFolderDone.messages', this.deletedFolder );

			// Events from the list
			this.on( 'setInitialMessage.messages', this.setInitialMessage );
			this.on( 'setInitialFolder.messages', this.setInitialFolder );
			this.on( 'changeSort.messages changeFilter.messages', this.updateParam );
			this.on( 'input', '[data-role="moderation"]', this.moderationInput );
			this.applyModMenuSelection();

			//this.on( 'selectMessage.messages', this.selectMessage );
			this.on( 'loadMessage.messages', this.loadMessage );

			// Events from the view
			this.on( 'changePage.messages', this.changePage );

			// Document events
			this.on( document, 'controllerReady', this.controllerReady );
			this.on( document, 'openDialog', '#elAddFolder', this.addFolderDialogOpen );
			this.on( document, 'openDialog', '#elFolderRename', this.renameFolderDialogOpen );

			// Primary event that watches for URL changes
			this.on( window, 'historychange:messages', this.stateChange );
		},

		/**
		 * Responds to sub-controllers indicating they are initialized
		 * Allows us to check all sub-controllers are initialized before going any further
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		controllerReady(e, data) {
			this._ready[ data.controllerType ] = true;

			if( this._ready['messages.list'] && this._ready['messages.view'] &&
					data.controllerType == 'core.front.messages.list' || data.controllerType == 'core.front.messages.view' ){
				this.trigger('messengerReady.messages');
			}
		},

		/**
		 * Responds to an event from the list controller informing us of the initial message ID that's selected
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		setInitialMessage(e, data) {
			this._currentMessageID = data.messageID;
		},

		/**
		 * Responds to an event from the list controller informing us of the initial folder ID
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		setInitialFolder(e, data) {
			Debug.log( data );
			this._currentFolder = data.folderID;
		},

		/**
		 * Responds to event from view controller indicating the message page has changed (from pagination)
		 * Updates the URL with the new page number
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		changePage(e, data) {
			this._updateURL({
				id: data.id,
				page: data.pageNo
			}, {
				id: data.id, // reset message id
				page: data.pageNo
			});
		},

		/**
		 * Event handler for the folder action menu
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		folderAction(e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			if( this._currentFolder == null ){

			}

			// Can't delete or rename protected folders
			if( _.indexOf( this._protectedFolders, this._currentFolder ) !== -1 && 
					_.indexOf( ['delete', 'rename'], data.selectedItemID ) !== -1 ){
				return;
			}

			switch( data.selectedItemID ){
				case 'markRead':
					this._actionMarkRead( data );
				break;
				case 'delete':
					this._actionDelete( data );
				break;
				case 'empty':
					this._actionEmpty( data );
				break;
				case 'rename':
					this._actionRename( data );
				break;
			}
		},

		/**
		 * Event handler for all 'folder action' loading events
		 * Displays a loading thingy in the messenger header
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		folderActionLoading(e, data) {
			var loading = this.scope.find('[data-role="loadingFolderAction"]');
			ips.utils.anim.go( 'fadeIn', loading );
		},

		/**
		 * Event handler for all 'folder action' loading done events
		 * Hides the loading thingy
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		folderActionDone(e, data) {
			var loading = this.scope.find('[data-role="loadingFolderAction"]');
			ips.utils.anim.go( 'fadeOut', loading );
		},

		/**
		 * Method to handle adding a folder
		 * Displays the dialog which contains the form
		 *	
		 * @param 		{Event} 	e 	Event object
		 * @returns 	{void}
		 */
		addFolder(e) {
			var button = $( e.currentTarget );

			if( ips.ui.dialog.getObj( button ) ){
				ips.ui.dialog.getObj( button ).show();
			} else {
				button.ipsDialog( {
					content: '#elAddFolder_content',
					title: ips.getString('addFolder'),
					size: 'narrow'
				});
			}
		},

		/**
		 * Responds to event from modal indicating a new folder has been added
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		addFolderDone(e, data) {
			var newItem = ips.templates.render('messages.main.folderMenu', {
				key: data.key,
				count: 0,
				name: data.folderName
			});

			// Find last menu item
			$('#elMessageFolders_menu')
				.find('[data-role="folderInMenu"]')
					.last()
					.after( newItem );
				
			// Browse to new folder
			$('#elMessageFolders_menu [data-ipsMenuValue="' + data.key + '"]')[0].dispatchEvent(new Event("click", {bubbles: true}));
		},

		/**
		 * Responds to event from modal indicating a folder has been renamed
		 * Updates the relevant menu item, and main messenger title
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		renameFolderDone(e, data) {
			var realFolderName = this._getRealFolder( data.folder );

			// Rename the menu item
			$('#elMessageFolders_menu')
				.find('[data-ipsMenuValue="' + data.folder + '"]')
					.find('[data-role="folderName"]')
						.text( data.folderName );

			// Rename the main title
			this.scope
				.find('[data-role="currentFolder"]')
					.text( data.folderName );

			// Show message
			ips.ui.flashMsg.show( ips.getString('renamedTo', {
				folderName: realFolderName,
				newFolderName: data.folderName
			}) );
		},

		/**
		 * Responds to modal event indicating a folder is marked read
		 * Displays a message box
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		markFolderDone(e, data) {
			var realFolderName = this._getRealFolder( data.folder );
			ips.ui.flashMsg.show( ips.getString('messengerMarked', {
				folderName: realFolderName
			}) );
		},

		/**
		 * Responds to modal event indicating a folder has been emptied
		 * Updates the count value in the folder menu
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		emptiedFolder(e, data) {
			var menuItem = $('#elMessageFolders_menu').find('[data-ipsMenuValue="' + data.folder + '"]');
			menuItem.find('.ipsMenu_itemCount').html('0');

			this.trigger( 'loadFolder', {
				folder: this._currentFolder,
				sortBy: this._params['sortBy'],
				filter: this._params['filter']
			});
		},

		/**
		 * Responds to modal event indicating a folder has been deleted
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		deletedFolder(e, data) {
			// Remove the folder from the folder list, then click the myconvos folder to load it.
			// Our event handlers will handle it from there.
			this.scope
				.find('#elMessageFolders_menu')
					.find('[data-ipsMenuValue="' + data.folder + '"]')
						.remove();
			
			this.scope.find('[data-ipsMenuValue="myconvo"]')[0].dispatchEvent(new Event("click", {bubbles: true}));

			// Show a flash message
			ips.ui.flashMsg.show( ips.getString('folderDeleted') );
		},

		/**
		 * Responds to the list event triggered when a new message needs to be loaded
		 * Updates the URL with the new message ID
		 * The view controller handles actually loading the message from the modal
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		loadMessage(e, data) {
			if( !data.messageID ){
				return;
			}

			this._newMessageID = data.messageID;
			this._updateURL( {
				id: data.messageID,
				url: data.messageURL
			}, {}, data.messageTitle );
		},

		/**
		 * Responds to the list event informing us that a sort/filter param has changed
		 * Stores this for later use in URL updates
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		updateParam(e, data) {
			if( !_.isUndefined( data.param ) && !_.isUndefined( data.value ) ){
				this._params[ data.param ] = data.value;
			}

			this._updateURL( false, this._params );
		},

		/**
		 * Event handler for the folder navigation menu
		 * Updates the URL with the new folder ID so we can navigate to a new folder
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		changeFolder(e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var folderID = data.selectedItemID;
			var folderURL = $(data.menuElem).find('[data-ipsMenuValue="' + data.selectedItemID + '"] a').attr('href');
			var folderName = $(data.menuElem).find('[data-ipsMenuValue="' + data.selectedItemID + '"]').find('[data-role="folderName"]').text();

			if( _.isUndefined( folderID ) ){
				return;
			}

			this._currentMessageID = null;

			this.scope.find('[data-ipsFilterBar]').trigger('switchTo.filterBar', {
				switchTo: 'filterBar'
			});

			this._updateURL( _.extend( { 
				folder: folderID,
				url: folderURL
			}, this._params ), {
				folder: folderID,
				id: null, // reset message id
				page: null
			}, folderName );
		},

		/**
		 * Handles an event.openDialog event for the add folder dialog
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		addFolderDialogOpen(e, data) {
			$( data.dialog )
				.find('input[type="text"]')
					.attr('data-folderID', this._currentFolder )
					.val('')
					.focus();
		},

		/**
		 * Handles an event.openDialog event for the rename folder dialog
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		renameFolderDialogOpen(e, data) {
			var realFolderName = this._getRealFolder( this._currentFolder );
			$( data.dialog )
				.find('[data-role="folderName"]')
					.attr('data-folderID', this._currentFolder )
					.val( _.unescape( realFolderName ) )
					.focus();
		},

		/**
		 * Responds to URL state changes
		 * Check whether the folder has changed, and load a new one if necessary
		 *	
		 * @returns 	{void}
		 */
		stateChange() {
			const state = ips.utils.history.getState('messages')
			// Folder change?
			if (state?.controller === 'messages' && state.folder !== this._currentFolder) {
				this._updateFolder(state.folder);
			}
		},

		/**
		 * Updates the browser URL
		 *	
		 * @param 		{object} 	urlParams 		Values which will be inserted into the URL
		 * @param 		{object} 	newValues 		Values which will be passed into the data object stored with the state
		 * @returns 	{void}
		 */
		_updateURL(urlParams, newValues, newTitle) {
			let url = '';
			const title = newTitle || document.title;

			if( urlParams === false ){
				url = window.location.href;
				if ( window.location.hash ) {
					url = url.substr( 0, url.length - window.location.hash.length );
				}
			} else if( urlParams.url ){
				url = urlParams.url;
			} else {
				url = [];

				url.push( '?app=core&module=messaging&controller=messenger' );

				_.each( urlParams, function (value, idx) {
					if( idx != 'page' || ( idx == 'page' && value != 1 ) ){
						url.push( idx + "=" + value );
					}
				});

				url = url.join('&');
			}

			const defaultObj = {
				id: this._newMessageID,
				folder: this._currentFolder,
				params: this._params,
				controller: 'messages',
			};

			ips.utils.history.pushState(
				{
					...defaultObj,
					...(newValues || {})
				},
				'messages',
				url
			);
			document.title = title
		},

		/**
		 * Updates the quota progressbar and tooltip, and the folder counts
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		updateCounts(e, data) {
			// Update quota tooltip text and width
			this.scope
				.find('[data-role="quotaTooltip"]')
					.attr('data-ipsTooltip-label', data.quotaText )
					.find('[data-role="quotaWidth"]')
					.val(parseInt(data.quotaPercent))
					.end()
					.find('[data-role="quotaValue"]')
						.text( parseInt( data.quotaPercent ) );
			
			// Update folder counts
			$('#elMessageFolders_menu').find('[data-ipsMenuValue]').each( function () {
				if( data.counts )
				{
					$( this ).find('.ipsMenu_itemCount').text( parseInt( data.counts[ $( this ).attr('data-ipsMenuValue') ] ? data.counts[ $( this ).attr('data-ipsMenuValue') ] : '0' ) );
				}
			});
		},

		/**
		 * Handles changing to a new folder.
		 * Updates the name of the folder in the header, and enables/disables action menu options as needed
		 * Actually loading a new folder is handled in the list/view controllers
		 *	
		 * @param 		{string} 	newFolder 		New folder name
		 * @returns 	{void}
		 */
		_updateFolder(newFolder) {

			var folderName = $('[data-ipsMenuValue="' + newFolder + '"]').find('[data-role="folderName"]').text();
			var self = this;

			// Remove all disabled states
			$('#elFolderSettings_menu')
				.find('[hidden]')
				.removeAttr('hidden');

			// Update the settings menu URLs with the new folder (the JS handles the correct ajax URL, but
			// updating it here prevents any issues if there's a JS error)
			$('#elFolderSettings_menu a').each( function () {
				$( this ).attr( 'href', $( this ).attr('href').replace( '&folder=' + self._currentFolder, '&folder=' + newFolder ) );
			});

			// See if we need to apply them again
			if( _.indexOf( this._protectedFolders, newFolder ) !== -1 ){
				$('#elFolderSettings_menu')
					.find('[data-ipsMenuValue="delete"], [data-ipsMenuValue="rename"]')
						.attr('hidden', true);
			}

			// Update folder name
			this.scope.find('[data-role="currentFolder"]').text( folderName );

			this._currentFolder = newFolder;
		},

		/**
		 * Method to handle folder renaming
		 * Displays the dialog which contains the form
		 *	
		 * @param 		{object} 	data 	Event data object from this.folderAction
		 * @returns 	{void}
		 */
		_actionRename(data) {
			var dialog = $('#elFolderSettings_menu').find('[data-ipsMenuValue="rename"]');

			if( ips.ui.dialog.getObj( dialog ) ){
				ips.ui.dialog.getObj( dialog ).show();
			} else {
				dialog.ipsDialog( {
					content: '#elFolderRename_content',
					title: ips.getString('renameFolder'),
					size: 'narrow'
				});
			}
		},

		/**
		 * Method to handle folder deleting
		 *	
		 * @param 		{object} 	data 	Event data object from this.folderAction
		 * @returns 	{void}
		 */
		_actionDelete(data) {
			var self = this;

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('messengerDeleteConfirm'),
				subText: ips.getString('cantBeUndone'),
				callbacks: {
					ok() {
						self.trigger( 'deleteFolder.messages', {
							folder: self._currentFolder
						});
					}
				}
			});
		},

		/**
		 * Method to handle marking a folder as reason
		 * Displays a confirmation box, and on success triggers an event for the modal
		 *	
		 * @param 		{object} 	data 	Event data object from this.folderAction
		 * @returns 	{void}
		 */
		_actionMarkRead(data) {
			var realFolderName = this._getRealFolder( this._currentFolder );
			var self = this;
			
			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('messengerMarkRead', {
					folderName: realFolderName
				}),
				callbacks: {
					ok() {
						self.trigger( 'markFolder.messages', {
							folder: self._currentFolder
						});
					}
				}
			});	
		},

		/**
		 * Method to handle folder emptying
		 * Displays a confirmation box, and on success triggers an event for the modal
		 *	
		 * @param 		{object} 	data 	Event data object from this.folderAction
		 * @returns 	{void}
		 */
		_actionEmpty(data) {
			var realFolderName = this._getRealFolder( this._currentFolder );
			var self = this;

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('messengerDeleteContents', {
					folderName: realFolderName
				}),
				subText: ips.getString('cantBeUndone'),
				callbacks: {
					ok() {
						self.trigger( 'emptyFolder.messages', {
							folder: self._currentFolder
						});
					}
				}
			});		
		},

		/**
		 * Returns the real folder name based on the folder key
		 *	
		 * @param 		{string} 	folder 		Folder key
		 * @returns 	{string} 	Real folder name
		 */
		_getRealFolder(folder) {
			var menuItem = $('#elMessageFolders_menu').find('[data-ipsMenuValue="' + folder + '"]');
			return menuItem.find('[data-role="folderName"]').html();
		},

		/**
		 * Store the moderation details
		 * @param {Event} e
		 */
		moderationInput(e) {
			const currentData = ips.utils.db.get('messages', 'mod_menu_checked') || {};
			const id = e.target.name;
			if (!id) {
				return;
			}
			if (e.target.checked) {
				currentData[id] = e.target.dataset.actions || "";
			} else {
				delete currentData[id];
			}

			ips.utils.db.set('messages', 'mod_menu_checked', currentData);
		},

		applyModMenuSelection() {
			const currentData = ips.utils.db.get('messages', 'mod_menu_checked');
			const pageAction = this.elem.querySelector('[data-ipspageaction]');
			if (pageAction && currentData && typeof currentData === "object" && Object.keys(currentData).length) {
				const messageSelector = [...Object.keys(currentData)]
					.map(id => `[name="${id}"]`)
					.join(',');

				const remainingIds = new Set(Object.keys(currentData));
				this.elem
					.querySelectorAll(`input[data-role="moderation"]:is(${messageSelector})`)
					.forEach(el => {
						remainingIds.delete(el.name);
						el.checked = true;
						$(el).trigger('change');
					});

				if (remainingIds.size) {
					remainingIds.forEach(id => {
						$(pageAction).trigger("addManualItem.pageAction", {
							id: id,
							actions: typeof currentData[id] === "string" ? currentData[id] : ''
						})
					});

					$(this.elem.querySelector('[data-ipsautocheck]')).trigger('setInitialCount.autoCheck', {count: remainingIds.size})
				}
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/messages" javascript_name="ips.messages.view.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.view.js - Controller for message view pane in messenger
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.messages.view', {

		_currentMessageID: null,
		_currentPage: 1,

		initialize() {
			// Events from within
			this.on( 'paginationClicked paginationJump', this.paginationClicked );
			this.on( 'addToCommentFeed', this.addToCommentFeed );
			this.on( 'deletedComment.comment', this.deleteComment );

			this.on( document, 'menuItemSelected', '#elConvoMove', this.moveConversation );
			this.on( document, 'click', '[data-action="deleteConversation"]', this.deleteConversation );

			this.on( document, 'menuItemSelected', '[data-role="userActions"]', this.userAction );

			this.on( 'submit', '[data-role="addUser"]', this.addUsersSubmit );

			// Events bubbled from the list
			this.on( document, 'selectedMessage.messages', this.selectedMessage );
			this.on( document, 'setInitialMessage.messages', this.setInitialMessage );

			// Events from the main controller
			this.on( document, 'getFolder.messages', this.getFolder );

			// Model events
			this.on( document, 'loadMessageLoading.messages', this.loadMessageLoading );
			this.on( document, 'loadMessageDone.messages', this.loadMessageDone );
			this.on( document, 'deleteMessageDone.messages', this.deleteMessageDone );
			this.on( document, 'blockUserDone.messages', this.blockUserDone );
			this.on( document, 'addUserDone.messages', this.addUserDone );
			this.on( document, 'addUserError.messages', this.addUserError );

			// Primary event that watches for URL changes
			this.on( window, 'historychange:messages', this.stateChange );
			this.setup();

		},
		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup() {
			if ( this.scope.attr('data-current-id') )
			{
				this._currentMessageID = this.scope.attr('data-current-id');
			}
		},

		/**
		 * A reply to the conversation
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data	Data object	from model
		 * @returns 	{void}
		 */
		addToCommentFeed(e, data) {
			if( data.totalItems ){
				this.trigger( 'updateReplyCount.messages', {
					messageID: this._currentMessageID,
					count: data.totalItems
				});
			}
		},

		/**
		 * Adding a user to the conversation failed
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data	Data object from model
		 * @returns 	{void}
		 */
		addUserError(e, data) {
			if( data.error ){
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: data.error,
					callbacks: {}
				});
			}
		},

		/**
		 * One or more users have been added to this conversation
		 * Inserts or replaces new HTML in the participants list and shows a flashMsg
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data	Data object	from model
		 * @returns 	{void}
		 */
		addUserDone(e, data) {
			if( data.id !== this._currentMessageID ){
				return;
			}

			if( data.error ){
				ips.ui.alert.show( {
					type: 'alert',
					icon: 'warn',
					message: data.error,
					callbacks: {}
				});
				return;
			}

			const numberMembers = _.size(data.members);

			if( data.members && numberMembers ){
				for(const i in data.members ){
					const participant = this.scope.find('.cMessage_members').find('[data-participant="' + i + '"]');

					Debug.log('Ajax response:');
					Debug.log( data.members[ i ] );

					// If this user already exists, replace them
					if( participant.length ){
						participant.replaceWith( data.members[ i ] );	
					} else {
						// New record, so append it
						this.scope.find('.cMessage_members [data-role="addUserItem"]').before( data.members[ i ] );
					}					
				}
			}

			let message = ips.getString('messageUserAdded');

			if( numberMembers > 1 ){
				message = ips.pluralize( ips.getString( 'messageUsersAdded' ), numberMembers );
			}

			ips.ui.flashMsg.show( message );

			if( data.failed && parseInt( data.failed ) > 0 ){
				ips.ui.flashMsg.show( ips.getString('messageNotAllUsers') );
			}

			// Hide the 'add' menu
			const menu = this.scope.find('#elInviteMember' + this._currentMessageID + '_menu');
			if(menu[0].matches("[popover]")){
				menu[0].hidePopover();
			}

			// Clear the autocomplete
			var autocomplete = ips.ui.autocomplete.getObj( this.scope.find('textarea[name="member_names"]') );

			autocomplete.removeAll();
		},

		/**
		 * Event handler for submitting the 'invite users' form
		 * Triggers the addUser event
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		addUsersSubmit(e) {
			e.preventDefault();

			const names = $(e.currentTarget).find('[name="member_names"]').val();

			this.trigger( 'addUser.messages', {
				id: this._currentMessageID,
				names: names
			});
		},

		/**
		 * The model has blocked a user
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data 	Data object	from model
		 * @returns 	{void}
		 */
		blockUserDone(e, data) {
			if( data.id != this._currentMessageID ){
				return;
			}

			// Find participant & replace
			var participant = this.scope.find('.cMessage_members').find('[data-participant="' + data.member + '"]');
			participant.replaceWith( data.response );

			ips.ui.flashMsg.show( ips.getString('messageRemovedUser') );
		},

		/**
		 * Event handler for the user actions menu
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data	Data object	from model
		 * @returns 	{void}
		 */
		userAction(e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var userID = $( data.triggerElem ).closest('[data-participant]').attr('data-participant');

			switch( data.selectedItemID ){
				case 'block':
					this.trigger('blockUser.messages', {
						member: userID,
						id: this._currentMessageID
					});
				break;
				case 'unblock':
					this.trigger('addUser.messages', {
						member: userID,
						id: this._currentMessageID,
						unblock: true
					});
				break;
			}
		},

		/**
		 * The model has deleted a message. If it's the one we're viewing, then remove the content and
		 * show the placeholder.
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data	Data object	from model
		 * @returns 	{void}
		 */
		deleteMessageDone(e, data) {
			var url = ipsSettings['baseURL'] + '?app=core&module=messaging&controller=messenger'
			window.location = url;
		},

		/**
		 * Event handler for selecting a folder into which this conversation will be moved
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @param 		{object} 	data	Data object	from menu widget
		 * @returns 	{void}
		 */
		moveConversation(e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var self = this;

			// Get real name of folder
			var realName = $('#elConvoMove_menu').find('[data-ipsMenuValue="' + data.selectedItemID + '"] a').html();

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('conversationMove', { name: realName } ),
				callbacks: {
					ok() {
						self.trigger( 'moveMessage.messages', { 
							id: self._currentMessageID,
							folder: data.selectedItemID
						});
					}
				}
			});
		},

		/**
		 * Event handler for clicking the delete conversation button.
		 * Confirms the user actually wants to delete it
		 *
		 * @param 		{Event} 	e 		Event object	
		 * @returns 	{void}
		 */
		deleteConversation(e) {
			e.preventDefault();

			var self = this;

			ips.ui.alert.show( {
				type: 'confirm',
				icon: 'question',
				message: ips.getString('messagesDelete'),
				subText: ips.getString('messagesDeleteSubText'),
				callbacks: {
					ok() {
						self.trigger( 'deleteMessage.messages', { 
							id: self._currentMessageID
						});
					}
				}
			});
		},

		/**
		 * Responds to the model loading message event
		 * Shows the loading thingy in the message pane
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		loadMessageLoading(e, data) {
			this.cleanContents();
			this.scope.html( 
				$('<div/>')
					.addClass('ipsLoading')
					.html('&nbsp;')
					.css( { minHeight: '150px' } )
			);
		},

		/**
		 * Responds to the model loaded message event
		 * Displays the loaded message in the message pane
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		loadMessageDone(e, data) {
			//this.cleanContents();
			this.scope.html( data.response );
			$( document ).trigger( 'contentChange', [ this.scope ] );
		},

		/**
		 * Responds to pagination event in conversation
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		paginationClicked(e, data){
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			/*this.trigger('changePage.messages', {
				pageNo: data.pageNo,
				perPage: data.perPage,
				id: this._currentMessageID
			});*/
		},

		/**
		 * Responds to event from main messages controller, informing us a message (or messages)
		 * have been selected. For a single message, we emit an event here to load the contents
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		selectedMessage(e, data) {
			//if( _.isArray( data.messageID ) ){
				//this.scope.html('');
			//} else {
				this.trigger( 'loadMessage.messages', { 
					messageID: data.messageID,
					messageURL: data.messageURL,
					messageTitle: data.messageTitle
				});
			//}

			this._currentMessageID = data.messageID;
		},

		/**
		 * Responds to the browser url changing
		 * We're only interested in watching for the message ID here. If it changes, we fetch a new message
		 *	
		 * @returns 	{void}
		 */
		stateChange() {
			const state = ips.utils.history.getState('messages');
			if (state?.controller !== 'messages') {
				return;
			}

			if (state.id == null) {
				this.cleanContents();
				this.scope.html( ips.templates.render('messages.view.placeholder') );

				// Reset values
				this._currentMessageID = null;
				this._currentPage = null;
				return;
			}

			if (state.id !== this._currentMessageID) {
				// Get message from le model
				this.trigger( 'fetchMessage.messages', {
					id: state.id,
					page: state.page || 1
				});

				// Track page view
				ips.utils.analytics.trackPageView( window.location.href );

				// Reset values
				this._currentMessageID = state.id;
				this._currentPage = state.page || 1;
			} else if (state.page !== this._currentPage) {
				this.trigger( 'fetchMessage.messages', {
					id: this._currentMessageID,
					page: state.page
				});

				this._currentPage = state.page;
			}
		},

		/**
		 * Responds to an event from the main controller letting us know the initially-selected message ID
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		setInitialMessage(e, data) {
			this._currentMessageID = data.messageID;
		},

		/**
		 * Responds to an event from the main controller indicating the selected folder has changed
		 * We remove any message present and replace it with the placeholder
		 *
		 * @returns 	{void}
		 */
		getFolder() {
			this.cleanContents();
			this.scope.html( ips.templates.render('messages.view.placeholder') );
			ips.utils.anim.go( 'fadeIn', this.scope );
		},
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.announcementForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://invisioncommunity.com
 *
 * ips.modcp.announcementForm.js - Controller for the announcement add/edit form
 *
 * Author: Stuart Silvester
 */
;( function($, _, undefined){
    "use strict";

    ips.controller.register('core.front.modcp.announcementForm', {

        _lastValue: '',
        _textField: null,
        _timer: 0,

        initialize: function () {

            this._textField = $('#elInput_announce_url');
			this.on( 'blur', '#elInput_announce_url', this.fieldKeyUp );
        },

        fieldKeyUp: function() {
			// Reset timer
			clearTimeout( this._timer );
			this._timer = setTimeout( _.bind( this._checkPermissions, this ), 700 );
        },

        _checkPermissions: function () {
            var value = this._textField.val().trim();

            // Must have more than 3 characters
            if( value.length < 3 )
            {
                return;
            }


            ips.getAjax()('?app=core&module=system&controller=announcement&do=permissionCheck', {
                dataType: 'json',
                data: {
                    url:  value
                }
            }).done( function (response) {

                // Remove any current warning if the latest response doesn't have one
                if( _.isUndefined( response.html ) && $('#elAnnouncementGroupWarning').length )
                {
					$('#elAnnouncementGroupWarning').remove();
                }

                // Replace existing, or create warning
                if( $('#elAnnouncementGroupWarning').length )
                {
                    $('#elAnnouncementGroupWarning').replaceWith( response.html );
                }
                else
                {
                    $( response.html ).insertAfter( '#elInput_announce_url' );
                }
            }).fail( function (err) {
				// fail gets called when it's aborted, so deliberately do nothing here
			});
        }

    });
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.approveQueue.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.approveQueue.js - Controller for using approval queue
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.modcp.approveQueue', {
	
		initialize: function () {
			this.on( 'click', '[data-action="approvalQueueAction"]', this.doConfirm );
		},
		
		/**
		 * Confirm
		 *
		 * @param 		{event} 	e	Event object
		 * @param		{object}	data	Event data
		 * @returns 	{void}
		 */
		doConfirm: function(e,data) {
			e.preventDefault();
			
			var self = this;
			var action = $( e.currentTarget ).attr('data-type');
			
			if( action !== 'delete' )
			{
			    self.doAction( e, data );
			    return;
			}
			
			var alert = {
				type: 'confirm',
				icon: 'warn',
				message: ips.getString('generic_confirm'),
				subText: '',
				callbacks: {
					ok: function () {
						self.doAction( e, data );
					},
					no: function () {
						return;
					}
				}
			};
			
			ips.ui.alert.show( alert );
		},
		
		/**
		 * Respond when an action button is clicked
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Event data
		 * @returns 	{void}
		 */
		doAction: function(e,data) {
			e.preventDefault();
			var element = $( e.target ).closest( 'a');

			ips.getAjax()( $( element ).attr('href') + '&_fromApproval=1', { bypassRedirect: true } )
				.done(function(){
					ips.getAjax()( ips.getSetting( 'baseURL' ) + '?app=core&module=modcp&controller=modcp&tab=approval&action=getCount' )
						.done(function(response){
							$('#elModCPApprovalCount').html( response.total );
							$(element).parents('[data-role="approvalItem"]').slideUp("slow", function() {
								$(this).remove();
							});
						})
						.fail(function(failresponse){
							window.location = ips.getSetting( 'baseURL' ) + '?app=core&module=modcp&controller=modcp&tab=approval';
						});
				})
				.fail(function(){
					window.location = $( e.currentTarget ).attr('href');
				});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.report.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.report.js - Controller for viewing a report
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.modcp.report', {
	
		initialize: function () {
			this.on( document, 'submitDialog', '[data-role=&quot;warnUserDialog&quot;]', this.dialogSubmitted );
			this.on( 'menuItemSelected', this.menuItemSelected );
		},
		
		/**
		 * Respond when a menu item is selected
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Event data
		 * @returns 	{void}
		 */
		menuItemSelected: function(e, data = e.detail) {
			data.originalEvent.preventDefault();

			var link = $(data.menuElem).find('[data-ipsMenuValue=&quot;' + data.selectedItemID + '&quot;] a');
			var langString = ( data.selectedItemID == 'spamFlagButton' ) ? ips.getString( 'confirmFlagAsSpammer' ) : ips.getString( 'confirmUnFlagAsSpammer' );
			var descString = ( data.selectedItemID == 'spamUnFlagButton' ) ? ips.getString( 'confirmUnFlagAsSpammerDesc' ) : '';
			var self = this;

			if( data.selectedItemID == 'spamFlagButton' || data.selectedItemID == 'spamUnFlagButton' ){
				ips.ui.alert.show({
					type: 'confirm',
					message: langString,
					subText: descString,
					callbacks: {
						ok: function () {
							self._startLoading();

							ips.getAjax()( link.attr('href'), {
								bypassRedirect: true
							} )
								.done( function (response) {
									self._refreshPanel();
								});
						},
					}
				});
			}
		},
		
		/**
		 * Respond when a dialog is submitted
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Event data
		 * @returns 	{void}
		 */
		dialogSubmitted: function(e, data) {
			this._startLoading();
			this._refreshPanel();
		},
		
		/**
		 * Start Loading
		 */
		_startLoading: function() {
			this.scope
				.find('[data-role=&quot;authorPanel&quot;]')
					.css( 'height', this.scope.find('[data-role=&quot;authorPanel&quot;]').height() + 'px' )
					.addClass('ipsLoading')
					.find('*')
						.hide();
		},
		
		/**
		 * Refresh Panel
		 */
		_refreshPanel: function() {
			var self = this;
			ips.getAjax()( window.location, {
				bypassRedirect: true
			} )
				.done( function(response){
					self.scope
						.find('[data-role=&quot;authorPanel&quot;]')
							.css( 'height', 'auto' )
							.removeClass('ipsLoading')
							.html( response );
				} );
		}
		
	});
}(jQuery, _));
</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.reportList.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.reportList.js - Report list controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.modcp.reportList', {

		initialize: function () {
			this.on( 'menuItemSelected', '[data-action=&quot;changeStatus&quot;]', this.changeReportStatus );
			this.on( 'menuItemSelected', '[data-role=&quot;filterButton&quot;]', this.filterList );
		},

		/**
		 * When a reports status is changed, check whether the row needs changing
		 *
		 * @param 		{event} 	e 		Event object
		 * @param		{object}	data	Event data
		 * @returns 	{void}
		 */
		changeReportStatus: function (e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var row = $( e.currentTarget ).closest('.ipsData__item');

			row.removeClass('ipsData__item--warning');

			switch( data.selectedItemID ){
				case '1':
					// row.addClass('ipsData__item--new');
				break;
				case '2':
					row.addClass('ipsData__item--warning');
				break;
			}
		},

		filterList: function( e, data = e.detail ){
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			var filter = data.selectedItemID || '';
			var container = $( this.scope ).find( '[data-baseUrl]' );
			ips.getAjax()( $( container ).data( 'baseUrl' ), {
				data: {
					filter: filter
				}
			})
				.done( function( response ){
					$( container ).replaceWith( response );
					$( document ).trigger( 'contentChange', [ container ] );
				});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.reportToggle.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.reportToggle.js - Controller for report toggling
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.modcp.reportToggle', {

		initialize: function () {
			this.on( 'click', '[data-action="_ipsMenu_ping"]', this.reportToggleClicked );
		},

		/**
		 * Shows an alert before changing the status of a report
		 *
		 * @param 	{Event} 	e 	Event object
		 * @returns {void}
		 */
		reportToggleClicked: function (e) {
			e.preventDefault();
			var elem = $( e.currentTarget );
			// var self = this;
			// var menuButton = this.scope.find('[data-action="menubutton"]');

			var reportId = this.scope.find('[data-reportId]').attr('data-reportId');
			var newStatus = $(elem).closest('[data-ipsMenuValue]').attr('data-ipsMenuValue');
			var newStatusText = $(elem).find('[data-role="ipsMenu_selectedText"]').text();
			if ( $(elem).attr('data-showconfirm') !== undefined ) {
				if ( $(elem).attr('data-hasNotifications') > 0 ) {
					/* Show an actual modal confirmation dialog via ajax with an optional message to send to the content author */
					var dialogRef = ips.ui.dialog.create({
						title: ips.getString('report_status_change_confirm', { newstatus: newStatusText}),
						size: 'narrow',
						url: '?app=core&module=modcp&controller=modcp&tab=reports&action=reportCenterConfirmModal&id=' + reportId + '&status=' + newStatus,
						forceReload: true
					});

					dialogRef.show();
				} else {
					ips.ui.alert.show({
						type: 'confirm',
						title: ips.getString('report_status_change_confirm', { newstatus: newStatusText}),
						icon: 'fa fa-question-circle',
						buttons: {
							ok: ips.getString('ok'),
							cancel: ips.getString('cancel')
						},
						callbacks: {
							ok: function () {
								// menuButton.addClass('ipsLoading ipsLoading_small');
								// menuButton.find('span').html('&nbsp;');
								$(elem).attr('data-action', 'ipsMenu_ping');
								$(elem)[0].dispatchEvent(new Event("click", {bubbles:true}));
							},
						}
					});
				}
			} else {
				// menuButton.addClass('ipsLoading ipsLoading_small');
				// menuButton.find('span').html('&nbsp;');
				$(elem).attr('data-action', 'ipsMenu_ping');
				$(elem)[0].dispatchEvent(new Event("click", {bubbles:true}));
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.warnForm.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.warnForm.js - Controller for the add warning form
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.modcp.warnForm', {
		pointsEdited: false,
		expirationEdited: false,
		editorSetTo: '',

		initialize() {
			this.on( 'change', '[name="warn_reason"]', this.changeReason ); 
			this.on( 'change', '[name="warn_points"]', this.changePoints );
			this.on( 'change', '[name="warn_remove"],[name="warn_remove_time"]', e =>{
				this.expirationEdited = true;
			} );
			this.on( 'editorWidgetInitialized', this.editorInitialized );
		},

		editorInitialized(e, data) {
			if( data.id === 'warn_member_note' ){
				$('[name="warn_reason"]').change(); // Set for initial value

				// check if we have a default note
				const editor = ips.ui.editorv5.getObj( $( 'textarea[name="warn_member_note"]' ).closest('[data-ipsEditorv5]') );
				this.editorSetTo = editor.getInstance().getHTML();
			}
		},
		
		/**
		 * Change reason handler
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		async changeReason(e) {
			const response = await ips.fetch( ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=warnings&do=reasonAjax&id=' + $( e.target ).val() )

			// If the points have been changed AND we can override the points, do not adjust
			if (!this.pointsEdited || !response.points_override)
			{
				const pointsNow = parseInt(this.scope.find('[name="warn_points"]').val());
				this.scope
					.find('[name="warn_points"]')
					.val( response.points )
					.prop( 'disabled', parseInt(response.points_override) === 0 );

				if (pointsNow !== response.points)
				{
					this.scope.find('[name="warn_points"]').change();
				}

				// Flag that we're back to default
				this.pointsEdited = false;
			}

			const removePointsUnlimited = this.scope.find('[name="warn_remove_unlimited"]');

			if (response.remove.unlimited) {
				if (!this.expirationEdited || !response.remove_override)
				{
					if( !removePointsUnlimited.prop( 'checked' ) )
					{
						if( removePointsUnlimited.prop('disabled') ){
							removePointsUnlimited.prop('disabled', false).click().prop('disabled', true);
						} else {
							removePointsUnlimited.click();
						}
					}
				}
			} else if( !this.expirationEdited || !response.remove_override) {
				removePointsUnlimited.prop( 'checked', false );
				this.scope.find('[name="warn_remove"]').val( response.remove.date ).prop( 'disabled', !response.remove_override );
				this.scope.find('[name="warn_remove_time"]').val( response.remove.time ).prop( 'disabled', !response.remove_override );
			}
			removePointsUnlimited.prop( 'disabled', !response.remove_override );

			const cheevPoints = this.scope.find('[name="warn_cheeve_point_reduction"]');
			if( !response.cheev_override ) {
				cheevPoints.prop('disabled', true);
			} else {
				cheevPoints.prop('disabled', false);
			}
			cheevPoints.val( response.cheev_point_reduction );

			const editor = ips.ui.editorv5.getObj( $( 'textarea[name="warn_member_note"]' ).closest('[data-ipsEditorv5]') );

			if( response.notes ){
				const currentContents = editor.getInstance().getHTML();
				const previousContents = this.editorSetTo;
				editor.unminimize(() => {
					if ( currentContents === previousContents ) {
						editor.reset();
					} else {
						editor.insertHtml('<p></p>');
					}
					editor.insertHtml( response.notes );
					this.editorSetTo = editor.getInstance().getHTML();
				});
			}

		},
		
		/**
		 * Change points handler
		 *	
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{Promise<void>}
		 */
		async changePoints(e) {
			this.pointsEdited	= true;

			const response = await ips.fetch( ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=warnings&do=actionAjax&points=' + $( e.target ).val() + '&member=' + this.elem.dataset.member );
			const types = [ 'mq', 'rpa', 'suspend' ];

			this.elem.querySelectorAll( 'ul#elWarningPenalties').forEach(e => e.remove());
			if (response.override) {
				this.elem.querySelectorAll( 'li#form_warn_punishment .ipsFieldRow__content' ).ipsShow();
			} else {
				this.elem.querySelectorAll( 'li#form_warn_punishment .ipsFieldRow__content' ).ipsHide();
				const enforcedPenalties = [];
				types.forEach(type => {
					if( parseInt( response.actions[ type ].unlimited ) ) {
						enforcedPenalties.push( ips.getString( 'warningPunishmentIndefinitely', { type: ips.getString( 'warningPunishment_' + type ) } ) );
					}
					else if( response.actions[ type ].date !== "" ) {
						const date = new Date( response.actions[ type ].date + ' ' + response.actions[ type ].time );
						enforcedPenalties.push( ips.getString( 'warningPunishmentDate', { type: ips.getString( 'warningPunishment_' + type ), date: ips.utils.time.localeDateString( date, { dateStyle: "long", timeStyle: "short" } ) } ) );
					}

					// uncheck checkbox to hide toggled on fields
					this.scope.find( '[name="warn_punishment[' + type + ']"]' ).prop( 'checked', false ).change();
				});

				// Generate penalty list
				this.scope.find( 'li#form_warn_punishment').append( ips.templates.render('system.warningpenalty.nomodify', { penalties: enforcedPenalties } ) );
			}

			types.forEach(type => {
				// Only check this checkbox if it can be overridden
				if (parseInt(response.override)) {
					this.scope.find( '[name="warn_punishment[' + type + ']"]' ).prop( 'checked', ( response.actions[ type ].date || response.actions[ type ].unlimited ) ).change();
				}
				this.scope.find( '[name="warn_' + type + '"]' ).val( response.actions[ type ].date ).prop( 'disabled', !parseInt( response.override ) );
				this.scope.find( '[name="warn_' + type + '_time"]' ).val( response.actions[ type ].time ).prop( 'disabled', !parseInt( response.override ) );
				this.scope.find( '[name="warn_' + type + '_unlimited"]' ).prop( 'checked', response.actions[ type ].unlimited ).prop( 'disabled', !parseInt( response.override ) );
			});
		}
		

	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/modcp" javascript_name="ips.modcp.warnPopup.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000250"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.modcp.warnPopup.js - Warning popup controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.modcp.warnPopup', {

		initialize: function () {
			this.on( 'click', '[data-action="revoke"]', this.revokeWarning );
		},

		/**
		 * Revoke warning
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		revokeWarning: function (e) {
			e.preventDefault();

			var url = $( e.currentTarget ).attr('href');

			ips.ui.alert.show( {
				type: 'verify',
				icon: 'question',
				message: ips.getString('revokeWarning'),
				buttons: {
					yes: ips.getString('reverseAndDelete'),
					no: ips.getString('justDelete'),
					cancel: ips.getString('cancel')
				},
				callbacks: {
					yes: function () {
						window.location = url + '&undo=1';
					},
					no: function () {
						window.location = url + '&undo=0';
					}
				}
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/profile" javascript_name="ips.profile.followers.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.profile.followers.js - Follower JS
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.profile.followers', {

		_feedID: null,

		initialize: function () {
			this.on( document, 'followingItem', this.followUser );
			this.on( 'menuItemSelected', "[data-role='followOption']", this.toggleFollowOption );
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */	 
		setup: function () {
			this._feedID = this.scope.attr('data-feedID');
		},

		/**
		 * Event handler for document-wide followingItem event
		 * Checks if the event is for this member (based on 'feedID'), and fetches new HTML
		 * for the followers block
		 *
		 * @param 	{event} 	Event object
		 * @param 	{object} 	Event data object
		 * @returns {void}
		 */	 
		followUser: function (e, data) {
			if( data.feedID != this._feedID ){
				return;
			}

			var self = this;
			var memberID = data.feedID.replace('member-', '');

			// Get the new followers
			// If there's an error we can just ignore it, it's not a big deal
			ips.getAjax()( ips.getSetting('baseURL') + 'index.php?app=core&module=members&controller=profile&do=followers&id=' + parseInt( memberID ) )
				.done( function (response) {
					self.scope.html( response );
				})
				.fail( function () {
					Debug.log('Error fetching follower HTML');
				});
		},

		/**
		 * Event handler for changing the follower preference (for profile owner)
		 *
		 * @param 	{event} 	Event object
		 * @param 	{object} 	Event data object
		 * @returns {void}
		 */	 
		toggleFollowOption: function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			var url = $(data.menuElem).find('[data-ipsMenuValue="' + data.selectedItemID + '"]').attr('href');

			// Ping
			ips.getAjax()( url )
				.done( function (response) {
					ips.ui.flashMsg.show( ips.getString('followerSettingToggled') );
				})
				.fail( function () {
					window.location = url;
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/profile" javascript_name="ips.profile.main.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.profile.main.js - Main profile wrapper
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.profile.main', {

		contentArea: null,
		lastType: null,

		/**
		 * Initialize controller events
		 * Sets up the events from the view that this controller will handle
		 *
		 * @returns 	{void}
		 */
		initialize() {
			this.on( 'click', '[data-action="goToProfile"]', this.changeType );
			this.on( 'click', '[data-action="browseContent"]', this.changeType );
			this.on( 'click', '[data-action="repLog"]', this.changeType );
			this.on( 'click', '[data-action="badgeLog"]', this.changeType );
			this.on( 'click', '[data-action="solutionLog"]', this.changeType );

			// Primary event that watches for URL changes
			this.on( window, 'historychange', this.stateChange );

			this.setup();
		},

		/**
		 * Try to see what the state of this is by the content in the DOM. It is not always going to be correct, but a good guess
		 *
		 * @return {"goToProfile"|"browseContent"|"repLog"|"solutionLog"|"badgeLog"}
		 * @private
		 */
		_getHistoryStateFromPage() {
			const elem = this.scope.get(0)

			const selectorMap = {
				browseContent: '#elUserContent',
				repLog: '#elUserReputation',
				badgeLog: '.cProfileBadgeGrid',
				solutionLog: '#elUserSolutions'
			}

			for (const state in selectorMap) {
				if (elem.querySelector(selectorMap[state])) {
					return state
				}
			}

			return "goToProfile"
		},

		/**
		 * Non-event-based setup
		 *
		 * @returns 	{void}
		 */
		setup() {
			this.contentArea = this.scope.find('[data-role="profileContent"]');
			this.contentHeader = this.scope.find('[data-role="profileHeader"]');

			if (!ips.utils.history.getState('profile')?.section) {
				ips.utils.history.replaceState({ section : this._getHistoryStateFromPage()}, 'profile', window.location.href);
			}

		},

		/**
		 * Called when browser navigation is invoked without triggering a true redirect
		 *
		 * @returns 	{void}
		 */
		stateChange(e) {
			if (e.detail?.type === 'load' || e.detail?.type === 'replace') {
				return
			}

			const url = window.location.href
			const data = ips.utils.history.getState('profile')

			// Only change the state if it's an actual change
			if (this._getHistoryStateFromPage() === data.section && data.section) {
				return
			}

			this.lastType = data.section;
			e?.stopPropagation?.()
			e?.stopImmediatePropagation?.()


			switch( data?.section ){
				case 'goToProfile':
					this._showProfile( url );
					break;
				case 'browseContent':
					this._showContent( url );
					break;
				case 'repLog':
				case 'solutionLog':
				case 'badgeLog':
					this._showGenericLog( url );
					break;
			}
		},

		/**
		 * User clicked something that changes the profile view
		 * Just change the URL, the state change handler does the rest
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		changeType(e) {
			e.preventDefault();
			let target = $( e.currentTarget );

			if( !target.is('a') ){
				target = target.find('a');
			}

			ips.utils.history.pushState({ section: $( e.currentTarget ).attr('data-action') }, 'profile', target.attr('href'));
			document.title = target.attr('title')
		},

		/**
		 * Shows the user's reputation or solution log
		 *
		 * @param 		{string} 	url 		URL to load the content
		 * @returns 	{void}
		 */
		_showGenericLog(url) {
			this._changeContent( true, url ).then(()=>{});
		},

		/**
		 * Shows the user's content
		 *
		 * @param 		{string} 	url 		URL to load the content
		 * @returns 	{void}
		 */
		_showContent(url) {
			this._changeContent( true, url ).then(()=>{});
		},

		/**
		 * Shows the user's profile
		 *
		 * @param 		{string} 	url 		URL to load the content
		 * @returns 	{void}
		 */
		_showProfile(url) {
			this._changeContent( false, url ).then(()=>{});
		},

		/**
		 * Changes the content in the content section
		 *
		 * @param 		{boolean} 	small 		Show the header in its minimal state?
		 * @param 		{string} 	url 		The URL to load
		 * @returns 	{Promise<void>}
		 */
		async _changeContent(small, url) {
			ips.controller.cleanContentsOf( this.contentArea );

			// Get height and set it, so that it doesn't jolt the page
			this.contentArea.css({
				height: String(this.contentArea.outerHeight())
			});

			// Remove content and set to loading
			this.contentArea.html(
				$('<div/>').addClass('ipsLoading').css({
					height: '300px'
				})
			);

			// Add class to the header to shrink it
			this.contentHeader.find('#elProfileHeader').toggleClass( 'ipsCoverPhoto--minimal', small );

			// Load the content
			url += (url.includes('?') ? '&' : '?') + 'entireSection=1';
			try {
				const response = await ips.fetch(url)
				this.contentArea
					.hide()
					.html(response)
					.css({
						height: 'auto'
					});

				ips.utils.anim.go('fadeIn fast', this.contentArea);

				$(document).trigger('contentChange', [this.contentArea]);
			} catch (e) {
				window.location = url;

			}
		}

	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/profile" javascript_name="ips.profile.toggleBlock.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000550">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.profile.toggleBlock.js - Toggle blocks on the profile
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.profile.toggleBlock', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;disable&quot;]', this.toggleBlock );
			this.on( 'click', '[data-action=&quot;enable&quot;]', this.toggleBlock );
		},

		/**
		 * Toggles a block on the profile, loading the new contents via ajax from the target URL
		 *	
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		toggleBlock: function (e) {
			e.preventDefault();

			var self = this;

			this.scope.css({
				opacity: &quot;0.6&quot;
			});

			ips.getAjax()( $( e.currentTarget ).attr('href'), {
				showLoading: true
			} )
				.done( function (response) {
					self.scope.html( response );
					$( document ).trigger( 'contentChange', [ self.scope ] );
				})
				.fail( function () {
					window.location = $( e.currentTarget ).attr('href');
				})
				.always( function () {
					self.scope.css({ 
						opacity: &quot;1&quot;
					});
				});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/search" javascript_name="ips.search.filters.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.search.filters.js - Filters form for search
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.search.filters', {

		initialize: function () {
			this.on( 'click', '[data-action="showFilters"]', this.showFilters );
			this.on( 'click', '[data-action="searchByTags"]', this.toggleSearchFields );
			this.on( 'click', '[data-action="searchByAuthors"]', this.toggleSearchFields );
			this.on( 'click', '[data-action="cancelFilters"]', this.cancelFilters );
			this.on( 'ips:refreshTogglesDone', this.toggleFilterByCounts );
			this.on( 'itemClicked.sideMenu', '[data-filterType="dateCreated"]', this.filterDate );
			this.on( 'itemClicked.sideMenu', '[data-filterType="dateUpdated"]', this.filterDate );
			this.on( 'itemClicked.sideMenu', '[data-filterType="joinedDate"]', this.filterDate );
			this.on( 'change', '[name^="search_min_"]', this.changeValue );
			this.on( 'tokenDeleted tokenAdded', this.tokenChanged );
			this.on( 'resultsLoading.search', this.resultsLoading );
			this.on( 'resultsDone.search', this.resultsDone );
			this.on( 'cancelResults.search', this.cancelResults );
			this.on( 'submit', this.submitForm );
			this.on( 'tabShown', this.tabShown );
			this.on( 'nodeInitialValues', this.setup );
			
			if( !this.scope.find('[data-role="hints"] ul li').length ){
				this.scope.find('[data-role="hints"]').hide();
			}
			
			this.setup();
		},

		setup: function () {
			var data = this.scope.find('form').serializeArray();

			this.trigger( 'initialData.search', {
				data: data
			});

			this.toggleFilterByCounts();
		},
		
		/**
		 * Remove the "Filter by number of..." header as the form toggles takes care of the rest
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		toggleFilterByCounts: function () {
			const searchTitleEl = document.getElementById('elSearch_filter_by_number');
			if (!searchTitleEl) {
				return;
			}

			const searchByNumberOptions = document.querySelector("#elSearch_filter_by_number + ul");

			// nothing visible?
			if (!searchByNumberOptions || !searchByNumberOptions.querySelector(':scope > :not([hidden])')) {
				searchTitleEl.hidden = true;
			} else {
				searchTitleEl.hidden = !this.elem.querySelector('input[name="type"]:checked').value;
			}
		},

		/**
		 * Triggered by search wrapper, resets search form back to initial state (i.e. no results showing)
		 *
		 * @returns 	{void}
		 */
		cancelResults: function () {
			this.showFilters();
			this.scope.find('[data-role="hints"]').remove();
			this.scope.find('#elMainSearchInput').val('').focus();
			this.scope.find('[data-action="cancelFilters"], [data-action="searchAgain"]').hide();
		},
		
		/**
		 * Event handler watching for changes on 'minimum' search fields. Shows a bubble
		 * when a positive value is applied.
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		changeValue: function (e) {
			var field = $( e.currentTarget ); 
			var name = field.attr('name');
			var bubble = this.scope.find('[data-role="' + name + '_link"] [data-role="fieldCount"]');

			if( field.val() == 0 ){
				bubble.text('0').addClass('ipsHide');
			} else {
				bubble.text( field.val() ).removeClass('ipsHide');
			}
		},

		/**
		 * Watches for token changes in tags field so we can show the and/or option
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from autocomplete
		 * @returns 	{void}
		 */
		tokenChanged: function (e, data) {
			var tags = this.scope.find('#elInput_tags_wrapper li.cToken');
			var term = this.scope.find('input[name="q"]');
			var andOr = this.scope.find('[data-role="searchTermsOrTags"]');
			
			// If we have a term and a token, show the and/or radios, otherwise hide them
			if( tags.length && term.val() && !andOr.is(':visible') ){
				andOr.slideDown();
			} else if ( ( !tags.length || !term.val() ) && andOr.is(':visible') ){
				andOr.slideUp();
			}
		},

		/**
		 * Watches for tab changes. When the 'member search' tab is focused, we select the
		 * hidden radio box that sets search to members
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from tab widget
		 * @returns 	{void}
		 */
		tabShown: function (e, data) {			
			if( data.tabID == 'ipsTabs_search_searchMembers' ){
				this.scope
					.find('input[name="type"][value="core_members"]')
						.prop( 'checked', true )
						.change()
					.end()
					.find('[data-action="updateResults"]')
						.text( ips.getString('searchMembers') );
			} else {
				this.scope
					.find('[data-role="searchApp"] .ipsSideMenu_itemActive input[type="radio"]')
						.prop( 'checked', true )
						.change()
					.end()
					.find('[data-action="updateResults"]')
						.text( ips.getString("searchContent") );
			}
		},

		/**
		 * Hides filters
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		cancelFilters: function (e) {
			var self = this;
			this.scope.find('[data-role="searchFilters"]').slideUp('fast', function () {
				self.scope.find('[data-action="showFilters"]').slideDown();
			});
		},

		/**
		 * Shows advanced filters
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		showFilters: function (e) {
			if( e ){
				e.preventDefault();
			}

			this.scope.find('[data-action="showFilters"]').hide();
			this.scope.find('[data-role="searchFilters"]').slideDown();

			/* We do this so the form toggles (i.e. show forums if you choose to search in forums content type) will reinitialize */
			$(document).trigger('contentChange', [ this.scope ] );
		},

		/**
		 * Event handler from main controller indicating results have loaded
		 * Remove loading mode, and hide the filters
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from main controller
		 * @returns 	{void}
		 */
		resultsDone: function (e, data) {
			var searchButton = this.scope.find('[data-action="updateResults"]');

			// Reset loading state
			searchButton.prop( 'disabled', false ).text( searchButton.attr('data-originalText') );
			
			// Hide filters
			this.scope.find('[data-role="searchFilters"]').hide();
			// Unhide 'more options' link
			this.scope.find('[data-action="showFilters"]').removeClass('ipsHide').show();
			// Unhide 'search again' button
			this.scope.find('[data-action="searchAgain"]').removeClass('ipsHide ipsButton--disabled').show();
			
			if( ! _.isUndefined( data.hints ) ){
				this.scope.find('[data-role="hints"]').html( data.hints ).show();
			}
			
			if( ! this.scope.find('[data-role="hints"] ul li').length ){
				this.scope.find('[data-role="hints"]').hide();
			}
			
			$( document ).trigger( 'contentChange', [ this.scope ] );
		},

		/**
		 * Event handler from main controller indicating results are loading
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from main controller
		 * @returns 	{void}
		 */
		resultsLoading: function (e, data) {
			var searchButton = this.scope.find('[data-action="updateResults"]');

			this.scope.find('[data-action="searchAgain"]').addClass('ipsButton--disabled');
			searchButton.prop( 'disabled', true ).attr( 'data-originalText', searchButton.text() ).text( ips.getString("searchFetchingResults") );
		},

		/**
		 * Event handlers for tags/author links to show a form filter
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		toggleSearchFields: function (e) {
			e.preventDefault();
			var link = $( e.currentTarget );
			var opens = link.attr('data-opens').split(',');
			var i;
			
			for( i = 0; i < opens.length; i++ ) {
				this.scope.find('[data-role="' + opens[i] + '"]').slideDown( function () {
					if( !link.closest('ul').find('li').length ){
						link.closest('ul').remove();
					}
	
					$( this ).find('input[type="text"]').focus();
				});
			}

			link.closest('li').hide();
		},

		/**
		 * Event handler for date filters, showing date fields when 'custom' is selected
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from side meun widget
		 * @returns 	{void}
		 */
		filterDate: function (e, data) {
			var elem = $( e.currentTarget );

			if( data.selectedItemID == 'custom' ){
				elem.find('[data-role="dateForm"]').slideDown();
			} else {
				elem.find('[data-role="dateForm"]').slideUp();
			}
		},

		/**
		 * Event handler for submitting the form. Triggers an event containing the data which
		 * the main controller will handle
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitForm: function (e) {
			e.preventDefault();

			// Make sure keyboard is hidden
			this.scope.find('#elMainSearchInput').blur();

			var self = this;
			var app = this.scope.find('[data-role="searchApp"] .ipsSideMenu_itemActive');
			var appKey = app.attr('data-ipsMenuValue');
			var appTitle = app.find('[data-role="searchAppTitle"]').text();
			var isMemberSearch = $('#ipsTabs_search_searchMembers').attr('aria-selected') == 'true';
			
			// Make sure we have at least one key field entered (a term, or tags)
			var searchTerm = this.scope.find('#elMainSearchInput').val().trim();
			var tagExists = ( this.scope.find('#elInput_tags').length && this.scope.find('#ipsTabs_search_searchContent').attr('aria-selected') === 'true' );

			if( tagExists ){
				var tagField = ips.ui.autocomplete.getObj( this.scope.find('#elInput_tags') );
				var tokens = tagField.getTokens();
			}
			
			if ( ! isMemberSearch ) {
				if ((!searchTerm && !tagExists) || (!searchTerm && tagExists && tokens.length === 0)) {
					ips.ui.alert.show( {
						type: 'alert',
						message: ( !searchTerm && !tagExists ) ? ips.getString('searchRequiresTerm') : ips.getString('searchRequiresTermTags'),
						icon: 'info',
						callbacks: {
							ok: function () {
								setTimeout( function () {
									self.scope.find('#elMainSearchInput').focus();
								}, 300 );
							}
						}
					});
					return;
				}
			}
			
			// I don't like it, however this is necessary to make sure that the htmlentities inside the tags are decoded
			const el = document.createElement('div');
			const data = this.scope.find('form').serializeArray();
			const tagsObject = data.find(item => item.name === 'tags');
			if (tagsObject) {
				el.innerHTML = tagsObject.value;
				tagsObject.value = el.textContent;
			}

			// Everything good? Trigger the event for the main controller to handle
			this.trigger( 'formSubmitted.search', {
				data,
				appKey: appKey,
				tabType: this.scope.closest('data-tabType').attr('data-tabType'),
				appTitle: appTitle
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/search" javascript_name="ips.search.main.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.search.main.js - Main search JS controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.search.main', {

		_content: null,
		_formData: {},
		_loadingDiv: null,
		_initialURL: '',
		_initialData: {},

		initialize() {
			this.on( 'initialData.search', this.initialData );
			this.on( 'formSubmitted.search', this.submittedSearch );
			this.on( 'paginationClicked paginationJump', this.paginationClicked );

			// Primary event that watches for URL changes
			this.on( window, 'historychange:search', this.stateChange);
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup() {
			this._content = this.scope.find('#elSearch_main');
			this._baseURL = this.scope.attr('data-baseURL');

			if ( this._baseURL.match(/\?/) ) {
				this._baseURL += '&';
			} else {
				this._baseURL += '?';
			}

			// If the last character is &, we can remove that because it'll be added back later
			if( this._baseURL.slice(-1) === '&' ){
				this._baseURL = this._baseURL.slice( 0, -1)
			}

			this._initialURL = window.location.href;
		},

		/**
		 * Filters have sent up their initial data
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		initialData(e, data) {
			this._formData = this._getFormData( data.data );
			this._initialData = _.clone( this._formData );
		},

		/**
		 * Main state change event handler that responds to URL changes
		 *
		 * @returns 	{void}
		 */
		stateChange() {
			const state = {
				data: ips.utils.history.getState('search'),
				url: window.location.href
			};

			if (this._initialURL === state.url && !Object.keys(state.data).length) {
				// If our URLs match but we have no state data, we can assume we've gone back to the intital search form, so let's reset
				this._cancelSearch();
			} else if (this._initialURL === state.url && state.data.url === undefined) {
				// If we don't have a URL, get it from our initial data
				this._loadResults( this._getUrlFromData( this._initialData ) );
			} else {
				// Otherwise use the state url
				this._loadResults( state.data.url );
			}
		},

		/**
		 * Responds to event from filters indicating the filter form has been submitted
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object	
		 * @returns 	{void}
		 */
		submittedSearch(e, data) {
			this._formData = this._getFormData( data.data );
			const url = this._getUrlFromData(this._formData);

			/* DataLayer event */
			try {
				if ( IpsDataLayerContext && !window.IpsDataLayerContext ) {
					let unique = '';
					let self = this;
					Object.keys( this._formData ).sort().forEach(function (index) {
						let value = self._formData[index];
						if (value.join) {
							value = value.join();
						}
						if (value.toString) {
							value = value.toString();
						}
						if (value && (typeof value === 'string')) {
							unique += value;
						}
					});

					$('body').trigger('ipsDataLayer', {
						_key: 'search',
						_properties: {
							query: this._formData.q || null
						},
						_uniquekeys: {'key':unique}
					});
				}
			} catch (e) {}

			ips.utils.history.pushState( {
				controller: 'core.front.search.main',
				url: url,
				filterData: this._formData
			}, 'search', url );
			document.title = this._getBrowserTitle();
		},

		/**
		 * Cancel the search results and reset the form
		 *
		 * @returns 	{void}
		 */
		_cancelSearch() {
			var results = this.scope.find('[data-role="filterContent"]');
			var blurb = this.scope.find('[data-role="searchBlurb"]');

			// Remove controller/widgets in results area before we empty it
			ips.controller.cleanContentsOf( results );

			// Tell filters to reset
			this.triggerOn( 'core.front.search.filters', 'cancelResults.search' );

			// Empty relevant elements
			results.html('');
			blurb.html('').hide();
		},

		/**
		 * Builds a search URL from the provided data
		 *
		 * @param 		{object} 	data 	Object containing search data
		 * @returns 	{string} 	url
		 */
		_getUrlFromData(data) {
			var params = [];

			// Basic params
			_.each( ['q', 'type', 'page', 'quick'], function (val) {
				if( !_.isUndefined( data[ val ] ) && data[ val ] !== '' ){
					params.push( val + '=' + encodeURIComponent( data[ val ] ) );
				}
			});

			// Are we searching content or members?
			if( data['type'] === 'core_members' ){

				// Joined date
				if( !_.isUndefined( data['joinedDate'] ) ){
					if( data['joinedDate'] !== 'custom' ){
						params.push( 'joinedDate=' + data['joinedDate'] );
					} else {
						if( !_.isUndefined( data['joinedDateCustom[start]'] ) ){
							params.push( 'start_after=' + encodeURIComponent( new Date( data['joinedDateCustom[start]'] ).getTime() / 1000 ) );	
						}
						if( !_.isUndefined( data['joinedDateCustom[end]'] ) ){
							params.push( 'start_before=' + encodeURIComponent( new Date( data['joinedDateCustom[end]'] ).getTime() / 1000 ) );	
						}						
					}
				}

				// Member group
				if( !_.isUndefined( data['group'] ) ){
					if( !_.isArray( data['group'] ) ){
						data['group'] = [ data['group'] ];
					}

					for( var i = 0; i < data['group'].length; i++ ){
						params.push( 'group[' + data['group'][ i ] + ']=1' );
					}
				}

				// Custom profile fields
				_.each( data, function (val, key){
					if( !key.startsWith('core_pfield') || val === 0 || val === '' ){
						return;
					}

					params.push( key + '=' + val );
				});
				
			} else {
				// Content-specific basic params
				_.each( ['item', 'author', 'search_min_replies', 
						'search_min_views', 'search_min_comments', 'search_min_reviews'], function (val) {
					if( !_.isUndefined( data[ val ] ) && data[ val ] !== '' && parseInt( data[ val ] ) !== 0 ){
						if( val === 'author' )
						{
							// Author names need treating slightly differently, since they may contain some HTML entities
							params.push( val + '=' + encodeURIComponent( data[ val ] ) );
							return;
						}
						params.push( val + '=' + data[ val ] );
					}
				});

				if( !_.isUndefined( data['tags'] ) ){
					params.push( 'tags=' + encodeURIComponent(data['tags'].replace(/\n/g, ',') ));
				}

				// Are we searching nodes?
				if( !_.isUndefined( data[ data['type'] + '_node' ] ) ){
					params.push( 'nodes=' + data[ data['type'] + '_node' ] );
				}
				else if( !_.isUndefined( data['nodes'] ) ){
					params.push( 'nodes=' + data['nodes'].replace(/\n/g, ',') );
				}
				if( !_.isUndefined( data['club[]'] ) ){
					if ( _.isArray( data['club[]'] ) ) {
						params.push( 'club=' + data['club[]'].filter(function(v){
							return v !== '__EMPTY';
						}));
					} else if ( data['club[]'].replace( '__EMPTY', '' ) ) {
						params.push( 'club=' + data['club[]'].replace( '__EMPTY', '' ) );
					}
				}

				// Only include eitherTermsOrTags if there's a term AND some tags
				if( !_.isUndefined( data['eitherTermsOrTags'] ) ){
					if( !_.isUndefined( data['q'] ) && data['q'].trim() !== '' && !_.isUndefined( data['tags'] ) && data['tags'].trim() !== '' ){
						params.push( 'eitherTermsOrTags=' + data['eitherTermsOrTags'] );
					}
				}

				// Only include search_and_or if its 'or' or 'and'
				if( !_.isUndefined( data['search_and_or'] ) && ( data['search_and_or'] === 'or' || data['search_and_or'] === 'and' ) ){
					params.push( 'search_and_or=' + data['search_and_or'] );
				}
				
				// Only include search_in if its 'title'
				if( !_.isUndefined( data['search_in'] ) && data['search_in'] === 'titles' ){
					params.push( 'search_in=' + data['search_in'] );
				}

				// Date params
				var datesSet = { startDate: false, updatedDate: false };
				_.each( [ ['startDate', 'start_after'], ['updatedDate', 'updated_after'] ], function (val) {
					if( !_.isUndefined( data[ val[0] ] ) ){
						if( data[ val[0] ] !== 'any' && data[ val[0] ] !== 'custom' ){
							params.push( val[1] + '=' + data[ val[0] ] );

							datesSet[ val[0] ] = true;
						} else if( data[ val[0] ] === 'any' ) {
							datesSet[ val[0] ] = true;
						}
					}
				});

				// Custom date param
				_.each( [ ['startDateCustom[start]', 'start_after'], ['startDateCustom[end]', 'start_before'],
						['updatedDateCustom[start]', 'updated_after'], ['updatedDateCustom[end]', 'updated_before'] ], function (val) {
					var thisType = ( val[0].indexOf('startDate') !== -1 ) ? 'startDate' : 'updatedDate';
					if( !_.isUndefined( data[ val[0] ] ) && !datesSet[ thisType ] ){
						// If we have selected 'any' for dates', do not add these
						if ( ( val[0] === 'startDateCustom[start]' || val[0] === 'startDateCustom[end]' ) && !_.isUndefined( data['startDate'] ) && data['startDate'] === 'any' ) {
							// Do nothing
						} else if ( ( val[0] === 'updatedDateCustom[start]' || val[0] === 'updatedDateCustom[end]' ) && !_.isUndefined( data['updatedDate'] ) && data['updatedDate'] === 'any' ) {
							// Do nothing
						} else {
							// We have to pass the form field to getDateFromInput() to account for polyfill
							params.push( val[1] + '=' + encodeURIComponent( ips.utils.time.getDateFromInput( $('[name="' + val[0] + '"]') ).getTime() / 1000 ) );
						}
					}
				});
			}
			
			// Sort
			if( !_.isUndefined( data['sortby'] ) ){
				params.push( 'sortby=' + data['sortby'] );
			}
			
			if( !_.isUndefined( data['sortdirection'] ) ){
				params.push( 'sortdirection=' + data['sortdirection'] );
			}

			return this._baseURL + '&' + params.join('&');
		},

		/**
		 * Main method to load new results from the server
		 *
		 * @param 		{string} 	url 				URL to load
		 * @returns 	{Promise<void>}
		 */
		async _loadResults(url ) {
			this.triggerOn( 'core.front.search.filters', 'resultsLoading.search' );
			this._setContentLoading( true );

			try {
				const response = await ips.fetch(url)
				if (typeof response !== 'object') {
					window.location = url;
				}

				if (response.css) {
					this._addCSS(response.css);
				}

				// Hide filters
				this.triggerOn('core.front.search.filters', 'resultsDone.search', {
					contents: response.filters,
					hints: response.hints
				});

				// Update content
				this._content.html(response.content);
				$(document).trigger('contentChange', [this._content]);

				// Update title
				this.scope.find('[data-role="searchBlurb"]').show().html(response.title);

				// Make sure cancel button is shown
				this.scope.find('[data-action="cancelFilters"]').show();

				// Animate new items
				const newItems = this.scope.find('[data-role="resultsArea"] [data-role="activityItem"]').css({
					opacity: "0"
				});
				const delay = 100;

				// Slide down to make space for them
				newItems.slideDown(function () {
					// Now fade in one by one, with a delay
					newItems.each(function (index) {
						var d = (index * delay);
						$(this).delay((d > 1200) ? 1200 : d).animate({
							opacity: "1"
						});
					});
				});
			} catch (e) {
				window.location = url;
			}
			this._setContentLoading( false );
		},

		/**
		 * Responds to pagination event in conversation
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		paginationClicked(e, data){
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}

			this._formData['page'] = data.pageNo;

			const url = this._getUrlFromData(this._formData);
			ips.utils.history.pushState( {controller: 'core.front.search.main', url}, 'search', url );

			const elemPosition = ips.utils.position.getElemPosition(this.scope);
			$('html, body').animate( { scrollTop: elemPosition.absPos.top + 'px' } );
		},

		/**
		 * Returns form data, converting jquery serializedArray objects into
		 * simple key/value pairs
		 *
		 * @param 		{object} 	data 	Form data object
		 * @returns 	{object}
		 */
		_getFormData(data) {
			if( !_.isObject( data ) ){
				return;
			}

			var returnData = {};
			var skipData = [ 'page', 'csrfKey' ];

			for( var i = 0; i < data.length; i++ ){
				if( _.indexOf( skipData, data[ i ].name ) === -1 && data[ i ].value !== '' ){

					// If we already have a value set for this param and it isn't an array, juggle it
					// so that it is an array and push the existing value into it
					if( !_.isUndefined( returnData[ data[ i ].name ] ) && !_.isArray( returnData[ data[ i ].name ] ) ){
						var tmp = returnData[ data[ i ].name ];
						returnData[ data[ i ].name ] = [];
						returnData[ data[ i ].name ].push( tmp );
					}

					// If we're an array, push it into it, otherwise just set the value
					if( !_.isUndefined( returnData[ data[ i ].name ] ) ){
						returnData[ data[ i ].name ].push( data[ i ].value );
					} else {
						returnData[ data[ i ].name ] = data[ i ].value;	
					}
					
					// Unlimited checkbox? Overwrite value
					if ( data[i].name !== 'club[]' ) {
						if ( $('#' + data[i].name + '-unlimitedCheck').length )
						{
							if ( ! $('#' + data[i].name + '-unlimitedCheck:checked').length )
							{
								returnData[ data[ i ].name ] = $('input[type=number][name=' + data[ i ].name + ']').val();
							}
							else
							{
								delete( returnData[ data[ i ].name ] );
							}
						}
					}
				}
			}
			
			if( ! _.isUndefined( data['type'] ) && data['type'] !== 'core_members' ){
				if ( ! _.isUndefined( data['sortby'] ) ){
					delete( data['sortby'] );
				}
				
				if ( ! _.isUndefined( data['sortdirection'] ) ){
					delete( data['sortdirection'] );
				}
			}

			return returnData;
		},

		/**
		 * Builds a string to use in the browser titlebar
		 *
		 * @returns 	{string}
		 */
		_getBrowserTitle() {
			var title = ips.getString('searchTitle');
			var currentType = this.scope.find('input[type="radio"][name="type"]:checked');
			var q = this._formData['q'];
			if ( _.isUndefined( q ) ) {
				q = '';
			}
			
			if( q !== '' && !currentType.length ){
				title = ips.getString('searchTitleTerm', {
					term: q
				});
			} else if( q !== '' && currentType.length ){
				title = ips.getString('searchTitleTermType', {
					term: q,
					type: currentType.next('[data-role="searchAppTitle"]').text()
				});
			} else if( q === '' && this._currentType !== '' ){
				title = ips.getString('searchTitleType', {
					type: currentType.next('[data-role="searchAppTitle"]').text()
				});
			}
			
			return title;
		},

		/**
		 * Adds css files to the page header
		 *
		 * @param 		{array} 	css 	Array of CSS urls to add
		 * @returns 	{void}
		 */
		_addCSS(css) {
			var head = $('head');

			if( css && css.length ){
				for( var i = 0; i < css.length; i++ ){
					head.append( $('<link/>').attr( 'href', css[i] ).attr( 'type', 'text/css' ).attr('rel', 'stylesheet') );
				}
			}
		},

		/**
		 * Toggles the loading state on the main search body area
		 *
		 * @param 		{boolean} 	showLoading 		Enable loading state?
		 * @returns 	{void}
		 */
		_setContentLoading(state) {
			var results = this.scope.find('[data-role="resultsContents"]');

			if( !results.length ){
				if( this._loadingDiv ){
					this._loadingDiv.hide();
				}

				return;
			}

			var dims = ips.utils.position.getElemDims( results );
			var position = ips.utils.position.getElemPosition( results );
			

			if( !this._loadingDiv ){
				this._loadingDiv = $('<div/>').append( 
					$('<div/>')
						.css({
							height: _.min( [ 200, results.outerHeight() ] ) + 'px'
						})
						.addClass('ipsLoading')
				);

				ips.getContainer().append( this._loadingDiv );
			}

			this._loadingDiv
				.show()
				.css({
					left: position.viewportOffset.left + 'px',
					top: position.viewportOffset.top + $( document ).scrollTop() + 'px',
					width: dims.width + 'px',
					height: dims.height + 'px',
					position: 'absolute',
					zIndex: ips.ui.zIndex()
				})
				

			if( state ){
				results
					.animate({
						opacity: "0.6"
					})
					.css({
						height: results.height() + 'px'
					});				
			} else {
				results.css({
					height: 'auto',
					opacity: "1"
				});

				this._loadingDiv.hide();
			}	
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/search" javascript_name="ips.search.results.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.search.results.js - Search results controller
 *
 * Author: Rikki Tissier
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.search.results', {

		_resultLength: 300,
		_terms: [],

		initialize: function () {
			this.setup();
			this.on( document, 'contentChange', _.bind( this.contentChange, this ) );
		},

		/**
		 * Setup methods. Adds case-insensitive jQuery expression.
		 *
		 * @param 		{string} 	term 	The word(s) to highlight
		 * @returns 	{void}
		 */
		setup() {
			const self = this;

			try {
				this._terms = JSON.parse( this.scope.attr('data-term') );
			} catch(err) {
				Debug.log("Error parsing search terms");
				return;
			}

			// Process each result
			this.scope.find('[data-role="activityItem"]').each( function () {
				self._processResult( $( this ) );
			});
		},

		/**
		 * Event handler for document content change
		 *
		 * @returns 	{void}
		 */
		contentChange: function () {
			var self = this;

			this.scope.find('[data-role="activityItem"]').each( function () {
				self._processResult( $( this ) );
			});
		},

		/**
		 * Processes the given element as a search result
		 *
		 * @param 		{element} 	result 		The search result element
		 * @returns 	{void}
		 */
		_processResult: function (result) {
			// Don't process it twice
			if( result.attr('data-processed') ){
				return;
			}

			// Start by locating the first hit
			var findWords = result.find('[data-findTerm]');

			if( findWords.length ){
				this._findWords( findWords );
			}

			// Now highlight the terms
			this._highlight( result );

			result.attr('data-processed', true);
		},


		/**
		 * Takes a search result, and finds the match within it and then reduces the text
		 * to just the characters surrounding the match
		 *
		 * @param 		{element} 	result 		The element containing the text to work on
		 * @returns 	{void}
		 */
		_findWords: function (result) {
			var text = result.text().trim();
			var firstMatch = text.length;
			var startPoint = 0;
			var foundMatches = false;

			//-----------
			// Step 1: Find the first occurrence of each term
			for( var i = 0; i < this._terms.length; i++){

				// Note: regexp used here because simple indexOf isn't case insensitive
				// and toLowercase doesn't work well with some languages
				var indexOf = text.search( new RegExp( ips.utils.escapeRegexp( this._terms[i] ), 'i' ) );

				if( indexOf !== -1 ){
					foundMatches = true;

					if( indexOf < firstMatch ){
						firstMatch = indexOf;
					}
				}
			}

			//-----------
			// Step 2: Search backwards to find the closest puncutation mark, which is where we'll start our result snippet
			// We'll go back up to half of our result length, but stop if we hit the beginning
			var punctuationMarks = ['.', ',', '?', '!'];
			var searchBack = ( firstMatch - ( this._resultLength / 2 ) < 0 ) ? 0 : firstMatch - ( this._resultLength / 2 ); 

			// if there were no matches, then we'll just set manual values
			if( !foundMatches ){
				startPoint = 0;
			} else {
				for( var j = firstMatch; j > searchBack; j-- ){
					if( punctuationMarks.indexOf( text[j] ) !== -1 ){
						startPoint = j + 1;
						break;
					}
				}
			}

			//-----------
			// Step 3: Count forward from the starting point to get our snippet
			var finalSnippet = text.substring( startPoint, startPoint + 300 ).trim();

			if( startPoint > 0 && foundMatches ){
				finalSnippet = '...' + finalSnippet;
			}

			if( startPoint + this._resultLength < text.length || ( !foundMatches && text.length > this._resultLength ) ){
				finalSnippet = finalSnippet + '...';
			}

			result.text( finalSnippet );
		},

		/**
		 * Highlight search results
		 *
		 * @param 		{string} 	term 	The word(s) to highlight
		 * @returns 	{void}
		 */
		_highlight (result) {
			// Find the elements we're searching in
			const elements = result.find('[data-searchable]');

			for(const index in this._terms) {
				const term = this._terms[index].toLowerCase();
				elements.each( function () {
					if (!$(this).text().toLowerCase().includes(term)) {
						return;
					}
										
					$( this ).contents().filter(
						function() { return this.nodeType === 3 }
					).each( function(){
						$( this ).replaceWith( _.escape( XRegExp.replace( $( this ).text(), new RegExp( "(\\b|\\s|^)(" + term + "\\w*)(\\b|\\s|$)", "ig" ), '<mark class="ipsMatch' + ( index + 1 ) + '">' + "$2 " + '</mark>' ) ).replace( new RegExp("&lt;mark class=&quot;ipsMatch" + ( index + 1 ) + "&quot;&gt;", 'ig'), " <mark class='ipsMatch" + ( index + 1 ) + "'>" ).replace( new RegExp("&lt;/mark&gt;", 'ig'), "</mark>" ) );
					} );
				});
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.downloadbutton.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650"><![CDATA[/**
 * @module core.admin.stats.downloadButton
 * Controller to manage the download button and change the location based on the active tab
 *
 * @since March 2025
 * @author Matt Finger
 * @copyright Invision Power Services, Inc.
 */
;(function($, _) {
    "use strict";
    ips.controller.register("core.admin.stats.downloadButton", {
        initialize() {
            const update = () => {
                const url = new URL(this.scope.attr('href'), window.location.origin);
                const locationParams = new URLSearchParams(window.location.search);
                url.updateSearchParams('report_id', locationParams.get('report_id') || '0');
                url.updateSearchParams('tab', locationParams.get('tab') || 'charts');
                const rangeVal = document.querySelector(`[data-controller*="core.admin.stats.overview"] .cStatsFilters select[name="predate"]`)?.value || '7';
                if (rangeVal && parseInt(rangeVal) === -1) {
                    url.updateSearchParams({param: 'range', value: null});
                    let startInput = document.querySelector(`[data-controller*="core.admin.stats.overview"] .cStatsFilters #dateFilterInputs input[name="date[start]"]`);
                    let endInput = document.querySelector(`[data-controller*="core.admin.stats.overview"] .cStatsFilters #dateFilterInputs input[name="date[end]"]`);
                    if (startInput.valueAsNumber && endInput.valueAsNumber) {
                        url.updateSearchParams('range[start]', Math.round(startInput.valueAsNumber / 1000).toString());
                        url.updateSearchParams('range[end]', Math.round((endInput.valueAsNumber || Date.now()) / 1000).toString());
                    }
                } else {
                    console.log('updating range; removing start and end')
                    url.updateSearchParams({params: {
                            'range[start]': null,
                            'range[end]': null,
                        }});
                    url.updateSearchParams("range", rangeVal);
                }
                this.scope.attr('href', url.toString());

                // hacky, but we can also update the existing report selector links
                const menuSelectorLink = this.scope.get(0).closest('[data-controller*="core.admin.core.pageActions"]')?.querySelector('[data-role="reportSelector"]');
                const menuSelector = menuSelectorLink?.getAttribute('id') && document.querySelector(`.ipsMenu#${menuSelectorLink?.getAttribute("id")}_menu`);
                menuSelector?.querySelectorAll('.ipsMenu_item a').forEach(link => {
                    const linkUrl = new URL(link.getAttribute('href'), window.location.href);
                    linkUrl.updateSearchParams({param: 'tab', value: url.searchParams.get('tab') || null});
                    link.setAttribute('href', linkUrl.toString());
                });
            };
            window.addEventListener("historychange", update);
            document.addEventListener('input', e => {
                if (e.target.matches( '[data-controller*="core.admin.stats.overview"] .cStatsFilters :not([data-role="dateFilterInputs"] *)' )) {
                    if (e.target.matches(`select[name="predate"]`) && parseInt(e.target.value) === -1) {
                        Debug.log(`Not updating because the date isn't updated`);
                        return;
                    }
                    setTimeout(() => {
                        update();
                    })
                }
            }, {capture: true});

            // The custom date range is only applied after the user clicks update
            document.addEventListener('submit', e => {
                if (e.target instanceof HTMLFormElement && e.target.matches(`[data-role="dateFilter"]`)) {
                    setTimeout(() => update());
                }
            }, {capture: true});

            update();
        }
    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.dynamicChart.mixin.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stats.dynamicChart.mixin.js - very hacky, but the form toggles don't work the way the menu is loaded for saving charts because it is hidden on page load, so :visible checks in jquery prevent `display:none` from being added. Here, we just add the class but todo in v5 this should just work because toggles are based on `hidden`
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
    "use strict";

    ips.controller.mixin( 'core.dynamicChartReportFields', 'core.admin.core.dynamicChart', true, function () {
        this.after('initialize', () => {
            return
            /**
             * todo see if this entire file can just be deleted
             * @todo this can probably be replaced with proper \IPS\Form creation on the backend
             */
            this.scope.get(0).querySelectorAll('[data-role="filterSaveMenu"].ipsHide').forEach(hiddenMenu => {
                const reportSelector = hiddenMenu.querySelector(`#statsreports_report_select`);
                const titleToggle = reportSelector?.querySelector('input[name="statsreports_report_unlimited"]')
                const reportTitle = hiddenMenu.querySelector(`#statsreports_report_new_title`);
                if (!reportSelector && !reportTitle) {
                    return;
                }


                const usingReport = !hiddenMenu.querySelector(`[name="statsreports_include_in_report"]`)?.value;
                let creatingNewReport = false;
                if (usingReport) {
                    if (!reportSelector) {
                        reportTitle.style.display = "";
                        return;
                    }
                    reportSelector.style.display = "";
                    if (titleToggle?.checked) {
                        creatingNewReport = true;
                    }
                } else {
                    if (!reportSelector) {
                        reportTitle.style.display = "none";
                        return;
                    }
                    reportSelector.style.display = "none";
                }

                if (reportTitle && creatingNewReport) {
                    reportTitle.style.display = "";
                } else if (reportTitle) {
                    reportTitle.style.display = "none";
                }
            });
        })
    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.filtering.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stats.filtering.js - Statistics filtering controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.stats.filtering', {

		initialize: function () {
			this.on( 'click', '[data-role=&quot;toggleGroupFilter&quot;]', this.toggleGroupFilter );

			// And hide by default
			if( $('#elGroupFilter').attr('data-hasGroupFilters') == 'true' )
			{
				$('#elGroupFilter').show();
			}
		},

		/**
		 * Toggle filtering by groups
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleGroupFilter: function (e) {
			e.preventDefault();
			
			if( $('#elGroupFilter').is(':visible') )
			{
				// If we are hiding the filter, we will assume they want to search everything and ensure all checkboxes are checked
				$('#elGroupFilter').find('input[type=&quot;checkbox&quot;]').prop('checked', true);
				$('#elGroupFilter').slideUp();
			}
			else
			{
				$('#elGroupFilter').slideDown();
			}
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.liveDateFilter.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stats.liveDateFilter.js - Controller for the date filter for overview stats pages
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.stats.liveDateFilter', {

		dateFilters: { 'start': null, 'end': null, 'range': null },

		initialize() {
			this.on( 'submit', this.updateDateFilter );
			this.on( 'change', '[name="predate"]', this.changeDateField );
			this.on( 'click', '[data-action="cancelDateRange"]', this.cancelDateRange );
			document.addEventListener( 'reloadStatsDateFilters', e => this.resendDateFilters(e) );
			this.dateFilters.range = this.elem.dataset.defaultrange;

			this.elem.querySelector('[name="predate"]')?.dispatchEvent(new CustomEvent('change', {bubbles: true, detail: {submit:false}}));
		},

		/**
		 * Dispatch a global event containing the date filters
		 */
		resendDateFilters() {
			const url = new URL(window.location.href);
			let days = parseInt(this.dateFilters.range?.toString?.() || 'NaN');
			if (Number.isInteger(days) && days >= 0) {
				url.updateSearchParams({param: 'predate', value: days.toString()});
			} else {
				['start', 'end'].forEach(prop => {
					let ts = null;
					if (typeof this.dateFilters[prop] === 'string') {
						try {
							ts = Math.round((new Date(this.dateFilters[prop])).getTime() / 1000);
						} catch (e) {
						} /* note this is an unhandled caught exception which "can" cause issues */
					}

					url.updateSearchParams({param: 'predate', value: null});
					url.updateSearchParams({param: `date[${prop}]`, value: ts});
				});
			}

			if (url.toString() !== window.location.href) {
				ips.utils.history.replaceState({}, 'stats.liveDateFilter', url.toString());
			}
			this.elem.dispatchEvent(new CustomEvent('ips:stats.setDateFilters', {
				bubbles: true,
				detail: {
					dateFilters: this.dateFilters
				}
			}));
		},

		/**
		 * Cancel
		 * @param {Event}	e
		 */
		cancelDateRange(e) {
			e.preventDefault();
			const select = this.elem.querySelector('select[name="predate"]');
			select.value = this.elem.dataset.defaultrange;
			select.dispatchEvent(new CustomEvent('change', {bubbles: true}));
		},

		/**
		 *
		 * @param {InputEvent|CustomEvent}	e
		 */
		changeDateField(e) {
			/**
			 * @type {HTMLSelectElement|EventTarget}
			 */
			const select = e.target;
			if (!(select instanceof HTMLSelectElement) || !select?.matches?.('select[name="predate"]')) {
				return;
			}

			const button = this.elem.querySelectorAll('.cStatsFilters button');
			if (Number(select.value) === -1) {
				select.ipsHide();
				button.ipsShow();
			} else {
				this.elem.dataset.defaultrange = select.value;
				select.ipsShow();
				button.ipsHide();
				if (e?.detail?.submit !== false) {
					select.closest('form')?.dispatchEvent(new CustomEvent('submit'));
				}
			}
		},

		/**
		 * Update blocks on the page to use the new date filters
		 *
		 * @param	{Event} 	e	Event
		 * @returns {void}
		 */
		updateDateFilter(e) {
			e.preventDefault();
			e.stopPropagation();

			this.dateFilters = {
				'start': null,
				'end': null,
				'range': this.elem.querySelector( '[name="predate"]' ).value
			};

			// Are we specifying a custom date range?
			if (Number(this.dateFilters.range) === -1) {
				this.dateFilters.start = this.elem.querySelector( '[name="date[start]"]' ).value;
				this.dateFilters.end = this.elem.querySelector( '[name="date[end]"]' ).value;
			}

			this.resendDateFilters();

			// submit the filter to the backend
			this.actuallySubmitForm();
		},

		/**
		 *
		 * @return {Promise<Object>}
		 */
		async actuallySubmitForm() {
			// only do this if we're viewing a report
			const url = new URL(this.elem.getAttribute('action'), window.location.href);
			if (!url.searchParams.has('report_id') || url.searchParams.get('app') !== 'core' || url.searchParams.get('module') !== 'overview' || url.searchParams.get('controller') !== 'mycharts') {
				return;
			}
			const values = Object.fromEntries([...(new FormData(this.elem)).entries()]);
			const response = await ips.fetch(url.toString(), {
				method: 'post',
				data: values,
			} );
			console.log('got form submission response', response);
			return response;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.overview.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stats.overview.js - Overview statistics controller
 *
 * Author: Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.stats.overview', {
		_dateFilters: undefined, // { 'start': null, 'end': null, 'range': null },
		_dateFilterQueue: new Set(),
		set dateFilters(dateFilters) {
			this._dateFilters = dateFilters;
			this._dateFilterQueue.forEach(cb => cb());
			this._dateFilterQueue.clear();
		},

		/**
		 *
		 * @return {{start: null|number, range: null|number, end: null|number}}
		 */
		get dateFilters() {
			if (this._dateFilters) {
				return this._dateFilters;
			}
			return {
				start: null,
				end: null,
				range: null,
			}
		},

		initialize: function () {
			document.addEventListener('ips:stats.setDateFilters', e => this.updateDateFilter(e));
			this.on( 'change', '[data-action="toggleApp"]', this.toggleApp );

			// we need to debounce this to prevent a loop from occurring. On page load, every overview block dispatches this event, but we only need to send the date filter back to the block once
			this.elem.addEventListener('stats.ready', _.debounce((...args) => this.blockReady(...args), 100) );
			this.url = this.scope.attr('data-url');
		},

		/**
		 * Promise that resolves after the date filters are known. Since the date filter form is handled as a separate component, we need to do this asynchronously.
		 * @return {Promise<void>}
		 */
		dateFiltersKnown() {
			return new Promise((resolve) => {
				if (this._dateFilters) {
					return resolve();
				}
				this._dateFilterQueue.add(resolve);
				setTimeout(() => {
					document.dispatchEvent(new CustomEvent('reloadStatsDateFilters'));
				})
			});
		},

		/**
		 * A block is ready to be loaded
		 *
		 * @param	{Event} 	e		Event
		 * @param 	{Object}	data 	Event data
		 *
		 * @returns {void}
		 */
		async blockReady(e, data) {
			await this.dateFiltersKnown();
			$(e.target).trigger('stats.loadBlock', {
				dateFilters: this.dateFilters,
				url: this.url
			});
		},

		/**
		 * Event handler for toggling which apps to see
		 *
		 * @returns {void}
		 */
		toggleApp: function () {
			// Get selected apps
			var enabledApps = _.map( this.scope.find('[data-action="toggleApp"]:checked'), function(app) { 
				return $( app ).attr('data-toggledApp') 
			});
			var disabledApps = _.map( this.scope.find('[data-action="toggleApp"]:not( :checked )'), function (app) {
				return $( app ).attr('data-toggledApp');
			});

			function toggleTiles(){
				this.scope.find('.cStatTile[data-app]').each( function () {
					var tile = $(this);
					if( tile.is('[hidden]') && enabledApps.indexOf( $( this ).attr('data-app') ) !== -1 ){
						tile.prop('hidden', false);
					} else if ( enabledApps.indexOf( $( this ).attr('data-app') ) === -1 ){
						tile.prop('hidden', true);
					}
				});
			};

			// Select all tiles, except those that are enabled
			if (document.startViewTransition){
                document.startViewTransition(() => toggleTiles());
            } else {
                toggleTiles();
            }

			// Write the cookie to set disabled apps
			ips.utils.cookie.set('overviewExcludedApps', JSON.stringify( disabledApps ), true );
		},

		/**
		 * Update blocks on the page to use the new date filters
		 *
		 * @param	{CustomEvent<{dateFilters:{start:*,end:*,range:*}}>} 	e	Event
		 * @returns {void}
		 */
		updateDateFilter: function (e){
			this.dateFilters = {...e.detail.dateFilters};
			this.triggerOn('core.admin.stats.overviewBlock', 'stats.loadBlock', {
				dateFilters: e.detail.dateFilters,
				url: this.url
			});

			this.triggerOn('core.admin.stats.nodeFilters', 'stats.setDateFilters', {
				dateFilters: e.detail.dateFilters,
				url: this.url
			});
		},
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/stats" javascript_name="ips.stats.overviewBlock.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000650"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stats.overviewBlock.js - Overview statistics block controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.stats.overviewBlock', {
		_lastURL: null,

		/**
		 * Initialize this controller
		 */
		initialize() {
			this.on('stats.loadBlock', this.loadBlock);
			$(document).on( 'stats.nodeFilters', (...args) => this.loadBlock(...args));

			this.refresh = null;
			this.loaded = false;
			this.currentCounts = [];
			this.url = null;
			this.block = this.elem.dataset.block;
			this.subblock = this.elem.dataset.subblock;
			this.savedstatid = this.elem.dataset.savedstatid;
			this.refreshInterval = this.elem.dataset.refresh ? parseInt(this.elem.dataset.refresh) : false;
			this.elem.dispatchEvent(new CustomEvent('stats.ready', {bubbles: true}));
			this.elem.addEventListener('submit', e => this.handleSubmit(e), {capture: true});
			this.elem.querySelector('[data-role="removeBlock"]')?.addEventListener('click', e => this.deleteBlock(e));
		},

		/**
		 * Redirect to the delete block endpoint, which in turn redirects back to this page without the block.
		 * @param {PointerEvent}	e
		 */
		deleteBlock(e) {
			e?.preventDefault();
			ips.ui.alert.show({
				message: ips.getString('statsreports_delete_confirm'),
				type: 'confirm',
				callbacks: {
					ok: () => {
						// we use this redirect approach to display errors to the user easily. TODO at some point this should use a proper ajax request but this works
						const url = new URL(window.location.protocol + ips.getSetting('baseURL'), window.location.origin);
						url.pathname += url.pathname.endsWith('/') ? "admin/" : "/admin/";
						url.searchParams.set('app', 'core');
						url.searchParams.set('module', 'overview');
						url.searchParams.set('controller', 'mycharts');
						url.searchParams.set('do', 'deleteBlock');
						url.searchParams.set('saved_block_id', this.savedstatid);
						url.searchParams.set('csrfKey', ips.getSetting('csrfKey'));
						window.location.href = url.toString();
					}
				}
			});
		},

		/**
		 * Handle the submisso
		 * @param {SubmitEvent}	e
		 */
		async handleSubmit(e) {
			e.preventDefault();
			e.stopPropagation();

			// all we need to do is send an update then load this block
			/**@type{HTMLFormElement} */
			const form = e.target;
			const dropdown = form.closest('i-dropdown[data-dropdown-role]');
			if (dropdown) {
				dropdown.createContentElement();
			}

			if (dropdown?.dataset.dropdownRole === 'saveReport') {
				const data = Object.fromEntries([...(new FormData(form)).entries()]);
				const url = (new URL(form.action, window.location.href)).toString();

				dropdown.contentElement.classList.add('ipsLoading', 'ipsLoading--small');
				try {
					const response = await ips.fetch(url, {
						method: "post",
						data
					});

					if (typeof response !== 'object' || response.message !== 'ok') {
						const err = new Error();
						err.jqxhr = jqxhr;
						throw err;
					}

					if (this.savedstatid && response.title && this.elem.querySelector(`[data-role="stat_title"]`)) {
						// if we're viewing the report, refresh so the title is updated
						this.elem.querySelector('[data-role="stat_title"]').innerText = response.title;
					}
				} catch (e) {
					if (e.jqxhr?.responseText && dropdown.contentElement) {
						dropdown.contentElement.innerHTML = e.jqxhr?.responseText;
						return;
					}

					if (e.jqxhr?.responseText || e.jqxhr?.responseJSON) {
						ips.ui.alert.show({message: e.jqxhr.responseText || e.jqxhr?.responseJSON});
						return;
					}
					ips.ui.alert.show({message: ips.getString('unexpected_error')});
					return;
				}
			} else if (dropdown?.dataset.dropdownRole === 'filterForm') { // node filter?
				this.elem.dataset.nodefilter = form.querySelector('[data-role="nodeValue"]')?.value;
				// reset our values so the user has confirmation the block is updated
				this.currentCounts = null;
			}

			if (this.url) {
				this.url = this.rebuildURL();
				this._lastURL = this.url;
				await this.fetchUpdate();
			} else {
				this.elem.dispatchEvent(new CustomEvent('stats.ready', {bubbles: true})); // this causes the block to be loaded
			}

			dropdown?.hidePopover();
			if (dropdown?.dataset.dropdownRole === 'saveReport') {
				ips.ui.flashMsg.show(ips.getString('saved'));
				await dropdown.resetRemoteContent();
			}
		},

		/**
		 * Return a normalized array of counts this block has shown, used to compare prev/next values
		 *
		 * @param	{Element|jQuery} 	elem	  Element to check for values
		 * @returns {Array<number|NaN>}
		 */
		getCounts(elem) {
			return [...$(elem).get(0).querySelectorAll('[data-number]')].map(el => parseInt(el.dataset.number));
		},

		/**
		 * Create an interval to update this block every so often
		 *
		 * @todo this could be enhanced with a websocket push at some point far in the future
		 */
		startInterval() {
			if (!this.refreshInterval || !this.url) {
				return;
			}

			clearInterval( this.refresh );
			this.refresh = setInterval(() => this.fetchUpdate(), this.refreshInterval * 1000);
		},

		/**
		 * Fetch the updated content for this block.
		 *
		 * @return {Promise<void>}
		 */
		async fetchUpdate() {
			const response = await ips.fetch(this.url, {
				type: 'get'
			});
			let identifiedDifference = !this.currentCounts;
			const counts = this.getCounts((new DOMParser()).parseFromString(response, 'text/html').body);

			// Is there a difference?
			if (!identifiedDifference) {
				if (counts.length !== this.currentCounts.length) {
					identifiedDifference = true;
				} else {
					for (let i = 0; i < counts.length; i++) {
						if (counts[i] !== this.currentCounts[i]) {
							identifiedDifference = true;
							break;
						}
					}
				}
			}

			if (identifiedDifference) {
				this.elem.classList.add('cStatTile--updated');
				let contentContainer = this.elem.querySelector('[data-role="statBlockContent"]');
				if (contentContainer) {
					contentContainer.innerHTML = "<div>" + response + "</div>";
				}

				this.currentCounts = counts;
				setTimeout(() => this.elem.classList.remove('cStatTile--updated'), 2200);
				$( document ).trigger('contentChange', [this.scope]);
			} else {
				Debug.log("No change in values in " + this.block);
			}
		},

		/**
		 * Rebuild a URL Based on data
		 * @param [data]
		 *
		 * @return {string}
		 */
		rebuildURL(data) {
			if (!data) {
				const currentURL = new URL(this.url||"", location.href);
				data = {
					url: this.url,
					dateFilters: {
						range: currentURL.searchParams.get('range'),
						start: currentURL.searchParams.get('start'),
						end: currentURL.searchParams.get('end'),
					}
				}
			}

			/**@type {URL} url*/
			let url = new URL(data.url, location.href);
			url.updateSearchParams('blockKey', this.block);
			url.updateSearchParams('subblock', this.subblock || null);

			const range = ![0,-1, Number.NaN].includes(parseInt(data?.dateFilters?.range)) ? data.dateFilters.range.toString() : null
			url.updateSearchParams('range', range);
			url.updateSearchParams('start', (!range && data?.dateFilters?.start?.toString()) || null);
			url.updateSearchParams('end', (!range && data?.dateFilters?.end?.toString()) || null);

			url.updateSearchParams('nodes', this.elem.dataset.nodefilter || null);

			return url.toString();
		},

		/**
		 * Load the block
		 *
		 * @param	{event} 	e	    Event
		 * @param   {object}    data    Event data
		 * @returns {void}
		 */
		async loadBlock(e, data) {
			// We might only want to refresh one block, in which case we can skip this
			if (!_.isUndefined(data.blockToRefresh) && (data.blockToRefresh !== this.block || data.subblockToRefresh !== this.subblock)) {
				Debug.log( "Skipping because " + data.blockToRefresh + " does not match " + this.block + " or " + data.subblockToRefresh + " does not match " + this.subblock );
				return;
			}

			if (!data.url) {
				throw new Error(`No URL provided to load this block`);
			}

			this._lastURL = this.url;
			this.url = this.rebuildURL(data);

			// Don't load unless the URL didn't change
			if (this.url === this._lastURL) {
				return;
			}

			clearInterval( this.refresh );
			if (this.loaded) {
				this.loaded = false;
				
				this.scope
					.removeClass('cStatTile--loaded')
					.find('.cStatTile__body')
						.addClass('ipsLoading')
					.end()
					.find('[data-role="statBlockContent"]')
						.hide()
						.html('');
			}

			const response = await ips.fetch(this.url, {
				type: 'get'
			})

			this.scope
				.addClass( 'cStatTile--loaded' )
				.find('.cStatTile__body')
					.removeClass('ipsLoading')
				.end()
				.find('[data-role="statBlockContent"]')
					.hide()
					.html( response );

			this.scope.find('[data-role="statBlockContent"]').fadeIn('fast');
			this.loaded = true;
			this.currentCounts = this.getCounts( this.scope );
			this.startInterval();

			$( document ).trigger( 'contentChange', [ this.scope ] );

		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="controllers/stockart" javascript_name="ips.stockart.pixabay.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * IPS Social Suite 4
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.stockart.pixabay.js - Controller for Pixabay Actions
 *
 * Author: Daniel Fatkic
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.global.stockart.pixabay', {

		initialize: function () {
			this.on( 'click', '.ipsPixabayImage', this.selectImage );
			this.on( 'focus', '[data-role="pixabaySearch"]', this.searchPixabay );
			this.on( 'blur', '[data-role="pixabaySearch"]', this.stopSearchPixabay );
			$('[data-role="pixabayResults"]').on( 'scroll', this.scrollEvent.bind(this) );
			this.setup();
		},
		_typeTimer: null,
		_lastVal: '',
		_perPage: 20,
		_status: 'init',
		
		setup: function () {
			this.uploader = $(document).find('[data-ipsUploader-name="'+ this.scope.attr('data-uploader') + '"]');
			this._doSearch(null);
		},


		searchPixabay: function (e) {
			this._typeTimer = setInterval( _.bind( this._typing, this ), 1500 );
		},
		
		/**
		 * Event handler for scrolling
		 * 
		 * @param 		{event}	 	e 		Event object
		 * @returns 	{void}
		 */
		scrollEvent: function (e) {
			
			var scrollScope = $('[data-role="pixabayResults"]');
			var scrollHeight = scrollScope[0].scrollHeight;
			const height = scrollScope.height();
			var distanceFromBottom = scrollHeight - scrollScope.height() - scrollScope.scrollTop();
			
			if ( this._status != 'ready' ) {
				return;
			}
			
			if( distanceFromBottom <= height * 1.2 ){
				this._status = 'loading';
				
				var offset = parseInt( this.scope.find('[data-role="pixabayMore"]').attr('data-offset') );
				this.scope.find('[data-role="pixabayMore"]').attr('data-offset', offset + this._perPage );
				
				this.scope.find('[data-role="pixabayMoreLoading"]').removeClass('ipsHide');
				
				this._doSearch( this._lastVal );
			}
		},
		
		/**
		 * The search box has blurred
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		stopSearchPixabay: function (e) {
			if( this._typeTimer ){
				clearInterval( this._typeTimer );
				this._typeTimer = null;
			}
			/* Clear Results */
		},

		/**
		 * Runs a continuous interval to check the current search value, and call the search function
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		_typing: function () {
			var textElem = this.scope.find('[data-role="pixabaySearch"]');

			if( this._lastVal == textElem.val() ){
				return;
			}
			
			this.scope.find('[data-role="pixabayMore"]').attr('data-offset', 0);
			
			this._doSearch( textElem.val() );
			
			this._lastVal = textElem.val();
		},

		/**
		 * AJAX call to fetch the images
		 *
		 * @param 		{string} 	value  		Search value
		 * @returns 	{void}
		 */
		async _doSearch(value) {
			var resultsbox = this.scope.find('[data-role="pixabayLoading"]');
			var offset = parseInt( this.scope.find('[data-role="pixabayMore"]').attr('data-offset') );

			const changed = value !== this._lastVal
			this.elem.classList.add('ipsLoading');
			if (changed) {
				this.elem.classList.add('ipsPixabay--loading-new-search');
			}
			this._status = 'loading';

			value = typeof value === 'string' ? value.trim() : value;
			let response;
			const cacheKey  = JSON.stringify({value, offset, perPage: this._perPage});
			if (ips.utils.db.get('pixabaySearch', cacheKey)) {
				response = ips.utils.db.get('pixabaySearch', cacheKey);
			} else {
				response = await ips.fetch(ips.getSetting('baseURL') + '?app=core&module=system&controller=pixabay&do=search&offset=' + offset + '&limit=' + this._perPage, {
					type: 'POST',
					data: {
						'search': value
					}
				});
				ips.utils.db.set('pixabaySearch', cacheKey, response, false, Date.now() / 1000 + 900); // 15 min cache
			}

			this.elem.classList.remove('ipsLoading');
			this.elem.classList.remove('ipsPixabay--loading-new-search');

			if ( response.error )
			{
				resultsbox.html(`<div class="ipsMessage ipsMessage--warning">${response.error}</div>`);
				this.status = 'error';
			}
			else
			{
				if (changed) {
					resultsbox.html('');
					this.elem.scrollTo({top: 0});
				}
				_.each( response.images, function (term) {
					const div = document.createElement('div');
					div.innerHTML = ips.templates.render('core.editor.pixabayThumb', {
						thumb: term.thumb,
						url: term.url,
						imgid: term.imgid,
						height: term.thumbHeight,
						width: term.thumbWidth,
						ratio: term.thumbWidth / term.thumbHeight,
					} );

					const content = div.querySelector('.ipsPixabayThumb');
					if (content) {
						resultsbox.append(content);
					}
				} );
				if ( offset > 0 || response.pagination.total_count > offset + this._perPage ) {
					this.scope.find('[data-role="pixabayMoreLoading"]').addClass('ipsHide');
					this._status = 'ready';
				}

				// No more available
				if ( response.pagination.total_count <= offset + this._perPage ) {
					this.scope.find('[data-role="pixabayMoreLoading"]').addClass('ipsHide');
					this._status = 'done';
				}
			}
		},
		
		selectImage: function(e)
		{
			var image = $( e.target );

			var pluploadObj = this.uploader.get(0);

			ips.getAjax()( ips.getSetting('baseURL') + '?app=core&module=system&controller=pixabay&do=getById&id=' + image.attr('data-id') ).done( async function (response) {
				var randomId = Math.random().toString(36).substring(7);
				var bstr = atob( response.content );
				var n = bstr.length;
				var u8arr = new Uint8Array(n);
				while(n--) {
					u8arr[n] = bstr.charCodeAt(n);
				}
				var file = new File( [u8arr], response.filename, { type: response.type } );

				const editorObj = await ips.ui.editorv5.getObjWithInit(pluploadObj.closest('.ipsComposeArea')?.querySelector('[data-ipseditorv5]'))
				if (editorObj) {
					editorObj.getInstance().commands.injectAttachments([file])
				} else {
					pluploadObj.dispatchEvent(new AttachmentInsertEvent({
						file,
						data: {
							ready(content, data) {
								const insertable = pluploadObj.querySelector(`[data-fileid="${data.fileID}"] [data-action="insertFile"]`)
								insertable?.click();
							}
						}
					}));
				}
			} );
			
			
			/* Now clear search and close the menu */
			this._status = 'init';
			this.scope.find('[data-role="pixabaySearch"]').val('');
			this.scope.find('[data-role="pixabayLoading"]').html('');
			this.elem.classList.add('ipsLoading');
			this.scope.trigger( 'closeDialog' );
		}
	});

	class AttachmentInsertEvent extends Event {
		constructor(data) {
			super('injectFile')
			this.data = data;
		}
	}
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/streams" javascript_name="ips.streams.form.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000350"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.streams.form.js
 *
 * Author: Esther Eisner
 */

;(function ($, _, undefined) {

    "use strict";

    ips.controller.register('core.admin.streams.form',
        {
            initialize: function () {
                this.checkReadStatus()
                this.elem.addEventListener('change', () => this.checkReadStatus())
            },

            /**
             * Disable the ability to include comments if we set the stream type to unread.
             * Unread logic is only at the item level, so including comments will never work.
             * @return void
             */
            checkReadStatus(){
                if(this.elem.querySelector('input[name="stream_read"][value="unread"]').checked){
                    this.elem.querySelector('input[name="stream_include_comments"][value="0"]')?.setAttribute('checked','')
                    this.elem.querySelector('input[name="stream_include_comments"][value="1"]')?.setAttribute('disabled','')
                } else {
                    this.elem.querySelector('input[name="stream_include_comments"][value="1"]')?.removeAttribute('disabled')
                }
            }
        });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/streams" javascript_name="ips.streams.form.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.streams.form.js - Streams filter form
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.streams.form', {
		loaded: {},
		formSnapshot: false,
		reloaded: false,
		_loadedContainer: {},
		_loadedClubs: false,
		_formData: {},
		
		initialize: function () {
			this.on( 'streamStateUpdate.streamForm', this.streamStateUpdate );
			this.on( 'itemClicked.sideMenu', '[data-filterType="type"]', this.selectedType );
			this.on( 'menuItemSelected', '#elStreamReadStatus, #elStreamShowMe', this.checkFormUpdate );
			this.on( 'tokenAdded tokenDeleted', this.tokensChanged );
			this.on( 'menuItemSelected', '#elStreamSortEdit', this.changeSort );
			this.on( 'click', '[data-action="saveStream"], [data-action="newStream"]', this.submitForm );
			this.on( 'click', '[data-role="streamContainer"]', this.openStreamContainer );
			this.on( 'click', '[data-role="streamClubs"]', this.openStreamClubs );
			this.on( 'click', '[data-action="dismissSave"]', this.dismissSave );
			this.on( 'keydown', 'input', this.inputKeydown );
			
			if ( this.scope.attr('data-formType') == 'createStream' ) {
				this.on( 'itemClicked.sideMenu', '[data-filterType="date"]', this.selectedDate );
				this.on( 'itemClicked.sideMenu', '[data-filterType="ownership"]', this.selectedOwnership );
			} else {
				this.on( 'menuItemSelected', '#elStreamFollowStatus', this.selectedFollowStatus );
				this.on( 'menuItemSelected', '#elStreamTimePeriod', this.selectedDate );
				this.on( 'menuItemSelected', '#elStreamOwnership', this.selectedOwnership );
			}
			
			this.on( 'change', '#elSelect_stream_club_filter', this.clubSelectionChanged );
			this.on( 'change', '#stream_club_filter_unlimited', this.clubSelectionChanged );
			
			this.on( 'menuItemSelected', '#elStreamSortEdit, #elStreamFollowStatus', this.selectedMenuItem );
			this.on( 'menuItemSelected', '#elStreamTimePeriod, #elStreamOwnership, #elStreamShowMe', this.selectedMenuItem );
			
			this.on( 'menuItemSelected', '#elStreamReadStatus', this.selectedReadStatus );

			this.on( 'menuClosed', this.menuClosed );
			
			this.setup();
		},
	
		setup: function () {
			// Custom serialization for our form
			this._serializeConfig = {
				'stream_date_range[start]': this._serializeDate,
				'stream_date_range[end]': this._serializeDate
			};

			// If we're just creating a stream, we have no configuration yet
			if( this.scope.attr('data-formType') != 'createStream' ){
				this._formData = ips.getSetting('stream_config');

				// Are we looking for unread things and data?
				this._changeReadStatus( this._formData['stream_read'] );

				this._updateFilterOverview();

				this.takeFormSnapshot();
			}

			this.trigger( 'initialFormData.stream', {
				data: this._formData
			});
		},

		/**
		 * Handles keydown on inputs inside the stream menus. 
		 * Prevents enter key from creating a new stream (which is a behavior that isn't obvious to users)
		 *
		 * @param 		{event} 	e 		Event Object
		 * @returns 	{void}
		 */		
		inputKeydown: function (e) {
			if( e.which == 13 ){
				e.preventDefault();
			}
		},
		
		/**
		 * Responds to an event from the main controller which tells us
		 * that the page state has changed, and we need to update our form field
		 * values to show the updated values
		 *
		 * @param 		{event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		streamStateUpdate: function (e, data) {
			this._formData = data.filterData;
			this._updateFieldValues();

			// Do we need to show the Save bar?
			if( !_.isUndefined( data.hideSaveBar ) && data.hideSaveBar ){
				this.scope.find('[data-role="saveButtonContainer"]').slideUp();
			} else {
				this.scope.find('[data-role="saveButtonContainer"]').slideDown();
			}
		},
		
		/**
		 * Adds a simple overview of each filter setting
		 *
		 * @returns 	{void}
		 */
		_updateFilterOverview: function () {
			
			// Only do this if we aren't creating
			if( this.scope.attr('data-formType') == 'createStream' ){
				return;
			}

			var self = this;
			var values = this._formData;
			
			var _overview = function (type) {
				return self.scope.find('[data-filter="' + type + '"] [data-role="filterOverview"]');
			};
			
			// Simple values
			_.each( ['stream_include_comments', 'stream_read', 'stream_sort', 'stream_solved'], function (val) {
				var lang = 'streamFilter_' + val + '_' + values[ val ];
				_overview( val ).html( ips.getString( lang ) );
			});
			
			// Tags
			if( !_.isUndefined( values['stream_tags'] ) && values['stream_tags'].trim() !== '' ){
				var tags = _.compact( values['stream_tags'].split(/\n/) );
			 	
				if( tags.length <= 2 ){
					var tagLang = ips.getString('streamFilter_stream_tags_tags', { 'tags': _.escape( tags.join(',') ) });
				} else {
					var tagLang = ips.pluralize( ips.getString('streamFilter_stream_tags_count'), tags.length ); 
				}
				
				_overview( 'stream_include_comments' ).append( '; ' + tagLang );
			} else {
				_overview( 'stream_include_comments' ).append( '; ' + ips.getString( 'streamFilter_stream_tags_noTags' ) );
			}
			
			// Ownership
			if ( values['stream_ownership'] == 'custom' && ( _.isUndefined( values['stream_custom_members'] ) || values['stream_custom_members'] == null || values['stream_custom_members'] == '' ) ) {
				values['stream_ownership'] = 'all'
			}
			if( values['stream_ownership'] !== 'custom' ){
				var ownershipLang = 'streamFilter_stream_ownership_' + values[ 'stream_ownership' ];
				_overview( 'stream_ownership' ).html( ips.getString( ownershipLang ) );
			} else if ( !_.isUndefined( values['stream_custom_members'] ) && values['stream_custom_members'] != null ) {
				var names = _.compact( ( _.isObject( values['stream_custom_members'] ) ? values['stream_custom_members'] : values['stream_custom_members'].split(/\n/) ) );
				var ownershipLang = ips.pluralize( ips.getString('streamFilter_stream_ownership_custom'), names.length );  
				_overview( 'stream_ownership' ).text( ownershipLang );
			}
			
			// Following
			if( values['stream_follow'] == 'all' ){
				_overview( 'stream_follow' ).html( ips.getString( 'streamFilter_stream_follow_all' ) );
			} else {
				var value = _.keys( values['stream_followed_types'] );
				var follows = [];
				
				for( var i = 0; i < value.length; i++ ){
					follows.push( ips.getString( 'streamFilter_stream_follow_' + value[i] ) );
				}
				
				_overview( 'stream_follow' ).html( follows.join( ', ' ) );
			}

			// Date range
			if ( values['stream_date_type'] == 'relative' && ( _.isUndefined( values['stream_date_relative_days'] ) || values['stream_date_relative_days'] == null || values['stream_date_relative_days'] == '' ) ) {
				values['stream_date_type'] = 'all';
			} else if( values['stream_date_type'] == 'custom' && ( ( _.isUndefined( values['stream_date_range']['start'] ) || values['stream_date_range']['start'] == null || values['stream_date_range']['start'] == '' ) || ( _.isUndefined( values['stream_date_range']['end'] ) || values['stream_date_range']['end'] == null || values['stream_date_range']['end'] == '' ) ) ) {
				values['stream_date_type'] = 'all';
			}
			if( values['stream_date_type'] == 'all' || values['stream_date_type'] == 'last_visit' ){
				_overview( 'stream_date_type' ).html( ips.getString( 'streamFilter_stream_date_type_' + values['stream_date_type'] ) );
			} else if( values['stream_date_type'] == 'relative' ){

				if( values['stream_date_relative_days']['unit'] == 'w' ) {
					var dateLang = ips.pluralize( ips.getString('streamFilter_stream_date_type_relative_weeks'), ( values['stream_date_relative_days']['val'] ? values['stream_date_relative_days']['val'] : values['stream_date_relative_days'] ) );
				}
				else {
					var dateLang = ips.pluralize( ips.getString('streamFilter_stream_date_type_relative'), ( values['stream_date_relative_days']['val'] ? values['stream_date_relative_days']['val'] : values['stream_date_relative_days'] ) );
				}
				_overview( 'stream_date_type' ).text( dateLang );
			} else {
				// If this is a member-owned stream *or* it's a real date stamp (xx-xx-xxxx), we need to strip out the timezone
				// However, if it's an admin-created stream, there's no timezone in the stamp, so leave as-is
				if( !_.isUndefined( values['__stream_owner'] ) || ( isNaN( values['stream_date_range']['start'] ) && values['stream_date_range']['start'].match('-') ) ){
					var start = ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( isNaN( values['stream_date_range']['start'] ) && values['stream_date_range']['start'].match('-') ? values['stream_date_range']['start'] : values['stream_date_range']['start'] * 1000 ) ) );
					var end = ips.utils.time.localeDateString( ips.utils.time.removeTimezone( new Date( isNaN( values['stream_date_range']['end'] ) && values['stream_date_range']['end'].match('-') ? values['stream_date_range']['end'] : values['stream_date_range']['end'] * 1000 ) ) );
				} else {
					var start = ips.utils.time.localeDateString( new Date( values['stream_date_range']['start'] * 1000 ) );
					var end = ips.utils.time.localeDateString( new Date( values['stream_date_range']['end'] * 1000 ) );
				}

				if( !_.isUndefined( values['stream_date_range']['start'] ) && !_.isUndefined( values['stream_date_range']['end'] ) ){
					var dateLang = ips.getString('streamFilter_stream_date_type_range', { start: start, end: end });
				} else if( !_.isUndefined( values['stream_date_range']['start'] ) ) {
					var dateLang = ips.getString('streamFilter_stream_date_type_start', { start: start });
				} else if( !_.isUndefined( values['stream_date_range']['start'] ) ) {
					var dateLang = ips.getString('streamFilter_stream_date_type_end', { end: end });
				}
				
				_overview( 'stream_date_type' ).text( dateLang );
			}
			
			// Content
			if( !values['stream_classes'] || values['stream_classes_type'] == 0 ){
								
				if ( values['stream_club_select'] == 'none' ) {
					_overview( 'stream_classes' ).html( ips.getString( 'streamFilter_stream_classes_no_clubs' ) );
				} else if ( values['stream_club_select'] == 'all' ) {
					_overview( 'stream_classes' ).html( ips.getString( 'streamFilter_stream_classes_all' ) );
				} else if( values['stream_club_filter'] ) {
					_overview( 'stream_classes' ).text( ips.getString('loading') );
					this._loadClubs(function(){
						var elem = this.scope.find('#elSelect_stream_club_filter');
						var clubIds = values['stream_club_filter'].split(',');
						var clubNames = [];
						for( var i = 0; i < clubIds.length; i++ ){
							var option = elem.find('option[value="' + clubIds[i] + '"]');
		
							if( option.length ){
								clubNames.push( option.text().trim() );
							}
						}
						_overview( 'stream_classes' ).text( clubNames.join( ', ') );
					}.bind(this));
				}
			} else {
				var classKeys = _.keys( values['stream_classes'] );
				var classes = [];
				
				for( var i = 0; i < classKeys.length; i++ ){
					var elem = this.scope.find('[data-class="' + classKeys[i].replace(/\\/g, '\\\\') + '"] > span');

					if( elem.length ){
						classes.push( elem.text().trim() );
					}
				}
				
				_overview( 'stream_classes' ).text( classes.join( ', ') );
			}
		},
		
		/**
		 * Update fields in our form to reflect the values in _formData,
		 * which have likely been updated by the page state changing.
		 *
		 * @returns 	{void}
		 */
		_updateFieldValues: function () {
			
			var self = this;
			var data = this._formData;
			
			if ( data['stream_read'] == 'unread' ) {
				data['stream_include_comments'] = 0;
			}
			
			// Basics
			_.each( ['stream_include_comments', 'stream_read', 'stream_sort', 
				'stream_follow', 'stream_ownership', 'stream_date_type'], function (key) {
				self.scope.find('[name="' + key + '"]')
					.prop( 'checked', false )
					.filter('[value="' + data[ key ] + '"]')
						.prop('checked', true)
						.change();
			});
			
			// Following types			
			var followSelector = _.map( data['stream_followed_types'], function (val, key) {
				return '[name="stream_followed_types[' + key + ']"]';
			});
			
			this.scope.find('[name^="stream_followed_types"]')
				.prop('checked', false)
				.filter( followSelector.join(',') )
					.prop('checked', true)
					.change();
					
			// Ownership
			if( this.scope.find('#elInput_stream_custom_members').length ){
				var ownerAC = ips.ui.autocomplete.getObj( this.scope.find('#elInput_stream_custom_members') );
				ownerAC.removeAll();
				
				if( data['stream_ownership'] == 'custom' ){
					var names = _.compact( data['stream_custom_members'].split(/\n/) );
					
					for( var i = 0; i < names.length; i++ ){
						ownerAC.addToken( names[ i ] );
					}
				}
			}
			
			// Tags
			if ( !_.isUndefined( data['stream_tags'] ) ){
				var tags = _.compact( data['stream_tags'].split(/\n/) );
				var tagAC = ips.ui.autocomplete.getObj( this.scope.find('#elInput_stream_tags') );
				tagAC.removeAll();
				
				if( tags.length ){
					for( var i = 0; i < tags.length; i++ ){
						tagAC.addToken( tags[ i ] );
					}
				}
			}

			// Dates
			this.scope.find('[name="stream_date_relative_days"], [name="stream_date_range[start]"], [name="stream_date_range[end]"]').val('');
			
			if( data['stream_date_type'] == 'relative' ){
				this.scope.find('[name="stream_date_relative_days"]').val( data['stream_date_relative_days'] );
			} else if( data['stream_date_type'] == 'custom' ){
				var html5 = ips.utils.time.supportsHTMLDate();
				
				if( data['stream_date_range']['start'] ){
					var startDateObj = new Date( data['stream_date_range']['start'] );
					
					if( html5 ){
						this.scope.find('[name="stream_date_range[start]"]').get(0).valueAsDate = startDateObj;
					} else {
						this.scope.find('[name="stream_date_range[start]"]').datepicker( 'setDate', ips.utils.time.removeTimezone( startDateObj ) );
					}
				}
				
				if( data['stream_date_range']['end'] ){
					var endDateObj = new Date( data['stream_date_range']['end'] );
					
					if( html5 ){
						this.scope.find('[name="stream_date_range[end]"]').get(0).valueAsDate = endDateObj;
					} else {
						this.scope.find('[name="stream_date_range[end]"]').datepicker( 'setDate', ips.utils.time.removeTimezone( endDateObj ) );
					}
				}
			}
			
			// Classes
			var classChecks = $('#elStreamContentTypes_menu').find('[type="checkbox"][name^="stream_classes"]');
			var classSelector = [];
			
			classChecks
				.prop('checked', false)
				.change()
				.closest('.ipsSideMenu_item')
					.removeClass('ipsSideMenu_itemActive');
			
			if( data['stream_classes_type'] == 0 ){
				this.scope.find('[name="stream_classes_type"]')
					.first()
					.closest('.ipsSideMenu_item')
						.addClass('ipsSideMenu_itemActive');
			} else {
				var classKeys = _.keys( data['stream_classes'] );
				
				// It's inefficient to do a .find on each key separately here, but I simply could not
				// get jQuery to find matches when a combined selector was used. 
				// The backslashes really cause a problem.
				_.each( classKeys, function (val) {
					self.scope.find( '[data-class="' + val.replace(/\\/g, '\\\\') + '"] input[type="checkbox"]' )
						.prop('checked', true)
						.change()
						.closest('.ipsSideMenu_item')
							.addClass('ipsSideMenu_itemActive');
				});
			}
			
			
			this._updateFilterOverview();
		},
		
		/**
		 * Stream container toggle
		 *
		 * @param 		{event} 	e 		Event
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		openStreamContainer: function (e, data) {
			e.preventDefault();
			
			var self = this;
			var link = $( e.currentTarget );
			var className = link.attr('data-class');
			var contentKey = link.attr('data-contentKey');
			var nodeContainer = link.next('.cStreamForm_nodes');
			
			if( !this._loadedContainer[ className ] ){
				// Show node container with loading text
				nodeContainer.slideDown();
				var containers = [];
				
				if ( _.isObject( ips.getSetting('stream_config') ) && ! _.isEmpty( ips.getSetting('stream_config')['containers'] ) ) {
					var keys = _.keys( ips.getSetting('stream_config')['containers'] );
					var values = _.values( ips.getSetting('stream_config')['containers'] );
					
					for( var i = 0; i < keys.length; i++ ){
						containers.push( 'stream_containers[' + keys[i] + ']=' + values[i] );
					}	
				}

				// Load container
				ips.getAjax()( this.scope.find('form').attr('action').replace( 'do=create', '' ), {
						type: 'post',
						data: 'do=getContainerNodeElement&className=' + className + '&key=' + contentKey + '&' + containers.join('&')
					} )
					.done( function (returnedData) {
						// Add this content to the menu
						nodeContainer.html( returnedData.node );

						// Remember we've loaded it
						self._loadedContainer[ className ] = true;
	
						$( document ).trigger( 'contentChange', [ nodeContainer.parent() ] );
					});
			} else {
				nodeContainer.slideToggle();
			}
		},
		
		/**
		 * Stream clubs toggle
		 *
		 * @param 		{event} 	e 		Event
		 * @returns 	{void}
		 */
		openStreamClubs: function (e) {
			e.preventDefault();			
			
			var clubContainer = $('#elStreamClubs');
			if ( !this._loadedClubs ) {
				clubContainer.slideDown();
				this._loadClubs(null);
			} else {
				clubContainer.slideToggle();
			}
		},
		
		/**
		 * Stream clubs toggle
		 *
		 * @param 		{event} 	e 		Event
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		_loadClubs: function(callback) {
			if ( !this._loadedClubs ) {
				var clubContainer = $('#elStreamClubs');
				
				var extra = null;
				if ( _.isObject( ips.getSetting('stream_config') ) ) {
					extra = '&stream_club_select=' + ips.getSetting('stream_config')['stream_club_select'] + '&stream_club_filter=' + ips.getSetting('stream_config')['stream_club_filter'];
				}
							
				var self = this;
				ips.getAjax()( this.scope.find('form').attr('action').replace( 'do=create', '' ), {
					type: 'post',
					data: 'do=getClubElement&' + extra
				} )
				.done( function (returnedData) {
					clubContainer.html( returnedData.field );
					self._loadedClubs = true;
					$( document ).trigger( 'contentChange', [ clubContainer.parent() ] );
					
					if ( callback ) {
						callback();
					}
				});
			} else if ( callback ) {
				callback();
			}
		},
		
		/**
		 * Event handler for menus being closed.
		 *
		 * @param 		{event} 	e 		Event
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		menuClosed: function (e, data = e.detail) {
			if ( data.elemID == 'elStreamContentTypes' || ( $('#' + data.elemID + '_menu' ).length && data.elemID != 'elSaveStream' ) ) {
				_.delay( function( self )
				{
					self.checkFormUpdate();
					self.reloaded = true;
				}, 500, this );
			}
		},
		
		/**
		 * Check to see if any of the form elements have changed and if so, update listing
		 *
		 * @returns 	{void}
		 */
		checkFormUpdate: function() {
			if( this.hasFormChanged() ){
				this.updateResults();
				this.scope.find('#elSaveStream').removeClass('i-opacity_4');
				this.takeFormSnapshot();
			}
		},
		
		/**
		 * Has the form changed?
		 *
		 * @returns {boolean}
		 */
		 hasFormChanged: function() {
			if ( _.isEqual( this.formSnapshot, ips.utils.form.serializeAsObject( this.scope.find('form'), this._serializeConfig ) ) ) {
				return false;
			}
			return true;
		},
		
		/**
		 * Take a form snapshot
		 *
		 * @returns {void}
		 */
		takeFormSnapshot: function() {
			this.formSnapshot = ips.utils.form.serializeAsObject( this.scope.find('form'), this._serializeConfig );
		},
		
		/**
		 * When tokens have changed in an autocomplete, mark the form as dirty
		 *
		 * @returns {void}
		 */
		tokensChanged: function () {
			this.reloaded = false;
		},

		/**
		 * Change the sort
		 *
		 * @returns {void}
		 */
		changeSort: function () {
			this.checkFormUpdate();
		},
		
		/**
		 * Prevents default event when a menu item is selected
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object}	data 	Event data object
		 * @returns {void}
		 */
		selectedMenuItem: function (e, data = e.detail) {
			if( data.originalEvent ){
				data.originalEvent.preventDefault();
			}			
		},
		
		/**
		 * Handles user selecting read status
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		selectedReadStatus: function (e, data = e.detail) {
			if( data.originalEvent ){
				// data.originalEvent.preventDefault();
			}
			
			this._changeReadStatus( data.selectedItemID );
		},
		
		/**
		 *  Toggles stuff when read status is changed
		 *
		 * @param 		{string} 	type 		Type (all/unread)
		 * @returns 	{void}
		 */
		_changeReadStatus: function( type ) {
			if( type == 'unread' ){
				/* Unread must be items only, the back-end does not have logic to filter out read comments from a stream of comments */
				this._formData['stream_include_comments'] = 0;
				this.scope.find('#stream_ownership_0').click();
				this.scope.find('#stream_ownership_1').attr('disabled', true);
			} else {
				this.scope.find('#stream_ownership_1').removeAttr('disabled');
			}
		},
		
		/**
		 * Dismiss the save bar
		 *
		 * @param 	{Event} 	e 		Event object
		 * @returns {void}
		 */
		dismissSave: function (e) {
			this.scope.find('[data-role="saveButtonContainer"]').slideUp();
		},

		/**
		 * Save the form
		 * We add different params depending on what we're doing - save as new stream,
		 * save & update, or just update.
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		submitForm: function (e) {
			
			var button = $( e.currentTarget );
			var form = button.closest('form');

			// If we are creating a stream, we don't want to handle the form with JS
			if( this.scope.attr('data-formType') == 'createStream' ){
				return;	
			}

			// If we're creating a new stream, just submit the page
			if( button.attr('data-action') == 'newStream' ){
				
				form.prepend( 
					$('<input />')
						.attr('type', 'hidden')
						.attr('name', 'do')
						.attr('value', 'create') 
				);

			} else {
				this._formData = ips.utils.form.serializeAsObject( this.scope.find('form'), this._serializeConfig );

				// Send form data up
				this.trigger('formSubmitted.stream', {
					data: this._formData,
					action: ( button.attr('data-action') == 'newStream' ) ? 'createForm' : 'saveForm'
				});
			}
		},
		
		/**
		 * Update results
		 * Takes the value from the form and updates the result set
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		updateResults: function () {
			this._formData = ips.utils.form.serializeAsObject( this.scope.find('form'), this._serializeConfig );
			
			this._updateFilterOverview();
			
			this.trigger('formSubmitted.stream', {
				data: this._formData,
				action: 'updateForm'
			});
		},

		/**
		 * Handles user selecting 'date' as a filter. Shows the date fields in the form
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		selectedDate: function (e, data = e.detail) {
			this.reloaded = false;
			
			if( data.selectedItemID == 'custom' ){
				this.scope.find('[data-role="dateRelativeForm"]').slideUp();
				this.scope.find('[data-role="dateForm"]').slideDown();
			} else if( data.selectedItemID == 'relative' ){
				this.scope.find('[data-role="dateForm"]').slideUp();
				this.scope.find('[data-role="dateRelativeForm"]').slideDown();
				this.scope.find('[name="stream_date_relative_days"]').focus();
			} else {
				// Check undefined to prevent actioning when clicking on form fields
				if ( ! _.isUndefined( data.selectedItemID ) ) {
					this.scope.find('[data-role="dateForm"]').slideUp();
					this.scope.find('[data-role="dateRelativeForm"]').slideUp();
					this.checkFormUpdate();
				}
			}
		},
		
		/**
		 * Handles user selecting 'follow status' as a filter.
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		selectedFollowStatus: function (e, data = e.detail) {
			
			// Get selected items
			var selectedItems = data.selectedItems;
			
			if( !_.size( selectedItems ) ){
				this.scope.find('[name="stream_follow"]').val( 'all' );
			} else {
				this.scope.find('[name="stream_follow"]').val( 'followed' );
			}
			
			this.checkFormUpdate();
		},
		
		/**
		 * Handles user selecting 'ownership' as a filter. Shows the custom member field
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		selectedOwnership: function (e, data = e.detail) {
			if( data.selectedItemID == 'custom' ){
				this.scope.find('[data-role="ownershipMemberForm"]').slideDown();
			} else {
				// Check undefined to prevent actioning when clicking on form fields
				if ( ! _.isUndefined( data.selectedItemID ) ) {
					this.scope.find('[data-role="ownershipMemberForm"]').slideUp();
					this.checkFormUpdate();
				}
			}
		},
		
		/**
		 * Handles changing the club selectionb
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		clubSelectionChanged: function () {
						
			if ( this.scope.find('[name="stream_club_filter_dummy_unlimited"]').is(':checked') ) {
				this.scope.find('[name="stream_club_select"]').val( 'all' );
			} else {
				this.scope.find('[name="stream_club_select"]').val( 'select' );
				this.scope.find('[name="stream_club_filter"]').val( $('#elSelect_stream_club_filter').val() );
			}

		},

		/**
		 * Responds to clicking a content type in the form. Ensures 'all' is selected
		 * if no other types are.
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object from the menu
		 * @returns 	{void}
		 */
		selectedType: function (e, data = e.detail) {
			var self = this;
			var typeMenu = this.scope.find('[data-filterType="type"]');
			var all = typeMenu.find('[data-ipsMenuValue="__all"]');
			var allButAll = typeMenu.find('[data-ipsMenuValue]:not( [data-ipsMenuValue="__all"] )');
			var allButAllChecks = allButAll.find('> input[type="checkbox"]');

			this.reloaded = false;
			
			if( data.selectedItemID == '__all' ){
				// Did the user click 'all'? If so, uncheck everything else and hide all content filters
				allButAll
					.removeClass('ipsSideMenu_itemActive')
					.find('> input[type="checkbox"]')
						.prop( 'checked', false );

				// Make sure 'all' is checked
				all.addClass('ipsSideMenu_itemActive');

				this.scope.find('input[type="radio"][name="stream_classes_type"][value="0"]').prop( 'checked', true );

				// Hide any content filters
				this.scope.find('[data-contentType]').closest('.cStreamForm_nodes').slideUp();

			} else {

				// If we have any checked items, uncheck 'all'
				if( allButAllChecks.filter(':checked').length ){
					all.removeClass('ipsSideMenu_itemActive')
					
					this.scope.find('input[type="radio"][name="stream_classes_type"][value="1"]').prop( 'checked', true );

					// If the selected types have extra filters, show those too
					allButAllChecks.filter(':checked').each( function () {
						var type = $( this ).closest('[data-ipsMenuValue]').attr('data-ipsMenuValue');

						if( self.scope.find('[data-contentType="' + type + '"]').length ){
							self.scope.find('[data-contentType="' + type + '"]').slideDown();
						}
					});

					// ...and hide any which aren't checked
					allButAllChecks.filter(':not( :checked )').each( function () {
						var type = $( this ).closest('[data-ipsMenuValue]').attr('data-ipsMenuValue');

						if( self.scope.find('[data-contentType="' + type + '"]').length ){
							self.scope.find('[data-contentType="' + type + '"]').slideUp();
						}
					})
				} else {
					// Nothing is checked now, so check 'all'
					all.addClass('ipsSideMenu_itemActive')
						.find('> input[type="checkbox"]')
							.prop( 'checked', true );

					this.scope.find('[data-contentType]').slideUp();
				}	
			}
		},

		/**
		 * A function which will be passed into the serializeAsObject function so that
		 * we can format dates consistently as YYYY-MM-DD. 
		 * MUST return a string.
		 *
		 * @param 		{string} 	name	Name of form field
		 * @param 		{string} 	value 	Value of form field as returned by jQuery's serializeArray()
		 * @returns 	{string}
		 */
		_serializeDate: function (name, value) {
			// If we're an HTML5 browser, dates are already in YYYY-MM-DD format, so we can return
			if( ips.utils.time.supportsHTMLDate() ){
				return value;
			}

			var dateObj = ips.utils.time.getDateFromInput( $('input[name=' + ips.utils.css.escapeSelector( name ) + ']') );

			// Nothing if this isn't really a date
			if( !ips.utils.time.isValidDateObj( dateObj ) ){
				return '';
			}

			// Format the date to YYYY-MM-DD
			var month = ( '0' + ( dateObj.getUTCMonth() + 1 ) ).slice( -2 );
			var day = ( '0' + ( dateObj.getUTCDate() ) ).slice( -2 );

			return dateObj.getUTCFullYear() + '-' + month + '-' + day;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/streams" javascript_name="ips.streams.main.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.streams.main.js - Main stream view
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.streams.main', {

		_streamLoadingOverlay: null,
		_tooltip: null,
		_tooltipTimer: null,
		_baseURL: '',
		_streamID: 0,
		_currentView: '',

		_shortInterval: 15, // Seconds
		_longInterval: 45, // Seconds
		_killUpdate: 45, // Minutes
		_timer: null,
		_killTimer: null,
		_activityUpdate: null,
		_loadMore: null,
		_timestamp: 0,
		_autoUpdate: false,
		_windowFocus: false,

		initialize() {
			this.on( 'formSubmitted.stream', this.formSubmitted );
			this.on( 'initialFormData.stream', this.initialFormData );
			this.on( 'loadMoreResults.stream', this.loadMoreResults );
			this.on( 'latestTimestamp.stream', this.latestTimestamp );
			this.on( 'click', '[data-action="switchView"]', this.switchView );
			this.on( 'menuOpened', '#elStreamShare', this.menuOpened );
			this.on( 'click', '[data-action="toggleStreamDefault"]', this.toggleDefault );
			this.on( 'click', '[data-action="removeStream"]', this.removeStream );
			this.on( 'click', '[data-action="loadMore"]', this.loadMoreResults );
			this.on( 'resultsUpdated.stream', this.resultsUpdated );
			this.on( document, 'markAllRead', this.markAllRead );

			// Figure out the visibility event we need
			this.on( document, ips.utils.events.getVisibilityEvent(), this.windowVisibilityChange );

			// Primary event that watches for URL changes
			this.on( window, 'historychange:streams', this.stateChange );
			
			this.setup();
		},

		setup() {
			this._streamID = this.scope.attr('data-streamID');			
			this._baseURL = ips.getSetting('stream_config')['url'];

			if ( this._baseURL.match(/\?/) ) {
				this._baseURL += '&';
			} else {
				this._baseURL += '?';
			}

			// If the last character is &, we can remove that because it'll be added back later
			if( this._baseURL.slice(-1) === '&' ){
				this._baseURL = this._baseURL.slice( 0, -1)
			}

			// Get the newest timestamp
			this._timestamp = parseInt( this.scope.find('[data-timestamp]').first().attr('data-timestamp') );
			this._currentView = this.scope.find('[data-action="switchView"].ipsDataFilters__button--active').attr('data-view');

			if( !_.isUndefined( this.scope.find('[data-role="streamResults"]').attr('data-autoPoll') ) ){
				this._autoUpdate = true;
				this.windowVisibilityChange(); // Call our visibility method manually to determine window visibility
			}

			// Hide the "Show filters" button if we don't have filters. This happens in the All Activity stream
			if(!document.getElementById('elStreamFilterForm')){
				document.querySelector("[aria-controls='elStreamFilterForm']").hidden = true;
			}
		},
		
		/**
		 * Event handler for the page state changing
		 * We have a few different states to support:
		 * - Form changes
		 * - Load More button
		 * - View type
		 * Each is handled a little differently but ultimately passes data to this._loadResults
		 *
		 * @returns 	{void}
		 */
		stateChange() {
			const state = {
				data: ips.utils.history.getState('streams') || {},
				url: window.location.href,
				title: document.title
			}

			if( ( !state.data.controller || state.data.controller !== 'core.front.streams.main' ) && this._initialURL !== state.url ){
				return;
			}

			if (state.data.action === 'saveForm' || state.data.action === 'updateForm') {
				// If this state alters the form, let the form know
				this.triggerOn( 'core.front.streams.form', 'streamStateUpdate.streamForm', {
					filterData: state.data.filterData,
					hideSaveBar: ( _.isEmpty( this._getUrlDiff( state.data.filterData ) ) || state.data.action === 'saveForm' )
				});

				// Track page view
				ips.utils.analytics.trackPageView( state.url );

				// Are we changing the sorting?
				if( !_.isUndefined( state.data.filterData.stream_sort ) ){
					this._togglePolling( !( state.data.filterData.stream_sort === 'oldest' ) );
				}

				const data = _.extend( { view: this._currentView }, state.data.filterData );

				switch (state.data.action) {
					case 'updateForm':
						data.updateOnly = 1
						break;
					case 'saveForm':
						data.form = 'save'
						break;
				}

				this._loadResults( data )
					.done((response) => {
						this.triggerOn( 'core.front.streams.results', 'updateResults.stream', {
							append: false,
							response
						});

						// Do we need to reset the URL & config?
						if (state.data.action === 'saveForm') {
							ips.setSetting( 'stream_config', JSON.parse( response.config ) );

							ips.utils.history.replaceState( {
								controller: 'core.front.streams.main',
								url: ips.getSetting( 'stream_config' )['url'],
								skipUpdate: true
							}, 'core.front.streams.main', ips.getSetting( 'stream_config' ).url );
						}
					})

			} else if( state.data.action === 'loadMore' ){

				const data = _.extend({
					before: state.data.before,
					view: this._currentView
				}, state.data.filters);

				// If it's from 'load more', load them and pass the results down
				const before = this.scope.find('[data-role="activityItem"]').last().attr('data-timestamp');
				this._loadResults( data )
					.done((response) => {
						const content = $('<div>' + response.results + '</div>');
						// We deduct one here because the SQL does a > or < which won't match all items if the timestamp is exact
						const latest = parseInt(content.find('[data-role="activityItem"]').last().attr('data-timestamp')) - 1;
						ips.utils.history.replaceState( {
							controller: 'core.front.streams.main',
							latest: latest
						}, 'core.front.streams.main', this._buildRequestURL( { before: before, latest: isNaN( latest ) ? 0 : latest } ) );

						this.triggerOn( 'core.front.streams.results', 'updateResults.stream', {
							append: true,
							response: response,
							url: this._buildRequestURL( { before: before, latest: isNaN( latest ) ? 0 : latest } )
						});
					});

			} else if (state.data.action === 'viewToggle') {
				this._setViewType(state.data.view);

				// If it's from the view toggle, load them and pass the results down
				this._loadResults({view: state.data.view, ...state.data.filters})
					.done(
						response => this.triggerOn( 'core.front.streams.results', 'updateResults.stream', {response})
					);

			} else {
				// Don't do anything
				Debug.log('skip update');
			}
		},
		
		/**
		 * Event handler for clicking the Load More button
		 *
		 * @param 		{Event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		loadMoreResults(e, data) {
			e.preventDefault();
			
			// Get the last timestap being shown
			var timestamp = this.scope.find('[data-role="activityItem"]').last().attr('data-timestamp');
			var url = this._buildRequestURL( { before: timestamp } );

			this.scope
				.find('[data-role="loadMoreContainer"] [data-action="loadMore"]')
					.addClass('ipsButton--disabled')
					.text( ips.getString('loading') );
			
			ips.utils.history.pushState({
				controller: 'core.front.streams.main',
				before: timestamp,
				filters: this._getUrlDiff( this._formData ),
				action: 'loadMore'
			}, 'streams', url );
		},

		/**
		 * Called when the view is changing
		 *
		 * @param 		{string} 	type 		The view type we're switching to
		 * @returns 	{void}
		 */
		_setViewType(type) {
			this._currentView = type;
			
			// Update the button
			this.scope
				.find('[data-action="switchView"]')
					.removeClass('ipsButton--active')
					.filter('[data-view="' + type + '"]')
						.addClass('ipsButton--active');
						
			// Set a cookie
			ips.utils.cookie.set( 'stream_view_' + this._streamID, type, true );
		},
		
		/**
		 * Handles switching views
		 * Sets a cookie so the preference is remembered
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		switchView(e) {
			e.preventDefault();

			const view = $( e.currentTarget ).attr('data-view');

			ips.utils.history.pushState({
				controller: 'core.front.streams.main',
				view,
				filters: this._getUrlDiff( this._formData ),
				action: 'viewToggle'
			}, 'streams', this._buildRequestURL({view}));
		},
		
		/**
		 * Handler for the filter form being submitted. When this happens we determine
		 * what data is different, then update the page state in order to get new results
		 *
		 * @param 		{Event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		formSubmitted(e, data) {
			this._formData = this._getFormData( data.data );
			const url = this._buildRequestURL();

			ips.utils.history.pushState( {
				controller: 'core.front.streams.main',
				url: url,
				filterData: this._formData,
				action: data.action
			}, 'streams', url );
		},
		
		/**
		 * The form has passed us its initial values on page load
		 *
		 * @param 		{Event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		initialFormData(e, data) {
			this._formData = this._getFormData( data.data );
		},

		/**
		 * The results controller has sent us the latest-shown timestamp
		 *
		 * @param 		{Event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		latestTimestamp(e, data) {
			this._timestamp = data.timestamp;
		},

		/**
		 * Event handler for windw visibility changing
		 * Allows us to slow the rate of auto-updates if the user isn't looking at the page
		 *
		 * @returns 	{void}
		 */
		windowVisibilityChange() {
			var hiddenProp = ips.utils.events.getVisibilityProp();

			if( !_.isUndefined( hiddenProp ) ){
				if( document[ hiddenProp] ){
					this._windowFocus = false;
					this._startTimer( this._longInterval );
					this._killTimer = setTimeout( _.bind( this._stopPolling, this ), this._killUpdate * 60 * 1000 );
					Debug.log("Set the kill timer");
				} else {
					this._windowFocus = true;
					this._startTimer( this._shortInterval );
					this._updateTitle(0);
					clearTimeout( this._killTimer );
					Debug.log("Cleared the kill timer");
				}
			} else {
				this._startTimer( this._longInterval );
			}
		},
		
		/**
		 * Loads new results from the server
		 *
		 * @param 		{object} 	data 		Params data object
		 * @param 		{string} 	updateType	The type of update we're doing, e.g. 'update' or 'save'
		 * @param 		{boolean} 	silent		Fetch silently? If true, won't show loading or update stream UI
		 * @returns 	{$.Deferred<*>}
		 */
		_loadResults(data, resetConfig, silent) {
			var self = this;			
			var promise = $.Deferred();
			
			if( !silent ){
				this._setStreamLoading( true );	
			}						
			
			ips.getAjax()( ips.getSetting('stream_config')['url'], {
				type: 'post',
				data: data || {}
			})
				.done( function (response) {
					if( !silent ){
						self._setStreamLoading( false );
						self._updateStreamUI( response );	
					}
					
					promise.resolve( response );
				})
				.fail( function (response) {
					if( !silent ){
						ips.ui.alert.show( {
							type: 'alert',
							message: ips.getString('errorLoadingStream'),
							icon: 'warn'
						});	
					}				
					
					promise.reject();
				});
				
			return promise;
		},
		
		/**
		 * Perform actions after the results have been updated and added to the DOM
		 *
		 * @param 		{Event} 	e 		Event Object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		resultsUpdated: function(e, data) {
			if ( this.scope.find('[data-role="activityItem"]').length === 0  ) {
				this.scope.find('[data-role="loadMoreContainer"]').hide();
				this.scope.find('[data-role="streamContent"]').removeClass('ipsStream_withTimeline');
			}
			else{
				this.scope.find('[data-role="streamContent"]').addClass('ipsStream_withTimeline');
				this.scope.find('[data-role="loadMoreContainer"]').show();
			}
		},
		
		/**
		 * Processes an update after new results have been loaded
		 * This method is responsible for the stream UI. The actual results
		 * are processed by core.front.streams.results.
		 *
		 * @param 		{object} 	response 	Event data object from form controller
		 * @returns 	{void}
		 */
		_updateStreamUI(response) {
			Debug.log("Updating stream UI...");
			
			// Update blurb
			this.scope.find('[data-role="streamBlurb"]').text( response.blurb.replace(/&#039;/g, "'") );
			this.scope.find('[data-role="streamTitle"]').html( response.title );
		
			// Hide or reset "Load more" button if needed
			if( response.count === 0 ){
				this.scope.find('[data-role="loadMoreContainer"]').show().html( ips.templates.render('core.streams.noMore') );
			} else {
				this.scope.find('[data-role="loadMoreContainer"]').show().html( ips.templates.render('core.streams.loadMore') );
			}	
			
			// Update menu
			if( response.id ){
				var menuItem = $('body').find('[data-streamid="' + response.id + '"] .ipsNavBar__text');
				menuItem.html( response.title );
			}
		},
		
		/**
		 * Takes a raw form data object and returns only the keys we're interested in
		 *
		 * @param 		{object} 	data	Form data object
		 * @returns 	{object}
		 */
		_getFormData(data) {			
			var returnValues = {};
			
			// Keep any data prefixed with 'stream'
			_.each( data, function (val, key){
				if( key.startsWith('stream_') ){
					returnValues[ key ] = val;
				}
			});

			// Remove the __EMPTY from classes
			try {
				if( !_.isUndefined( returnValues['stream_classes']['__EMPTY'] ) ){
					returnValues['stream_classes'] = _.omit( returnValues['stream_classes'], '__EMPTY' );
				}	
			} catch (err) { }			
			
			return returnValues;
		},
		
		/**
		 * Returns an object that only contains the params that are
		 * different to our base stream config, allowing us to use them in
		 * the URL but not duplicate the 'default' stream values
		 *
		 * @param 		{object} 	data	Form data object
		 * @returns 	{object}
		 */
		_getUrlDiff(data) {

			var returnedValues = {};
			var defaultValues = ips.getSetting( 'stream_config' );

			// Reset any values that have been altered 
			if ( ! _.isUndefined( defaultValues['changed'] ) ) {
				_.each( defaultValues['changed'], function( val, key ) {
					returnedValues[ ( key === 'containers' ) ? 'stream_containers' : key ] = defaultValues[ key ];
				}  );
			}

			if( !_.size( data ) ){
				return returnedValues;
			}

			// Simple values
			_.each( ['stream_sort', 'stream_include_comments', 'stream_read', 'stream_default_view', 'stream_club_select', 'stream_club_filter'], function (val) {
				if( defaultValues[ val ] !== data[ val ] && !_.isUndefined( data[ val ] ) ){
					returnedValues[ val ] = data[ val ];
				}
			});
			
			// Ownership
			if( data['stream_ownership']=== 'custom' ){
				// We're filtering by custom members, so work out if there's any differences
				var newNames = _.isObject( data['stream_custom_members'] ) ? data['stream_custom_members'] : data['stream_custom_members'].split(/\n/);
				var oldNames = defaultValues['stream_custom_members'];
				
				if ( ! _.isObject( oldNames ) ) {
					oldNames = [];
				}
				
				var nameIntersection = _.intersection( newNames, oldNames );

				// Got any names now?
				if ( ! newNames.length ) {
					returnedValues['stream_ownership'] = 'all';
				}
				// If the lengths don't match, include them
				else if( newNames.length !== oldNames.length || nameIntersection.length !== newNames.length ){
					returnedValues['stream_ownership'] = 'custom';
					returnedValues['stream_custom_members'] = data['stream_custom_members'];
				}
			} else if( defaultValues['stream_ownership'] !== data['stream_ownership'] ) {
				returnedValues['stream_ownership'] = data['stream_ownership'];
			}
			
			// Follows
			if( !( defaultValues['stream_follow']=== 'all' && data['stream_follow']=== 'all' ) ){
				if( data['stream_follow']=== 'followed' ){
					var newFollowTypes = _.keys( data['stream_followed_types'] );
					var oldFollowTypes = _.keys( defaultValues['stream_followed_types'] );
					var followIntersection = _.intersection( newFollowTypes, oldFollowTypes );
					
					if( newFollowTypes.length !== oldFollowTypes.length || followIntersection.length !== newFollowTypes.length ){
						returnedValues['stream_follow'] = 'followed';
						returnedValues['stream_followed_types'] = data['stream_followed_types'];
					}
				} else {
					returnedValues['stream_follow'] = data['stream_follow'];
				}			
			}
			
			// Tags
			if( !_.isUndefined( data['stream_tags'] ) && !_.isEmpty( data['stream_tags'].trim() ) ){
				var newTags = _.compact( ( data['stream_tags'] || '' ).split(/\n/) );
				var oldTags = _.compact( ( defaultValues['stream_tags'] || '' ).split(/\n/) );
				var tagIntersection = _.intersection( newTags, defaultValues['stream_tags'] );

				if( newTags.length !== oldTags.length || tagIntersection.length !== newTags.length ){
					returnedValues['stream_tags'] = _.map( newTags, function (str) { return str.trim() } ).join(',');
				}
			} else if ( defaultValues['stream_tags'] ) {
				// There were tags
				returnedValues['stream_tags'] = '';
			}
			
			// Dates
			if( data['stream_date_type']=== 'custom' ){
				var startTest = data['stream_date_range']['start'];

				if( startTest.toString().match( /^[0-9]{9,10}$/ ) )
				{
					var start = data['stream_date_range']['start'];
					var end = data['stream_date_range']['end'];
				}
				else
				{
					var start = new Date( data['stream_date_range']['start'] ).getTime() / 1000;
					var end = new Date( data['stream_date_range']['end'] ).getTime() / 1000;
				}
				
				// Check if there's a start date, and if so, is it different to the stream default?
				if( data['stream_date_range']['start'] && 
					( _.isUndefined( defaultValues['stream_date_range'] ) || start !== defaultValues['stream_date_range']['start'] ) ){
					returnedValues['stream_date_type'] = 'custom';
					returnedValues['stream_date_start'] = start;
				}
				// Check if there's an end date, and if so, is it different to the stream default?
				if( data['stream_date_range']['end'] && 
					( _.isUndefined( defaultValues['stream_date_range'] ) || end !== defaultValues['stream_date_range']['end'] ) ){
					returnedValues['stream_date_type'] = 'custom';
					returnedValues['stream_date_end'] = end;
				}
			} else if( data['stream_date_type']=== 'relative' ){
				// Has the number of relative days changed?
				if( defaultValues['stream_date_relative_days'] !== data['stream_date_relative_days'] ){
					returnedValues['stream_date_type'] = 'relative';
					returnedValues['stream_date_relative_days'] = data['stream_date_relative_days'];
				}
			} else if( defaultValues['stream_date_type'] !== data['stream_date_type'] ){
				returnedValues['stream_date_type'] = data['stream_date_type'];
			}
			
			// Classes
			if( data['stream_classes_type']=== 0 && defaultValues['stream_classes_type']=== 1 ){
				returnedValues['stream_classes'] = {};
			} else {
				var newClasses = _.without( _.keys( data['stream_classes'] ), '__EMPTY' );
				var classIntersection = _.intersection( newClasses, _.keys( defaultValues['stream_classes'] ) );
			
				if( classIntersection.length !== newClasses.length ){
					returnedValues['stream_classes'] = _.omit( data['stream_classes'], '__EMPTY' );
				}	
			}			
			
			// Containers
			var containers = {};
			if ( ! _.isUndefined( data['stream_classes'] ) && _.isObject( data['stream_classes'] ) ) {
				_.each( _.without( _.keys( data['stream_classes'] ), '__EMPTY' ), function( val, key ) {
					var contentType = $('div[data-role="streamContainer"][data-className="' + val.replace( /\\/g, '\\\\' ) + '"]').attr('data-contentKey');
					if ( ! _.isUndefined( contentType ) && $('input[name="stream_containers_' + contentType + '"]').length ) {
						containers[ val ] = $('input[name="stream_containers_' + contentType + '"]').val();
					}
				} );
			}
			
			if ( ! _.isEmpty( containers ) ) {
				if ( ! _.isUndefined( defaultValues['containers'] ) && ! _.isEqual( containers, defaultValues['containers'] ) ) {
					returnedValues['stream_containers'] = containers;
				}
			}
			
			return returnedValues;
		},
		
		/**
		 * Builds a request URL by getting a diff of the current stream params,
		 * and adding any extra params we need.
		 *
		 * @param 		{object} 	[extraParams] 	Any extra request params to use
		 * @returns 	{string}
		 */
		_buildRequestURL(extraParams) {			
			var urlDiff = this._getUrlDiff( this._formData );
			var params = [];
			
			// Loop through each 'diffed' param to build the request URL
			_.each( urlDiff, function (val, key) {
				if( _.isObject( val ) ){
					if( !_.size( val ) ){
						params.push( key + '=' );
					} else {
						var keys = _.keys( val );
						var values = _.values( val );
						
						for( var i = 0; i < keys.length; i++ ){
							var paramValue = ( ! _.isUndefined( values[i] ) ? values[i] : 1 );
							params.push( key + '[' + encodeURIComponent( keys[i] ) + ']=' + paramValue );
						}	
					}					
				} else {
					params.push( key + '=' + encodeURIComponent( val ) );
				}
			});
			
			// Do we have extra params?
			if( _.isObject( extraParams ) ){
				_.each( extraParams, function (val, key) {
					params.push( key + '=' + encodeURIComponent( val ) );
				});
			}

			return this._baseURL + '&' + params.join('&');
		},

		/**
		 * Selects the value of the textbox in the share popup
		 *
		 * @param 		{Event} 	e 		Event object
		 * @param 		{object} 	data	Event data object
		 * @returns 	{void}
		 */
		menuOpened(e, data = e.detail) {
			$(data.menu).find('input[type="text"]').focus().get(0).select();
		},
		
		/**
		 * Confirms user click to remove this stream
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		removeStream(e) {
			e.preventDefault();
			
			ips.ui.alert.show({
				type: 'confirm',
				message: ips.getString('confirmRemoveStream'),
				callbacks: {
					ok() {
						window.location = $(e.currentTarget).attr('href') + '&wasConfirmed=1';
					},
				}
			});
		},
		
		/**
		 * Toggles a stream as the shortcut
		 *
		 * @param 		{Event} 	e 		Event object
		 * @returns 	{void}
		 */
		toggleDefault(e) {
			e.preventDefault();
		
			var self  = this;
			var link  = $( e.currentTarget );
			var value = link.attr('data-change');
			var url   = link.attr('href');
			
			ips.getAjax()( url )
				.done( function (response) {					
					if( value == 1){
						self.scope.find('[data-role="toggleDefaultTrue"]').attr('hidden', '');
						self.scope.find('[data-role="toggleDefaultFalse"]').removeAttr('hidden');
					} else {
						self.scope.find('[data-role="toggleDefaultTrue"]').removeAttr('hidden');
						self.scope.find('[data-role="toggleDefaultFalse"]').attr('hidden', '');
					}
						
					if( !response.title ) {
						$('a[data-action="defaultStream"]').hide();
					} else {
						$('a[data-action="defaultStream"]')
							.attr('href', response.url )
							.attr('aria-label', response.title )
							.show()
							.find('[data-role="defaultStreamName"]')
								.html( response.title );
					}
	
					if( value == 1 ){
						if( !ips.utils.responsive.enabled || !ips.utils.responsive.currentIs('phone') && $('a[data-action="defaultStream"]').is(':visible') ){
							self._showStreamTooltip( response.tooltip );
						} else {
							ips.utils.anim.go( 'pulseOnce', $('a[data-action="defaultStream"]') );
						}
					}			
			});
		},

		/**
		 * Shows a tooltip on the 'default stream' link to help the user
		 *
		 * @param 		{string} 	title 		Title of the default stream
		 * @returns 	{void}
		 */
		_showStreamTooltip(title) {
			if( !this._tooltip ){
				// Build it from a template
				var tooltipHTML = ips.templates.render( 'core.tooltip', {
					id: 'elDefaultStreamTooltip_' + this.controllerID
				});

				// Append to body
				ips.getContainer().append( tooltipHTML );

				this._tooltip = $('#elDefaultStreamTooltip_' + this.controllerID );
			} else {
				this._tooltip[0].hidePopover();
			}

			if( this._tooltipTimer ){
				clearTimeout( this._tooltipTimer );
			}

			this._tooltip.text( ips.getString('streamDefaultTooltip', {
				title: title
			}));

			// Get image
			var streamLink = $('a[data-action="defaultStream"]:visible');
			var self = this;

			// Now position it
			var positionInfo = {
				trigger: streamLink.first(),
				target: this._tooltip,
				center: true,
				above: true
			};

			var tooltipPosition = ips.utils.position.positionElem( positionInfo );

			$( this._tooltip ).css({
				left: tooltipPosition.left + 'px',
				top: tooltipPosition.top + 'px'
			});

			if( tooltipPosition.location.vertical=== 'top' ){
				this._tooltip.addClass('ipsTooltip_top');
			} else {
				this._tooltip.addClass('ipsTooltip_bottom');
			}

			this._tooltip[0].showPopover();

			setTimeout( function () {
				if( self._tooltip && self._tooltip.is(':visible') ){
					self._tooltip[0].hidePopover();
				}
			}, 3000);
		},
		
		/**
		 * Puts the stream into loading mode by adding an overlaid loading div
		 *
		 * @param 		{boolean} 	loading 		Are we loading?
		 * @returns 	{void}
		 */
		_setStreamLoading(loading) {
			var stream = this.scope.find('[data-role="streamContent"]');

			if( !loading ){
				this._streamLoadingOverlay.hide();
				stream.css({
					opacity: "1"
				});
				return;
			} else {

				if( !this._streamLoadingOverlay ){
					this._streamLoadingOverlay = $('<div/>').addClass('ipsLoading');
					ips.getContainer().append( this._streamLoadingOverlay );
				}

				// Get dims & position			
				var dims = ips.utils.position.getElemDims( stream );
				var position = ips.utils.position.getElemPosition( stream );

				this._streamLoadingOverlay.show().css({
					left: position.viewportOffset.left + 'px',
					top: position.viewportOffset.top + $( document ).scrollTop() + 'px',
					width: dims.width + 'px',
					height: dims.height + 'px',
					position: 'absolute',
					zIndex: ips.ui.zIndex()
				});

				stream.css({
					opacity: "0.5"
				});
			}

		},

		/**
		 * Sets or resets the timer to check for new posts
		 *
		 * @param 		{number} 	interval 		Interval (in seconds) between checks
		 * @returns 	{void}
		 */
		_startTimer(interval) {
			if( !this._autoUpdate ){
				return;
			}
			
			if( !interval ){
				interval = this._shortInterval;
			}

			if( this._timer ){
				clearInterval( this._timer );
			}

			this._timer = setInterval( _.bind( this._autoFetchNew, this ), interval * 1000 );	
		},

		/**
		 * Toggles auto-polling for new content depending on the status passed in as a param
		 *
		 * @param 		{boolean} 	status 		Enable polling?
		 * @returns 	{void}
		 */
		_togglePolling(status) {
			// Only enable if we have polling possible
			if( !this._autoUpdate ){
				clearInterval( this._timer );
				return;
			}

			if( status ){
				this._startTimer();
				this.scope.find('[data-role="updateMessage"]').show();
			} else {
				if( this._timer ){
					clearInterval( this._timer );
					this.scope.find('[data-role="updateMessage"]').hide();
				}
			}
		},

		/**
		 * Method to check for new activity results on the server.
		 *
		 * @returns 	{void}
		 */
		_autoFetchNew() {
			if( !_.isNumber( this._timestamp ) || _.isNaN( this._timestamp ) ){
				Debug.log("Timestamp not a number");
				clearInterval( this._timer );
				return;
			}

			// Fetch the results, then pass them to the results controller to display
			this._loadResults( { after: this._timestamp }, false, true )
				.done(response =>{

					const count = parseInt(response.count);

					// If auto-polling is now disabled, stop everything
					if( response.error && response.error === 'auto_polling_disabled' ){
						this.scope.find('[data-role="updateMessage"]').remove();
						clearInterval( this._timer );
						return;
					}

					// Nothing returned?
					if( _.isNaN( count ) || count === 0 ){
						return;
					}

					this.triggerOn( 'core.front.streams.results', 'resultsTeaser.stream', {
						response: response
					});
				});
		},

		/**
		 * Stops the auto-updating from running for good
		 *
		 * @returns 	{void}
		 */
		_stopPolling() {
			clearInterval( this._timer );
			this._autoUpdate = false;
			this.scope.find('[data-role="updateMessage"]').html( ips.getString('autoUpdateStopped') );
			Debug.log("Stopped polling due to user inactivity");
		},

		/**
		 * Updates the browser title with an 'unseen count' of new items
		 *
		 * @param 		{number} 	count 		Number of unseen items
		 * @returns 	{void}
		 */
		_updateTitle(count) {
			// Moved to instant notifications		
		},

		/**
		 * Marks everything in this stream as read
		 *
		 * @returns {void}
		 */
		markAllRead() {
			this.scope
				.find('[data-ips-unread]')
				.removeAttr('data-ips-unread');

		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/streams" javascript_name="ips.streams.results.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000400"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.streams.results.js - Manages results in a stream
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.streams.results', {		
		_streamID: 0,
		_newUpdates: $('<div/>'),
		_waitingCount: 0,
		_config: {},
		
		initialize: function () {
			this.on( 'updateResults.stream', this.updateResults );
			this.on( 'resultsTeaser.stream', this.resultsTeaser );
			this.on( 'click', '[data-action="insertNewItems"]', this.insertNewItems );
			this.on( 'click', 'a[data-linkType]', this.clickResult );
			
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns 	{void}
		 */
		setup: function () {
			if( this.scope.attr('data-streamID') ){
				this._streamID = this.scope.attr('data-streamID');
			}
			
			this._config = ips.getSetting('stream_config');
		},
		
		/**
		 * Determine whether we need to replace all results, or append them
		 *
		 * @param 	{object} 	data 	Data object that originated from the ajax request
		 * @returns {void}
		 */
		updateResults: function (e, data) {
			if( data.append ){
				this._appendNewResults( data );
			} else {
				this._replaceWithNewResults( data );
			}
		},
		
		/**
		 * Replaces all results in the stream with new results
		 *
		 * @param 	{object} 	data 	Data object that originated from the ajax request
		 * @returns {void}
		 */
		_replaceWithNewResults: function (data) {
			this._config = JSON.parse( data.response.config );

			// Do we need to replace the entire HTML
			if( data.response.results.indexOf('core.front.streams.results') !== -1 ){
				var content = $('<div>' + data.response.results + '</div>');
				var root = content.find('[data-controller="core.front.streams.results"]');
				
				this.cleanContents();
				this.scope
					.html( root.html() )
					.attr( 'data-streamReadType', root.attr('data-streamReadType') )
					.attr( 'data-streamURL', root.attr('data-streamURL') )
					.attr( 'data-streamID', root.attr('data-streamID') );				
			} else {
				ips.controller.cleanContentsOf( this.scope.find('[data-role="streamContent"]') );
				this.scope.find('[data-role="streamContent"]').html( data.response.results );
			}
			
			this.trigger('resultsUpdated.stream', {
				response: data.response
			});

			$( document ).trigger( 'contentChange', [ this.scope ] );
		},
		
		/**
		 * Appends new results to the existing results
		 *
		 * @param 	{object} 	data 	Data object that originated from the ajax request
		 * @returns {void}
		 */
		_appendNewResults: function (data) {			
			var content = $('<div>' + data.response.results + '</div>');

			// Get the latest time bubble
			var latestBubble = this.scope.find('[data-timeType]').last().attr('data-timeType');

			// If the new content has that bubble, get rid of it
			content.find('[data-timeType="' + latestBubble + '"]').remove();

			// Get items ready to display
			content
				.find('[data-role="activityItem"]')
					.attr('data-new', true)
					.css({
						opacity: "0"
					});
			
			// Forms created on the next slice post back to the default URL which doesn't have this silce, so updated action here
			if ( ! _.isUndefined( data.url ) ) {
				content
					.find('.js-ipsEntry__content form[action="' + this._config['url'] + '"]')
					.attr('action', data.url );
			}
			
			// Get th count of current items in the feed
			var existingItems = this.scope.find('[data-role="activityItem"]');
			var count = existingItems.length;

			// Get the last activity item and insert new content
			existingItems.last().after( content );

			// Init only the new items
			this.scope.find('[data-role="activityItem"]').slice( count ).each( function () {
				$( document ).trigger( 'contentChange', [ $( this ) ] );	
			});

			this._animateNewItems();
		},
		
		/**
		 * When we click a result, we're going to track it in local storage
		 * so that when the user returns, we can scroll to it and highlight it
		 *
		 * @returns {void}
		 */
		clickResult: function (e, data) {
			
			var item = $( e.target ).closest( '[data-indexID]' );
			var star = item.find('a[data-linkType="star"]');
			
			// Remove 'active' from all items
			this.scope.find('.ipsStreamItem_active').removeClass('ipsStreamItem_active');
			
			// If this result is unread, mark it read.
			// Add a class that we'll use to indicate last click
			item
				.addClass('ipsStreamItem_active')
				.removeAttr('data-ips-unread');
					
			// Hide the unread marker if needed
			if( star.attr('data-iPostedIn') ){
				star.addClass('ipsIndicator--read').unwrap();
			} else {
				star.attr('hidden', true);
			}
		},

		/**
		 * Event handler for clicking the teaser button when there's new results queued to show
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		insertNewItems: function (e) {
			e.preventDefault();

			var insertBefore = null;

			// First, we need to figure out the timing bubble. Our new results may contain a bubble too,
			// so we have to square that away with the ones already showing in the feed.
			if( this.scope.find('[data-timeType="past_hour"]').length ){
				insertBefore = this.scope.find('[data-timeType="past_hour"]').siblings('[data-role="activityItem"]').first();
				// If we already have a 'past_hour' bubble in the stream, then remove it from the new content
				this._newUpdates.find('[data-timeType]').remove();
			} else {
				insertBefore = this.scope.find('[data-timeType], [data-role="activityItem"]').first();
			}

			// Add a bar at the end of the content to show the user where they've seen up to
			this.scope.find('[data-role="unreadBar"]').remove();
			this._newUpdates.append( ips.templates.render('core.streams.unreadBar') );

			// Lets set some styles on the items to show
			this._newUpdates
				.find('[data-role="activityItem"]')
					.attr('data-new', true)
					.css({
						opacity: "0"
					});

			// Insert the new content
			insertBefore.before( this._newUpdates.html() );

			// Reinit
			$( document ).trigger( 'contentChange', [ this.scope ] );

			// Remove the teaser button and animate the new items in
			this.scope.find('[data-action="insertNewItems"]').remove();
			this._animateNewItems();

			// Reset our tracking vars
			this._newUpdates = $('<div/>');
			this._waitingCount = 0;
		},

		/**
		 * Finds the new items in the feed and animates them into view
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		_animateNewItems: function () {
			var newItems = this.scope.find('[data-new]');
			var delay = 200;

			// Now fade in one by one, with a delay
			newItems.each( function (index) {
				var d = ( index * delay );
				$( this ).delay( ( d > 1200 ) ? 1200 : d ).animate({
					opacity: "1"
				}).removeAttr('data-new');
			});	
		},

		/**
		 * Method to check for new activity results on the server.
		 * We don't show the results immediately, otherwise it would bounce the user around the page.
		 * Instead, we store the new results and show a teaser block at the top of the feed. When
		 * the user clicks the teaser, then we insert the results.
		 *
		 * @param 		{event} 	e 		Event object
		 * @param 		{object} 	data 	Event data object
		 * @returns 	{void}
		 */
		resultsTeaser: function (e, data) {
			var self = this;
			var response = data.response;
			var count = parseInt( response.count );

			// Get the count and latest timestamp
			var tmp = $('<div>' + response.results + '</div>');

			self.trigger( 'latestTimestamp.stream', {
				timestamp: parseInt( tmp.find('[data-timestamp]').first().attr('data-timestamp') )
			});

			self._waitingCount += count;

			// If we have a date bubble in this new content, we need to check any other new content we haven't
			// shown yet has them too, and remove them.
			if( tmp.find('[data-timeType]').length ){
				var type = tmp.find('[data-timeType]').attr('data-timeType');
				self._newUpdates.find('[data-timeType="' + type + '"]').remove();
			}

			self._newUpdates.prepend( tmp.contents() );

			// Build the teaser
			var teaser = ips.templates.render('core.streams.teaser', {
				count: self._waitingCount,
				words: ips.pluralize( ips.getString('newActivityItems'), [ self._waitingCount, self._waitingCount ] )
			});

			// If a teaser already exists, replace it; otherwise, insert at top
			if( self.scope.find('[data-action="insertNewItems"]').length ){
				self.scope.find('[data-action="insertNewItems"]').replaceWith( teaser );
				self.scope.find('[data-action="insertNewItems"]').show();
			} else {
				self.scope.find('[data-role="activityItem"]').first().before( teaser );
				self.scope.find('[data-action="insertNewItems"]').slideDown();
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/support" javascript_name="ips.support.contact.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.support.contact.js
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.support.contact', {

		initialize: function () {
			this.on( 'change', '#elCheckbox_support_request_extra_admin', this.acpAccountCheckboxChange );
			this.on( document, 'refreshSupportSummary', this.embedSummary );

			this.embedSummary();
		},

		/**
		 * Toggle handler for support account function
		 *
		 * @param	{event}	e	Change event
		 * @returns	{void}
		 */
		acpAccountCheckboxChange: function (e) {
			if ( !$('#elCheckbox_support_request_extra_admin').is(':checked') ) {
				ips.ui.alert.show({
					type: 'confirm',
					message: ips.getString('supportAcpAccountHead'),
					subText: ips.getString('supportAcpAccountDisableBlurb'),
					icon: 'warn',
					buttons: {
						ok: ips.getString('supportAcpAccountDisableYes'),
						cancel: ips.getString('supportAcpAccountDisableNo')
					},
					callbacks: {
						ok: function(){
							$('#elCheckbox_support_request_extra_admin').prop( 'checked', true );
						}
					}
				});
			}
		},


		/**
		 * Get the summary and embed on the form
		 *
		 * @returns	{void}
		 */
		embedSummary: function() {
			var summary = $(document).find('[data-controller="core.admin.support.dashboard"] [data-role="summary"]');

			if( summary.length )
			{
				var html = $('<div>').append( summary.clone() );
				html.find( '.i-float_end' ).remove();
				html.find('[data-role="summary"]').addClass('i-margin-bottom_3');
				html.find('[data-role="summaryText"]').append( ips.templates.render('support.ticket.supportSummary' ) );
				html = html.html();

				this.scope.find('ul.ipsForm').prepend('<li>' + html + '</li>');
			}
		}	
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/support" javascript_name="ips.support.dashboard.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.support.dashboard.js
 *
 * Author: Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.support.dashboard', {
		// Counters
		blocksToLoad: 0,
		blocksLoaded: 0,

		criticalIssuesCount: 0,
		recommendedIssuesCount: 0,

		// AJAX guide searching
		results: {},
		_ajax: {},
		_timers: {},
		_lastValue: '',
		_input : null,

		/**
		 * Initialization method
		 *
		 * @returns {void}
		 */
		initialize: function () {
			this.on( 'click', '[data-role="checkAgain"]', this.checkAgain );
			this.on( 'click', '[data-role="disableCustomizations"]', this.disableCustomizations );
			this.on( 'click', '[data-role="enableCustomizations"]', this.enableCustomizations );
			this.on( 'click', '[data-action="enableThirdPartyPart"]', this.enableSingleCustomizations );
			this.on( document, 'customizationsEnabled', this.setCustomizationsButton );

			this._input = $('#elInput_support_advice_search');
			this.on( 'focus', '#elInput_support_advice_search', this.fieldFocus );
			this.on( 'blur', '#elInput_support_advice_search', this.fieldBlur );
			this.on( 'submit', '#guidesForm form', this.guideFormSubmit );

			this.initializeBlocks();
		},

		/**
		 * Stop guide search form submissions
		 *
		 * @param	{event}		e	Event object
		 * @returns	{void}
		 */
		guideFormSubmit: function (e) {
			e.preventDefault();
		},

		/**
		 * Event handler for focusing in the search box
		 * Set a timer going that will watch for value changes. If there's already a value,
		 * we'll show the results immediately
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		fieldFocus: function (e) {
			// Set the timer going
			this._timers.focus = setInterval( _.bind( this.guideSearch, this ), 700 );
		},

		/**
		 * Event handler for field blur
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		fieldBlur: function (e) {
			clearInterval( this._timers );
		},

		/**
		 * Guides live search
		 *
		 * @param	{event}	e	Event
		 * @returns	void
		 */
		 guideSearch: function( e ) {
			var searchTerm = this._input.val().trim();

			if( searchTerm == this._lastValue ) {
				return;
			}

			if( searchTerm.length < 3 ) {
				if( !$('#featuredGuides').is(':visible') && searchTerm.length == 0 ) {
					ips.utils.anim.go( 'fadeIn fast', $('#featuredGuides') );
					ips.utils.anim.go( 'fadeOut fast', $('#guideSearchResults') );
				}
				return;
			}

			this._lastValue = searchTerm;

		 	$('#guideSearchResults > ul').html('').parent().addClass('ipsLoading');

		 	if( $('#featuredGuides').is(':visible') ) {
				ips.utils.anim.go( 'fadeOut fast', $('#featuredGuides') );
				ips.utils.anim.go( 'fadeIn fast', $('#guideSearchResults') );
		 	}

			var self = this;

			// Abort any requests running now
			if( _.size( this._ajax ) ){
				_.each( this._ajax, function (ajax) {
					try {
						if( _.isFunction( ajax.abort ) ) {
							ajax.abort();
							Debug.log('aborted ajax');
						}
					} catch (err) { }
				});
			}

			// Check caches
		 	if( !_.isUndefined( this.results[ searchTerm ] ) )
		 	{
		 		this.showResults( this.results[ searchTerm ] );
		 		return;
		 	}

			ips.getAjax()('?app=core&module=support&controller=support&do=guideSearch', {
				dataType: 'json',
				data: {
					search_term: encodeURIComponent( searchTerm )
				}
			}).done( function (response) {
				
				self.results[ searchTerm ] = response;
				
				self.showResults( response );
			}).fail( function (err) {
				// fail gets called when it's aborted, so deliberately do nothing here
			});
		},

		/**
		 * Process the guide search results and display
		 *
		 * @param	{object}	results		Search results
		 * @returns	{void}
		 */
		showResults: function( results ) {
			$('#guideSearchResults').removeClass('ipsLoading');

			var html = '';
			if( results.length )
			{
				_.each( results, function( result ) {
					html += ips.templates.render('support.guideSearch', result );
				});
			}
			else
			{
				html = ips.templates.render('support.guideSearch.noResults' );
			}

			if( html ) {
				$('#guideSearchResults > ul').html( html );
			} else {
				// Show "no results"
			}
		},

		/**
		 * Initializes all blocks
		 *
		 * @returns {void}
		 */
		initializeBlocks: function() {
			var self = this;

			self.blocksToLoad	= 0;
			self.blocksLoaded	= 0;
			self.criticalIssuesCount	= 0;
			self.recommendedIssuesCount	= 0;

			_.each( $(this.scope).find('[data-role="patchworkItem"]'), function( elem ) {
				$(elem).find('[data-role="supportBlock"]').html('').addClass( 'ipsLoading' );
				$(elem).find('[data-iconType]').hide();
				$(elem).removeClass( 'elCritical' );
				self.loadBlock( $(elem).attr('data-blockid') );
				self.blocksToLoad++;
			});
		},

		/**
		 * Callback when we click the "check again" button. Resets our counters and reinitializes.
		 *
		 * @returns {void}
		 */
		checkAgain: function() {
			this.blocksToLoad = 0;
			this.blocksLoaded = 0;

			this.scope.find('[data-role="summary"]').hide();

			this.initializeBlocks();
		},

		/**
		 * Callback when we click the "disable customizations" button.
		 *
		 * @param	{event} 	e 	Click event
		 * @returns {void}
		 */
		disableCustomizations: function( e ) {
			e.preventDefault();

			$(e.target).prop( 'disabled', true ).attr( 'data-oldText', $(e.target).text() ).text( ips.getString('supportDisablingCustomizations') );

			var self = this;
			ips.getAjax()( $(e.target).attr('href') )
				.done( function( response ) {
					self.scope.find('[data-role="customizationsWrapper"]').html( response );

					self.scope.find('[data-role="disableCustomizations"]')
						.text( $(e.target).attr('data-oldText') )
						.prop( 'disabled', false )
						.hide();
					self.scope.find('[data-role="enableCustomizations"]').show();

					$( document ).trigger( 'contentChange', [ self.scope ] );
				});
		},

		/**
		 * Callback when we click the "re-enable customizations" button.
		 *
		 * @param	{event} 	e 	Click event
		 * @returns {void}
		 */
		enableCustomizations: function( e ) {
			e.preventDefault();

			$(e.target).prop( 'disabled', true ).attr( 'data-oldText', $(e.target).text() ).text( ips.getString('supportEnablingCustomizations') );
			
			var self = this;
			ips.getAjax()( $(e.target).attr('href') )
				.done( function( response ) {
					self.scope.find('[data-role="disableCustomizations"]').show();
					self.scope.find('[data-role="enableCustomizations"]').prop( 'disabled', false ).text( $(e.target).attr('data-oldText') ).hide();

					var container = self.scope.find('[data-role="disabledInformation"]');
					container.find('.i-color_warning').removeClass('i-color_warning').addClass('i-color_soft');
					container.find('.fa-exclamation-triangle').removeClass('fa-exclamation-triangle').addClass('fa-info-circle');
					container.find('.ipsButton--negative').removeClass('ipsButton--negative').addClass('ipsButton--inherit');
					container.find('[data-role="disabledMessage"]').hide();
					container.find('[data-role="enabledMessage"]').show();
					container.find('[data-action="enableThirdPartyPart"]').remove();

					$( document ).trigger( 'contentChange', [ self.scope ] );
				});
		},

		/**
		 * Callback when we click the "re-enable customizations" button.
		 *
		 * @param	{event} 	e 	Click event
		 * @returns {void}
		 */
		enableSingleCustomizations: function( e ) {
			e.preventDefault();

			$(e.target).prop('disabled', true).text( ips.getString('supportEnablingCustomizations') );
			
			var self = this;
			ips.getAjax()( $(e.target).attr('href') + '&enable=1&type=' + $(e.target).attr('data-type') )
				.done( function( response ) {
					var container = $(e.target).closest('li');
					container.find('.i-color_warning').removeClass('i-color_warning').addClass('i-color_soft');
					container.find('.fa-exclamation-triangle').removeClass('fa-exclamation-triangle').addClass('fa-info-circle');
					container.find('.ipsButton--negative').removeClass('ipsButton--negative').addClass('ipsButton--inherit');
					container.find('[data-role="disabledMessage"]').hide();
					container.find('[data-role="enabledMessage"]').show();

					if( self.scope.find('.ipsButton--negative').length < 1 )
					{
						self.scope.find('[data-role="disableCustomizations"]').show();
						self.scope.find('[data-role="enableCustomizations"]').hide();

						$( document ).trigger( 'customizationsEnabled' );
					}
					
					$(e.target).remove();

					$( document ).trigger( 'contentChange', [ self.scope ] );
				});
		},

		/**
		 * Load an individual block
		 *
		 * @param	{string} 	blockid 	The block id to load
		 * @returns {void}
		 */
		loadBlock: function( blockid ) {
			var loadBlockUrl = '?app=core&module=support&controller=support&do=getBlock&block=' + blockid;
			var self = this;

			ips.getAjax()( loadBlockUrl )
				.done( function( response ) {
					self.scope.find('[data-blockid="' + blockid + '"] [data-role="supportBlock"]').html( response.html ).removeClass( 'ipsLoading' );
				
					$( document ).trigger( 'contentChange', [ self.scope.find('[data-blockid="' + blockid + '"]') ] );

					self.blocksLoaded++;
					self.criticalIssuesCount = self.criticalIssuesCount + parseInt( response.criticalIssues );
					self.recommendedIssuesCount = self.recommendedIssuesCount + parseInt( response.recommendedIssues );

					self.scope.find('[data-blockid="' + blockid + '"] [data-iconType]').hide();

					if( parseInt( response.criticalIssues ) )
					{
						ips.utils.anim.go( 'fadeIn slow', self.scope.find('[data-blockid="' + blockid + '"] [data-iconType="critical"]') );
						self.scope.find('[data-blockid="' + blockid + '"]').addClass( 'elCritical' );
					}
					else if( parseInt( response.recommendedIssues ) )
					{
						ips.utils.anim.go( 'fadeIn slow', self.scope.find('[data-blockid="' + blockid + '"] [data-iconType="recommended"]') );
					}

					if( self.blocksLoaded == self.blocksToLoad )
					{
						self.finishSetup();
					}
				})
				.fail( function(response)
					{
						self.scope.find('[data-blockid="' + blockid + '"] [data-role="supportBlock"]').removeClass( "ipsLoading" );
						self.scope.find('[data-blockid="' + blockid + '"]').addClass( 'elCritical' );
						$( document ).trigger( 'contentChange', [ self.scope.find('[data-blockid="' + blockid + '"]') ] );

						self.blocksLoaded++;
					});
		},

		/**
		 * Callback once all blocks have loaded
		 *
		 * @returns {void}
		 */
		finishSetup: function() {
			this.scope.find('[data-role="summaryText"]').html( ips.pluralize( ips.getString( 'health_check_summary' ), [ this.criticalIssuesCount, this.recommendedIssuesCount ] ) );

			ips.utils.anim.go( 'fadeIn slow', this.scope.find('[data-role="summary"]') );

			$(document).trigger('refreshSupportSummary');
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/support" javascript_name="ips.support.md5.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.support.md5.js
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.support.md5', {

		initialize: function () {
			this.on( 'click', '[data-action=&quot;downloadDelta&quot;]', this.downloadDelta );
		},

		downloadDelta: function (e) {
			e.preventDefault();
			
			$(this.scope).find('[data-role=&quot;initialScreen&quot;]').hide();
			$(this.scope).find('[data-role=&quot;downloadForm&quot;]').show();
			
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.api.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.api.js - API Docs controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.system.api', {

		initialize: function () {
			this.on( 'click', '[data-action="showEndpoint"]', this.showEndpoint );
		},

		/**
		 * Dynamically loads an endpoint reference
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		showEndpoint: function (e) {
			e.preventDefault();

			var self = this;
			var url = $( e.currentTarget ).attr('href');

			// Make all endpoints inactive
			this.scope.find('.cApiTree_activeNode').removeClass('cApiTree_activeNode');

			// Make this one active
			$( e.currentTarget ).parent('li').addClass('cApiTree_activeNode');

			// Set the content area to loading
			this.scope.find('[data-role="referenceContainer"]')
				.html( 
					$('<div/>')
						.addClass('ipsLoading')
						.css({ height: '300px' })
				);

			ips.getAjax()( url )
				.done( function (response) {
					self.scope.find('[data-role="referenceContainer"]')
						.html( response )
				})
				.fail( function () {
					window.location = url;
				});

			// Scroll the content area into view
			this.scope.find('[data-role="referenceContainer"]')[0].scrollIntoView({ behavior: "smooth" });
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.apiPermissions.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.apiPermissions.js - API Permissions form
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.system.apiPermissions', {

		initialize: function () {
			this.on( 'click', '[data-action="toggleSection"]', this.toggleSection );
			this.on( 'click', '.cApiPermissions [data-action="checkAll"]', this.checkAll );
			this.on( 'click', '.cApiPermissions [data-action="checkNone"]', this.checkNone );
			this.on( 'click', '.cApiPermissions_header [data-action="checkAll"]', this.checkAllHeader );
			this.on( 'click', '.cApiPermissions_header [data-action="checkNone"]', this.checkNoneHeader );
			this.setup();
		},

		setup: function () {
			var self = this;
			var sections = this.scope.find('.cApiPermissions > li');

			sections.each( function () {
				self._calculatedCheckedEndpoints( $( this ) );
			});
		},

		/**
		 * Toggles the display of a section when a subheader is clicked
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		toggleSection: function (e) {
			var header = $( e.currentTarget ).parent();

			if( header.hasClass('cApiPermissions_open') ){
				this._collapseSection( header );
			} else {
				this._expandSection( header );
			}
		},

		/**
		 * Checks all toggles for an app
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkAllHeader: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).closest('.cApiPermissions_header');
			var sections = header.next('.cApiPermissions').find('> li');

			sections.each( function () {
				var next = $( this ).find('> ul');

				if( !next.is(':visible') ){
					next.animationComplete( function () {
						setTimeout( function () {
							self._togglePermissions( true, next );
						}, 300 );
					});

					self._expandSection( $( this ) );	
				} else {
					self._togglePermissions( true, next );
				}
			})
		},

		/**
		 * Checks all toggles for an app
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkNoneHeader: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).closest('.cApiPermissions_header');
			var sections = header.next('.cApiPermissions').find('> li');

			sections.each( function () {
				var next = $( this ).find('> ul');

				if( !next.is(':visible') ){
					next.animationComplete( function () {
						setTimeout( function () {
							self._togglePermissions( false, next );
						}, 300 );
					});

					self._expandSection( $( this ) );	
				} else {
					self._togglePermissions( false, next );
				}	
			})
		},

		/**
		 * Checks all toggles in the section, opening the section too if necessary
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkAll: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).parents('li').first();
			var next = header.find('> ul');

			// If the section isn't visible, do the toggling after the section has
			// animated in, so that the user can see the change happen. Otherwise, just do it immediately
			if( !next.is(':visible') ){
				next.animationComplete( function () {
					setTimeout( function () {
						self._togglePermissions( true, next );
					}, 300 );
				});

				this._expandSection( header );	
			} else {
				this._togglePermissions( true, next );
			}	
		},

		/**
		 * Unchecks all toggles in the section, opening the section too if necessary
		 *
		 * @param	{event} 	e 	Event object
		 * @returns {void}
		 */
		checkNone: function (e) {
			e.preventDefault();
			var self = this;
			var header = $( e.currentTarget ).parents('li').first();
			var next = header.find('> ul');

			// If the section isn't visible, do the toggling after the section has
			// animated in, so that the user can see the change happen. Otherwise, just do it immediately
			if( !next.is(':visible') ){
				next.animationComplete( function () {
					setTimeout( function () {
						self._togglePermissions( false, next );
					}, 300 );
				});

				this._expandSection( header );	
			} else {
				this._togglePermissions( false, next );
			}			
		},

		_calculatedCheckedEndpoints: function (section) {
			var totalEndpoints = section.find('input[name*="access"]');
			var checkedEndpoints = totalEndpoints.filter(':checked');
			var endpointSpan = section.find('[data-role="endpointOverview"]');

			if( section.hasClass('cApiPermissions_open') ){
				endpointSpan.hide();
			} else {
				var text = ips.getString('apiEndpoints_all');

				if( !checkedEndpoints.length ){
					text = ips.getString('apiEndpoints_none');
				} else if( totalEndpoints.length !== checkedEndpoints.length ){
					text = ips.pluralize( ips.getString( 'apiEndpoints_some', { checked: checkedEndpoints.length } ), totalEndpoints.length );	
				}

				endpointSpan.text( text ).show();
			}
		},

		/**
		 * Sets all checkboxes to the given state in the given container
		 *
		 * @param	{boolean} 	state 		The state to which checkboxes will be set
		 * @param 	{element} 	container 	The container in which the checkboxes must exist
		 * @returns {void}
		 */
		_togglePermissions: function (state, container) {
			container.find('input[type="checkbox"]:not( [disabled] )').prop('checked', state).change();
		},

		/**
		 * Displays a section with animation
		 *
		 * @param	{element} 	section 	The section to show
		 * @returns {void}
		 */
		_expandSection: function (section) {
			var next = section.find('> ul');

			section
				.addClass('cApiPermissions_open')
				.removeClass('cApiPermissions_closed');

			ips.utils.anim.go( 'fadeInDown fast', next );

			this._calculatedCheckedEndpoints( section );
		},

		/**
		 * Hides a section
		 *
		 * @param	{element} 	section  	The section to hide
		 * @returns {void}
		 */
		_collapseSection: function (section) {
			section
				.removeClass('cApiPermissions_open')
				.addClass('cApiPermissions_closed');

			this._calculatedCheckedEndpoints( section );
		},
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.autoupgradetimer.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.autoupgradetimer.js - Countdown timer for CIC autoupgrade failures necessitating a full applylatestfiles call, or an upgrade call from Cloud2.
 *
 * Author: Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.system.autoupgradetimer', {

		initialize: function () {
			var self = this;

			// Set a timer that counts down every second
			var secondsRemaining = 60 * 5;
			
			if ( ips.getSetting('cloud2') ) {
				// If we're on Cloud2, set it to 15 seconds initially instead
				secondsRemaining = 15;
			}
			
			var interval = setInterval( function() {
				// Take a second off
				secondsRemaining--;

				// If we are at 0, we're done
				if( secondsRemaining < 1 )
				{
					clearInterval( interval );
					self.scope.find('[data-role="counter-wrapper"]').hide();
					self.scope.find('[data-role="continue-button"]').show();
				}
				// Otherwise update the displayed countdown
				else
				{
					var minutes = Math.floor( secondsRemaining / 60 );
					var seconds = secondsRemaining % 60;

					self.scope.find('[data-role="counter"]').html( minutes + ':' + ( ( seconds >= 10 ) ? seconds : '0' + seconds ) );
				}
			}, 1000 );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.codeHook.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.codeHook.js - Handles editing code hooks
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.system.codeHook', {
		
		codeMirror: null,
		
		initialize: function () {
			this.on( 'click', '[data-codeToInject]', this._itemClick );
		},
		
		/**
		 * Event handler for clicking on an item
		 *
		 * @param 	{event} 	e 		Event object
		 * @returns {void}
		 */
		_itemClick: function (e) {
			var codeMirror = $( this.scope ).find('textarea').data('CodeMirrorInstance');
						
			var regex = new RegExp( $.parseJSON( $(e.currentTarget).attr('data-signature') ) );
			
			var found = false;
			var lastLine = codeMirror.doc.lineCount() - 1;
			codeMirror.doc.eachLine(function(line){
				if ( line.text.match( regex ) ) {
					found = true;
					codeMirror.setSelection( { line: codeMirror.doc.getLineNumber( line ), ch: 0 }, { line: codeMirror.doc.getLineNumber( line ), ch: line.text.length } );
					codeMirror.scrollIntoView( { line: codeMirror.doc.getLineNumber( line ), ch: 0 } );
				}
				if ( line.text.match( /^\s*}\s*$/ ) ) {
					lastLine = codeMirror.doc.getLineNumber( line );
				}
			});
			
			if ( !found ) {
				codeMirror.doc.replaceRange( $.parseJSON( $(e.currentTarget).attr('data-codeToInject') ), { line: lastLine - 1, chr: 0 }, { line: lastLine - 1, chr: 0 } );
				codeMirror.scrollIntoView( { line: codeMirror.doc.lineCount(), ch: 0 } );
			}
		}
	});
}(jQuery, _));
</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.login.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.login.js - ACP login screen controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.system.login', {

		initialize: function () {
			this.on( 'tabChanged', this.tabChanged );
			this.on( 'click', '[data-action=&quot;upgradeWarningContinue&quot;]', this.upgradeWarningContinue );
			this.setup();
		},

		/**
		 * Setup method
		 * Focuses the first text field on the first visible tab automatically
		 *
		 * @returns {void}
		 */
		setup: function () {
			// find the active tab, if any, then the first text field to focus it
			this.scope
				.find(&quot;#elTabContent .ipsTabs__panel:visible&quot;)
					.first()
					.find('input[type=&quot;text&quot;]')
						.first()
						.focus();
		},

		/**
		 * Event handler for the active tab being changed
		 * Saves the new active tab in a cookie for the next time the login screen is loaded
		 * so that we can show the user their correct login method automatically
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		tabChanged: function (e, data) {
			// Store the tab they've clicked on in the local DB so that we can
			// show it by default next time they log in
			ips.utils.cookie.set( 'acpLoginMethod', data.tabID, 1 );
		},
		
		/**
		 * Event handler for when the upgrade warning is skipped
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		upgradeWarningContinue: function (e, data) {
			e.preventDefault();
			$(this.scope).find('[data-role=&quot;upgradeWarning&quot;]').hide();
			$(this.scope).find('[data-role=&quot;loginForms&quot;]').removeClass('ipsHide').show();
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.menuManager.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.menuManager.js - Menu manager JS
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.admin.system.menuManager', {

		_hasChanges: false,

		initialize: function () {
			this.on( 'sortstop', '.ipsTree_rows > .ipsTree', this.afterSort );
			this._hasChanges = ips.getSetting( 'menuChanged' );
			this.togglePublish();
		},

		afterSort: function(event, ui){
			this._hasChanges = true;
			this.togglePublish();
		},

		togglePublish: function(){
			if( this._hasChanges ){
				$( '#acpPageHeader > .ipsMessage' ).fadeIn();
			} else {
				$( '#acpPageHeader > .ipsMessage' ).hide();
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.settings.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.settings.js - ACP login screen controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.system.settings', {

		initialize: function () {
			this.on( 'change', 'input[name=datastore_method]', this.datastoreChanged );
			this.on( 'change', 'input[name=cache_method]', this.cacheChanged );
			this.setup();
		},

		/**
		 * Setup method
		 * Focuses the first text field on the first visible tab automatically
		 *
		 * @returns {void}
		 */
		setup: function () {
			if ( $('input[name=datastore_method]:checked').val() == 'Redis' ) {
				$(&quot;input[name=cache_method][value=Redis]&quot;).prop(&quot;checked&quot;, true);
				$('#form_cache_method').slideUp();
				$('li[id^=redis]').slideDown();
			}
		},
		
		/**
		 * Event handler for when the the cache store radio is checked
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		cacheChanged: function (e, data) {
			var value = $(e.currentTarget ).val();
			
			if ( value == 'Redis' ) {
				$(&quot;input[name=datastore_method][value=Redis]&quot;).prop(&quot;checked&quot;, true);
				$('#form_cache_method,#id_datastore_filesystem_path').slideUp();
				$('li[id^=redis]').slideDown();
			} else {
				$('#form_cache_method').slideDown();
				$('li[id^=redis]').slideUp();
				
				if ( $('input[name=datastore_method]:checked').val() == &quot;Redis&quot; ) {
					$(&quot;input[name=datastore_method][value=FileSystem]&quot;).prop(&quot;checked&quot;, true);
				}
			}
		},
		
		/**
		 * Event handler for when the the datastore radio is checked
		 *
		 * @param 	{event} 	e 		Event object
		 * @param 	{object} 	data	Event data object
		 * @returns {void}
		 */
		datastoreChanged: function (e, data) {
			var value = $(e.currentTarget ).val();
			
			if ( value == 'Redis' ) {
				$(&quot;input[name=cache_method][value=Redis]&quot;).prop(&quot;checked&quot;, true);
				$('#form_cache_method').slideUp();
				$('li[id^=redis]').slideDown();
			} else {
				$('#form_cache_method').slideDown();
				$('li[id^=redis]').slideUp();
				
				if ( $('input[name=cache_method]:checked').val() == &quot;Redis&quot; ) {
					$(&quot;input[name=cache_method][value=None]&quot;).prop(&quot;checked&quot;, true);
				}
			}
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/system" javascript_name="ips.system.upgradeManualQuery.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000450">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.upgradeManualQuery.js - Widget to run a query with a check for timeouts
 *
 * Author: Mark Wade
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.system.upgradeManualQuery', {

		initialize: function () {
			this.scope.find('[data-role=&quot;runManualButton&quot;]').css({'display':'inline'});
			
			this.on( 'click', '[data-action=&quot;runQuery&quot;]', this.runQuery );
		},
		
		runQuery: function (e) {
			this.scope.find('[data-role=&quot;querySuccessButtons&quot;]').hide();
			this.scope.css({'opacity':&quot;0.5&quot;}).addClass('ipsLoading');
			
			ips.getAjax()( this.scope.attr('data-url'), { timeout: 30000 } )
				.done(function(response){
					if ( response.runManualQuery ) {
						this.scope.find('[data-action=&quot;redirectContinue&quot;]').click();
					} else {
						this.runQueryFailed();
					}
				}.bind(this))
				.fail(function(a,b,c){
					this.runQueryFailed();
				}.bind(this));
		},
		
		runQueryFailed: function() {
			this.scope.css({'opacity':&quot;1&quot;}).removeClass('ipsLoading');
			this.scope.find('[data-role=&quot;querySuccessButtons&quot;]').show();
			this.scope.find('[data-role=&quot;runManualButton&quot;]').hide();
			
			ips.ui.alert.show( {
				type: 'alert',
				icon: 'warn',
				message: ips.getString('delta_upgrade_run_manual_query_fail_title'),
				subText: ips.getString('delta_upgrade_run_manual_query_fail_desc')
			});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/system" javascript_name="ips.system.manageFollowed.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.manageFollowed.js - Followed content controll
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.system.manageFollowed', {

		initialize: function () {
			$( document ).on( 'followingItem', _.bind( this.followingItemChange, this ) );
			this.setup();
		},

		setup: function () {
			this._followID = this.scope.attr('data-followID');
		},

		followingItemChange: function (e, data) {
			if( data.feedID != this._followID ){
				return;
			}

			if( !_.isUndefined( data.unfollow ) ){
				this.scope.find('[data-role=&quot;followDate&quot;], [data-role=&quot;followFrequency&quot;]').html('');
				this.scope.find('[data-role=&quot;followAnonymous&quot;]').attr('hidden', '');
				this.scope.find('[data-role=&quot;followButton&quot;]').addClass('ipsButton--disabled');
				this.scope.addClass('i-opacity_4');
				return;
			}

			// Update anonymous badge
			if(data.anonymous){
				this.scope.find('[data-role=&quot;followAnonymous&quot;]').removeAttr('hidden');
			} else {
				this.scope.find('[data-role=&quot;followAnonymous&quot;]').attr('hidden','');
			}

			// Update notification type
			if( data.notificationType ){
				this.scope.find('[data-role=&quot;followFrequency&quot;]').html( ips.templates.render( 'follow.frequency', {
					hasNotifications: ( data.notificationType !== 'none' ),
					text: ips.getString( 'followFrequency_' + data.notificationType )
				} ));	
			}			
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/system" javascript_name="ips.system.metaTagEditor.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.metaTagEditor.js - Live meta tag editor functionality
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.system.metaTagEditor', {

		_changed: false,

		initialize: function () {
			this.on( 'click', '[data-action="addMeta"]', this.addMetaBlock );
			this.on( 'click', '[data-action="deleteMeta"]', this.removeMetaBlock );
			this.on( 'click', '[data-action="deleteDefaultMeta"]', this.removeDefaultMeta );
			this.on( 'click', '[data-action="restoreMeta"]', this.restoreDefaultMeta );
			this.on( 'change', 'input, select', this.changed );
			this.on( 'submit', 'form', this.formSubmit );
			this.on( window, 'beforeunload', this.beforeUnload );

			this.on( 'change', '[data-role="metaTagChooser"]', this.toggleNameField );
			this.setup();
		},

		setup: function () {
			this.scope.css({
				zIndex: "10000"
			});
		},

		/**
		 * Show/hide the meta tag name field as appropriate
		 *
		 * @returns 	{void}
		 */
		toggleNameField: function (e) {
			if( $(e.currentTarget).val() == 'other' )
			{
				$(e.currentTarget).closest('ul').find('[data-role="metaTagName"]').show();
			}
			else
			{
				$(e.currentTarget).closest('ul').find('[data-role="metaTagName"]').hide();
			}
		},

		/**
		 * Restores a previously deleted default meta tag
		 *
		 * @param e
		 */
		restoreDefaultMeta: function(e) {
			var tag = $(e.currentTarget).attr('data-tag');

			// Duplicate the metaTemplate block and append it to the list
			var copy = this.scope.find('[data-role="metaTemplate"]').clone().attr( 'data-role', 'metaTagRow' ).hide();

			if( tag == 'robots' || tag == 'keywords' || tag == 'description' )
			{
				copy.find('select[name="meta_tag_name[]"]').val( tag );
			}
			else
			{
				copy.find('select[name="meta_tag_name[]"]').val( 'other' );
				copy.find('[name="meta_tag_name_other[]"]').val( tag ).parent().removeClass('ipsHide');
			}

			if( this.scope.find('input[name="defaultMetaTag[' + tag + ']"]') )
			{
				copy.find('[name="meta_tag_content[]"]').val( this.scope.find('input[name="defaultMetaTag[' + tag + ']"]').val() );
			}

			copy.find('[data-action="deleteMeta"]').attr( 'data-action', 'deleteDefaultMeta' );

			$('#elMetaTagEditor_defaultTags').append( copy );

			ips.utils.anim.go( 'fadeIn', copy );

			$(document).trigger( 'contentChange', [ this.scope ] );
			
			this._doMetaRemoval( e );
		},

		/**
		 * Removes a default meta tag element
		 *
		 * @param e
		 */
		removeDefaultMeta: function(e) {
			if( $( e.currentTarget ).siblings('select').first().val() == 'other' )
			{
				var name	= $( e.currentTarget ).closest('ul').find('input[name="meta_tag_name_other[]"]').val();
			}
			else
			{
				var name	= $( e.currentTarget ).siblings('select').first().val();
			}

			$( e.currentTarget )
				.closest( 'form' )
				.find( 'input' )
				.first()
				.after( "<input type='hidden' name='deleteDefaultMeta[]' value='" + name + "'>" );
			
			this.removeMetaBlock( e, false );

			var string = ips.getString('meta_tag_deleted', {
				tag: name
			});

			var copy = this.scope.find('[data-role="metaDefaultDeletedTemplate"]').clone().attr( 'data-role', 'metaTagRow' ).hide();

			copy.find('[data-role="metaDeleteMessage"]').html( string );
			copy.find('[data-action="restoreMeta"]').attr( 'data-tag', name );

			$('#elMetaTagEditor_defaultTags').find('.i-background_3').after( copy );

			ips.utils.anim.go( 'fadeIn', copy );

			$(document).trigger( 'contentChange', [ this.scope ] );

			this.changed();

			this._showHideNoTagsMessage();
		},

		/**
		 * Removes a meta tag element
		 *
		 * @param e
		 */
		removeMetaBlock: function( e, restoreDefault ) {
			// We can't use ECMAScript 2015 yet so no default function parameter values
			if( _.isUndefined( restoreDefault ) )
			{
				restoreDefault = true;
			}

			if( $( e.currentTarget ).siblings('select').first().val() == 'other' )
			{
				var tag	= $( e.currentTarget ).closest('ul').find('input[name="meta_tag_name_other[]"]').val();
			}
			else
			{
				var tag	= $( e.currentTarget ).siblings('select').first().val();
			}

			if( this.scope.find('input[name="defaultMetaTag[' + tag + ']"]').length && restoreDefault )
			{
				$(e.currentTarget).attr( 'data-tag', tag );

				this.restoreDefaultMeta(e);
			}
			else
			{
				this._doMetaRemoval( e );
			}
		},

		/**
		 * Actually remove the row
		 *
		 * @param e
		 */
		 _doMetaRemoval: function(e) {
			e.preventDefault();
			var elem = $( e.currentTarget ).closest('[data-role="metaTagRow"]');
			elem.remove();
			ips.utils.anim.go( 'fadeOut', elem );

			this.changed();

			this._showHideNoTagsMessage();
		 },

		/**
		 * Determine if the "no custom meta tags" message should be shown or hidden
		 *
		 * @returns	{void}
		 */
		_showHideNoTagsMessage: function() {
			if( $('#elMetaTagEditor_customTags').find('li[data-role="metaTagRow"]').length )
			{
				$('#elMetaTagEditor_customTags').find('li[data-role="noCustomMetaTagsMessage"]').hide();
			}
			else
			{
				$('#elMetaTagEditor_customTags').find('li[data-role="noCustomMetaTagsMessage"]').show();
			}
		},

		/**
		 * Event handler for submitting the meta tags form
		 *
		 * @returns 	{void}
		 */
		formSubmit: function (e) {
			var form = $( e.currentTarget );
			
			if ( form.attr('data-noAjax') ) {
				return;
			}

			e.preventDefault();

			var self = this;

			form.find('.ipsButton').prop( 'disabled', true ).addClass('ipsButton--disabled');

			// Send ajax request to save
			ips.getAjax()( form.attr('action'), {
				data: form.serialize(),
				type: 'post'
			})
				.done( function () {
					ips.ui.flashMsg.show( ips.getString('metaTagsSaved') );
					form.find('.ipsButton').prop( 'disabled', false ).removeClass('ipsButton--disabled');
					self._changed = false;

					if( form.find('[name="meta_tag_title"]').val() )
					{
						document.title = form.find('[name="meta_tag_title"]').val();
					}
					else
					{
						document.title = self.scope.attr('data-defaultPageTitle');
					}
				})
				.fail( function () {
					form.attr('data-noAjax', 'true');
					form.submit();
				});
		},

		/**
		 * Warns the user if they've got unsaved changes
		 *
		 * @returns 	{string|null}
		 */
		beforeUnload: function () {
			if( this._changed ){
				return ips.getString('metaTagsUnsaved');
			}
		},

		/**
		 * Clones a new set of meta tag elements
		 *
		 * @returns 	{void}
		 */
		addMetaBlock: function (e) {

			// Duplicate the metaTemplate block and append it to the list
			var copy = this.scope.find('[data-role="metaTemplate"]').clone().attr( 'data-role', 'metaTagRow' ).hide();

			$('#elMetaTagEditor_customTags').append( copy );

			ips.utils.anim.go( 'fadeIn', copy );

			$(document).trigger( 'contentChange', [ copy ] );

			this.changed();

			this._showHideNoTagsMessage();
		},

		/**
		 * Called when an input changes, so we can later warn the use rif they leave the page
		 *
		 * @returns 	{void}
		 */
		changed: function (e) {
			this._changed = true;
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/system" javascript_name="ips.system.notificationSettings.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.notificationSettings.js - Notification settings controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.system.notificationSettings', {

		initialize: function () {
			this.on( 'click', '[data-action="showNotificationSettings"]', this.showNotificationSettings );
			this.on( 'click', '[data-action="closeNotificationSettings"]', this.closeNotificationSettings );
			this.on( 'change', '[data-role="notificationSettingsWindow"]', this.saveNotificationSettings );
		},

		/**
		 * Event handler for when a notification type is clicked
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		showNotificationSettings: function (e) {
			e.preventDefault();
			
			var target = $(e.currentTarget);
			var expandedContainer = target.parent().find('[data-role="notificationSettingsWindow"]');
			
			this.scope.find('.cNotificationTypes__row--selected').removeClass('cNotificationTypes__row--selected');
			this.scope.find('[data-action="showNotificationSettings"]').show();
			this.scope.find('[data-role="notificationSettingsWindow"]').hide();
			
			target.parent().addClass('cNotificationTypes__row--selected');
			target.find('.cNotificationSettings_expand').addClass('ipsLoading ipsLoading--tiny').find('i').addClass('ipsHide');
						
			ips.getAjax()( target.attr('href') ).done(function(response){
				expandedContainer.html(response).show();
				target.hide();
				target.find('.cNotificationSettings_expand').removeClass('ipsLoading').find('i').removeClass('ipsHide');
			}).fail(function(){
				window.location = target.attr('href');
			})
		},
		
		/**
		 * Event handler for when a notification type is clicked
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		closeNotificationSettings: function (e) {
			e.preventDefault();
			
			this.scope.find('.cNotificationTypes__row--selected').removeClass('cNotificationTypes__row--selected');
			this.scope.find('[data-action="showNotificationSettings"]').show();
			this.scope.find('[data-role="notificationSettingsWindow"]').hide();
		},
		
		/**
		 * Event handler for when a notification form is saved
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		saveNotificationSettings: function (e) {
			e.preventDefault();
			
			var target = $(e.target);
			var form = target.closest('form');
			var container = form.closest('[data-role="notificationSettingsWindow"]');
			var containerParent = container.closest('.cNotificationTypes__row');
			var closeIcon = container.find('[data-action="closeNotificationSettings"]');
			
			closeIcon.addClass('ipsLoading ipsLoading--tiny').text('');
						
			ips.getAjax()( form.attr('action'), {
				data: form.serialize(),
				type: 'post'
			} ).done(function(response){
				closeIcon.removeClass('ipsLoading').html('&times;');
				containerParent.find('[data-action="showNotificationSettings"]').html(response);
				ips.ui.flashMsg.show( ips.getString('saved') );
			});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/system" javascript_name="ips.system.referrals.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.referrals.js - Referrals section
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.front.system.referrals', {

		initialize: function () {
			
			// There can be a delay while the library loads for the first time
			$('.cReferrer_copy').each( function()
			{
				$(this).hide();
			} );

			ips.loader.getStatic(&quot;/applications/core/interface/static/clipboard/clipboard.min.js&quot;).then( function()
	        {
		        if ( ClipboardJS.isSupported() ) {
			        $('.cReferrer_copy').each( function()
					{
						$(this).show();
					} );
			
					var clipboard = new ClipboardJS('.cReferrer_copy');
					
					clipboard.on('success', function(e) {
					    ips.ui.flashMsg.show( ips.getString('copied') );
					    e.clearSelection();
					});
				} else {
					$('.cReferrals_directLink_input').removeClass('ipsHide');
					$('.cReferrals_directLink_link').addClass('ipsHide');
				}
			} );
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/system" javascript_name="ips.system.register.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000500"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.system.register.js - Registration controller
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.system.register', {

		usernameField: null,
		timers: { 'username': null, 'email': null },
		ajax: ips.getAjax(),
		popup: null,
		passwordBlurred: true,
		dirty: false,
		initialize: function () {
			this.on( 'keyup', '#elInput_username', this.changeUsername );
			this.on( 'blur', '#elInput_username', this.changeUsername );
			this.on( 'keyup', '#elInput_password_confirm', this.confirmPassword );
			this.on( 'blur', '#elInput_password_confirm', this.confirmPassword );
			this.on( 'click', 'a[data-ipsPbrCancel]', this.cancelPbr );
			this.setup();
		},

		/**
		 * Setup method
		 * Loads the template file for registration, and adds an empty element after the username field
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		setup: function () {
			this.usernameField = this.scope.find('#elInput_username');
			this.passwordField = this.scope.find('#elInput_password');
			this.confirmPasswordField = this.scope.find('#elInput_password_confirm');

			// Build extra element after username
			this.usernameField.after( $('<span/>').attr( 'data-role', 'validationCheck' ) );
			this.confirmPasswordField.after( $('<span/>').attr( 'data-role', 'validationCheck' ) );

			this.convertExistingErrors();
		},

		/**
		 * Looks for any validation errors present when the page was loaded (i.e. errors added by the backend)
		 * and converts them into the dynamic errors we use here.
		 *
		 * @returns 	{void}
		 */
		convertExistingErrors: function () {
			var fields = this.scope.find('#elInput_username, #elInput_password, #elInput_password_confirm');
			var self = this;

			fields.each( function () {
				var elem = $(this);
				var wrapper = elem.closest('.ipsFieldRow');

				// Bail if no errors found
				if( !wrapper.hasClass('ipsFieldRow_error') ){
					return;
				}

				var message = wrapper.find('.i-color_warning').html();
				self._clearResult( elem );

				wrapper.find('[data-role="validationCheck"]').show().html( ips.templates.render( 'core.forms.validateFailText', { message: message } ) );
				elem.removeClass('ipsField_success').addClass('ipsField_error');
			});
		},

		/**
		 * Cancel the post before register submission
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		cancelPbr: function (e) {
			var url = $(e.target).closest('[data-ipsPbrCancel]').attr('href');
			
			e.preventDefault();
			e.stopPropagation();
			
			/* Show confirmation Prompt */
			ips.ui.alert.show({
				type: 'confirm',
				message: ips.getString('pbr_confirm_title'),
				subText: ips.getString('pbr_confirm_text'),
				icon: 'warn',
				buttons: {
					ok: ips.getString('pbr_confirm_ok'),
					cancel: ips.getString('pbr_confirm_cancel')
				},
				callbacks: {
					ok: function(){
						window.location = url;
					},
					cancel: function(){
						return false;
					}
				}
			});
		},
		
		/**
		 * Event handler for a change on the username field
		 * Waits 700ms, then calls this._doCheck
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		changeUsername: function (e) {
			if( this.timers['username'] ){
				clearTimeout( this.timers['username'] );
			}

			if( this.usernameField.val().length > 4 || e.type != "keyup" ){
				this.timers['username'] = setTimeout( _.bind( this._doCheck, this, this.usernameField ), 700 );
			} else {
				this._clearResult( this.usernameField );
			}
		},

		/**
		 * Event handler for a change on the password field
		 * Waits 200ms, then calls this._doPasswordCheck
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		changePassword: function (e) {
			if( this.timers['password'] ){
				clearTimeout( this.timers['password'] );
			}

			if( this.passwordField.val().length > 2 || e.type != "keyup" ){
				this.timers['password'] = setTimeout( _.bind( this._doPasswordCheck, this, this.passwordField ), 200 );
			} else {
				this._clearResult( this.passwordField );
			}

			this.confirmPassword();
		},

		/**
		 * Event handler for a change on the confirm password field
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		confirmPassword: function (e) {
			var resultElem = this.confirmPasswordField.next('[data-role="validationCheck"]');

			if( this.passwordField.val() && this.passwordField.val() === this.confirmPasswordField.val() ){
				resultElem.hide().html('');
				this.confirmPasswordField.removeClass('ipsField_error').addClass('ipsField_success');
			} else {
				this._clearResult( this.confirmPasswordField );
			}
		},

		/**
		 * Clears a previous validation result
		 *
		 * @returns 	{void}
		 */
		_clearResult: function (field) {
			field
				.removeClass('ipsField_error')
				.removeClass('ipsField_success')
				.next('[data-role="validationCheck"]')
					.html('');

			field
				.closest('.ipsFieldRow')
					.removeClass('ipsFieldRow_error')
					.find('.i-color_warning, .ipsFieldRow__content br:last')
						.remove();
		},

		/**
		 * Fires an ajax request to check whether the username is already in use
		 * Updates the result element depending on the result
		 *
		 * @returns 	{void}
		 */
		_doCheck: function ( field ) {
			var value = field.val();
			var resultElem = field.next('[data-role="validationCheck"]');
			var self = this;

			if( this.ajax && this.ajax.abort ){
				this.ajax.abort();
			}

			// Set loading
			field.addClass('ipsField_loading');

			// Do ajax
			this.ajax( ips.getSetting('baseURL') + '?app=core&module=system&controller=ajax&do=usernameExists', {
				dataType: 'json',
				data: {
					input: encodeURIComponent( value )
				}
			})
				.done( function (response) {
					if( response.result == 'ok' ){
						resultElem.hide().html('');
						field.removeClass('ipsField_error').addClass('ipsField_success');
					} else {
						resultElem.show().html( ips.templates.render( 'core.forms.validateFailText', { message: response.message } ) );
						field.removeClass('ipsField_success').addClass('ipsField_error');
					}
				})
				.fail( function () {} )
				.always( function () {
					field.removeClass('ipsField_loading');
				});
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="controllers/templates" javascript_name="ips.templates.simple.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.templates.simple.js - Templates: controller for the simple editor
 *
 * Author: Matt &quot;Oops I did it again&quot; Mecham
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.controller.register('core.admin.templates.simple', {
		
		_cmInstances: {},
		
		initialize: function () {
			this.on( 'click', 'button[type=&quot;submit&quot;]', this.save );
			this.on( 'tabChanged', this.changedTab );
			var debounce = _.debounce( _.bind( this._recalculatePanelWrapper, this ), 100 );
			this.on( window, 'resize', debounce );

			// Other setup
			this.setup();
		},

		/**
		 * Setup method
		 *
		 * @returns {void}
		 */
		setup: function () {
			var self = this;
			
			ips.loader.getStatic( ['applications/core/interface/static/codemirror/diff_match_patch.js','applications/core/interface/static/codemirror/codemirror.js'] ).then( function () {
				self._initCodeMirror( 'theme_simple_header', 'htmlmixed' );
				self._initCodeMirror( 'theme_simple_footer', 'htmlmixed' );
				self._initCodeMirror( 'theme_simple_css', 'css' );
			});
		},
		
		/**
		 * Initializes CodeMirror on a textarea with the provided key
		 *
		 * @param 	{string}	key 	Key of the textarea to be turned into codemirrior
		 * @param	{string} 	type 	'templates' or 'css'
		 * @returns {void}
		 */
		_initCodeMirror: function (key, type) {
			var self = this;
			this._cmInstances[ key ] = CodeMirror.fromTextArea( document.getElementById( 'elTextarea_' + key ), { 
				mode: type,
				lineNumbers: false
			} );
			this._cmInstances[ key ].setSize( null, this._getContentHeight() );

			this.scope.find('#elTextarea_' + key ).parent().addClass('i-background_3 i-padding_2');
		},
		
		/**
		 * Tab widget has indicated that the user has changed tab
		 * If there's a file ID, trigger a new event with it, to enable the file listing to highlight it
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data 	Event data object
		 * @returns {void}
		 */
		changedTab: function (e, data) {
			this._recalculatePanelWrapper();
		},
		
		/**
		 * Saves the contents of the editor
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		save: function (e) {
			e.preventDefault();
			var self = this;
			var form = this.scope.find('form[data-formid=&quot;form&quot;]');
			var save = {};
			
			// We call .save() on the CodeMirror instance, which will cause it to update the
			// contents of the original textbox.
			_.each( this._cmInstances, function(key, cm)
			{
				key.save();
			});

			// Get the fields
			form.find('input').each( function() {
				save[ $(this).attr('name') ] = $(this).val();
			} );
			
			form.find('textarea').each( function() {
				save[ $(this).attr('name') ] = $(this).val();
			} );
			
			Debug.log( save );
			
			self.scope.find('button[type=&quot;submit&quot;]').addClass('ipsButton--disabled').removeClass('ipsButton--primary');
			
			// Send it
			ips.getAjax()( form.attr('action'), {
				dataType: 'json',
				data: save,
				type: 'post'
			})
				.done( function (response) {
					ips.ui.flashMsg.show( ips.getString('saved') );
				})
				.fail( function ( jqXHR ) {
					var message = ips.getString('saveThemeError');
					try
					{
						message = $.parseJSON( jqXHR.responseText );
					}
					catch (e) {}

					ips.ui.alert.show( {
						type: 'alert',
						message: message,
						icon: 'warn'
					});
				})
				.always( function () {
					self.scope.find('button[type=&quot;submit&quot;]').removeClass('ipsButton--disabled').addClass('ipsButton--primary');
				});
		},
		
		/**
		 * Returns the current height of the tab panel wrapper
		 *
		 * @returns {number}
		 */
		_getContentHeight: function () {
			return $( window ).height() - this.scope.find('#tabs_form').offset().top - 250;
		},
		
		/**
		 * Calculates whether the tab bar has wrapped, and if so, resizes the panel wrapper and updates
		 * CodeMirror instances with the new height
		 *
		 * @returns {void}
		 */
		_recalculatePanelWrapper: function () {
			// Get the height of it
			var self = this;

			_.each( this._cmInstances, function(key, cm)
			{
				key.setSize( null, self._getContentHeight() );
			});
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/widgets" javascript_name="ips.widgets.area.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.widgets.area.js - Widget area controller
 *
 * Author: Matt Finger (orig. Rikki Tissier)
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.widgets.area', {
		_managing: false,
		reactContainer: null,
		reactRoot: null,

		initialize() {
			// we don't want nested areas doing things or areas in the pagebuilder doing things
			if (this.elem.closest('.pageBuilderRoot')) {
				return;
			}

			this.on( 'managingStarted.widgets', this.managingStarted );
			this.on( 'managingFinished.widgets', this.managingFinished );
		},

		isRoot() {
			if (!this.elem?.parentElement) {
				return false
			}

			return !this.elem.parentElement.closest('[data-controller="core.front.widgets.area"]')
		},

		/**
		 * Called when we're managing widgets
		 *
		 * @returns {void}
		 */
		async managingStarted() {
			if (!this.reactContainer && this.elem.dataset.widgetarea && this.isRoot()) {
				this._managing = true;
				const container = this.reactContainer = document.createElement('div')
				container.className = 'pageBuilderRoot'
				this.elem.parentElement.insertBefore(container, this.elem)
				this.reactContainer.ipsHide()
				this.elem.classList.add('cWidgetContainer_managing')
				this.elem.querySelectorAll('.cWidgetContainer').forEach(el => el.classList.add('cWidgetContainer_managing'))
				this.reactRoot = await ips.utils.pagebuilder.initializePageBuilderTree(container, this.elem).root

				// wait a split second so there isn't a blank screen for a split sec. Not sure **exactly** why but this resolved the blank screen for chrome and safari
				await new Promise(resolve => setTimeout(resolve, 10))
				this.elem.ipsHide()
				this.reactContainer.ipsShow()
			}
		},

		/**
		 * Called when we're no longer managing widgets
		 *
		 * @returns {void}
		 */
		managingFinished() {
			if (this.isRoot()) {
				this._managing = false;

				const rootClone = this.reactContainer?.cloneNode(true)
				rootClone?.querySelectorAll('details > summary > input').forEach(titleInput => {
					const titleNode = document.createTextNode(titleInput.value)
					titleInput.parentElement.replaceChild(titleNode, titleInput)
				})

				rootClone?.querySelectorAll('[draggable]').forEach(el => el.removeAttribute('draggable'))

				const newState = rootClone?.querySelector(`[data-depth="0"]`)?.innerHTML;
				this.reactRoot?.unmount();
				this.reactContainer?.remove();
				document.querySelectorAll('[data-role="widgetAreaConfigForm"]').forEach(el => el.remove())
				this.reactContainer = null;
				this.reactRoot = null;

				if (newState !== undefined) {
					// need to clean up old HTML
					ips.cleanContentsOf(this.elem);
					this.elem.innerHTML = newState;
					const widgets = [...this.elem.querySelectorAll('.cWidgetContainer > .ipsWidget__content--wrap > .ipsWidget')];
					if (newState && widgets.some(widget => !!widget.innerHTML.match(/\S/))) {
						widgets.forEach(widget => {
							if (!widget.innerHTML.match(/\S/)) {
								widget.closest('.cWidgetContainer').setAttribute('hidden', '');
							}
						})
						this.elem.ipsShow();
					}
					this.cleanContents()
					this.elem.querySelectorAll('section.cWidgetContainer').forEach(element => {
						if (!element.dataset.controller?.split(',').includes('core.front.widgets.area')) {
							element.dataset.controller = [(element.dataset.controller || ''), 'core.front.widgets.area'].filter(i => !!i).join(',')
						}
					})

					// This can throw errors, but it shouldn't block the widget manager from closing
					try {
						$(document).trigger('contentChange', [$(this.elem)])
					} catch (e) {
						Debug.error(e)
					}
				}
			}
		},

		/**
		 * Clean the contents of the area after the editing has finished
		 */
		cleanContents() {
			this.elem.querySelectorAll('.cWidgetContainer .ipsWidget__content--wrap > :is(.ipsWidgetBlank, .cSidebarBlock_managing), .cWidgetContainer__menu_region').forEach(el => el.remove())

			const classesToRemove = ['cWidgetContainer_managing', 'cWidgetContainer--menu_open', 'cWidgetContainer--dragLeft', 'cWidgetContainer--dragRight', 'cWidgetContainer--dragAbove', 'cWidgetContainer--dragBelow', 'cWidgetContainer--dragInside', 'cWidgetContainer--editable']
			const query = `:is(${classesToRemove.map(token => `.${token}`).join(', ')})`;
			[this.elem, ...this.elem.querySelectorAll(query)]
				.forEach(el => {
					for (const token of classesToRemove) {
						el.classList.remove(token)
					}
				})
		},
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/widgets" javascript_name="ips.widgets.block.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.widgets.block.js - Widget block controller for handling individual widgets
 *
 * Author: Matt Finger (orig. Rikki Tissier)
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('core.front.widgets.block', {

		_orientation: '',
		_blockID: '',

		initialize() {
			this._blockID = this.scope.attr('data-blockID');
			this._orientation = this.scope.closest('[data-role="widgetReceiver"]').attr('data-orientation');

			this.on( 'reloadContents.sidebar', this.reloadContent );

			$( document ).on( 'markAllRead', _.bind( this.markAllRead, this ) );
		},

		/**
		 * Event handler/method that reloads the entire contents of this widget
		 *
		 * @returns {Promise<void>}
		 */
		async reloadContent() {
			this._setLoading(true);

			// Get content
			try {
				const pageID = ips.getSetting('pageID')
				const data = {
					app: pageID ? 'cms' : 'core',
					module: pageID ? 'pages' : 'system',
					controller: pageID ? 'builder' : 'widgets',
					do: 'getBlock',
					blockID: this._blockID,
					orientation: this._orientation
				}

				Object.assign(data, pageID ?
					{pageID} :
					{
						pageArea: this.elem.closest('[data-widgetArea]').dataset.widgetarea,
						pageApp: document.body.dataset.pageapp,
						pageModule: document.body.dataset.pagemodule,
						pageController: document.body.dataset.pagecontroller,
					}
				)

				/**
				 * @type {({html?:string, devices?: ("Phone"|"Tablet"|"Desktop")[]})}
				 */
				const response = await ips.fetch(ips.getSetting('baseURL'), {
					method: 'GET',
					data
				});

				this.scope.hide().html(response.html);

				if ('devices' in response && Array.isArray(response.devices)) {
					this.resetResponsiveClasses(response.devices);
				}

				ips.utils.anim.go('fadeIn', this.scope);
				this.trigger('loadedWidget.widgets', {
					blockID: this._blockID
				});
			} catch (e) {
				this.scope.html('Error');
			}

			this._setLoading(false);
		},

		/**
		 * Reset responsive CSS classes on outer object dependent upon list passed in
		 *
		 * @param {array} deviceList
		 *
		 * @returns {void}
		 */
		 resetResponsiveClasses(deviceList) {
		 	// Remove existing classes
		 	this.scope.removeClass( 'ipsResponsive_hidePhone' )
		 		.removeClass( 'ipsResponsive_hideDesktop' )
		 		.removeClass( 'ipsResponsive_hideTablet' );

		 	// Find the entries missing
			for(const value of ["Phone", "Tablet", "Desktop"].filter(i => !deviceList.includes(i))) {
				this.scope.addClass( 'ipsResponsive_hide' + value );
			}
		 },
		
		/**
		 * Marks lists within this block as read
		 *
		 * @returns {void}
		 */
		markAllRead() {
			// Update row
			this.scope
				.find('[data-ips-unread]')
					.removeAttr('data-ips-unread');
		},

		/**
		 * Sets the loading status of this widget
		 *
		 * @param {boolean}	status
		 *
		 * @returns {void}
		 */
		_setLoading(status) {
			if (status) {
				this.scope.html('').addClass('ipsLoading cSidebarBlock_loading');
			} else {
				this.scope.removeClass('ipsLoading cSidebarBlock_loading');
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/widgets" javascript_name="ips.widgets.carouselControls.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.widgets.carouselControls.js - Widget area controller
 *
 * Author: Matt Finger
 */
;( function($, _, undefined){
    "use strict";

    ips.controller.register('core.front.widgets.carouselControls', {
        /** @type {HTMLElement|null|undefined} */
        _area: undefined,
        _carouselInterval: undefined,

        /** @type {HTMLElement|undefined} */
        _carouselIndicator: undefined,
        _isScrolling: false,
        _actualCarouselIndex: 0,
        _container: undefined,

        initialize() {
            // we don't want nested areas doing things or areas in the pagebuilder doing things
            if (this.elem.closest('.pageBuilderRoot') || !this.getCarousel()) {
                return;
            }
            this._area = undefined;
            this.setupCarousel();
        },

        destroy() {
            if(this._carouselInterval) {
                clearInterval(this._carouselInterval);
            }
        },

        /**
         * Get the scrolling element directly containing the items of the carousel
         * @return {HTMLElement|null}
         */
        getCarousel() {
            if (this._area === undefined) {
                const container = this.getContainer();
                if (!container?.classList.contains('cWidgetContainer--carousel')) {
                    this._area = null;
                } else {
                    this._area = container.querySelector(":scope > .cWidgetContainer__carousel-wrap") || container;
                }
            }
            return this._area;
        },

        /**
         * Get the widget group containing the carousel items and the scroller
         * @return {HTMLElement|null}
         */
        getContainer() {
            if (this._container === undefined) {
                const container = this.elem.closest('.cWidgetContainer');
                if (!container?.classList.contains('cWidgetContainer--carousel')) {
                    this._container = null;
                } else {
                    this._container = container;
                }
            }
            return this._container;
        },

        /**
         * @returns {[number, number, NodeList<HTMLElement>]}
         */
        getCarouselOffset() {
            let children = [...this.getCarousel().querySelectorAll(':scope > .cWidgetContainer:not([hidden])')];
            if (this._isScrolling) {
                return [this._actualCarouselIndex, children.length, children];
            }

            const box = this.getScrollerBox();
            let index;
            for (index = 0; index < children.length - 1; index++) {
                if (!this.isRTL() && Math.ceil(children[index].getBoundingClientRect().left) >= Math.floor(box.left)) {
                    return [index, children.length, children];
                } else if (this.isRTL() && Math.floor(children[index].getBoundingClientRect().right) <= Math.ceil(box.right)) {
                    return [index, children.length, children];
                }
            }
            return [children.length - 1, children.length, children];
        },

        /**
         * Whether this carousel is in RTL mode
         * @return {boolean}
         */
        isRTL() {
            return ips.ui.carousel.isRTL(this.getCarousel());
        },

        /**
         * @returns {HTMLElement}
         */
        getCarouselIndicator() {
            if (this._carouselIndicator === undefined) {
                this._carouselIndicator = this.elem.querySelector(`.cWidgetContainer__carousel-indicator`);
            }

            return this._carouselIndicator;
        },

        /**
         * Update the carousel index
         */
        updateCarouselIndicator() {
            const indicator = this.getCarouselIndicator();
            if (!indicator) {
                Debug.warn(`Couldn't find a carousel indicator for a carousel`);
                return;
            }
            let [index, total] = this.getCarouselOffset();
            index = Math.min(index, this.getPageCount());
            total = Math.min(total, this.getPageCount());

            indicator.innerHTML = this.shouldUseCarouselLinks() ? `<a href="#${this.getCarouselHref(index)}">${index + 1}/${total}</a>` : `${index + 1}/${total}`;
            this.elem.querySelectorAll('button').forEach(el => total <= 1 ? el.setAttribute('disabled', '') : el.removeAttribute('disabled'));
        },

        /**
         * Scroll the carousel
         * @param {MouseEvent|CustomEvent<{dir:"left"|"right"}>|Event}	e
         */
        carouselScroll(e) {
            let dir;
            if (e instanceof PointerEvent) {
                const button = e.target?.closest?.(`[data-carousel-arrow]`);
                if (!button) {
                    return;
                }
                dir = button.dataset.carouselArrow || 'next';
            } else if (e.detail.dir) {
                dir = e.detail.dir
            }

            if (!dir || !['prev', 'next'].includes(dir)) {
                Debug.warn("Not scrolling because the direction could not be determined")
                return;
            }

            if (this._carouselInterval && e instanceof PointerEvent) {
                clearInterval(this._carouselInterval);
                this._carouselInterval = null;
            }

            const [index, total, children] = this.getCarouselOffset();
            const box = this.getScrollerBox();
            let atEnd = false;
            if (dir === 'next') {
                if (index === total - 1) {
                    atEnd = true;
                } else if (!this.isRTL()) {
                    atEnd = Math.floor(children[total-1].getBoundingClientRect().right) <= Math.ceil(box.right);
                } else {
                    atEnd = Math.ceil(children[total-1].getBoundingClientRect().left) >= Math.floor(box.left);
                }
            } else {
                // dir === 'prev'
                if (index === 0) {
                    atEnd = true;
                } else if (this.isRTL()) {
                    atEnd = Math.floor(children[0].getBoundingClientRect().right) <= Math.ceil(box.right);
                } else {
                    atEnd = Math.ceil(children[0].getBoundingClientRect().left) >= Math.floor(box.left);
                }
            }

            const toIndex = ((dir === 'prev' && atEnd) ?
                (total - 1) :
                (atEnd ? 0 : index + (dir === 'prev' ? -1 : 1))) % total;

            const childBox = children[toIndex].getBoundingClientRect();
            const paddedBox = this.getPaddedScrollBox();
            let scrollAmount;
            if (this.isRTL()) {
                scrollAmount = (toIndex === total - 1 ? childBox.left : childBox.right) - paddedBox.right;
            } else {
                scrollAmount = (toIndex === total - 1 ? childBox.right : childBox.left) - paddedBox.left;
            }

            this._isScrolling = true;
            this._actualCarouselIndex = toIndex;
            children.forEach(child => child.style.scrollSnapStop="normal")
            this.getCarousel().scrollTo({left: this.getCarousel().scrollLeft + scrollAmount, behavior: "smooth"});
            this.updateCarouselIndicator();
        },

        /**
         * @return {DOMRect}
         */
        getScrollerBox() {
            return this.getCarousel().getBoundingClientRect();
        },

        /**
         * Get the padded scroll box. This is the portion of the scroll box where the scroll snap begins
         * @return {DOMRect}
         */
        getPaddedScrollBox() {
            const box = this.getScrollerBox();
            const padding = this.getScrollPadding();
            return new DOMRect(
                box.x + padding.left,
                box.y,
                box.width - (padding.left + padding.right),
                box.height
            );
        },

        /**
         * Get the scroll padding for this carousel
         * @return {{left: number, right: number}|*}
         */
        getScrollPadding() {
            return ips.ui.carousel.getScrollPadding(this.getCarousel());
        },

        /**
         *  Handle the end of the carousel scrolling
         */
        carouselScrollEnd() {
            this._isScrolling = false;
            const children = this.getCarousel().querySelectorAll(":scope > .cWidgetContainer:not([hidden])");
            children.forEach(child => child.style.scrollSnapStop="")
            this.updateCarouselIndicator();
        },

        /**
         * Generate an anchor (without the '#' at the start) to reference this element
         *
         * @param 	{number}	idx
         *
         * @return {string}
         */
        getCarouselHref(idx) {
            if (this.shouldUseCarouselLinks()) {
                return `carouselwidget_${this.getCarousel().dataset.widgetarea}_${this.getCarousel().dataset.widgetAreaId}_${idx + 1}`;
            }
            return '';
        },

        /**
         *
         * @return {boolean}
         */
        shouldUseCarouselLinks() {
            return !!(this.getCarousel().dataset.widgetAreaId && this.getCarousel().dataset.widgetarea);
        },

        /**
         * Actually set up the carousel
         */
        setupCarousel() {
            // If there is no usable scrollbar, quit now
            if (!(this.getCarousel() instanceof Element) || this.getCarousel().closest('body') !== document.body || !this.getCarousel().querySelector(`:scope > .cWidgetContainer`) || (this.getCarousel().querySelectorAll(`:scope > .cWidgetContainer`).length === 1 && this.getCarousel().querySelector(`:scope > .cWidgetContainer`).getBoundingClientRect().width >= this.elem.getBoundingClientRect().width)) {
                this.elem.ipsHide();
                return;
            }

            this.elem.ipsShow();

            const buttonContainer = this.elem;
            buttonContainer.querySelectorAll('[data-carousel-arrow]').forEach(button => button.addEventListener('click', e => this.carouselScroll(e)));
            if ('onscrollend' in this.getCarousel()) {
                this.getCarousel().addEventListener('scrollend', () => this.carouselScrollEnd(), {capture: true});
            } else {
                this.getCarousel().addEventListener('scroll', _.debounce(() => this.carouselScrollEnd(), 200), {capture: true});
            }

             this.updateCarouselIndicator();

            // see if we need to scroll
            if (this.shouldUseCarouselLinks() && window.location.hash) {
                const [_, total, children] = this.getCarouselOffset();
                for (let i = 0; i < total; i++) {
                    const hash = this.getCarouselHref(i);
                    if (hash && window.location.hash === `#${hash}`) {
                        this._actualCarouselIndex = i;
                        this._isScrolling = true;
                        children[i].scrollIntoView({behavior:"instant", block:"start", inline:"start"});
                        break;
                    }
                }
            } else {
                this.setupLoop(); // we only setup the loop if the page's URL didn't link to a specific page in the carousel
            }

            this.getContainer()?.addEventListener('ips:scrollCarousel', e => this.carouselScroll(e));

            this.setupObserver();
        },

        /**
         * Setup the interval loop
         *
         * @return {void}
         */
        setupLoop() {
            if (this._carouselInterval) {
                return;
            }
            const container = this.getContainer();
            if (container && container.dataset.widgetInterval) {
                const interval = parseInt(container.dataset.widgetInterval);
                if (interval > 0) {
                    this._carouselInterval = setInterval(() => {
                        // just in case cleanup
                        if (this.elem?.ownerDocument !== document) {
                            Debug.log('not scrolling because the carousel is no longer in the document');
                            clearInterval(this._carouselInterval);
                            return;
                        }
                        this.elem.dispatchEvent(new CustomEvent('ips:scrollCarousel', {
                            bubbles: true,
                            detail: {
                                dir: "next"
                            }
                        }))
                    }, interval * 1000);
                }
            }
        },

        /**
         * Get the number of "pages" in the carousel. This is the number of positions that can actually be snapped to
         *
         * @return {number}
         */
        getPageCount() {
            const box = this.getCarousel()?.getBoundingClientRect();
            if (!box) {
                return 1;
            }

            let children = [...this.getCarousel().querySelectorAll(`:scope > .cWidgetContainer:not([hidden])`)];
            if (children.length < 2) {
                return 1;
            }
            if (this.isRTL()) {
                children = children.reverse();
            }

            let basePages = Math.ceil(Math.abs(children[children.length - 1].getBoundingClientRect().right - children[0].getBoundingClientRect().left) / box.width);

            /* The last one is special because its scroll margin is at the end. In short, if the end of the last one is not visible when the second to last is snapped, we add one */
            if (children.length > 2 && (children[children.length - 1].getBoundingClientRect().right - children[children.length - 2].getBoundingClientRect().left) > box.width) {
                basePages++;
            }

            return basePages;
        },

        setupObserver() {
            if (this._observer) {
                this._observer.disconnect();
            }

            if (this.getCarousel() instanceof HTMLElement) {
                this._observer = new ResizeObserver(_.debounce(() => this.updateCarouselIndicator()));
                this._observer.observe(this.getCarousel());
            }
        }

    });
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/widgets" javascript_name="ips.widgets.manager.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.widgets.manager.js - Widget manager controller
 *
 * Author: Matt Finger (orig. Rikki Tissier)
 */
	
;( function($, _){
	"use strict";

	let pageLoadTime;
	setTimeout(() => pageLoadTime = Date.now());
	let state = 'unloaded';
	/** @type {function():void} */
	const whenLoadedCallbacks = [];
	function whenLoaded() {
		return new Promise(resolve => {
			if (state === 'loaded') {
				resolve();
				return;
			}

			whenLoadedCallbacks.push(resolve);

			if (state === 'unloaded') {
				ips.loader.get(['core/front/controllers/widgets/ips.widgets.block.js'])
					.then(async () => {
						if (!window.ips.utils.pagebuilder) {
							const url = ips.getSetting('baseURL') + `/applications/core/interface/static/pagebuilder/manifest.json?v=${ips.getSetting('pagebuilderKey')}&antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`
							const data = await ips.fetch(url)

							const toLoad = [];
							for (const key in data) {
								if (data[key].file?.match(/\.css$/i)) {
									const href = ips.getSetting('baseURL') + '/applications/core/interface/static/pagebuilder/' + data[key].file + `?antiCache=${encodeURIComponent(ips.getSetting('jsAntiCache'))}`
									if (!document.querySelector(`[href="${encodeURI(href)}"]`)) {
										const style = document.createElement('link')
										style.rel = 'stylesheet'
										style.href = href
										document.head.appendChild(style)
									}

								} else if (data[key].isEntry) {
									toLoad.push('/applications/core/interface/static/pagebuilder/' + data[key].file)
								}
							}

							if (toLoad.length) {
								await ips.loader.getStatic(toLoad)
							}
						}

						state = 'loaded';
						while (whenLoadedCallbacks.length) {
							whenLoadedCallbacks.shift()();
						}
					})
				state = 'loading';
			}


		})
	}
		
	ips.controller.register('core.front.widgets.manager', {

		_loadedManager: false,
		_loadingManager: false,
		_inManagingState: false,
		_wasUnused: false,

		initialize() {
			this.on( 'click', '[data-action="openSidebar"]', this.openSidebarManager );
			this.on( 'click', '[data-action="closeSidebar"]', this.closeSidebarManager );

			// todo not sure this is ever needed. I cannot think of any front end pages (except maybe the login page) that have a user bar but no page editor areas. This can be deleted or uncommented after some time has passed depending on whether it is actually useful
			// if (ips.getSetting('pageID') && !document.querySelector('.cWidgetContainer')) {
			// 	document.querySelectorAll('[data-action="openSidebar"]').forEach(el => el.ipsHide())
			// }

			this._wasUnused = !!document.querySelector('.ipsLayout__secondary-column.ipsLayout__secondary-column--hide') || this._wasUnused;
			whenLoaded()
				.then(() => {
					// Should we automatically open?
					if (ips.utils.url.getParam('_blockManager')) {
						this.openSidebarManager();
					}
				});

			window.addEventListener('historychange', _.debounce((e) => {
				if (ips.utils.history.getLastChangeType() !== 'pagebuilder' && e.detail?.type !== 'pop') {
					return;
				}
				if (this._inManagingState && !ips.utils.url.getParam('_blockManager')) {
					this.closeSidebarManager()
				} else if (!this._inManagingState && ips.utils.url.getParam('_blockManager')) {
					this.openSidebarManager()
				}
			}, 50))
		},

		getSidebar() {
			return this.elem.querySelector('#elSidebarManager');
		},

		/**
		 * Add search terms for widgets and search when the search is updated
		 */
		setupSearch() {
			for (const group of this.getSidebar()?.querySelectorAll("[data-role='block_group']") || []) {
				let widgetsFound = group.querySelectorAll('[data-blockid][data-blocktitle]');
				if (widgetsFound && widgetsFound.length) {
					for (const block of widgetsFound) {
						ips.utils.search.addTerm('widgets', block.dataset.blocktitle, [block.dataset.blockid]);
						if (block.dataset.searchterms) {
							block.dataset.searchterms.split(',').forEach(term => {
								ips.utils.search.addTerm('widgets', term, [block.dataset.blockid]);
							});
						}
					}
				}
			}


			this.getSearchBar().addEventListener('input', e => {
				const value = e.target.value;
				const widgetIds = ips.utils.search.search('widgets', value);
				if (!widgetIds.size) {
					this.getSidebar().querySelector('[data-role="emptyMessage"]').removeAttribute('hidden');
					this.getSidebar().querySelector('[data-role="availableBlocks"]').setAttribute('hidden', '');
				} else {
					this.getSidebar().querySelector('[data-role="emptyMessage"]').setAttribute('hidden', '');
					this.getSidebar().querySelector('[data-role="availableBlocks"]').removeAttribute('hidden');
					this.getSidebar()?.querySelectorAll('[data-role=block_group]').forEach(group => {
						if ('favorites' in group.dataset) {
							// hide it if we're searching or if there just arent any blocks
							if (value.trim() || !group.querySelector('[data-blockid][data-blocktitle]')) {
								group.setAttribute('hidden', '');
							} else {
								group.removeAttribute('hidden');
							}
							return;
						}
						const blocks = group.querySelectorAll('[data-blockid][data-blocktitle]');
						let groupHasVisibleBlocks = (!value.trim() && "showWhenEmpty" in group.dataset);
						blocks.forEach(block => {
							if (!value.trim() || widgetIds.has(block.dataset.blockid)) {
								groupHasVisibleBlocks = true;
								block.removeAttribute('hidden');
							} else {
								block.setAttribute('hidden', '');
							}
						});

						if (!groupHasVisibleBlocks) {
							group.setAttribute('hidden', '');
						} else {
							group.removeAttribute('hidden');
						}
					})
				}
			})
		},

		sidebarSetup: false,

		setupFavorites() {
			if (!this.sidebarSetup) {
				this.getSidebar().addEventListener('click', e => {
					const indicator = e.target.closest('[data-blockid] [data-role="favorite-indicator"]');
					if (indicator) {
						this.toggleFavorite(indicator);
					}
				});
			}

			this.getSidebar().querySelectorAll(`[data-role="favorite-indicator"]`).forEach(indicator => {
				if ('isFavorite' in indicator.dataset) {
					indicator.title = ips.getString('cSidebarBlock_unset-favorite')
				} else {
					indicator.title = ips.getString('cSidebarBlock_set-favorite')
				}
			});

			this.sidebarSetup = true;
		},

		async toggleFavorite(indicator) {
			const block = indicator.closest('[data-blockid]');
			const blockID = block.dataset.blockid;
			const isFavorite = "isFavorite" in indicator.dataset;
			const favoriteGroup = this.getSidebar().querySelector('[data-favorites]');
			const favoriteList = favoriteGroup.querySelector('ul');
			if (!isFavorite) {
				if (!favoriteList.querySelector(`[data-blockid="${blockID}"]`)) {
					const clone = block.cloneNode(true);
					clone.querySelector(`[data-role="favorite-indicator"]`).dataset.isFavorite = '';
					clone.querySelector(`[data-role="favorite-indicator"]`).title = ips.getString('cSidebarBlock_unset-favorite');

					this._setupDraggingOnItem(clone);

					favoriteList.appendChild(clone);
					favoriteGroup.removeAttribute('hidden');
				}
			} else {
				favoriteList.querySelectorAll(`[data-blockid="${blockID}"]`).forEach(itemInFavorites => {
					itemInFavorites.remove();
				});

				if (!favoriteGroup.querySelectorAll(`[data-blockid]`).length) {
					favoriteGroup.setAttribute('hidden', '');
				}
			}

			this.getSidebar().querySelectorAll(`[data-blockid="${blockID}"] [data-role="favorite-indicator"]`).forEach(indicator => {
				if (isFavorite) {
					delete indicator.dataset.isFavorite;
					indicator.title = ips.getString('cSidebarBlock_set-favorite');
				} else {
					indicator.dataset.isFavorite = "";
					indicator.title = ips.getString('cSidebarBlock_unset-favorite');
				}
			});

			try {
				await ips.fetch(ips.getSetting('baseURL'), {
					method: "get",
					data: {
						app: 'core',
						module: 'system',
						controller: 'widgets',
						do: isFavorite ? "removeFavorite" : "addFavorite",
						blockID: blockID.split('_', 3).pop()
					}
				});
			} catch (e) {
				ips.ui.alert.show({"message": "Something went wrong, the favorites may not have been saved"});
			}
		},

		/**
		 *
		 * @return {HTMLInputElement|null}
		 */
		getSearchBar() {
			return this.elem.querySelector('input[data-role="widgetSearch"]');
		},

		/**
		 * Opens the manager panel, building it if necessary
		 *
		 * @param	{Event} 	[e] 			The event
		 * @returns {void}
		 */
		async openSidebarManager(e) {
			const userMenu = document.getElementById('elUserLink_menu');
			userMenu.hidePopover();

			e?.preventDefault();
			await whenLoaded();

			if (this._inManagingState) {
				return
			}

			document.querySelectorAll('.ipsTableOfContents__linkOptions').forEach(el => el.dispatchEvent(new CustomEvent('remove')));

			if (!this.elem.querySelector('[data-role="manager"]')) {
				this._buildSidebar();
			} else {
				// reset css code
				this.elem.querySelectorAll('#elSidebarManager .ipsToolbox__tools').forEach(elem => Object.assign(elem.style, {
					overflow: '',
					position: '',
					top: ''
				}));
			}

			this.triggerOn('core.front.widgets.area', 'managingStarted.widgets');
			this._showManager();

			// make sure that _blockManager=1 is in the url
			if (!window.location.search.includes('_blockManager')) {
				let anchor = window.location.href.match(/(#.*)$/)?.[1] || ''
				let url = window.location.href.replaceAll(/#.*$|\b_blockManager=1?\b/g, '')
				url += url.includes('?') ? '&_blockManager=1' : '?_blockManager=1'
				url += anchor
				ips.utils.history.pushState({artificial: true}, 'pagebuilder', url)
			}

			this.scope.addClass('cWidgetsManaging');
		},

		/**
		 * Closes the manager panel
		 *
		 * @param	{Event} 	[e] 			The event
		 * @returns {void}
		 */
		closeSidebarManager(e) {
			e?.preventDefault();
			let self = this;
			let pageUrl = window.location.href.replace(/\?(.*?)&?_blockManager=[^&]*/, '?$1').replace(/[?&]+$/, '');

			if (this._inManagingState) {
				document.querySelectorAll('.ipsMenu[data-page-editor-menu]').forEach(element => {
					element.dispatchEvent(new CustomEvent('closeMenu'));
					element.remove();
				});

				// Trigger ajax request to actually delete
				ips.getAjax()( pageUrl, {
					showLoading: true,
					data: {
						do: 'storeRevision'
					}
				} )
				.done( function (response) {
					self.scope.removeClass('cWidgetsManaging');
					self._hideManager();
					try {
						self.triggerOn('core.front.widgets.area', 'managingFinished.widgets');
					} catch(e) {
						Debug.error(e);
					}
					if (ips.utils.url.getParam('_blockManager')) {
						// if we artificially added the block manager state, just go back
						if (ips.utils.history.getState('pagebuilder').artificial) {
							window.history.back()

						}
						// just make sure we unset the artificial flag
						setTimeout(
							() => ips.utils.history.replaceState({}, 'pagebuilder', pageUrl )
						);
					}
				})
				.fail( function () {
					window.location = pageUrl;
				});
			}
		},
		
		/**
		 * Set up drags on the main list and manager lists
		 *
		 * @param	{event} 	e 			The event
		 * @returns {void}
		 */
		_setUpDragging() {
			this.elem.querySelectorAll('[data-role="availableBlocks"] ul').forEach(list => {
				list.style.zIndex = ips.ui.zIndex();
				list.querySelectorAll(':scope > .cSidebarManager_block').forEach(item => this._setupDraggingOnItem(item));
			})
		},

		/**
		 * Setup dragging on an element
		 * @param {Element} item
		 * @private
		 */
		_setupDraggingOnItem(item) {
			item.setAttribute('draggable', 'true');
			const wrapBehavior = item.dataset.widgetLayouts?.split(',')?.[0]?.trim() || 'table'
			item.addEventListener('dragstart', function(e) {
				e.stopPropagation();
				e.dataTransfer.clearData();
				const data = {
					blockID: e.target.dataset.blockid,
					blockTitle: e.target.dataset.blocktitle,
					allowReuse: e.target.dataset.allowreuse,
					config: !!e.target.dataset.blockconfig,
					blank: e.target.dataset.blockerrormessage,
					menustyle: e.target.dataset.menustyle,
					ipsWrapBehavior: wrapBehavior,
				};
				e.dataTransfer.setData('application/x.ipsblock', JSON.stringify(data));

				// Dragover events cannot access data stored inside the dataTransfer object, so while it's being dragged we will set the data as a global setting
				ipsSettings.__pageeditor_last_dragged_widget_data__ = data;
				item.addEventListener(
					'dragend',
						e => {
							delete ipsSettings.__pageeditor_last_dragged_widget_data__;
						},
					{once: true}
				);
			})
		},

		/**
		 * Shows the manager panel, loading the contents remotely if needed
		 *
		 * @returns {void}
		 */
		async _showManager() {
			this.scope.find('#elSidebarManager').removeAttr('hidden');
			this._fadeUnmanagedRoots();

			// Fetch the sidebar list
			if (!this._loadedManager && !this._loadingManager) {
				try {
					const response = await ips.fetch(ips.getSetting('baseURL') + 'index.php?app=core&module=system&controller=widgets&do=getBlockList', {
						data: {pageApp: $('body').attr('data-pageApp'), pageModule: $('body').attr('data-pageModule'), pageController: $('body').attr('data-pageController')}
					})

					this._loadedManager = true;
					this.scope.find('[data-role="availableBlocks"]').html(response);
					this.scope.find('[data-role="availableBlocks"]').attr("data-unloaded", null);
					this._setUpDragging();
					this.setupSearch();
					this.setupFavorites();

					// Content change again
					try {
						$(document).trigger('contentChange', [$('#elSidebarManager')]);
					} catch (e) {
						Debug.error(e);
					}
					document.dispatchEvent(new CustomEvent('ipsWidgetManagerLoaded', {bubbles: true, cancelable: true}))
				} catch (e) {
					Debug.error(e)
					ips.ui.alert.show({
						type: 'alert',
						icon: 'warn',
						message: ips.getString('sidebar_fetch_blocks_error'),
						callbacks: {}
					});
				}
				this.scope.find('[data-role="availableBlocks"]').removeClass('ipsLoading ipsLoading_dark');
				this._loadingManager = false;
			} else {
				// If we've loaded the data already, we still need to call these
				this._setUpDragging();
				this.setupSearch();
				this.setupFavorites();
			}

			this._inManagingState = true;
		},

		/**
		 * Hides the manager panel
		 *
		 * @returns {void}
		 */
		_hideManager() {
			this._unfadeUnmanagedRoots();
			this.scope.find('#elSidebarManager').attr('hidden', true);
			this._inManagingState = false;
		},


		/**
		 * Add the manager sidebar HTML to the page
		 *
		 * @returns {void}
		 */
		_buildSidebar() {
			this.elem.innerHTML += ips.templates.render('core.sidebar.managerWrapper');

			// This can throw errors and shouldn't really be blocking
			try {
				$(document).trigger('contentChange', [this.scope]);
			} catch (e) {
				Debug.error(e);
			}
		},

		_getUnmanagedRoots() {
			const unmanagedRoots = new Set();
			const visitedNodes = new Set();
			const root = document.querySelector('[data-ips-hook="main"]');
			function bubbleUp(el) {
				if (el === root) {
					return;
				}

				if (visitedNodes.has(el)) {
					return;
				}

				// check all the children
				[...el.children].forEach(child => {
					if (!child.matches('.pageBuilderRoot, .cWidgetContainer, :is(.pageBuilderRoot, .cWidgetContainer) *') && !child.querySelector('.pageBuilderRoot, .cWidgetContainer')) {
						unmanagedRoots.add(child);
					}
				});

				if (el.parentElement) {
					bubbleUp(el.parentElement);
				}

				visitedNodes.add(el);
			}

			root.querySelectorAll('.cWidgetContainer--main, .cWidgetContainer:not(.cWidgetContainer *)').forEach(el => {
				bubbleUp(el.parentElement);
			})

			return unmanagedRoots;
		},

		_fadeUnmanagedRoots() {
			this._getUnmanagedRoots().forEach(root => {
				setTimeout(() => {
					if (Date.now() - pageLoadTime > 3000) {
						root.classList.add('cWidgetsManaging__faded-root--animating');
					}
					root.classList.add('cWidgetsManaging__faded-root');
					Promise
						.all(root.getAnimations().map(animation => animation.finished))
						.then(() => root.classList.remove('cWidgetsManaging__faded-root--animating'));
				})
			})
		},

		_unfadeUnmanagedRoots() {
			document.querySelectorAll('.cWidgetsManaging__faded-root').forEach(root => {
				root.classList.add('cWidgetsManaging__faded-root--animating');
				root.classList.remove('cWidgetsManaging__faded-root');
				Promise
					.all(root.getAnimations().map(animation => animation.finished))
					.then(() => root.classList.remove('cWidgetsManaging__faded-root--animating'));
			});
		}
	});
}(jQuery, _));
]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="controllers/widgets" javascript_name="ips.widgets.sidebar.js" javascript_type="controller" javascript_version="5001403" javascript_position="1000600"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.widgets.sidebar.js - Special additional controller for the sidebar, to show/hide the whole sidebar as needed
 *
 * Author: Matt Finger (orig. Rikki Tissier, but that finger guy made it wayyy better)
 */
;( function($, _){
	"use strict";

	ips.controller.register('core.front.widgets.sidebar', {

		initialize() {
			this.on( 'managingStarted.widgets', this.managingStarted );
			this.on( 'managingFinished.widgets', this.managingFinished );
			this.setup();
		},

		setup() {
			if (!CSS.supports("selector(a:has(b))") || ips.getSetting('sidebar_use_js_fallback')) {
				Debug.log('using the js sidebar hide fallback')
				this._addConditionalClasses();
				this.on(window, 'resize', this._addConditionalClasses);
				this.on('addConditionalClasses', this._addConditionalClasses)
			}
		},

		/**
		 * Called when we're managing widgets
		 * Shows the sidebar if it was hidden, and sets the height of the droppable area
		 *
		 * @returns {void}
		 */
		managingStarted() {
			this.scope.addClass('ipsLayout__secondary-column--managing');
		},

		/**
		 * Called when we've finished managing widgets
		 * Hides the sidebar completely if there's no widgets or contextual tools displaying
		 *
		 * @returns {void}
		 */
		managingFinished() {
			this.scope.trigger('addConditionalClasses');
			this.scope.removeClass('ipsLayout__secondary-column--managing');
		},

		/**
		 * Adds a class to the body that indicates if the sidebar is shown
		 *
		 * @returns {void}
		 */
		_addConditionalClasses() {
			const isVisible = [
				...this.elem.querySelectorAll('.cWidgetContainer--isWidget [data-blockID]:not([hidden]), #elContextualTools, [data-role="sidebarAd"]')
			].find(el => {
				const rect = el.getBoundingClientRect();
				return !!(rect.width * rect.height);
			});

			if (!isVisible) {
				this.scope.addClass('ipsLayout__secondary-column--hide');
			} else {
				this.scope.removeClass('ipsLayout__secondary-column--hide');
			}
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="jquery" javascript_name="jquery-migrate.js" javascript_type="framework" javascript_version="5001403" javascript_position="102"><![CDATA[/*! jQuery Migrate v3.4.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */
"undefined"==typeof jQuery.migrateMute&&(jQuery.migrateMute=!0),function(t){"use strict";"function"==typeof define&&define.amd?define(["jquery"],function(e){return t(e,window)}):"object"==typeof module&&module.exports?module.exports=t(require("jquery"),window):t(jQuery,window)}(function(s,n){"use strict";function e(e){return 0<=function(e,t){for(var r=/^(\d+)\.(\d+)\.(\d+)/,n=r.exec(e)||[],o=r.exec(t)||[],a=1;a<=3;a++){if(+o[a]<+n[a])return 1;if(+n[a]<+o[a])return-1}return 0}(s.fn.jquery,e)}s.migrateVersion="3.4.1";var t=Object.create(null);s.migrateDisablePatches=function(){for(var e=0;e<arguments.length;e++)t[arguments[e]]=!0},s.migrateEnablePatches=function(){for(var e=0;e<arguments.length;e++)delete t[arguments[e]]},s.migrateIsPatchEnabled=function(e){return!t[e]},n.console&&n.console.log&&(s&&e("3.0.0")&&!e("5.0.0")||n.console.log("JQMIGRATE: jQuery 3.x-4.x REQUIRED"),s.migrateWarnings&&n.console.log("JQMIGRATE: Migrate plugin loaded multiple times"),n.console.log("JQMIGRATE: Migrate is installed"+(s.migrateMute?"":" with logging active")+", version "+s.migrateVersion));var o={};function u(e,t){var r=n.console;!s.migrateIsPatchEnabled(e)||s.migrateDeduplicateWarnings&&o[t]||(o[t]=!0,s.migrateWarnings.push(t+" ["+e+"]"),r&&r.warn&&!s.migrateMute&&(r.warn("JQMIGRATE: "+t),s.migrateTrace&&r.trace&&r.trace()))}function r(e,t,r,n,o){Object.defineProperty(e,t,{configurable:!0,enumerable:!0,get:function(){return u(n,o),r},set:function(e){u(n,o),r=e}})}function a(e,t,r,n,o){var a=e[t];e[t]=function(){return o&&u(n,o),(s.migrateIsPatchEnabled(n)?r:a||s.noop).apply(this,arguments)}}function c(e,t,r,n,o){if(!o)throw new Error("No warning message provided");return a(e,t,r,n,o),0}function i(e,t,r,n){return a(e,t,r,n),0}s.migrateDeduplicateWarnings=!0,s.migrateWarnings=[],void 0===s.migrateTrace&&(s.migrateTrace=!0),s.migrateReset=function(){o={},s.migrateWarnings.length=0},"BackCompat"===n.document.compatMode&&u("quirks","jQuery is not compatible with Quirks Mode");var d,l,p,f={},m=s.fn.init,y=s.find,h=/\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/,g=/\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g,v=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;for(d in i(s.fn,"init",function(e){var t=Array.prototype.slice.call(arguments);return s.migrateIsPatchEnabled("selector-empty-id")&&"string"==typeof e&&"#"===e&&(u("selector-empty-id","jQuery( '#' ) is not a valid selector"),t[0]=[]),m.apply(this,t)},"selector-empty-id"),s.fn.init.prototype=s.fn,i(s,"find",function(t){var r=Array.prototype.slice.call(arguments);if("string"==typeof t&&h.test(t))try{n.document.querySelector(t)}catch(e){t=t.replace(g,function(e,t,r,n){return"["+t+r+'"'+n+'"]'});try{n.document.querySelector(t),u("selector-hash","Attribute selector with '#' must be quoted: "+r[0]),r[0]=t}catch(e){u("selector-hash","Attribute selector with '#' was not fixed: "+r[0])}}return y.apply(this,r)},"selector-hash"),y)Object.prototype.hasOwnProperty.call(y,d)&&(s.find[d]=y[d]);c(s.fn,"size",function(){return this.length},"size","jQuery.fn.size() is deprecated and removed; use the .length property"),c(s,"parseJSON",function(){return JSON.parse.apply(null,arguments)},"parseJSON","jQuery.parseJSON is deprecated; use JSON.parse"),c(s,"holdReady",s.holdReady,"holdReady","jQuery.holdReady is deprecated"),c(s,"unique",s.uniqueSort,"unique","jQuery.unique is deprecated; use jQuery.uniqueSort"),r(s.expr,"filters",s.expr.pseudos,"expr-pre-pseudos","jQuery.expr.filters is deprecated; use jQuery.expr.pseudos"),r(s.expr,":",s.expr.pseudos,"expr-pre-pseudos","jQuery.expr[':'] is deprecated; use jQuery.expr.pseudos"),e("3.1.1")&&c(s,"trim",function(e){return null==e?"":(e+"").replace(v,"$1")},"trim","jQuery.trim is deprecated; use String.prototype.trim"),e("3.2.0")&&(c(s,"nodeName",function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},"nodeName","jQuery.nodeName is deprecated"),c(s,"isArray",Array.isArray,"isArray","jQuery.isArray is deprecated; use Array.isArray")),e("3.3.0")&&(c(s,"isNumeric",function(e){var t=typeof e;return("number"==t||"string"==t)&&!isNaN(e-parseFloat(e))},"isNumeric","jQuery.isNumeric() is deprecated"),s.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){f["[object "+t+"]"]=t.toLowerCase()}),c(s,"type",function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?f[Object.prototype.toString.call(e)]||"object":typeof e},"type","jQuery.type is deprecated"),c(s,"isFunction",function(e){return"function"==typeof e},"isFunction","jQuery.isFunction() is deprecated"),c(s,"isWindow",function(e){return null!=e&&e===e.window},"isWindow","jQuery.isWindow() is deprecated")),s.ajax&&(l=s.ajax,p=/(=)\?(?=&|$)|\?\?/,i(s,"ajax",function(){var e=l.apply(this,arguments);return e.promise&&(c(e,"success",e.done,"jqXHR-methods","jQXHR.success is deprecated and removed"),c(e,"error",e.fail,"jqXHR-methods","jQXHR.error is deprecated and removed"),c(e,"complete",e.always,"jqXHR-methods","jQXHR.complete is deprecated and removed")),e},"jqXHR-methods"),e("4.0.0")||s.ajaxPrefilter("+json",function(e){!1!==e.jsonp&&(p.test(e.url)||"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&p.test(e.data))&&u("jsonp-promotion","JSON-to-JSONP auto-promotion is deprecated")}));var j=s.fn.removeAttr,b=s.fn.toggleClass,w=/\S+/g;function x(e){return e.replace(/-([a-z])/g,function(e,t){return t.toUpperCase()})}i(s.fn,"removeAttr",function(e){var r=this,n=!1;return s.each(e.match(w),function(e,t){s.expr.match.bool.test(t)&&r.each(function(){if(!1!==s(this).prop(t))return!(n=!0)}),n&&(u("removeAttr-bool","jQuery.fn.removeAttr no longer sets boolean properties: "+t),r.prop(t,!1))}),j.apply(this,arguments)},"removeAttr-bool"),i(s.fn,"toggleClass",function(t){return void 0!==t&&"boolean"!=typeof t?b.apply(this,arguments):(u("toggleClass-bool","jQuery.fn.toggleClass( boolean ) is deprecated"),this.each(function(){var e=this.getAttribute&&this.getAttribute("class")||"";e&&s.data(this,"__className__",e),this.setAttribute&&this.setAttribute("class",!e&&!1!==t&&s.data(this,"__className__")||"")}))},"toggleClass-bool");var Q,A,R=!1,C=/^[a-z]/,N=/^(?:Border(?:Top|Right|Bottom|Left)?(?:Width|)|(?:Margin|Padding)?(?:Top|Right|Bottom|Left)?|(?:Min|Max)?(?:Width|Height))$/;s.swap&&s.each(["height","width","reliableMarginRight"],function(e,t){var r=s.cssHooks[t]&&s.cssHooks[t].get;r&&(s.cssHooks[t].get=function(){var e;return R=!0,e=r.apply(this,arguments),R=!1,e})}),i(s,"swap",function(e,t,r,n){var o,a,i={};for(a in R||u("swap","jQuery.swap() is undocumented and deprecated"),t)i[a]=e.style[a],e.style[a]=t[a];for(a in o=r.apply(e,n||[]),t)e.style[a]=i[a];return o},"swap"),e("3.4.0")&&"undefined"!=typeof Proxy&&(s.cssProps=new Proxy(s.cssProps||{},{set:function(){return u("cssProps","jQuery.cssProps is deprecated"),Reflect.set.apply(this,arguments)}})),e("4.0.0")?(A={animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},"undefined"!=typeof Proxy?s.cssNumber=new Proxy(A,{get:function(){return u("css-number","jQuery.cssNumber is deprecated"),Reflect.get.apply(this,arguments)},set:function(){return u("css-number","jQuery.cssNumber is deprecated"),Reflect.set.apply(this,arguments)}}):s.cssNumber=A):A=s.cssNumber,Q=s.fn.css,i(s.fn,"css",function(e,t){var r,n,o=this;return e&&"object"==typeof e&&!Array.isArray(e)?(s.each(e,function(e,t){s.fn.css.call(o,e,t)}),this):("number"==typeof t&&(r=x(e),n=r,C.test(n)&&N.test(n[0].toUpperCase()+n.slice(1))||A[r]||u("css-number",'Number-typed values are deprecated for jQuery.fn.css( "'+e+'", value )')),Q.apply(this,arguments))},"css-number");var S,P,k,H,E=s.data;i(s,"data",function(e,t,r){var n,o,a;if(t&&"object"==typeof t&&2===arguments.length){for(a in n=s.hasData(e)&&E.call(this,e),o={},t)a!==x(a)?(u("data-camelCase","jQuery.data() always sets/gets camelCased names: "+a),n[a]=t[a]):o[a]=t[a];return E.call(this,e,o),t}return t&&"string"==typeof t&&t!==x(t)&&(n=s.hasData(e)&&E.call(this,e))&&t in n?(u("data-camelCase","jQuery.data() always sets/gets camelCased names: "+t),2<arguments.length&&(n[t]=r),n[t]):E.apply(this,arguments)},"data-camelCase"),s.fx&&(k=s.Tween.prototype.run,H=function(e){return e},i(s.Tween.prototype,"run",function(){1<s.easing[this.easing].length&&(u("easing-one-arg","'jQuery.easing."+this.easing.toString()+"' should use only one argument"),s.easing[this.easing]=H),k.apply(this,arguments)},"easing-one-arg"),S=s.fx.interval,P="jQuery.fx.interval is deprecated",n.requestAnimationFrame&&Object.defineProperty(s.fx,"interval",{configurable:!0,enumerable:!0,get:function(){return n.document.hidden||u("fx-interval",P),s.migrateIsPatchEnabled("fx-interval")&&void 0===S?13:S},set:function(e){u("fx-interval",P),S=e}}));var M=s.fn.load,q=s.event.add,O=s.event.fix;s.event.props=[],s.event.fixHooks={},r(s.event.props,"concat",s.event.props.concat,"event-old-patch","jQuery.event.props.concat() is deprecated and removed"),i(s.event,"fix",function(e){var t,r=e.type,n=this.fixHooks[r],o=s.event.props;if(o.length){u("event-old-patch","jQuery.event.props are deprecated and removed: "+o.join());while(o.length)s.event.addProp(o.pop())}if(n&&!n._migrated_&&(n._migrated_=!0,u("event-old-patch","jQuery.event.fixHooks are deprecated and removed: "+r),(o=n.props)&&o.length))while(o.length)s.event.addProp(o.pop());return t=O.call(this,e),n&&n.filter?n.filter(t,e):t},"event-old-patch"),i(s.event,"add",function(e,t){return e===n&&"load"===t&&"complete"===n.document.readyState&&u("load-after-event","jQuery(window).on('load'...) called after load event occurred"),q.apply(this,arguments)},"load-after-event"),s.each(["load","unload","error"],function(e,t){i(s.fn,t,function(){var e=Array.prototype.slice.call(arguments,0);return"load"===t&&"string"==typeof e[0]?M.apply(this,e):(u("shorthand-removed-v3","jQuery.fn."+t+"() is deprecated"),e.splice(0,0,t),arguments.length?this.on.apply(this,e):(this.triggerHandler.apply(this,e),this))},"shorthand-removed-v3")}),s.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,r){c(s.fn,r,function(e,t){return 0<arguments.length?this.on(r,null,e,t):this.trigger(r)},"shorthand-deprecated-v3","jQuery.fn."+r+"() event shorthand is deprecated")}),s(function(){s(n.document).triggerHandler("ready")}),s.event.special.ready={setup:function(){this===n.document&&u("ready-event","'ready' event is deprecated")}},c(s.fn,"bind",function(e,t,r){return this.on(e,null,t,r)},"pre-on-methods","jQuery.fn.bind() is deprecated"),c(s.fn,"unbind",function(e,t){return this.off(e,null,t)},"pre-on-methods","jQuery.fn.unbind() is deprecated"),c(s.fn,"delegate",function(e,t,r,n){return this.on(t,e,r,n)},"pre-on-methods","jQuery.fn.delegate() is deprecated"),c(s.fn,"undelegate",function(e,t,r){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",r)},"pre-on-methods","jQuery.fn.undelegate() is deprecated"),c(s.fn,"hover",function(e,t){return this.on("mouseenter",e).on("mouseleave",t||e)},"pre-on-methods","jQuery.fn.hover() is deprecated");function T(e){var t=n.document.implementation.createHTMLDocument("");return t.body.innerHTML=e,t.body&&t.body.innerHTML}var F=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi;s.UNSAFE_restoreLegacyHtmlPrefilter=function(){s.migrateEnablePatches("self-closed-tags")},i(s,"htmlPrefilter",function(e){var t,r;return(r=(t=e).replace(F,"<$1></$2>"))!==t&&T(t)!==T(r)&&u("self-closed-tags","HTML tags must be properly nested and closed: "+t),e.replace(F,"<$1></$2>")},"self-closed-tags"),s.migrateDisablePatches("self-closed-tags");var D,W,_,I=s.fn.offset;return i(s.fn,"offset",function(){var e=this[0];return!e||e.nodeType&&e.getBoundingClientRect?I.apply(this,arguments):(u("offset-valid-elem","jQuery.fn.offset() requires a valid DOM element"),arguments.length?this:void 0)},"offset-valid-elem"),s.ajax&&(D=s.param,i(s,"param",function(e,t){var r=s.ajaxSettings&&s.ajaxSettings.traditional;return void 0===t&&r&&(u("param-ajax-traditional","jQuery.param() no longer uses jQuery.ajaxSettings.traditional"),t=r),D.call(this,e,t)},"param-ajax-traditional")),c(s.fn,"andSelf",s.fn.addBack,"andSelf","jQuery.fn.andSelf() is deprecated and removed, use jQuery.fn.addBack()"),s.Deferred&&(W=s.Deferred,_=[["resolve","done",s.Callbacks("once memory"),s.Callbacks("once memory"),"resolved"],["reject","fail",s.Callbacks("once memory"),s.Callbacks("once memory"),"rejected"],["notify","progress",s.Callbacks("memory"),s.Callbacks("memory")]],i(s,"Deferred",function(e){var a=W(),i=a.promise();function t(){var o=arguments;return s.Deferred(function(n){s.each(_,function(e,t){var r="function"==typeof o[e]&&o[e];a[t[1]](function(){var e=r&&r.apply(this,arguments);e&&"function"==typeof e.promise?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[t[0]+"With"](this===i?n.promise():this,r?[e]:arguments)})}),o=null}).promise()}return c(a,"pipe",t,"deferred-pipe","deferred.pipe() is deprecated"),c(i,"pipe",t,"deferred-pipe","deferred.pipe() is deprecated"),e&&e.call(a,a),a},"deferred-pipe"),s.Deferred.exceptionHook=W.exceptionHook),s});]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="jquery" javascript_name="jquery.imagesloaded.js" javascript_type="framework" javascript_version="5001403" javascript_position="102"><![CDATA[/*!
 * imagesLoaded PACKAGED v4.1.1
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

!function(t,e){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",e):"object"==typeof module&&module.exports?module.exports=e():t.EvEmitter=e()}("undefined"!=typeof window?window:this,function(){function t(){}var e=t.prototype;return e.on=function(t,e){if(t&&e){var i=this._events=this._events||{},n=i[t]=i[t]||[];return-1==n.indexOf(e)&&n.push(e),this}},e.once=function(t,e){if(t&&e){this.on(t,e);var i=this._onceEvents=this._onceEvents||{},n=i[t]=i[t]||{};return n[e]=!0,this}},e.off=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=i.indexOf(e);return-1!=n&&i.splice(n,1),this}},e.emitEvent=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=0,o=i[n];e=e||[];for(var r=this._onceEvents&&this._onceEvents[t];o;){var s=r&&r[o];s&&(this.off(t,o),delete r[o]),o.apply(this,e),n+=s?0:1,o=i[n]}return this}},t}),function(t,e){"use strict";"function"==typeof define&&define.amd?define(["ev-emitter/ev-emitter"],function(i){return e(t,i)}):"object"==typeof module&&module.exports?module.exports=e(t,require("ev-emitter")):t.imagesLoaded=e(t,t.EvEmitter)}(window,function(t,e){function i(t,e){for(var i in e)t[i]=e[i];return t}function n(t){var e=[];if(Array.isArray(t))e=t;else if("number"==typeof t.length)for(var i=0;i<t.length;i++)e.push(t[i]);else e.push(t);return e}function o(t,e,r){return this instanceof o?("string"==typeof t&&(t=document.querySelectorAll(t)),this.elements=n(t),this.options=i({},this.options),"function"==typeof e?r=e:i(this.options,e),r&&this.on("always",r),this.getImages(),h&&(this.jqDeferred=new h.Deferred),void setTimeout(function(){this.check()}.bind(this))):new o(t,e,r)}function r(t){this.img=t}function s(t,e){this.url=t,this.element=e,this.img=new Image}var h=t.jQuery,a=t.console;o.prototype=Object.create(e.prototype),o.prototype.options={},o.prototype.getImages=function(){this.images=[],this.elements.forEach(this.addElementImages,this)},o.prototype.addElementImages=function(t){"IMG"==t.nodeName&&this.addImage(t),this.options.background===!0&&this.addElementBackgroundImages(t);var e=t.nodeType;if(e&&d[e]){for(var i=t.querySelectorAll("img"),n=0;n<i.length;n++){var o=i[n];this.addImage(o)}if("string"==typeof this.options.background){var r=t.querySelectorAll(this.options.background);for(n=0;n<r.length;n++){var s=r[n];this.addElementBackgroundImages(s)}}}};var d={1:!0,9:!0,11:!0};return o.prototype.addElementBackgroundImages=function(t){var e=getComputedStyle(t);if(e)for(var i=/url\((['"])?(.*?)\1\)/gi,n=i.exec(e.backgroundImage);null!==n;){var o=n&&n[2];o&&this.addBackground(o,t),n=i.exec(e.backgroundImage)}},o.prototype.addImage=function(t){var e=new r(t);this.images.push(e)},o.prototype.addBackground=function(t,e){var i=new s(t,e);this.images.push(i)},o.prototype.check=function(){function t(t,i,n){setTimeout(function(){e.progress(t,i,n)})}var e=this;return this.progressedCount=0,this.hasAnyBroken=!1,this.images.length?void this.images.forEach(function(e){e.once("progress",t),e.check()}):void this.complete()},o.prototype.progress=function(t,e,i){this.progressedCount++,this.hasAnyBroken=this.hasAnyBroken||!t.isLoaded,this.emitEvent("progress",[this,t,e]),this.jqDeferred&&this.jqDeferred.notify&&this.jqDeferred.notify(this,t),this.progressedCount==this.images.length&&this.complete(),this.options.debug&&a&&a.log("progress: "+i,t,e)},o.prototype.complete=function(){var t=this.hasAnyBroken?"fail":"done";if(this.isComplete=!0,this.emitEvent(t,[this]),this.emitEvent("always",[this]),this.jqDeferred){var e=this.hasAnyBroken?"reject":"resolve";this.jqDeferred[e](this)}},r.prototype=Object.create(e.prototype),r.prototype.check=function(){var t=this.getIsImageComplete();return t?void this.confirm(0!==this.img.naturalWidth,"naturalWidth"):(this.proxyImage=new Image,this.proxyImage.addEventListener("load",this),this.proxyImage.addEventListener("error",this),this.img.addEventListener("load",this),this.img.addEventListener("error",this),void(this.proxyImage.src=this.img.src))},r.prototype.getIsImageComplete=function(){return this.img.complete&&void 0!==this.img.naturalWidth},r.prototype.confirm=function(t,e){this.isLoaded=t,this.emitEvent("progress",[this,this.img,e])},r.prototype.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},r.prototype.onload=function(){this.confirm(!0,"onload"),this.unbindEvents()},r.prototype.onerror=function(){this.confirm(!1,"onerror"),this.unbindEvents()},r.prototype.unbindEvents=function(){this.proxyImage.removeEventListener("load",this),this.proxyImage.removeEventListener("error",this),this.img.removeEventListener("load",this),this.img.removeEventListener("error",this)},s.prototype=Object.create(r.prototype),s.prototype.check=function(){this.img.addEventListener("load",this),this.img.addEventListener("error",this),this.img.src=this.url;var t=this.getIsImageComplete();t&&(this.confirm(0!==this.img.naturalWidth,"naturalWidth"),this.unbindEvents())},s.prototype.unbindEvents=function(){this.img.removeEventListener("load",this),this.img.removeEventListener("error",this)},s.prototype.confirm=function(t,e){this.isLoaded=t,this.emitEvent("progress",[this,this.element,e])},o.makeJQueryPlugin=function(e){e=e||t.jQuery,e&&(h=e,h.fn.imagesLoaded=function(t,e){var i=new o(this,t,e);return i.jqDeferred.promise(h(this))})},o.makeJQueryPlugin(),o});]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="jquery" javascript_name="jquery.js" javascript_type="framework" javascript_version="5001403" javascript_position="101"><![CDATA[/*! jQuery v3.7.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(ie,e){"use strict";var oe=[],r=Object.getPrototypeOf,ae=oe.slice,g=oe.flat?function(e){return oe.flat.call(e)}:function(e){return oe.concat.apply([],e)},s=oe.push,se=oe.indexOf,n={},i=n.toString,ue=n.hasOwnProperty,o=ue.toString,a=o.call(Object),le={},v=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},y=function(e){return null!=e&&e===e.window},C=ie.document,u={type:!0,src:!0,nonce:!0,noModule:!0};function m(e,t,n){var r,i,o=(n=n||C).createElement("script");if(o.text=e,t)for(r in u)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[i.call(e)]||"object":typeof e}var t="3.7.1",l=/HTML$/i,ce=function(e,t){return new ce.fn.init(e,t)};function c(e){var t=!!e&&"length"in e&&e.length,n=x(e);return!v(e)&&!y(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}function fe(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}ce.fn=ce.prototype={jquery:t,constructor:ce,length:0,toArray:function(){return ae.call(this)},get:function(e){return null==e?ae.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ce.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ce.each(this,e)},map:function(n){return this.pushStack(ce.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(ae.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(ce.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(ce.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:oe.sort,splice:oe.splice},ce.extend=ce.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||v(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(ce.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||ce.isPlainObject(n)?n:{},i=!1,a[t]=ce.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},ce.extend({expando:"jQuery"+(t+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==i.call(e))&&(!(t=r(e))||"function"==typeof(n=ue.call(t,"constructor")&&t.constructor)&&o.call(n)===a)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){m(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(c(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},text:function(e){var t,n="",r=0,i=e.nodeType;if(!i)while(t=e[r++])n+=ce.text(t);return 1===i||11===i?e.textContent:9===i?e.documentElement.textContent:3===i||4===i?e.nodeValue:n},makeArray:function(e,t){var n=t||[];return null!=e&&(c(Object(e))?ce.merge(n,"string"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:se.call(t,e,n)},isXMLDoc:function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!l.test(t||n&&n.nodeName||"HTML")},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(c(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:le}),"function"==typeof Symbol&&(ce.fn[Symbol.iterator]=oe[Symbol.iterator]),ce.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var pe=oe.pop,de=oe.sort,he=oe.splice,ge="[\\x20\\t\\r\\n\\f]",ve=new RegExp("^"+ge+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ge+"+$","g");ce.contains=function(e,t){var n=t&&t.parentNode;return e===n||!(!n||1!==n.nodeType||!(e.contains?e.contains(n):e.compareDocumentPosition&&16&e.compareDocumentPosition(n)))};var f=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;function p(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e}ce.escapeSelector=function(e){return(e+"").replace(f,p)};var ye=C,me=s;!function(){var e,b,w,o,a,T,r,C,d,i,k=me,S=ce.expando,E=0,n=0,s=W(),c=W(),u=W(),h=W(),l=function(e,t){return e===t&&(a=!0),0},f="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",t="(?:\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",p="\\["+ge+"*("+t+")(?:"+ge+"*([*^$|!~]?=)"+ge+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+t+"))|)"+ge+"*\\]",g=":("+t+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+p+")*)|.*)\\)|)",v=new RegExp(ge+"+","g"),y=new RegExp("^"+ge+"*,"+ge+"*"),m=new RegExp("^"+ge+"*([>+~]|"+ge+")"+ge+"*"),x=new RegExp(ge+"|>"),j=new RegExp(g),A=new RegExp("^"+t+"$"),D={ID:new RegExp("^#("+t+")"),CLASS:new RegExp("^\\.("+t+")"),TAG:new RegExp("^("+t+"|[*])"),ATTR:new RegExp("^"+p),PSEUDO:new RegExp("^"+g),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ge+"*(even|odd|(([+-]|)(\\d*)n|)"+ge+"*(?:([+-]|)"+ge+"*(\\d+)|))"+ge+"*\\)|)","i"),bool:new RegExp("^(?:"+f+")$","i"),needsContext:new RegExp("^"+ge+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ge+"*((?:-\\d)?\\d*)"+ge+"*\\)|)(?=[^-]|$)","i")},N=/^(?:input|select|textarea|button)$/i,q=/^h\d$/i,L=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,H=/[+~]/,O=new RegExp("\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\([^\\r\\n\\f])","g"),P=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},M=function(){V()},R=J(function(e){return!0===e.disabled&&fe(e,"fieldset")},{dir:"parentNode",next:"legend"});try{k.apply(oe=ae.call(ye.childNodes),ye.childNodes),oe[ye.childNodes.length].nodeType}catch(e){k={apply:function(e,t){me.apply(e,ae.call(t))},call:function(e){me.apply(e,ae.call(arguments,1))}}}function I(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(V(e),e=e||T,C)){if(11!==p&&(u=L.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return k.call(n,a),n}else if(f&&(a=f.getElementById(i))&&I.contains(e,a)&&a.id===i)return k.call(n,a),n}else{if(u[2])return k.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&e.getElementsByClassName)return k.apply(n,e.getElementsByClassName(i)),n}if(!(h[t+" "]||d&&d.test(t))){if(c=t,f=e,1===p&&(x.test(t)||m.test(t))){(f=H.test(t)&&U(e.parentNode)||e)==e&&le.scope||((s=e.getAttribute("id"))?s=ce.escapeSelector(s):e.setAttribute("id",s=S)),o=(l=Y(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+Q(l[o]);c=l.join(",")}try{return k.apply(n,f.querySelectorAll(c)),n}catch(e){h(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return re(t.replace(ve,"$1"),e,n,r)}function W(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function F(e){return e[S]=!0,e}function $(e){var t=T.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function B(t){return function(e){return fe(e,"input")&&e.type===t}}function _(t){return function(e){return(fe(e,"input")||fe(e,"button"))&&e.type===t}}function z(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&R(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function X(a){return F(function(o){return o=+o,F(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function U(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function V(e){var t,n=e?e.ownerDocument||e:ye;return n!=T&&9===n.nodeType&&n.documentElement&&(r=(T=n).documentElement,C=!ce.isXMLDoc(T),i=r.matches||r.webkitMatchesSelector||r.msMatchesSelector,r.msMatchesSelector&&ye!=T&&(t=T.defaultView)&&t.top!==t&&t.addEventListener("unload",M),le.getById=$(function(e){return r.appendChild(e).id=ce.expando,!T.getElementsByName||!T.getElementsByName(ce.expando).length}),le.disconnectedMatch=$(function(e){return i.call(e,"*")}),le.scope=$(function(){return T.querySelectorAll(":scope")}),le.cssHas=$(function(){try{return T.querySelector(":has(*,:jqfake)"),!1}catch(e){return!0}}),le.getById?(b.filter.ID=function(e){var t=e.replace(O,P);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(O,P);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):t.querySelectorAll(e)},b.find.CLASS=function(e,t){if("undefined"!=typeof t.getElementsByClassName&&C)return t.getElementsByClassName(e)},d=[],$(function(e){var t;r.appendChild(e).innerHTML="<a id='"+S+"' href='' disabled='disabled'></a><select id='"+S+"-\r\\' disabled='disabled'><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+ge+"*(?:value|"+f+")"),e.querySelectorAll("[id~="+S+"-]").length||d.push("~="),e.querySelectorAll("a#"+S+"+*").length||d.push(".#.+[+~]"),e.querySelectorAll(":checked").length||d.push(":checked"),(t=T.createElement("input")).setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),r.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&d.push(":enabled",":disabled"),(t=T.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||d.push("\\["+ge+"*name"+ge+"*="+ge+"*(?:''|\"\")")}),le.cssHas||d.push(":has"),d=d.length&&new RegExp(d.join("|")),l=function(e,t){if(e===t)return a=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!le.sortDetached&&t.compareDocumentPosition(e)===n?e===T||e.ownerDocument==ye&&I.contains(ye,e)?-1:t===T||t.ownerDocument==ye&&I.contains(ye,t)?1:o?se.call(o,e)-se.call(o,t):0:4&n?-1:1)}),T}for(e in I.matches=function(e,t){return I(e,null,null,t)},I.matchesSelector=function(e,t){if(V(e),C&&!h[t+" "]&&(!d||!d.test(t)))try{var n=i.call(e,t);if(n||le.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){h(t,!0)}return 0<I(t,T,null,[e]).length},I.contains=function(e,t){return(e.ownerDocument||e)!=T&&V(e),ce.contains(e,t)},I.attr=function(e,t){(e.ownerDocument||e)!=T&&V(e);var n=b.attrHandle[t.toLowerCase()],r=n&&ue.call(b.attrHandle,t.toLowerCase())?n(e,t,!C):void 0;return void 0!==r?r:e.getAttribute(t)},I.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},ce.uniqueSort=function(e){var t,n=[],r=0,i=0;if(a=!le.sortStable,o=!le.sortStable&&ae.call(e,0),de.call(e,l),a){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)he.call(e,n[r],1)}return o=null,e},ce.fn.uniqueSort=function(){return this.pushStack(ce.uniqueSort(ae.apply(this)))},(b=ce.expr={cacheLength:50,createPseudo:F,match:D,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(O,P),e[3]=(e[3]||e[4]||e[5]||"").replace(O,P),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||I.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&I.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return D.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&j.test(n)&&(t=Y(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(O,P).toLowerCase();return"*"===e?function(){return!0}:function(e){return fe(e,t)}},CLASS:function(e){var t=s[e+" "];return t||(t=new RegExp("(^|"+ge+")"+e+"("+ge+"|$)"))&&s(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=I.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(v," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(d,e,t,h,g){var v="nth"!==d.slice(0,3),y="last"!==d.slice(-4),m="of-type"===e;return 1===h&&0===g?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u=v!==y?"nextSibling":"previousSibling",l=e.parentNode,c=m&&e.nodeName.toLowerCase(),f=!n&&!m,p=!1;if(l){if(v){while(u){o=e;while(o=o[u])if(m?fe(o,c):1===o.nodeType)return!1;s=u="only"===d&&!s&&"nextSibling"}return!0}if(s=[y?l.firstChild:l.lastChild],y&&f){p=(a=(r=(i=l[S]||(l[S]={}))[d]||[])[0]===E&&r[1])&&r[2],o=a&&l.childNodes[a];while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if(1===o.nodeType&&++p&&o===e){i[d]=[E,a,p];break}}else if(f&&(p=a=(r=(i=e[S]||(e[S]={}))[d]||[])[0]===E&&r[1]),!1===p)while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if((m?fe(o,c):1===o.nodeType)&&++p&&(f&&((i=o[S]||(o[S]={}))[d]=[E,p]),o===e))break;return(p-=g)===h||p%h==0&&0<=p/h}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||I.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?F(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=se.call(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:F(function(e){var r=[],i=[],s=ne(e.replace(ve,"$1"));return s[S]?F(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:F(function(t){return function(e){return 0<I(t,e).length}}),contains:F(function(t){return t=t.replace(O,P),function(e){return-1<(e.textContent||ce.text(e)).indexOf(t)}}),lang:F(function(n){return A.test(n||"")||I.error("unsupported lang: "+n),n=n.replace(O,P).toLowerCase(),function(e){var t;do{if(t=C?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=ie.location&&ie.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===r},focus:function(e){return e===function(){try{return T.activeElement}catch(e){}}()&&T.hasFocus()&&!!(e.type||e.href||~e.tabIndex)},enabled:z(!1),disabled:z(!0),checked:function(e){return fe(e,"input")&&!!e.checked||fe(e,"option")&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return q.test(e.nodeName)},input:function(e){return N.test(e.nodeName)},button:function(e){return fe(e,"input")&&"button"===e.type||fe(e,"button")},text:function(e){var t;return fe(e,"input")&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:X(function(){return[0]}),last:X(function(e,t){return[t-1]}),eq:X(function(e,t,n){return[n<0?n+t:n]}),even:X(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:X(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:X(function(e,t,n){var r;for(r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:X(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=B(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=_(e);function G(){}function Y(e,t){var n,r,i,o,a,s,u,l=c[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=y.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=m.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(ve," ")}),a=a.slice(n.length)),b.filter)!(r=D[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?I.error(e):c(e,s).slice(0)}function Q(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function J(a,e,t){var s=e.dir,u=e.next,l=u||s,c=t&&"parentNode"===l,f=n++;return e.first?function(e,t,n){while(e=e[s])if(1===e.nodeType||c)return a(e,t,n);return!1}:function(e,t,n){var r,i,o=[E,f];if(n){while(e=e[s])if((1===e.nodeType||c)&&a(e,t,n))return!0}else while(e=e[s])if(1===e.nodeType||c)if(i=e[S]||(e[S]={}),u&&fe(e,u))e=e[s]||e;else{if((r=i[l])&&r[0]===E&&r[1]===f)return o[2]=r[2];if((i[l]=o)[2]=a(e,t,n))return!0}return!1}}function K(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Z(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function ee(d,h,g,v,y,e){return v&&!v[S]&&(v=ee(v)),y&&!y[S]&&(y=ee(y,e)),F(function(e,t,n,r){var i,o,a,s,u=[],l=[],c=t.length,f=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)I(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),p=!d||!e&&h?f:Z(f,u,d,n,r);if(g?g(p,s=y||(e?d:c||v)?[]:t,n,r):s=p,v){i=Z(s,l),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(s[l[o]]=!(p[l[o]]=a))}if(e){if(y||d){if(y){i=[],o=s.length;while(o--)(a=s[o])&&i.push(p[o]=a);y(null,s=[],i,r)}o=s.length;while(o--)(a=s[o])&&-1<(i=y?se.call(e,a):u[o])&&(e[i]=!(t[i]=a))}}else s=Z(s===t?s.splice(c,s.length):s),y?y(null,t,s,r):k.apply(t,s)})}function te(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=J(function(e){return e===i},a,!0),l=J(function(e){return-1<se.call(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!=w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[J(K(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return ee(1<s&&K(c),1<s&&Q(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(ve,"$1"),t,s<n&&te(e.slice(s,n)),n<r&&te(e=e.slice(n)),n<r&&Q(e))}c.push(t)}return K(c)}function ne(e,t){var n,v,y,m,x,r,i=[],o=[],a=u[e+" "];if(!a){t||(t=Y(e)),n=t.length;while(n--)(a=te(t[n]))[S]?i.push(a):o.push(a);(a=u(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=E+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==T||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==T||(V(o),n=!C);while(s=v[a++])if(s(o,t||T,n)){k.call(r,o);break}i&&(E=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=pe.call(r));f=Z(f)}k.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&ce.uniqueSort(r)}return i&&(E=h,w=p),c},m?F(r):r))).selector=e}return a}function re(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&Y(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&C&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(O,P),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=D.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(O,P),H.test(o[0].type)&&U(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&Q(o)))return k.apply(n,r),n;break}}}return(l||ne(e,c))(r,t,!C,n,!t||H.test(e)&&U(t.parentNode)||t),n}G.prototype=b.filters=b.pseudos,b.setFilters=new G,le.sortStable=S.split("").sort(l).join("")===S,V(),le.sortDetached=$(function(e){return 1&e.compareDocumentPosition(T.createElement("fieldset"))}),ce.find=I,ce.expr[":"]=ce.expr.pseudos,ce.unique=ce.uniqueSort,I.compile=ne,I.select=re,I.setDocument=V,I.tokenize=Y,I.escape=ce.escapeSelector,I.getText=ce.text,I.isXML=ce.isXMLDoc,I.selectors=ce.expr,I.support=ce.support,I.uniqueSort=ce.uniqueSort}();var d=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&ce(e).is(n))break;r.push(e)}return r},h=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},b=ce.expr.match.needsContext,w=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function T(e,n,r){return v(n)?ce.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?ce.grep(e,function(e){return e===n!==r}):"string"!=typeof n?ce.grep(e,function(e){return-1<se.call(n,e)!==r}):ce.filter(n,e,r)}ce.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ce.find.matchesSelector(r,e)?[r]:[]:ce.find.matches(e,ce.grep(t,function(e){return 1===e.nodeType}))},ce.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(ce(e).filter(function(){for(t=0;t<r;t++)if(ce.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)ce.find(e,i[t],n);return 1<r?ce.uniqueSort(n):n},filter:function(e){return this.pushStack(T(this,e||[],!1))},not:function(e){return this.pushStack(T(this,e||[],!0))},is:function(e){return!!T(this,"string"==typeof e&&b.test(e)?ce(e):e||[],!1).length}});var k,S=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(ce.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||k,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:S.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof ce?t[0]:t,ce.merge(this,ce.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:C,!0)),w.test(r[1])&&ce.isPlainObject(t))for(r in t)v(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=C.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==n.ready?n.ready(e):e(ce):ce.makeArray(e,this)}).prototype=ce.fn,k=ce(C);var E=/^(?:parents|prev(?:Until|All))/,j={children:!0,contents:!0,next:!0,prev:!0};function A(e,t){while((e=e[t])&&1!==e.nodeType);return e}ce.fn.extend({has:function(e){var t=ce(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ce.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&ce(e);if(!b.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&ce.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?ce.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?se.call(ce(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ce.uniqueSort(ce.merge(this.get(),ce(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ce.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return d(e,"parentNode")},parentsUntil:function(e,t,n){return d(e,"parentNode",n)},next:function(e){return A(e,"nextSibling")},prev:function(e){return A(e,"previousSibling")},nextAll:function(e){return d(e,"nextSibling")},prevAll:function(e){return d(e,"previousSibling")},nextUntil:function(e,t,n){return d(e,"nextSibling",n)},prevUntil:function(e,t,n){return d(e,"previousSibling",n)},siblings:function(e){return h((e.parentNode||{}).firstChild,e)},children:function(e){return h(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(fe(e,"template")&&(e=e.content||e),ce.merge([],e.childNodes))}},function(r,i){ce.fn[r]=function(e,t){var n=ce.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=ce.filter(t,n)),1<this.length&&(j[r]||ce.uniqueSort(n),E.test(r)&&n.reverse()),this.pushStack(n)}});var D=/[^\x20\t\r\n\f]+/g;function N(e){return e}function q(e){throw e}function L(e,t,n,r){var i;try{e&&v(i=e.promise)?i.call(e).done(t).fail(n):e&&v(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}ce.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},ce.each(e.match(D)||[],function(e,t){n[t]=!0}),n):ce.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){ce.each(e,function(e,t){v(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==x(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return ce.each(arguments,function(e,t){var n;while(-1<(n=ce.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<ce.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},ce.extend({Deferred:function(e){var o=[["notify","progress",ce.Callbacks("memory"),ce.Callbacks("memory"),2],["resolve","done",ce.Callbacks("once memory"),ce.Callbacks("once memory"),0,"resolved"],["reject","fail",ce.Callbacks("once memory"),ce.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return ce.Deferred(function(r){ce.each(o,function(e,t){var n=v(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,v(t)?s?t.call(e,l(u,o,N,s),l(u,o,q,s)):(u++,t.call(e,l(u,o,N,s),l(u,o,q,s),l(u,o,N,o.notifyWith))):(a!==N&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){ce.Deferred.exceptionHook&&ce.Deferred.exceptionHook(e,t.error),u<=i+1&&(a!==q&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(ce.Deferred.getErrorHook?t.error=ce.Deferred.getErrorHook():ce.Deferred.getStackHook&&(t.error=ce.Deferred.getStackHook()),ie.setTimeout(t))}}return ce.Deferred(function(e){o[0][3].add(l(0,e,v(r)?r:N,e.notifyWith)),o[1][3].add(l(0,e,v(t)?t:N)),o[2][3].add(l(0,e,v(n)?n:q))}).promise()},promise:function(e){return null!=e?ce.extend(e,a):a}},s={};return ce.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=ae.call(arguments),o=ce.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?ae.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(L(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||v(i[t]&&i[t].then)))return o.then();while(t--)L(i[t],a(t),o.reject);return o.promise()}});var H=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;ce.Deferred.exceptionHook=function(e,t){ie.console&&ie.console.warn&&e&&H.test(e.name)&&ie.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},ce.readyException=function(e){ie.setTimeout(function(){throw e})};var O=ce.Deferred();function P(){C.removeEventListener("DOMContentLoaded",P),ie.removeEventListener("load",P),ce.ready()}ce.fn.ready=function(e){return O.then(e)["catch"](function(e){ce.readyException(e)}),this},ce.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ce.readyWait:ce.isReady)||(ce.isReady=!0)!==e&&0<--ce.readyWait||O.resolveWith(C,[ce])}}),ce.ready.then=O.then,"complete"===C.readyState||"loading"!==C.readyState&&!C.documentElement.doScroll?ie.setTimeout(ce.ready):(C.addEventListener("DOMContentLoaded",P),ie.addEventListener("load",P));var M=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===x(n))for(s in i=!0,n)M(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,v(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ce(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},R=/^-ms-/,I=/-([a-z])/g;function W(e,t){return t.toUpperCase()}function F(e){return e.replace(R,"ms-").replace(I,W)}var $=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function B(){this.expando=ce.expando+B.uid++}B.uid=1,B.prototype={cache:function(e){var t=e[this.expando];return t||(t={},$(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[F(t)]=n;else for(r in t)i[F(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][F(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(F):(t=F(t))in r?[t]:t.match(D)||[]).length;while(n--)delete r[t[n]]}(void 0===t||ce.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ce.isEmptyObject(t)}};var _=new B,z=new B,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,U=/[A-Z]/g;function V(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(U,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:X.test(i)?JSON.parse(i):i)}catch(e){}z.set(e,t,n)}else n=void 0;return n}ce.extend({hasData:function(e){return z.hasData(e)||_.hasData(e)},data:function(e,t,n){return z.access(e,t,n)},removeData:function(e,t){z.remove(e,t)},_data:function(e,t,n){return _.access(e,t,n)},_removeData:function(e,t){_.remove(e,t)}}),ce.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=z.get(o),1===o.nodeType&&!_.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=F(r.slice(5)),V(o,r,i[r]));_.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){z.set(this,n)}):M(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=z.get(o,n))?t:void 0!==(t=V(o,n))?t:void 0;this.each(function(){z.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){z.remove(this,e)})}}),ce.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=_.get(e,t),n&&(!r||Array.isArray(n)?r=_.access(e,t,ce.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ce.queue(e,t),r=n.length,i=n.shift(),o=ce._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){ce.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return _.get(e,n)||_.access(e,n,{empty:ce.Callbacks("once memory").add(function(){_.remove(e,[t+"queue",n])})})}}),ce.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?ce.queue(this[0],t):void 0===n?this:this.each(function(){var e=ce.queue(this,t,n);ce._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&ce.dequeue(this,t)})},dequeue:function(e){return this.each(function(){ce.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ce.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=_.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var G=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Y=new RegExp("^(?:([+-])=|)("+G+")([a-z%]*)$","i"),Q=["Top","Right","Bottom","Left"],J=C.documentElement,K=function(e){return ce.contains(e.ownerDocument,e)},Z={composed:!0};J.getRootNode&&(K=function(e){return ce.contains(e.ownerDocument,e)||e.getRootNode(Z)===e.ownerDocument});var ee=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&K(e)&&"none"===ce.css(e,"display")};function te(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return ce.css(e,t,"")},u=s(),l=n&&n[3]||(ce.cssNumber[t]?"":"px"),c=e.nodeType&&(ce.cssNumber[t]||"px"!==l&&+u)&&Y.exec(ce.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)ce.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,ce.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ne={};function re(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=_.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ee(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ne[s])||(o=a.body.appendChild(a.createElement(s)),u=ce.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ne[s]=u)))):"none"!==n&&(l[c]="none",_.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}ce.fn.extend({show:function(){return re(this,!0)},hide:function(){return re(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ee(this)?ce(this).show():ce(this).hide()})}});var xe,be,we=/^(?:checkbox|radio)$/i,Te=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Ce=/^$|^module$|\/(?:java|ecma)script/i;xe=C.createDocumentFragment().appendChild(C.createElement("div")),(be=C.createElement("input")).setAttribute("type","radio"),be.setAttribute("checked","checked"),be.setAttribute("name","t"),xe.appendChild(be),le.checkClone=xe.cloneNode(!0).cloneNode(!0).lastChild.checked,xe.innerHTML="<textarea>x</textarea>",le.noCloneChecked=!!xe.cloneNode(!0).lastChild.defaultValue,xe.innerHTML="<option></option>",le.option=!!xe.lastChild;var ke={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function Se(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&fe(e,t)?ce.merge([e],n):n}function Ee(e,t){for(var n=0,r=e.length;n<r;n++)_.set(e[n],"globalEval",!t||_.get(t[n],"globalEval"))}ke.tbody=ke.tfoot=ke.colgroup=ke.caption=ke.thead,ke.th=ke.td,le.option||(ke.optgroup=ke.option=[1,"<select multiple='multiple'>","</select>"]);var je=/<|&#?\w+;/;function Ae(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===x(o))ce.merge(p,o.nodeType?[o]:o);else if(je.test(o)){a=a||f.appendChild(t.createElement("div")),s=(Te.exec(o)||["",""])[1].toLowerCase(),u=ke[s]||ke._default,a.innerHTML=u[1]+ce.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;ce.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<ce.inArray(o,r))i&&i.push(o);else if(l=K(o),a=Se(f.appendChild(o),"script"),l&&Ee(a),n){c=0;while(o=a[c++])Ce.test(o.type||"")&&n.push(o)}return f}var De=/^([^.]*)(?:\.(.+)|)/;function Ne(){return!0}function qe(){return!1}function Le(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Le(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=qe;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return ce().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=ce.guid++)),e.each(function(){ce.event.add(this,t,i,r,n)})}function He(e,r,t){t?(_.set(e,r,!1),ce.event.add(e,r,{namespace:!1,handler:function(e){var t,n=_.get(this,r);if(1&e.isTrigger&&this[r]){if(n)(ce.event.special[r]||{}).delegateType&&e.stopPropagation();else if(n=ae.call(arguments),_.set(this,r,n),this[r](),t=_.get(this,r),_.set(this,r,!1),n!==t)return e.stopImmediatePropagation(),e.preventDefault(),t}else n&&(_.set(this,r,ce.event.trigger(n[0],n.slice(1),this)),e.stopPropagation(),e.isImmediatePropagationStopped=Ne)}})):void 0===_.get(e,r)&&ce.event.add(e,r,Ne)}ce.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.get(t);if($(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&ce.find.matchesSelector(J,i),n.guid||(n.guid=ce.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof ce&&ce.event.triggered!==e.type?ce.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(D)||[""]).length;while(l--)d=g=(s=De.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=ce.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ce.event.special[d]||{},c=ce.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ce.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ce.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.hasData(e)&&_.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(D)||[""]).length;while(l--)if(d=g=(s=De.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=ce.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||ce.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)ce.event.remove(e,d+t[l],n,r,!0);ce.isEmptyObject(u)&&_.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=ce.event.fix(e),l=(_.get(this,"events")||Object.create(null))[u.type]||[],c=ce.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=ce.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((ce.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<ce(i,this).index(l):ce.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(ce.Event.prototype,t,{enumerable:!0,configurable:!0,get:v(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[ce.expando]?e:new ce.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click",!0),!1},trigger:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click"),!0},_default:function(e){var t=e.target;return we.test(t.type)&&t.click&&fe(t,"input")&&_.get(t,"click")||fe(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ce.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},ce.Event=function(e,t){if(!(this instanceof ce.Event))return new ce.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ne:qe,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ce.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[ce.expando]=!0},ce.Event.prototype={constructor:ce.Event,isDefaultPrevented:qe,isPropagationStopped:qe,isImmediatePropagationStopped:qe,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ne,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ne,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ne,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ce.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},ce.event.addProp),ce.each({focus:"focusin",blur:"focusout"},function(r,i){function o(e){if(C.documentMode){var t=_.get(this,"handle"),n=ce.event.fix(e);n.type="focusin"===e.type?"focus":"blur",n.isSimulated=!0,t(e),n.target===n.currentTarget&&t(n)}else ce.event.simulate(i,e.target,ce.event.fix(e))}ce.event.special[r]={setup:function(){var e;if(He(this,r,!0),!C.documentMode)return!1;(e=_.get(this,i))||this.addEventListener(i,o),_.set(this,i,(e||0)+1)},trigger:function(){return He(this,r),!0},teardown:function(){var e;if(!C.documentMode)return!1;(e=_.get(this,i)-1)?_.set(this,i,e):(this.removeEventListener(i,o),_.remove(this,i))},_default:function(e){return _.get(e.target,r)},delegateType:i},ce.event.special[i]={setup:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i);n||(C.documentMode?this.addEventListener(i,o):e.addEventListener(r,o,!0)),_.set(t,i,(n||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i)-1;n?_.set(t,i,n):(C.documentMode?this.removeEventListener(i,o):e.removeEventListener(r,o,!0),_.remove(t,i))}}}),ce.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){ce.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||ce.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),ce.fn.extend({on:function(e,t,n,r){return Le(this,e,t,n,r)},one:function(e,t,n,r){return Le(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ce(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=qe),this.each(function(){ce.event.remove(this,e,n,t)})}});var Oe=/<script|<style|<link/i,Pe=/checked\s*(?:[^=]|=\s*.checked.)/i,Me=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function Re(e,t){return fe(e,"table")&&fe(11!==t.nodeType?t:t.firstChild,"tr")&&ce(e).children("tbody")[0]||e}function Ie(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function We(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Fe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(_.hasData(e)&&(s=_.get(e).events))for(i in _.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)ce.event.add(t,i,s[i][n]);z.hasData(e)&&(o=z.access(e),a=ce.extend({},o),z.set(t,a))}}function $e(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=v(d);if(h||1<f&&"string"==typeof d&&!le.checkClone&&Pe.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),$e(t,r,i,o)});if(f&&(t=(e=Ae(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=ce.map(Se(e,"script"),Ie)).length;c<f;c++)u=e,c!==p&&(u=ce.clone(u,!0,!0),s&&ce.merge(a,Se(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,ce.map(a,We),c=0;c<s;c++)u=a[c],Ce.test(u.type||"")&&!_.access(u,"globalEval")&&ce.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?ce._evalUrl&&!u.noModule&&ce._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):m(u.textContent.replace(Me,""),u,l))}return n}function Be(e,t,n){for(var r,i=t?ce.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||ce.cleanData(Se(r)),r.parentNode&&(n&&K(r)&&Ee(Se(r,"script")),r.parentNode.removeChild(r));return e}ce.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=K(e);if(!(le.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ce.isXMLDoc(e)))for(a=Se(c),r=0,i=(o=Se(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&we.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||Se(e),a=a||Se(c),r=0,i=o.length;r<i;r++)Fe(o[r],a[r]);else Fe(e,c);return 0<(a=Se(c,"script")).length&&Ee(a,!f&&Se(e,"script")),c},cleanData:function(e){for(var t,n,r,i=ce.event.special,o=0;void 0!==(n=e[o]);o++)if($(n)){if(t=n[_.expando]){if(t.events)for(r in t.events)i[r]?ce.event.remove(n,r):ce.removeEvent(n,r,t.handle);n[_.expando]=void 0}n[z.expando]&&(n[z.expando]=void 0)}}}),ce.fn.extend({detach:function(e){return Be(this,e,!0)},remove:function(e){return Be(this,e)},text:function(e){return M(this,function(e){return void 0===e?ce.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return $e(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Re(this,e).appendChild(e)})},prepend:function(){return $e(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Re(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ce.cleanData(Se(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ce.clone(this,e,t)})},html:function(e){return M(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Oe.test(e)&&!ke[(Te.exec(e)||["",""])[1].toLowerCase()]){e=ce.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(ce.cleanData(Se(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return $e(this,arguments,function(e){var t=this.parentNode;ce.inArray(this,n)<0&&(ce.cleanData(Se(this)),t&&t.replaceChild(e,this))},n)}}),ce.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){ce.fn[e]=function(e){for(var t,n=[],r=ce(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),ce(r[o])[a](t),s.apply(n,t.get());return this.pushStack(n)}});var _e=new RegExp("^("+G+")(?!px)[a-z%]+$","i"),ze=/^--/,Xe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=ie),t.getComputedStyle(e)},Ue=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ve=new RegExp(Q.join("|"),"i");function Ge(e,t,n){var r,i,o,a,s=ze.test(t),u=e.style;return(n=n||Xe(e))&&(a=n.getPropertyValue(t)||n[t],s&&a&&(a=a.replace(ve,"$1")||void 0),""!==a||K(e)||(a=ce.style(e,t)),!le.pixelBoxStyles()&&_e.test(a)&&Ve.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function Ye(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",J.appendChild(u).appendChild(l);var e=ie.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),J.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=C.createElement("div"),l=C.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",le.clearCloneStyle="content-box"===l.style.backgroundClip,ce.extend(le,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=C.createElement("table"),t=C.createElement("tr"),n=C.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="box-sizing:content-box;border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",J.appendChild(e).appendChild(t).appendChild(n),r=ie.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,J.removeChild(e)),a}}))}();var Qe=["Webkit","Moz","ms"],Je=C.createElement("div").style,Ke={};function Ze(e){var t=ce.cssProps[e]||Ke[e];return t||(e in Je?e:Ke[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Qe.length;while(n--)if((e=Qe[n]+t)in Je)return e}(e)||e)}var et=/^(none|table(?!-c[ea]).+)/,tt={position:"absolute",visibility:"hidden",display:"block"},nt={letterSpacing:"0",fontWeight:"400"};function rt(e,t,n){var r=Y.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function it(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0,l=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(l+=ce.css(e,n+Q[a],!0,i)),r?("content"===n&&(u-=ce.css(e,"padding"+Q[a],!0,i)),"margin"!==n&&(u-=ce.css(e,"border"+Q[a]+"Width",!0,i))):(u+=ce.css(e,"padding"+Q[a],!0,i),"padding"!==n?u+=ce.css(e,"border"+Q[a]+"Width",!0,i):s+=ce.css(e,"border"+Q[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u+l}function ot(e,t,n){var r=Xe(e),i=(!le.boxSizingReliable()||n)&&"border-box"===ce.css(e,"boxSizing",!1,r),o=i,a=Ge(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(_e.test(a)){if(!n)return a;a="auto"}return(!le.boxSizingReliable()&&i||!le.reliableTrDimensions()&&fe(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===ce.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===ce.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+it(e,t,n||(i?"border":"content"),o,r,a)+"px"}function at(e,t,n,r,i){return new at.prototype.init(e,t,n,r,i)}ce.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Ge(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=F(t),u=ze.test(t),l=e.style;if(u||(t=Ze(s)),a=ce.cssHooks[t]||ce.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=Y.exec(n))&&i[1]&&(n=te(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(ce.cssNumber[s]?"":"px")),le.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=F(t);return ze.test(t)||(t=Ze(s)),(a=ce.cssHooks[t]||ce.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Ge(e,t,r)),"normal"===i&&t in nt&&(i=nt[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),ce.each(["height","width"],function(e,u){ce.cssHooks[u]={get:function(e,t,n){if(t)return!et.test(ce.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?ot(e,u,n):Ue(e,tt,function(){return ot(e,u,n)})},set:function(e,t,n){var r,i=Xe(e),o=!le.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===ce.css(e,"boxSizing",!1,i),s=n?it(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-it(e,u,"border",!1,i)-.5)),s&&(r=Y.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=ce.css(e,u)),rt(0,t,s)}}}),ce.cssHooks.marginLeft=Ye(le.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Ge(e,"marginLeft"))||e.getBoundingClientRect().left-Ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),ce.each({margin:"",padding:"",border:"Width"},function(i,o){ce.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+Q[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(ce.cssHooks[i+o].set=rt)}),ce.fn.extend({css:function(e,t){return M(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Xe(e),i=t.length;a<i;a++)o[t[a]]=ce.css(e,t[a],!1,r);return o}return void 0!==n?ce.style(e,t,n):ce.css(e,t)},e,t,1<arguments.length)}}),((ce.Tween=at).prototype={constructor:at,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||ce.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ce.cssNumber[n]?"":"px")},cur:function(){var e=at.propHooks[this.prop];return e&&e.get?e.get(this):at.propHooks._default.get(this)},run:function(e){var t,n=at.propHooks[this.prop];return this.options.duration?this.pos=t=ce.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):at.propHooks._default.set(this),this}}).init.prototype=at.prototype,(at.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ce.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){ce.fx.step[e.prop]?ce.fx.step[e.prop](e):1!==e.elem.nodeType||!ce.cssHooks[e.prop]&&null==e.elem.style[Ze(e.prop)]?e.elem[e.prop]=e.now:ce.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=at.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ce.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},ce.fx=at.prototype.init,ce.fx.step={};var st,ut,lt,ct,ft=/^(?:toggle|show|hide)$/,pt=/queueHooks$/;function dt(){ut&&(!1===C.hidden&&ie.requestAnimationFrame?ie.requestAnimationFrame(dt):ie.setTimeout(dt,ce.fx.interval),ce.fx.tick())}function ht(){return ie.setTimeout(function(){st=void 0}),st=Date.now()}function gt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=Q[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function vt(e,t,n){for(var r,i=(yt.tweeners[t]||[]).concat(yt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function yt(o,e,t){var n,a,r=0,i=yt.prefilters.length,s=ce.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=st||ht(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:ce.extend({},e),opts:ce.extend(!0,{specialEasing:{},easing:ce.easing._default},t),originalProperties:e,originalOptions:t,startTime:st||ht(),duration:t.duration,tweens:[],createTween:function(e,t){var n=ce.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=F(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=ce.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=yt.prefilters[r].call(l,o,c,l.opts))return v(n.stop)&&(ce._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return ce.map(c,vt,l),v(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),ce.fx.timer(ce.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}ce.Animation=ce.extend(yt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return te(n.elem,e,Y.exec(t),n),n}]},tweener:function(e,t){v(e)?(t=e,e=["*"]):e=e.match(D);for(var n,r=0,i=e.length;r<i;r++)n=e[r],yt.tweeners[n]=yt.tweeners[n]||[],yt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ee(e),v=_.get(e,"fxshow");for(r in n.queue||(null==(a=ce._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,ce.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ft.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||ce.style(e,r)}if((u=!ce.isEmptyObject(t))||!ce.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=_.get(e,"display")),"none"===(c=ce.css(e,"display"))&&(l?c=l:(re([e],!0),l=e.style.display||l,c=ce.css(e,"display"),re([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===ce.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=_.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&re([e],!0),p.done(function(){for(r in g||re([e]),_.remove(e,"fxshow"),d)ce.style(e,r,d[r])})),u=vt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?yt.prefilters.unshift(e):yt.prefilters.push(e)}}),ce.speed=function(e,t,n){var r=e&&"object"==typeof e?ce.extend({},e):{complete:n||!n&&t||v(e)&&e,duration:e,easing:n&&t||t&&!v(t)&&t};return ce.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in ce.fx.speeds?r.duration=ce.fx.speeds[r.duration]:r.duration=ce.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){v(r.old)&&r.old.call(this),r.queue&&ce.dequeue(this,r.queue)},r},ce.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ee).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=ce.isEmptyObject(t),o=ce.speed(e,n,r),a=function(){var e=yt(this,ce.extend({},t),o);(i||_.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=ce.timers,r=_.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&pt.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||ce.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=_.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=ce.timers,o=n?n.length:0;for(t.finish=!0,ce.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),ce.each(["toggle","show","hide"],function(e,r){var i=ce.fn[r];ce.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(gt(r,!0),e,t,n)}}),ce.each({slideDown:gt("show"),slideUp:gt("hide"),slideToggle:gt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){ce.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),ce.timers=[],ce.fx.tick=function(){var e,t=0,n=ce.timers;for(st=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||ce.fx.stop(),st=void 0},ce.fx.timer=function(e){ce.timers.push(e),ce.fx.start()},ce.fx.interval=13,ce.fx.start=function(){ut||(ut=!0,dt())},ce.fx.stop=function(){ut=null},ce.fx.speeds={slow:600,fast:200,_default:400},ce.fn.delay=function(r,e){return r=ce.fx&&ce.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=ie.setTimeout(e,r);t.stop=function(){ie.clearTimeout(n)}})},lt=C.createElement("input"),ct=C.createElement("select").appendChild(C.createElement("option")),lt.type="checkbox",le.checkOn=""!==lt.value,le.optSelected=ct.selected,(lt=C.createElement("input")).value="t",lt.type="radio",le.radioValue="t"===lt.value;var mt,xt=ce.expr.attrHandle;ce.fn.extend({attr:function(e,t){return M(this,ce.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){ce.removeAttr(this,e)})}}),ce.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?ce.prop(e,t,n):(1===o&&ce.isXMLDoc(e)||(i=ce.attrHooks[t.toLowerCase()]||(ce.expr.match.bool.test(t)?mt:void 0)),void 0!==n?null===n?void ce.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=ce.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!le.radioValue&&"radio"===t&&fe(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(D);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),mt={set:function(e,t,n){return!1===t?ce.removeAttr(e,n):e.setAttribute(n,n),n}},ce.each(ce.expr.match.bool.source.match(/\w+/g),function(e,t){var a=xt[t]||ce.find.attr;xt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=xt[o],xt[o]=r,r=null!=a(e,t,n)?o:null,xt[o]=i),r}});var bt=/^(?:input|select|textarea|button)$/i,wt=/^(?:a|area)$/i;function Tt(e){return(e.match(D)||[]).join(" ")}function Ct(e){return e.getAttribute&&e.getAttribute("class")||""}function kt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(D)||[]}ce.fn.extend({prop:function(e,t){return M(this,ce.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[ce.propFix[e]||e]})}}),ce.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ce.isXMLDoc(e)||(t=ce.propFix[t]||t,i=ce.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=ce.find.attr(e,"tabindex");return t?parseInt(t,10):bt.test(e.nodeName)||wt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),le.optSelected||(ce.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ce.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ce.propFix[this.toLowerCase()]=this}),ce.fn.extend({addClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).addClass(t.call(this,e,Ct(this)))}):(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++)i=e[o],n.indexOf(" "+i+" ")<0&&(n+=i+" ");a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).removeClass(t.call(this,e,Ct(this)))}):arguments.length?(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(" "+i+" "))n=n.replace(" "+i+" "," ")}a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this:this.attr("class","")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s="string"===a||Array.isArray(t);return v(t)?this.each(function(e){ce(this).toggleClass(t.call(this,e,Ct(this),n),n)}):"boolean"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=kt(t),this.each(function(){if(s)for(o=ce(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&"boolean"!==a||((r=Ct(this))&&_.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===t?"":_.get(this,"__className__")||""))}))},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+Tt(Ct(n))+" ").indexOf(t))return!0;return!1}});var St=/\r/g;ce.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=v(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,ce(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=ce.map(t,function(e){return null==e?"":e+""})),(r=ce.valHooks[this.type]||ce.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=ce.valHooks[t.type]||ce.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(St,""):null==e?"":e:void 0}}),ce.extend({valHooks:{option:{get:function(e){var t=ce.find.attr(e,"value");return null!=t?t:Tt(ce.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!fe(n.parentNode,"optgroup"))){if(t=ce(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=ce.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<ce.inArray(ce.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ce.each(["radio","checkbox"],function(){ce.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<ce.inArray(ce(e).val(),t)}},le.checkOn||(ce.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Et=ie.location,jt={guid:Date.now()},At=/\?/;ce.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new ie.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||ce.error("Invalid XML: "+(n?ce.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var Dt=/^(?:focusinfocus|focusoutblur)$/,Nt=function(e){e.stopPropagation()};ce.extend(ce.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||C],d=ue.call(e,"type")?e.type:e,h=ue.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||C,3!==n.nodeType&&8!==n.nodeType&&!Dt.test(d+ce.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[ce.expando]?e:new ce.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:ce.makeArray(t,[e]),c=ce.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!y(n)){for(s=c.delegateType||d,Dt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||C)&&p.push(a.defaultView||a.parentWindow||ie)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(_.get(o,"events")||Object.create(null))[e.type]&&_.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&$(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!$(n)||u&&v(n[d])&&!y(n)&&((a=n[u])&&(n[u]=null),ce.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Nt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Nt),ce.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=ce.extend(new ce.Event,n,{type:e,isSimulated:!0});ce.event.trigger(r,null,t)}}),ce.fn.extend({trigger:function(e,t){return this.each(function(){ce.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ce.event.trigger(e,t,n,!0)}});var qt=/\[\]$/,Lt=/\r?\n/g,Ht=/^(?:submit|button|image|reset|file)$/i,Ot=/^(?:input|select|textarea|keygen)/i;function Pt(n,e,r,i){var t;if(Array.isArray(e))ce.each(e,function(e,t){r||qt.test(n)?i(n,t):Pt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==x(e))i(n,e);else for(t in e)Pt(n+"["+t+"]",e[t],r,i)}ce.param=function(e,t){var n,r=[],i=function(e,t){var n=v(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!ce.isPlainObject(e))ce.each(e,function(){i(this.name,this.value)});else for(n in e)Pt(n,e[n],t,i);return r.join("&")},ce.fn.extend({serialize:function(){return ce.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ce.prop(this,"elements");return e?ce.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ce(this).is(":disabled")&&Ot.test(this.nodeName)&&!Ht.test(e)&&(this.checked||!we.test(e))}).map(function(e,t){var n=ce(this).val();return null==n?null:Array.isArray(n)?ce.map(n,function(e){return{name:t.name,value:e.replace(Lt,"\r\n")}}):{name:t.name,value:n.replace(Lt,"\r\n")}}).get()}});var Mt=/%20/g,Rt=/#.*$/,It=/([?&])_=[^&]*/,Wt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ft=/^(?:GET|HEAD)$/,$t=/^\/\//,Bt={},_t={},zt="*/".concat("*"),Xt=C.createElement("a");function Ut(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(D)||[];if(v(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Vt(t,i,o,a){var s={},u=t===_t;function l(e){var r;return s[e]=!0,ce.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Gt(e,t){var n,r,i=ce.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ce.extend(!0,e,r),e}Xt.href=Et.href,ce.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":zt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":ce.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Gt(Gt(e,ce.ajaxSettings),t):Gt(ce.ajaxSettings,e)},ajaxPrefilter:Ut(Bt),ajaxTransport:Ut(_t),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=ce.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?ce(y):ce.event,x=ce.Deferred(),b=ce.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Wt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace($t,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(D)||[""],null==v.crossDomain){r=C.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Xt.protocol+"//"+Xt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=ce.param(v.data,v.traditional)),Vt(Bt,v,t,T),h)return T;for(i in(g=ce.event&&v.global)&&0==ce.active++&&ce.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ft.test(v.type),f=v.url.replace(Rt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Mt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(At.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(It,"$1"),o=(At.test(f)?"&":"?")+"_="+jt.guid+++o),v.url=f+o),v.ifModified&&(ce.lastModified[f]&&T.setRequestHeader("If-Modified-Since",ce.lastModified[f]),ce.etag[f]&&T.setRequestHeader("If-None-Match",ce.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+zt+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Vt(_t,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=ie.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&ie.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<ce.inArray("script",v.dataTypes)&&ce.inArray("json",v.dataTypes)<0&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(ce.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(ce.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--ce.active||ce.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return ce.get(e,t,n,"json")},getScript:function(e,t){return ce.get(e,void 0,t,"script")}}),ce.each(["get","post"],function(e,i){ce[i]=function(e,t,n,r){return v(t)&&(r=r||n,n=t,t=void 0),ce.ajax(ce.extend({url:e,type:i,dataType:r,data:t,success:n},ce.isPlainObject(e)&&e))}}),ce.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),ce._evalUrl=function(e,t,n){return ce.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){ce.globalEval(e,t,n)}})},ce.fn.extend({wrapAll:function(e){var t;return this[0]&&(v(e)&&(e=e.call(this[0])),t=ce(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return v(n)?this.each(function(e){ce(this).wrapInner(n.call(this,e))}):this.each(function(){var e=ce(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=v(t);return this.each(function(e){ce(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){ce(this).replaceWith(this.childNodes)}),this}}),ce.expr.pseudos.hidden=function(e){return!ce.expr.pseudos.visible(e)},ce.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ce.ajaxSettings.xhr=function(){try{return new ie.XMLHttpRequest}catch(e){}};var Yt={0:200,1223:204},Qt=ce.ajaxSettings.xhr();le.cors=!!Qt&&"withCredentials"in Qt,le.ajax=Qt=!!Qt,ce.ajaxTransport(function(i){var o,a;if(le.cors||Qt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Yt[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&ie.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),ce.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ce.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return ce.globalEval(e),e}}}),ce.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ce.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=ce("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),C.head.appendChild(r[0])},abort:function(){i&&i()}}});var Jt,Kt=[],Zt=/(=)\?(?=&|$)|\?\?/;ce.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Kt.pop()||ce.expando+"_"+jt.guid++;return this[e]=!0,e}}),ce.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Zt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Zt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Zt,"$1"+r):!1!==e.jsonp&&(e.url+=(At.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||ce.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=ie[r],ie[r]=function(){o=arguments},n.always(function(){void 0===i?ce(ie).removeProp(r):ie[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Kt.push(r)),o&&v(i)&&i(o[0]),o=i=void 0}),"script"}),le.createHTMLDocument=((Jt=C.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Jt.childNodes.length),ce.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(le.createHTMLDocument?((r=(t=C.implementation.createHTMLDocument("")).createElement("base")).href=C.location.href,t.head.appendChild(r)):t=C),o=!n&&[],(i=w.exec(e))?[t.createElement(i[1])]:(i=Ae([e],t,o),o&&o.length&&ce(o).remove(),ce.merge([],i.childNodes)));var r,i,o},ce.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=Tt(e.slice(s)),e=e.slice(0,s)),v(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&ce.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?ce("<div>").append(ce.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},ce.expr.pseudos.animated=function(t){return ce.grep(ce.timers,function(e){return t===e.elem}).length},ce.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=ce.css(e,"position"),c=ce(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=ce.css(e,"top"),u=ce.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),v(t)&&(t=t.call(e,n,ce.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},ce.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){ce.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===ce.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===ce.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=ce(e).offset()).top+=ce.css(e,"borderTopWidth",!0),i.left+=ce.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-ce.css(r,"marginTop",!0),left:t.left-i.left-ce.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===ce.css(e,"position"))e=e.offsetParent;return e||J})}}),ce.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;ce.fn[t]=function(e){return M(this,function(e,t,n){var r;if(y(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),ce.each(["top","left"],function(e,n){ce.cssHooks[n]=Ye(le.pixelPosition,function(e,t){if(t)return t=Ge(e,n),_e.test(t)?ce(e).position()[n]+"px":t})}),ce.each({Height:"height",Width:"width"},function(a,s){ce.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){ce.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return M(this,function(e,t,n){var r;return y(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?ce.css(e,t,i):ce.style(e,t,n,i)},s,n?e:void 0,n)}})}),ce.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ce.fn[t]=function(e){return this.on(t,e)}}),ce.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.on("mouseenter",e).on("mouseleave",t||e)}}),ce.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){ce.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var en=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;ce.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),v(e))return r=ae.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(ae.call(arguments)))}).guid=e.guid=e.guid||ce.guid++,i},ce.holdReady=function(e){e?ce.readyWait++:ce.ready(!0)},ce.isArray=Array.isArray,ce.parseJSON=JSON.parse,ce.nodeName=fe,ce.isFunction=v,ce.isWindow=y,ce.camelCase=F,ce.type=x,ce.now=Date.now,ce.isNumeric=function(e){var t=ce.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},ce.trim=function(e){return null==e?"":(e+"").replace(en,"$1")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return ce});var tn=ie.jQuery,nn=ie.$;return ce.noConflict=function(e){return ie.$===ce&&(ie.$=nn),e&&ie.jQuery===ce&&(ie.jQuery=tn),ce},"undefined"==typeof e&&(ie.jQuery=ie.$=ce),ce});]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="linkify" javascript_name="linkify-jquery.min.js" javascript_type="framework" javascript_version="5001403" javascript_position="400"><![CDATA["use strict";!function(e,t,n){var i=function(t,n){function i(e,t,n){var i=n[n.length-1];e.replaceChild(i,t);for(var r=n.length-2;r>=0;r--)e.insertBefore(n[r],i),i=n[r]}function r(e,t,n){for(var i=[],r=e,a=Array.isArray(r),o=0,r=a?r:r[Symbol.iterator]();;){var l;if(a){if(o>=r.length)break;l=r[o++]}else{if(o=r.next(),o.done)break;l=o.value}var f=l;if("nl"===f.type&&t.nl2br)i.push(n.createElement("br"));else if(f.isLink&&t.check(f)){var s=t.resolve(f),c=s.formatted,u=s.formattedHref,d=s.tagName,m=s.className,y=s.target,h=s.events,k=s.attributes,v=n.createElement(d);if(v.setAttribute("href",u),m&&v.setAttribute("class",m),y&&v.setAttribute("target",y),k)for(var g in k)v.setAttribute(g,k[g]);if(h)for(var b in h)v.addEventListener?v.addEventListener(b,h[b]):v.attachEvent&&v.attachEvent("on"+b,h[b]);v.appendChild(n.createTextNode(c)),i.push(v)}else i.push(n.createTextNode(f.toString()))}return i}function a(e,t,n){if(!e||e.nodeType!==d)throw new Error("Cannot linkify "+e+" - Invalid DOM Node type");var o=t.ignoreTags;if("A"===e.tagName||s.contains(o,e.tagName))return e;for(var l=e.firstChild;l;){switch(l.nodeType){case d:a(l,t,n);break;case m:var c=l.nodeValue,y=f(c);if(0===y.length||1===y.length&&y[0]instanceof u)break;var h=r(y,t,n);i(e,l,h),l=h[h.length-1]}l=l.nextSibling}return e}function o(t,n){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];try{i=i||document||e&&e.document||global&&global.document}catch(r){}if(!i)throw new Error("Cannot find document implementation. If you are in a non-browser environment like Node.js, pass the document implementation as the third argument to linkifyElement.");return n=new c(n),a(t,n,i)}function l(t){function n(e){return e=o.normalize(e),this.each(function(){o.helper(this,e,i)})}var i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t.fn=t.fn||{};try{i=i||document||e&&e.document||global&&global.document}catch(r){}if(!i)throw new Error("Cannot find document implementation. If you are in a non-browser environment like Node.js, pass the document implementation as the second argument to linkify/jquery");"function"!=typeof t.fn.linkify&&(t.fn.linkify=n,t(i).ready(function(){t("[data-linkify]").each(function(){var e=t(this),n=e.data(),i=n.linkify,r=n.linkifyNlbr,a={attributes:n.linkifyAttributes,defaultProtocol:n.linkifyDefaultProtocol,events:n.linkifyEvents,format:n.linkifyFormat,formatHref:n.linkifyFormatHref,nl2br:!!r&&0!==r&&"false"!==r,tagName:n.linkifyTagname,target:n.linkifyTarget,className:n.linkifyClassName||n.linkifyLinkclass,validate:n.linkifyValidate,ignoreTags:n.linkifyIgnoreTags},o="this"===i?e:e.find(i);o.linkify(a)})}))}t="default"in t?t["default"]:t;var f=n.tokenize,s=n.options,c=s.Options,u=n.parser.TOKENS.TEXT,d=1,m=3;o.helper=a,o.normalize=function(e){return new c(e)};try{!define&&(e.linkifyElement=o)}catch(y){}return l}(n,t);"function"!=typeof n.fn.linkify&&i(n)}(window,linkify,jQuery);]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="linkify" javascript_name="linkify.min.js" javascript_type="framework" javascript_version="5001403" javascript_position="350"><![CDATA[!function(){"use strict";var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};!function(e){function n(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=Object.create(t.prototype);for(var a in n)o[a]=n[a];return o.constructor=e,e.prototype=o,e}function o(t){t=t||{},this.defaultProtocol=t.defaultProtocol||h.defaultProtocol,this.events=t.events||h.events,this.format=t.format||h.format,this.formatHref=t.formatHref||h.formatHref,this.nl2br=t.nl2br||h.nl2br,this.tagName=t.tagName||h.tagName,this.target=t.target||h.target,this.validate=t.validate||h.validate,this.ignoreTags=[],this.attributes=t.attributes||t.linkAttributes||h.attributes,this.className=t.className||t.linkClass||h.className;for(var e=t.ignoreTags||h.ignoreTags,n=0;n<e.length;n++)this.ignoreTags.push(e[n].toUpperCase())}function a(t,e){for(var n=0;n<t.length;n++)if(t[n]===e)return!0;return!1}function r(t){return t}function i(t,e){return"url"===e?"_blank":null}function s(){return function(t){this.j=[],this.T=t||null}}function c(t,e,n,o){for(var a=0,r=t.length,i=e,s=[],c=void 0;a<r&&(c=i.next(t[a]));)i=c,a++;if(a>=r)return[];for(;a<r-1;)c=new m(o),s.push(c),i.on(t[a],c),i=c,a++;return c=new m(n),s.push(c),i.on(t[r-1],c),s}function l(){return function(t){t&&(this.v=t)}}function u(t){var e=t?{v:t}:{};return n(b,l(),e)}function p(t){return t instanceof v||t instanceof R}var h={defaultProtocol:"http",events:null,format:r,formatHref:r,nl2br:!1,tagName:"a",target:i,validate:!0,ignoreTags:[],attributes:null,className:"linkified"};o.prototype={resolve:function(t){var e=t.toHref(this.defaultProtocol);return{formatted:this.get("format",t.toString(),t),formattedHref:this.get("formatHref",e,t),tagName:this.get("tagName",e,t),className:this.get("className",e,t),target:this.get("target",e,t),events:this.getObject("events",e,t),attributes:this.getObject("attributes",e,t)}},check:function(t){return this.get("validate",t.toString(),t)},get:function(e,n,o){var a=this[e];if(!a)return a;switch("undefined"==typeof a?"undefined":t(a)){case"function":return a(n,o.type);case"object":var r=a[o.type]||h[e];return"function"==typeof r?r(n,o.type):r}return a},getObject:function(t,e,n){var o=this[t];return"function"==typeof o?o(e,n.type):o}};var g=Object.freeze({defaults:h,Options:o,contains:a}),f=s();f.prototype={defaultTransition:!1,on:function(t,e){if(t instanceof Array){for(var n=0;n<t.length;n++)this.j.push([t[n],e]);return this}return this.j.push([t,e]),this},next:function(t){for(var e=0;e<this.j.length;e++){var n=this.j[e],o=n[0],a=n[1];if(this.test(t,o))return a}return this.defaultTransition},accepts:function(){return!!this.T},test:function(t,e){return t===e},emit:function(){return this.T}};var m=n(f,s(),{test:function(t,e){return t===e||e instanceof RegExp&&e.test(t)}}),d=n(f,s(),{jump:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=this.next(new t(""));return n===this.defaultTransition?(n=new this.constructor(e),this.on(t,n)):e&&(n.T=e),n},test:function(t,e){return t instanceof e}}),b=l();b.prototype={toString:function(){return this.v+""}};var v=u(),y=u("@"),k=u(":"),w=u("."),j=u(),x=u(),z=u("\n"),O=u(),S=u("+"),N=u("#"),T=u(),A=u("mailto:"),L=u("?"),E=u("/"),C=u("_"),P=u(),R=u(),q=u(),H=u("{"),B=u("["),U=u("<"),M=u("("),D=u("}"),I=u("]"),K=u(">"),_=u(")"),G=u("&"),Y=Object.freeze({Base:b,DOMAIN:v,AT:y,COLON:k,DOT:w,PUNCTUATION:j,LOCALHOST:x,NL:z,NUM:O,PLUS:S,POUND:N,QUERY:L,PROTOCOL:T,MAILTO:A,SLASH:E,UNDERSCORE:C,SYM:P,TLD:R,WS:q,OPENBRACE:H,OPENBRACKET:B,OPENANGLEBRACKET:U,OPENPAREN:M,CLOSEBRACE:D,CLOSEBRACKET:I,CLOSEANGLEBRACKET:K,CLOSEPAREN:_,AMPERSAND:G}),Q="aaa|aarp|abb|abbott|abogado|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|af|afl|ag|agency|ai|aig|airforce|airtel|al|alibaba|alipay|allfinanz|alsace|am|amica|amsterdam|an|analytics|android|ao|apartments|app|apple|aq|aquarelle|ar|aramco|archi|army|arpa|arte|as|asia|associates|at|attorney|au|auction|audi|audio|author|auto|autos|avianca|aw|ax|axa|az|azure|ba|baidu|band|bank|bar|barcelona|barclaycard|barclays|bargains|bauhaus|bayern|bb|bbc|bbva|bcg|bcn|bd|be|beats|beer|bentley|berlin|best|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bom|bond|boo|book|boots|bosch|bostik|bot|boutique|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|camera|camp|cancerresearch|canon|capetown|capital|car|caravan|cards|care|career|careers|cars|cartier|casa|cash|casino|cat|catering|cba|cbn|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chloe|christmas|chrome|church|ci|cipriani|circle|cisco|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|date|dating|datsun|day|dclk|de|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|diamonds|diet|digital|direct|directory|discount|dj|dk|dm|dnp|do|docs|dog|doha|domains|download|drive|dubai|durban|dvag|dz|earth|eat|ec|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epson|equipment|er|erni|es|esq|estate|et|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|fage|fail|fairwinds|faith|family|fan|fans|farm|fashion|fast|feedback|ferrero|fi|film|final|finance|financial|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|florist|flowers|flsmidth|fly|fm|fo|foo|football|ford|forex|forsale|forum|foundation|fox|fr|fresenius|frl|frogans|frontier|fund|furniture|futbol|fyi|ga|gal|gallery|gallup|game|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|gold|goldpoint|golf|goo|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|group|gs|gt|gu|gucci|guge|guide|guitars|guru|gw|gy|hamburg|hangout|haus|hdfcbank|health|healthcare|help|helsinki|here|hermes|hiphop|hitachi|hiv|hk|hm|hn|hockey|holdings|holiday|homedepot|homes|honda|horse|host|hosting|hoteles|hotmail|house|how|hr|hsbc|ht|hu|hyundai|ibm|icbc|ice|icu|id|ie|ifm|iinet|il|im|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|international|investments|io|ipiranga|iq|ir|irish|is|iselect|ist|istanbul|it|itau|iwc|jaguar|java|jcb|je|jetzt|jewelry|jlc|jll|jm|jmp|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kitchen|kiwi|km|kn|koeln|komatsu|kp|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|lamborghini|lamer|lancaster|land|landrover|lanxess|lasalle|lat|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|legal|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|limited|limo|lincoln|linde|link|live|living|lixil|lk|loan|loans|local|locus|lol|london|lotte|lotto|love|lr|ls|lt|ltd|ltda|lu|lupin|luxe|luxury|lv|ly|ma|madrid|maif|maison|makeup|man|management|mango|market|marketing|markets|marriott|mba|mc|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|mg|mh|miami|microsoft|mil|mini|mk|ml|mm|mma|mn|mo|mobi|mobily|moda|moe|moi|mom|monash|money|montblanc|mormon|mortgage|moscow|motorcycles|mov|movie|movistar|mp|mq|mr|ms|mt|mtn|mtpc|mtr|mu|museum|mutuelle|mv|mw|mx|my|mz|na|nadex|nagoya|name|natura|navy|nc|ne|nec|net|netbank|network|neustar|new|news|nexus|nf|ng|ngo|nhk|ni|nico|nikon|ninja|nissan|nl|no|nokia|norton|nowruz|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|office|okinawa|om|omega|one|ong|onl|online|ooo|oracle|orange|org|organic|origins|osaka|otsuka|ovh|pa|page|pamperedchef|panerai|paris|pars|partners|parts|party|passagens|pe|pet|pf|pg|ph|pharmacy|philips|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pohl|poker|porn|post|pr|praxi|press|pro|prod|productions|prof|promo|properties|property|protection|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|racing|re|read|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|ricoh|rio|rip|ro|rocher|rocks|rodeo|room|rs|rsvp|ru|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|saxo|sb|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scor|scot|sd|se|seat|security|seek|select|sener|services|seven|sew|sex|sexy|sfr|sg|sh|sharp|shell|shia|shiksha|shoes|show|shriram|si|singles|site|sj|sk|ski|skin|sky|skype|sl|sm|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|st|stada|star|starhub|statefarm|statoil|stc|stcgroup|stockholm|storage|store|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|taobao|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|team|tech|technology|tel|telecity|telefonica|temasek|tennis|tf|tg|th|thd|theater|theatre|tickets|tienda|tiffany|tips|tires|tirol|tj|tk|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tp|tr|trade|trading|training|travel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubs|ug|uk|unicom|university|uno|uol|us|uy|uz|va|vacations|vana|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|viking|villas|vin|vip|virgin|vision|vista|vistaprint|viva|vlaanderen|vn|vodka|volkswagen|vote|voting|voto|voyage|vu|vuelos|wales|walter|wang|wanggou|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|wme|wolterskluwer|work|works|world|ws|wtc|wtf|xbox|xerox|xin|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|youtube|yt|za|zara|zero|zip|zm|zone|zuerich|zw".split("|"),W="0123456789".split(""),X="0123456789abcdefghijklmnopqrstuvwxyz".split(""),Z=[" ","\f","\r","\t","\x0B","","",""],F=[],J=function(t){return new m(t)},V=J(),$=J(O),tt=J(v),et=J(),nt=J(q);V.on("@",J(y)).on(".",J(w)).on("+",J(S)).on("#",J(N)).on("?",J(L)).on("/",J(E)).on("_",J(C)).on(":",J(k)).on("{",J(H)).on("[",J(B)).on("<",J(U)).on("(",J(M)).on("}",J(D)).on("]",J(I)).on(">",J(K)).on(")",J(_)).on("&",J(G)).on([",",";","!",'"',"'"],J(j)),V.on("\n",J(z)).on(Z,nt),nt.on(Z,nt);for(var ot=0;ot<Q.length;ot++){var at=c(Q[ot],V,R,v);F.push.apply(F,at)}var rt=c("file",V,v,v),it=c("ftp",V,v,v),st=c("http",V,v,v),ct=c("mailto",V,v,v);F.push.apply(F,rt),F.push.apply(F,it),F.push.apply(F,st);var lt=rt.pop(),ut=it.pop(),pt=st.pop(),ht=ct.pop(),gt=J(v),ft=J(T),mt=J(A);ut.on("s",gt).on(":",ft),pt.on("s",gt).on(":",ft),F.push(gt),lt.on(":",ft),gt.on(":",ft),ht.on(":",mt);var dt=c("localhost",V,x,v);F.push.apply(F,dt),V.on(W,$),$.on("-",et).on(W,$).on(X,tt),tt.on("-",et).on(X,tt);for(var bt=0;bt<F.length;bt++)F[bt].on("-",et).on(X,tt);et.on("-",et).on(W,tt).on(X,tt),V.defaultTransition=J(P);var vt=function(t){for(var e=t.replace(/[A-Z]/g,function(t){return t.toLowerCase()}),n=t.length,o=[],a=0;a<n;){for(var r=V,i=null,s=null,c=0,l=null,u=-1;a<n&&(s=r.next(e[a]));)i=null,r=s,r.accepts()?(u=0,l=r):u>=0&&u++,c++,a++;if(!(u<0)){a-=u,c-=u;var p=l.emit();o.push(new p(t.substr(a-c,c)))}}return o},yt=V,kt=Object.freeze({State:m,TOKENS:Y,run:vt,start:yt}),wt=l();wt.prototype={type:"token",isLink:!1,toString:function(){for(var t=[],e=0;e<this.v.length;e++)t.push(this.v[e].toString());return t.join("")},toHref:function(){return this.toString()},toObject:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http";return{type:this.type,value:this.toString(),href:this.toHref(t)}}};var jt=n(wt,l(),{type:"email",isLink:!0}),xt=n(wt,l(),{type:"email",isLink:!0,toHref:function(){this.v;return"mailto:"+this.toString()}}),zt=n(wt,l(),{type:"text"}),Ot=n(wt,l(),{type:"nl"}),St=n(wt,l(),{type:"url",isLink:!0,toHref:function(){for(var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",e=!1,n=!1,o=this.v,a=[],r=0;o[r]instanceof T;)e=!0,a.push(o[r].toString().toLowerCase()),r++;for(;o[r]instanceof E;)n=!0,a.push(o[r].toString()),r++;for(;p(o[r]);)a.push(o[r].toString().toLowerCase()),r++;for(;r<o.length;r++)a.push(o[r].toString());return a=a.join(""),e||n||(a=t+"://"+a),a},hasProtocol:function(){return this.v[0]instanceof T}}),Nt=Object.freeze({Base:wt,MAILTOEMAIL:jt,EMAIL:xt,NL:Ot,TEXT:zt,URL:St}),Tt=function(t){return new d(t)},At=Tt(),Lt=Tt(),Et=Tt(),Ct=Tt(),Pt=Tt(),Rt=Tt(),qt=Tt(),Ht=Tt(St),Bt=Tt(),Ut=Tt(St),Mt=Tt(St),Dt=Tt(),It=Tt(),Kt=Tt(),_t=Tt(),Gt=Tt(),Yt=Tt(St),Qt=Tt(St),Wt=Tt(St),Xt=Tt(St),Zt=Tt(),Ft=Tt(),Jt=Tt(),Vt=Tt(),$t=Tt(),te=Tt(),ee=Tt(xt),ne=Tt(),oe=Tt(xt),ae=Tt(jt),re=Tt(),ie=Tt(),se=Tt(),ce=Tt(),le=Tt(Ot);At.on(z,le).on(T,Lt).on(A,Et).on(E,Ct),Lt.on(E,Ct),Ct.on(E,Pt),At.on(R,Rt).on(v,Rt).on(x,Ht).on(O,Rt),Pt.on(R,Mt).on(v,Mt).on(O,Mt).on(x,Mt),Rt.on(w,qt),$t.on(w,te),qt.on(R,Ht).on(v,Rt).on(O,Rt).on(x,Rt),te.on(R,ee).on(v,$t).on(O,$t).on(x,$t),Ht.on(w,qt),ee.on(w,te),Ht.on(k,Bt).on(E,Mt),Bt.on(O,Ut),Ut.on(E,Mt),ee.on(k,ne),ne.on(O,oe);var ue=[v,y,x,O,S,N,T,E,R,C,P,G],pe=[k,w,L,j,D,I,K,_,H,B,U,M];Mt.on(H,It).on(B,Kt).on(U,_t).on(M,Gt),Dt.on(H,It).on(B,Kt).on(U,_t).on(M,Gt),It.on(D,Mt),Kt.on(I,Mt),_t.on(K,Mt),Gt.on(_,Mt),Yt.on(D,Mt),Qt.on(I,Mt),Wt.on(K,Mt),Xt.on(_,Mt),Zt.on(D,Mt),Ft.on(I,Mt),Jt.on(K,Mt),Vt.on(_,Mt),It.on(ue,Yt),Kt.on(ue,Qt),_t.on(ue,Wt),Gt.on(ue,Xt),It.on(pe,Zt),Kt.on(pe,Ft),_t.on(pe,Jt),Gt.on(pe,Vt),Yt.on(ue,Yt),Qt.on(ue,Qt),Wt.on(ue,Wt),Xt.on(ue,Xt),Yt.on(pe,Yt),Qt.on(pe,Qt),Wt.on(pe,Wt),Xt.on(pe,Xt),Zt.on(ue,Yt),Ft.on(ue,Qt),Jt.on(ue,Wt),Vt.on(ue,Xt),Zt.on(pe,Zt),Ft.on(pe,Ft),Jt.on(pe,Jt),Vt.on(pe,Vt),Mt.on(ue,Mt),Dt.on(ue,Mt),Mt.on(pe,Dt),Dt.on(pe,Dt),Et.on(R,ae).on(v,ae).on(O,ae).on(x,ae),ae.on(ue,ae).on(pe,re),re.on(ue,ae).on(pe,re);var he=[v,O,S,N,L,C,P,G,R];Rt.on(he,ie).on(y,se),Ht.on(he,ie).on(y,se),qt.on(he,ie),ie.on(he,ie).on(y,se).on(w,ce),ce.on(he,ie),se.on(R,$t).on(v,$t).on(x,ee);var ge=function(t){for(var e=t.length,n=0,o=[],a=[];n<e;){for(var r=At,i=null,s=null,c=0,l=null,u=-1;n<e&&!(i=r.next(t[n]));)a.push(t[n++]);for(;n<e&&(s=i||r.next(t[n]));)i=null,r=s,r.accepts()?(u=0,l=r):u>=0&&u++,n++,c++;if(u<0)for(var p=n-c;p<n;p++)a.push(t[p]);else{a.length>0&&(o.push(new zt(a)),a=[]),n-=u,c-=u;var h=l.emit();o.push(new h(t.slice(n-c,n)))}}return a.length>0&&o.push(new zt(a)),o},fe=Object.freeze({State:d,TOKENS:Nt,run:ge,start:At});Array.isArray||(Array.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)});var me=function(t){return ge(vt(t))},de=function(t){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=me(t),o=[],a=0;a<n.length;a++){var r=n[a];!r.isLink||e&&r.type!==e||o.push(r.toObject())}return o},be=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=me(t);return 1===n.length&&n[0].isLink&&(!e||n[0].type===e)};e.find=de,e.inherits=n,e.options=g,e.parser=fe,e.scanner=kt,e.test=be,e.tokenize=me}(self.linkify=self.linkify||{})}();]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="mixins" javascript_name="ips.core.files.moderate.js" javascript_type="mixins" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.files.moderate.js - Mixin to update moderator form endpoint when table sorting changes
 *
 * Author: bfarber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.mixin( 'file.moderate', 'core.global.core.table', false, function () {

		/**
		 * After we handle state changes, check the URL and adjust the moderation form
		 *
		 * @returns {void}
		 */
		this.after('_updateSort', function () {
			var current = this._getSortValue();

			var formAction = ips.utils.url.removeParams( [ 'sortby', 'sortdirection', 'listResort' ], this.scope.find('[data-role="moderationTools"]').attr('action') );
			this.scope.find('[data-role="moderationTools"]').attr( 'action', formAction + '&listResort=1&sortby=' + current.by + '&sortdirection=' + current.order );
		});
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="mixins" javascript_name="ips.core.groups.counts.js" javascript_type="mixins" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.groups.counts.js - Mixin to fetch group counts in ACP
 *
 * Author: bfarber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.mixin('group.counts', 'core.global.core.table', true, function () {

		/**
		 * After init, init
		 *
		 * @returns {void}
		 */
		this.after('setup', function () {
			this.getGroupCounts();
			$(document).on( 'tableRowsUpdated', _.bind( this.getGroupCounts, this ) );
		});

		/**
		 * Get the group count
		 *
		 * @returns {void}
		 */
		this.getGroupCounts = function() {
			this.scope.find('[data-ipsGroupCount].ipsLoading').each( function(){
				var element = $(this);
				var groupId = element.attr('data-ipsGroupId');

				ips.getAjax()( '?app=core&module=members&controller=groups&do=getCount&group=' + groupId )
					.done( function (response) {
						element
							.removeClass( 'ipsLoading' )
							.removeClass( 'ipsLoading--tiny' )
							.html( response );

						// Inform the document
						$( document ).trigger( 'contentChange', [ element ] );
					});
			} );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="mixins" javascript_name="ips.core.table.js" javascript_type="mixins" javascript_version="5001403" javascript_position="1000100"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.table.js - ACP mixin for tables 
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.mixin('acpTable', 'core.global.core.table', true, function () {

		this._timer = null;
		this._searchField = null;
		this._curSearchValue = '';
		this._currentValue = '';

		/**
		 * Add acp-specific events
		 *
		 * @returns {void}
		 */
		this.after('initialize', function () {
			this.on( 'focus', '[data-role="tableSearch"]', this.startLiveSearch );
			this.on( 'blur', '[data-role="tableSearch"]', this.endLiveSearch );
			this.on( 'click', '[data-action="tableSort"]', this.changeSorting );
			this.on( 'paginationClicked', this.adminPaginationClicked );
			this.on( 'menuItemSelected', '#elSortMenu', this.sortByMenu );
			this.on( 'menuItemSelected', '#elOrderMenu', this.orderByMenu );
		});

		/**
		 * Set up search
		 *
		 * @returns {void}
		 */
		this.before('setup', function () {			
			this._searchField = this.scope.find('[data-role="tableSearch"]');
			this.scope.find('[data-role="tableSearch"]').removeClass('ipsHide').show();			
		});

		/**
		 * Mixin for _getUrlParams, adding our current search value
		 *
		 * @returns {object}	Extended object including search value
		 */
		this.around('_getUrlParams', function (origFn) {
			return _.extend( origFn(), {
				quicksearch: this._getSearchValue() || ''
			});
		});

		/**
		 * Updates the sorting order classnames
		 *
		 * @param 	{object} 	data 	Sort data
		 * @returns {void}
		 */
		this.after('_updateSort', function (data) {
			var directions = 'ipsTable_sortableAsc ipsTable_sortableDesc';
			
			// Do the cell headers
			this.scope
				.find('[data-role="table"] [data-action="tableSort"]')
					.removeClass('ipsTable_sortableActive')
					.removeAttr('aria-sort')
				.end()
				.find('[data-action="tableSort"][data-key="' + data.by + '"]')
					.addClass('ipsTable_sortableActive')
					.removeClass( directions )
					.addClass( 'ipsTable_sortable' + data.order.charAt(0).toUpperCase() + data.order.slice(1) )
					.attr( 'aria-sort', ( data.order == 'asc' ) ? 'ascending' : 'descending' );

			// Do the menus
			$('#elSortMenu_menu, #elOrderMenu_menu')
				.find('[aria-selected="true"]')
					.removeAttr('aria-selected')
				.end()
				.find('[data-ipsMenuValue="' + data.by + '"], [data-ipsMenuValue="' + data.order + '"]')
					.attr('aria-selected', 'true');
		});	

		/**
		 * Mixin for _handleStateChange, checking for an updated search value
		 *
		 * @returns {object}	Extended object including search value
		 */
		this.after('_handleStateChanges', function (state) {
			if( !_.isUndefined( state.data.quicksearch ) && state.data.quicksearch != this._urlParams.quicksearch ){
				this._updateSearch( state.data.quicksearch );
			}
		});

		/**
		 * Scroll to pagination when clicked
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		this.adminPaginationClicked = function () {
			var wrappingDialog = this.scope.closest('.ipsDialog');

			// Get top postition of table
			var elemPosition = ips.utils.position.getElemPosition( wrappingDialog.length ? wrappingDialog : this.scope );
			$('html, body').animate( { scrollTop: ( elemPosition.absPos.top - 60 ) + 'px' } );
		};

		/**
		 * Handles events from the sort menu (shown only on mobile)
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		this.sortByMenu = function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			this.updateURL( {
				sortby: data.selectedItemID
			});
		};

		/**
		 * Handles events from the order menu (shown only on mobile)
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		this.orderByMenu = function (e, data = e.detail) {
			data.originalEvent.preventDefault();

			this.updateURL( {
				sortdirection: data.selectedItemID
			});
		};

		/**
		 * Event handler for choosing new sort column/order
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		this.changeSorting = function (e) {
			e.preventDefault();
			var cell = $( e.currentTarget );
			var order = '';

			// Apply asc or desc classnames to the cell, depending on its current state
			if( cell.hasClass('ipsTable_sortableActive') ){
				order = ( cell.hasClass('ipsTable_sortableDesc') ) ? 'asc' : 'desc';
			} else {
				order = ( cell.hasClass('ipsTable_sortableDesc') ) ? 'desc' : 'asc';
			}

			this.updateURL( {
				sortby: cell.attr('data-key'),
				sortdirection: order
			});
		};

		/**
		 * Focus event handler for live search box
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		this.startLiveSearch = function (e) {
			this._timer = setInterval( _.bind( this._checkSearchValue, this ), 500 );
		};

		/**
		 * Blur event handler for live search box
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		this.endLiveSearch = function (e) {
			clearInterval( this._timer );
		};

		/**
		 * Determines whether the search field value has changed from the last loop run,
		 * and updates the URL if it has
		 *
		 * @returns {void}
		 */
		this._checkSearchValue = function () {
			var val = this._searchField.val();

			if( this._currentValue != val ){
				this.updateURL({
					quicksearch: val,
					page: 1
				});

				this._currentValue = val;
			}
		};
		
		/**
		 * Updates the search field with a provided value
		 *
		 * @param	{string} 	searchValue 		Value to update
		 * @returns {void}
		 */
		this._updateSearch = function (searchValue) {
			this._searchField.val( searchValue );
		};

		/**
		 * Updates element classnames for filtering
		 *
		 * @param	{string} 	newFilter 		Filter ID of new filter to select
		 * @returns {void}
		 */
		this._updateFilter = function (newFilter) {
			this.scope
				.find('[data-role="tableSortBar"] [data-action="tableFilter"] a')
					.removeClass('ipsDataFilters__button--active')
				.end()
				.find('[data-action="tableFilter"][data-filter="' + newFilter + '"] a')
					.addClass('ipsDataFilters__button--active');
		};

		/**
		 * Returns the current sort by and sort order value
		 *
		 * @returns {object}	Object containing by and order keys
		 */
		this._getSortValue = function () {
			var sortBy = this.scope.find('[data-role="table"] thead .ipsTable_sortable.ipsTable_sortableActive');			
			var sortOrder = 'desc';
			if( sortBy.hasClass('ipsTable_sortableAsc') ){
				sortOrder = 'asc';
			}

			return { by: sortBy.attr('data-key'), order: sortOrder };
		};

		/**
		 * Returns the current filter value
		 *
		 * @returns {string}
		 */
		this._getFilterValue = function () {
			var sortBar = this.scope.find('[data-role="tableSortBar"]');

			if( !sortBar.length ){
				return '';
			}

			return sortBar.find('.ipsDataFilters__button--active').closest('[data-filter]').attr('data-filter');
		};

		/**
		 * Gets the current search value, either from the URL or contents of the search box
		 *
		 * @returns {string}
		 */
		this._getSearchValue = function () {
			if( ips.utils.url.getParam('quicksearch') ){
				return ips.utils.url.getParam('quicksearch');
			}

			return this.scope.find('[data-role="tableSearch"]').val();
		};
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="mixins" javascript_name="ips.core.table.js" javascript_type="mixins" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.table.js - Front-end mixin for tables 
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.mixin('contentListing', 'core.global.core.table', true, function () {

		this._rowSelector = 'li';

		/**
		 * Adds front-end table events
		 *
		 * @returns {void}
		 */
		this.after('initialize', function () {
			this.on( 'menuItemSelected', '[data-role="sortButton"]', this.changeSorting );
			this.on( 'change', '[data-role="moderation"]', this.selectRow );
			this.on( 'paginationClicked', this.frontPaginationClicked );
			this.on( 'markTableRead', this.markAllRead );

			$( document ).on( 'markTableRowRead', _.bind( this.markRowRead, this ) );
			$( document ).on( 'markAllRead', _.bind( this.markAllRead, this ) );
			$( document ).on( 'updateTableURL', _.bind( this.updateTableURL, this ) );
			$( document ).on( 'moderationSubmitted', _.bind( this.clearLocalStorage, this ) );
		});

		this.after('setup', function () {
			this._tableID = this.scope.attr('data-tableID');
			this._storeID = 'table-' + this._stateKey;

			if( this.scope.attr('data-dummyLoadingSelector') ){
				this._rowSelector = this.scope.attr('data-dummyLoadingSelector');
			}

			this._findCheckedRows();

			// after running this the first time, we may need to run it again if the page action bar is initialized afterwards
			this.on('pageActionReady', this._findCheckedRows);
		});

		/**
		 * Handle state changes (called after we've already verified this controller *should* handle this state change)
		 *
		 * @param 	{object} 	state  History state object
		 * @returns {void}
		 */
		this.before('_handleStateChanges', function (state) {
			ips.utils.analytics.trackPageView( state.url );
		});

		/**
		 * Show the table as loading before the ajax
		 *
		 * @returns {void}
		 */
		this.before('_getResults', function () {
			this._setTableLoading( true );
		});

		/**
		 * Switch off table loading after results are fetched
		 *
		 * @returns {void}
		 */
		this.after('_getResultsAlways', function () {
			this._setTableLoading( false );
		});

		/**
		 * After the table is updated, check for any pageAction widgets and refresh them
		 *
		 * @returns {void}
		 */
		this.after('_updateTable', function () {
			this.scope.find('[data-ipsPageAction]').trigger('refresh.pageAction');
			this.scope.find('[data-role="tableRows"]')
				.css({ opacity: "0.0001" })
				.animate({
					opacity: "1"
				});

			this._findCheckedRows();
		});

		/**
		 * Checks localStorage and checks any rows that we've previously selected in this topic
		 *
		 * @returns {void}
		 */
		this._findCheckedRows = function () {
			if( !this.scope.find('input[type="checkbox"]').length ){
				return;
			}

			// Fetch the checked comments for this feedID
			var dataStore = ips.utils.db.get( 'moderation', this._storeID ) || {};
			var self = this;
			var pageAction = this.scope.find('[data-ipsPageAction]');

			if( _.size( dataStore ) ){
				var sizeOtherPage = 0;

				_.each( dataStore, function (val, key) {
					if( self.scope.find('[data-rowid="' + key + '"]').length ){
						self.scope
							.find('[data-rowid="' + key + '"]')
								.addClass( 'ipsData__item--selected' )
								.find('input[type="checkbox"][data-role="moderation"]')
									.attr( 'checked', true )
									.trigger('change');
					} else {
						sizeOtherPage++;

						pageAction.trigger('addManualItem.pageAction', {
							id: 'moderate[' + key + ']',
							actions: val
						});
					}
				});

				if( this.scope.find('[data-ipsAutoCheck]') )
				{
					this.scope.find('[data-ipsAutoCheck]').trigger( 'setInitialCount.autoCheck', { count: sizeOtherPage } );
				}
			}
		};

		/**
         * Clear local storage after form is submitted
         *
         * @returns {void}
         */
        this.clearLocalStorage = function () {
            ips.utils.db.remove( 'moderation', this._storeID );
        };

		/**
		 * Prevent the default loading throbber from being shown here
		 *
		 * @returns {void}
		 */
		this._showLoading = function () {
			return _.isUndefined( this.scope.attr('data-dummyLoading') );
		};

		/**
		 * Marks everything in this table as read
		 *
		 * @returns {void}
		 */
		this.markAllRead = function () {
			this.scope
				.find('.ipsSubList__item--unread')
					.removeClass('ipsSubList__item--unread')
					.addClass('ipsSubList__item--read');

				this.scope
					.find('[data-ips-unread]')
						.removeAttr('data-ips-unread')
						.attr('data-ips-read', '');

				this.scope
					.find('[data-ips-badge-new]')
					.remove();

			this.elem.querySelectorAll('.ipsIndicator').forEach(unreadIcon => unreadIcon.remove())
		};

		/**
		 * Marks a row in this table read
		 *
		 * @returns {void}
		 */
		this.markRowRead = function (e, data) {

			// Make sure we're working on the right table
			if( _.isUndefined( data.tableID ) || data.tableID != this._tableID ){
				return;
			}

			// Update row
			this.scope
				.find('[data-rowID="' + data.rowID + '"]')
					.removeAttr('data-ips-unread')
					.attr('data-ips-read', '');
		};
		
		/**
		 * Update the table URL from an external source
		 *
		 * @returns {void}
		 */
		this.updateTableURL = function (e, data) {
			this.updateURL( data );
		};

		/**
		 * Scroll to pagination when clicked
		 *
		 * @returns {void}
		 */
		this.frontPaginationClicked = function () {
			var wrappingDialog = this.scope.closest('.ipsDialog');

			// Get top postition of table
			var elemPosition = ips.utils.position.getElemPosition( wrappingDialog.length ? wrappingDialog : this.scope );
			$('html, body').animate( { scrollTop: elemPosition.absPos.top + 'px' } );
		};

		/**
		 * Toggles classes when the moderation checkbox is checked
		 *
		 * @param	{event} 	e 		Event object
		 * @returns {void}
		 */
		this.selectRow = function (e) {
			var row = $( e.currentTarget ).closest('.ipsData__item');
			var rowID = row.attr('data-rowID');
			var dataStore = ips.utils.db.get( 'moderation', this._storeID ) || {};
			var rowActions = row.find('[data-role="moderation"]').attr('data-actions');

			// Toggle the row styling
			row.toggleClass( 'ipsData__item--selected', $( e.currentTarget ).is(':checked') );

			// Add it to our dataStore object which will go into localstorage
			if (rowID) {
				if ($(e.currentTarget).is(':checked')) {
					if (_.isUndefined(dataStore[rowID])) {
						dataStore[rowID] = rowActions;
					}
				} else {
					delete dataStore[rowID];
				}

				// Store the updated value for a day, or delete if it's empty now
				if( _.size( dataStore ) ){
					ips.utils.db.set( 'moderation', this._storeID, dataStore, undefined, Date.now() / 1000 + 86400 );
				} else {
					ips.utils.db.remove( 'moderation', this._storeID );
				}
			}
		};

		/**
		 * Update the content and pagination elements
		 *
		 * @param	{object} 	response 		JSON object containing new HTML pieces
		 * @returns {void}
		 */
		this._setTableLoading = function (loading) {
			var rowElem = this.scope.find('[data-role="tableRows"]');
			var rows = rowElem.find('> ' + this._rowSelector);
			
			if( _.isUndefined( this.scope.attr('data-dummyLoading') ) ){
				this._basicLoading( loading );
				return;
			}

			if( !loading || !rowElem.length || !rows.length ){
				return;
			}

			var template = 'table.row.loading';

			if( this.scope.attr('data-dummyLoadingTemplate') ){
				template = this.scope.attr('data-dummyLoadingTemplate');
			}

			var newRows = [];

			// Build an array of rendered rows that we'll insert in one go
			for( var i = 0; i <= rows.length; i++ ){
				var rnd = parseInt( Math.random() * (10 - 1) + 1 );
				newRows.push( ips.templates.render( template, { extraClass: this.scope.attr('data-dummyLoadingClass') || '', rnd: rnd } ) );
			}

			this.scope.find('[data-role="tableRows"]').html( newRows.join('') );
		};

		/**
		 * Show a loading spinner over the top of the existing rows
		 *
		 * @param	{object} 	response 		JSON object containing new HTML pieces
		 * @returns {void}
		 */
		this._basicLoading = function ( loading ) {
			var rowElem = this.scope.find('[data-role="tableRows"]');

			// Make sure we actually have a tableRows element
			if( !rowElem.length )
			{
				return;
			}

			if( !this._tableOverlay ){
				this._tableOverlay = $('<div/>').addClass('ipsLoading').hide();
				ips.getContainer().append( this._tableOverlay );
			}

			if( loading ){
				// Get dims & position			
				var dims = ips.utils.position.getElemDims( rowElem );
				var position = ips.utils.position.getElemPosition( rowElem );

				this._tableOverlay.show().css({
					left: position.viewportOffset.left + 'px',
					top: position.viewportOffset.top + $( document ).scrollTop() + 'px',
					width: dims.width + 'px',
					height: dims.height + 'px',
					position: 'absolute',
					zIndex: ips.ui.zIndex()
				});

				rowElem.css({
					opacity: "0.5"
				});
			} else {
				rowElem.animate({
					opacity: "1"
				});

				this._tableOverlay.hide();
			}
		};

		/**
		 * Change the sorting
		 *
		 * @param	{event} 	e 		Event object
		 * @param	{object} 	data	Event data object
		 * @returns {void}
		 */
		this.changeSorting = function (e, data = e.detail) {
			data.originalEvent.preventDefault();
			
			// Don't sort if there's no sort value on this item
			if( _.isUndefined( data.selectedItemID ) ){
				return;
			}

			var current = this._getSortValue();
			var menuItem = $(data.menuElem).find('[data-ipsMenuValue="' + data.selectedItemID + '"]');
			var sortBy = data.selectedItemID;
			var sortDirection = current.order;

			// Does this option also have a direction?
			if( menuItem.attr('data-sortDirection') ){
				sortDirection = menuItem.attr('data-sortDirection');
			}

			this.updateURL( {
				sortby: sortBy,
				sortdirection: sortDirection,
				page: 1
			});
		};

		/**
		 * Returns the current sort by and sort order value
		 *
		 * @returns {object}	Object containing by and order keys
		 */
		this._getSortValue = function () {
			var by = ips.utils.url.getParam('sortby');
			var order = ips.utils.url.getParam('sortdirection');

			return { by: by || '', order: order || '' };
		};

		/**
		 * Returns the current sort by and sort order value
		 *
		 * @returns {object}	Object containing by and order keys
		 */
		this._getFilterValue = function () {
			var filter = ips.utils.url.getParam('filter');
			return filter || '';
		};
	
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="front" javascript_path="models/core" javascript_name="ips.core.comment.js" javascript_type="model" javascript_version="5001403" javascript_position="1000100">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.core.comment.js - Comment model
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.model.register('core.comment', {

		initialize: function () {
			this.on( 'getEditForm.comment', this.getEditForm );
			this.on( 'saveEditComment.comment', this.saveEditComment );
			this.on( 'deleteComment.comment', this.deleteComment );
			this.on( 'newComment.comment', this.newComment );
			this.on( 'approveComment.comment', this.approveComment );
			this.on( 'unrecommendComment.comment', this.unrecommendComment );
		},
				
		/**
		 * Retrieves edit form
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		getEditForm: function (e, data) {
			this.getData( {
				url: data.url,
				dataType: 'html',
				data: {},
				events: 'getEditForm',
				namespace: 'comment'
			}, data);
		},

		/**
		 * Saves edit back to server
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		saveEditComment: function (e, data) {
			var url = data.url;
			
			this.getData( {
				url: data.url,
				dataType: 'html',
				type: 'post',
				data: data.form || {},
				events: 'saveEditComment',
				namespace: 'comment'
			}, data);
		},

		/**
		 * Approves comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		approveComment: function (e, data) {
			this.getData( {
				url: data.url,
				dataType: 'html',
				data: data.form || {},
				events: 'approveComment',
				namespace: 'comment'
			}, data);
		},

		/**
		 * Unrecommend this comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		unrecommendComment: function (e, data) {
			this.getData( {
				url: data.url,
				dataType: 'json',
				data: data.form || {},
				events: 'unrecommendComment',
				namespace: 'comment'
			}, data);
		},

		/**
		 * Deletes comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		deleteComment: function (e, data) {
			this.getData( {
				url: data.url,
				dataType: 'html',
				data: data.form || {},
				events: 'deleteComment',
				namespace: 'comment'
			}, data);
		},

		/**
		 * Adds a new comment
		 *	
		 * @param 		{event} 	e 		Event object
		 * @param 		{object}	data 	Event data object
		 * @returns 	{void}
		 */
		newComment: function (e, data) {
			this.getData( {
				url: data.url,
				dataType: 'json',
				data: data.form || {},
				events: 'newComment',
				namespace: 'comment'
			}, data);
		}
	});
}(jQuery, _));</file>
 <file javascript_app="core" javascript_location="front" javascript_path="models/messages" javascript_name="ips.messages.folder.js" javascript_type="model" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.folder.js - Message folders model
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.model.register('messages.folder', {

		initialize: function () {
			this.on( 'loadFolder.messages', this.loadFolder );
			this.on( 'addFolder.messages', this.addFolder );
			this.on( 'renameFolder.messages', this.renameFolder );
			this.on( 'markFolder.messages', this.markFolder );
			this.on( 'emptyFolder.messages', this.emptyFolder );
			this.on( 'searchFolder.messages', this.searchFolder );
			/*this.on( 'markFolderRead.messages', this.markFolderRead );
			this.on( 'emptyFolder.messages', this.emptyFolder );*/
			this.on( 'deleteFolder.messages', this.deleteFolder );
			this.on( 'deleteMessages.messages', this.deleteMessages );
		},

		searchFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger',
				dataType: 'json',
				data: data,
				events: 'searchFolder',
				namespace: 'messages'
			}, data);
		},

		loadFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger',
				dataType: 'json',
				data: {
					folder: data.folder,
					sortBy: data.sortBy,
					filter: data.filter,
					overview: 1
				},
				events: 'loadFolder',
				namespace: 'messages'
			}, data);
		},

		addFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=addFolder',
				dataType: 'json',
				data: {
					messenger_add_folder_name: data.name,
					form_submitted: 1
				},
				type: 'post',
				events: 'addFolder',
				namespace: 'messages'
			}, data);
		},

		renameFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=renameFolder',
				dataType: 'json',
				data: {
					folder: data.folder,
					messenger_add_folder_name: data.name,
					form_submitted: 1
				},
				events: 'renameFolder',
				namespace: 'messages'
			}, data);
		},

		markFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=readFolder',
				dataType: 'html',
				data: {
					folder: data.folder,
					form_submitted: 1
				},
				events: 'markFolder',
				namespace: 'messages'
			}, data);
		},

		emptyFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=emptyFolder',
				dataType: 'json',
				data: {
					folder: data.folder,
					form_submitted: 1
				},
				events: 'emptyFolder',
				namespace: 'messages'
			}, data);
		},

		deleteFolder: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=deleteFolder',
				dataType: 'json',
				data: {
					folder: data.folder,
					form_submitted: 1,
					wasConfirmed: 1
				},
				events: 'deleteFolder',
				namespace: 'messages'
			}, data);
		},

		deleteMessages: function (e, data) {
			this.getData({
				url: 'app=core&module=messaging&controller=messenger&do=leaveConversation',
				dataType: 'json',
				data: {
					id: data.id
				},
				events: 'deleteMessages',
				namespace: 'messages'
			}, data);
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="models/messages" javascript_name="ips.messages.message.js" javascript_type="model" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.messages.message.js - Messages model for messenger
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.model.register('messages.message', {

		initialize: function () {
			this.on( 'fetchMessage.messages', this.fetchMessage );
			this.on( 'deleteMessage.messages', this.deleteMessage );
			this.on( 'moveMessage.messages', this.moveMessage );
			this.on( 'blockUser.messages', this.blockUser );
			this.on( 'addUser.messages', this.addUser );
		},

		fetchMessage: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger',
				dataType: 'html',
				data: {
					id: data.id,
					page: data.page || 1
				},
				events: 'loadMessage',
				namespace: 'messages'
			}, data );
		},

		deleteMessage: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=leaveConversation',
				dataType: 'json',
				data: {
					id: data.id
				},
				events: 'deleteMessage',
				namespace: 'messages'
			}, data );
		},

		moveMessage: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=move',
				dataType: 'json',
				data: {
					id: data.id,
					to: data.folder
				},
				events: 'moveMessage',
				namespace: 'messages'
			}, data );
		},

		blockUser: function (e, data) {
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=blockParticipant',
				dataType: 'html',
				data: {
					id: data.id,
					member: data.member
				},
				events: 'blockUser',
				namespace: 'messages'
			}, data );
		},

		addUser: function (e, data) {
			var sendData = {
				id: data.id
			};

			if( data.names ){
				_.extend( sendData, {
					member_names: data.names
				});
			}

			if( data.member ){
				_.extend( sendData, {
					member: data.member
				});
			}
			
			if( data.unblock ){
				_.extend( sendData, {
					unblock: true
				});
			}
			
			this.getData( {
				url: 'app=core&module=messaging&controller=messenger&do=addParticipant',
				dataType: 'json',
				data: sendData,
				events: 'addUser',
				namespace: 'messages'
			}, data );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="mustache" javascript_name="mustache.js" javascript_type="framework" javascript_version="5001403" javascript_position="150"><![CDATA[/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/
(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=global||self,global.Mustache=factory())})(this,function(){"use strict";var objectToString=Object.prototype.toString;var isArray=Array.isArray||function isArrayPolyfill(object){return objectToString.call(object)==="[object Array]"};function isFunction(object){return typeof object==="function"}function typeStr(obj){return isArray(obj)?"array":typeof obj}function escapeRegExp(string){return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}function hasProperty(obj,propName){return obj!=null&&typeof obj==="object"&&propName in obj}function primitiveHasOwnProperty(primitive,propName){return primitive!=null&&typeof primitive!=="object"&&primitive.hasOwnProperty&&primitive.hasOwnProperty(propName)}var regExpTest=RegExp.prototype.test;function testRegExp(re,string){return regExpTest.call(re,string)}var nonSpaceRe=/\S/;function isWhitespace(string){return!testRegExp(nonSpaceRe,string)}var entityMap={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};function escapeHtml(string){return String(string).replace(/[&<>"'`=\/]/g,function fromEntityMap(s){return entityMap[s]})}var whiteRe=/\s*/;var spaceRe=/\s+/;var equalsRe=/\s*=/;var curlyRe=/\s*\}/;var tagRe=/#|\^|\/|>|\{|&|=|!/;function parseTemplate(template,tags){if(!template)return[];var lineHasNonSpace=false;var sections=[];var tokens=[];var spaces=[];var hasTag=false;var nonSpace=false;var indentation="";var tagIndex=0;function stripSpace(){if(hasTag&&!nonSpace){while(spaces.length)delete tokens[spaces.pop()]}else{spaces=[]}hasTag=false;nonSpace=false}var openingTagRe,closingTagRe,closingCurlyRe;function compileTags(tagsToCompile){if(typeof tagsToCompile==="string")tagsToCompile=tagsToCompile.split(spaceRe,2);if(!isArray(tagsToCompile)||tagsToCompile.length!==2)throw new Error("Invalid tags: "+tagsToCompile);openingTagRe=new RegExp(escapeRegExp(tagsToCompile[0])+"\\s*");closingTagRe=new RegExp("\\s*"+escapeRegExp(tagsToCompile[1]));closingCurlyRe=new RegExp("\\s*"+escapeRegExp("}"+tagsToCompile[1]))}compileTags(tags||mustache.tags);var scanner=new Scanner(template);var start,type,value,chr,token,openSection;while(!scanner.eos()){start=scanner.pos;value=scanner.scanUntil(openingTagRe);if(value){for(var i=0,valueLength=value.length;i<valueLength;++i){chr=value.charAt(i);if(isWhitespace(chr)){spaces.push(tokens.length);indentation+=chr}else{nonSpace=true;lineHasNonSpace=true;indentation+=" "}tokens.push(["text",chr,start,start+1]);start+=1;if(chr==="\n"){stripSpace();indentation="";tagIndex=0;lineHasNonSpace=false}}}if(!scanner.scan(openingTagRe))break;hasTag=true;type=scanner.scan(tagRe)||"name";scanner.scan(whiteRe);if(type==="="){value=scanner.scanUntil(equalsRe);scanner.scan(equalsRe);scanner.scanUntil(closingTagRe)}else if(type==="{"){value=scanner.scanUntil(closingCurlyRe);scanner.scan(curlyRe);scanner.scanUntil(closingTagRe);type="&"}else{value=scanner.scanUntil(closingTagRe)}if(!scanner.scan(closingTagRe))throw new Error("Unclosed tag at "+scanner.pos);if(type==">"){token=[type,value,start,scanner.pos,indentation,tagIndex,lineHasNonSpace]}else{token=[type,value,start,scanner.pos]}tagIndex++;tokens.push(token);if(type==="#"||type==="^"){sections.push(token)}else if(type==="/"){openSection=sections.pop();if(!openSection)throw new Error('Unopened section "'+value+'" at '+start);if(openSection[1]!==value)throw new Error('Unclosed section "'+openSection[1]+'" at '+start)}else if(type==="name"||type==="{"||type==="&"){nonSpace=true}else if(type==="="){compileTags(value)}}stripSpace();openSection=sections.pop();if(openSection)throw new Error('Unclosed section "'+openSection[1]+'" at '+scanner.pos);return nestTokens(squashTokens(tokens))}function squashTokens(tokens){var squashedTokens=[];var token,lastToken;for(var i=0,numTokens=tokens.length;i<numTokens;++i){token=tokens[i];if(token){if(token[0]==="text"&&lastToken&&lastToken[0]==="text"){lastToken[1]+=token[1];lastToken[3]=token[3]}else{squashedTokens.push(token);lastToken=token}}}return squashedTokens}function nestTokens(tokens){var nestedTokens=[];var collector=nestedTokens;var sections=[];var token,section;for(var i=0,numTokens=tokens.length;i<numTokens;++i){token=tokens[i];switch(token[0]){case"#":case"^":collector.push(token);sections.push(token);collector=token[4]=[];break;case"/":section=sections.pop();section[5]=token[2];collector=sections.length>0?sections[sections.length-1][4]:nestedTokens;break;default:collector.push(token)}}return nestedTokens}function Scanner(string){this.string=string;this.tail=string;this.pos=0}Scanner.prototype.eos=function eos(){return this.tail===""};Scanner.prototype.scan=function scan(re){var match=this.tail.match(re);if(!match||match.index!==0)return"";var string=match[0];this.tail=this.tail.substring(string.length);this.pos+=string.length;return string};Scanner.prototype.scanUntil=function scanUntil(re){var index=this.tail.search(re),match;switch(index){case-1:match=this.tail;this.tail="";break;case 0:match="";break;default:match=this.tail.substring(0,index);this.tail=this.tail.substring(index)}this.pos+=match.length;return match};function Context(view,parentContext){this.view=view;this.cache={".":this.view};this.parent=parentContext}Context.prototype.push=function push(view){return new Context(view,this)};Context.prototype.lookup=function lookup(name){var cache=this.cache;var value;if(cache.hasOwnProperty(name)){value=cache[name]}else{var context=this,intermediateValue,names,index,lookupHit=false;while(context){if(name.indexOf(".")>0){intermediateValue=context.view;names=name.split(".");index=0;while(intermediateValue!=null&&index<names.length){if(index===names.length-1)lookupHit=hasProperty(intermediateValue,names[index])||primitiveHasOwnProperty(intermediateValue,names[index]);intermediateValue=intermediateValue[names[index++]]}}else{intermediateValue=context.view[name];lookupHit=hasProperty(context.view,name)}if(lookupHit){value=intermediateValue;break}context=context.parent}cache[name]=value}if(isFunction(value))value=value.call(this.view);return value};function Writer(){this.templateCache={_cache:{},set:function set(key,value){this._cache[key]=value},get:function get(key){return this._cache[key]},clear:function clear(){this._cache={}}}}Writer.prototype.clearCache=function clearCache(){if(typeof this.templateCache!=="undefined"){this.templateCache.clear()}};Writer.prototype.parse=function parse(template,tags){var cache=this.templateCache;var cacheKey=template+":"+(tags||mustache.tags).join(":");var isCacheEnabled=typeof cache!=="undefined";var tokens=isCacheEnabled?cache.get(cacheKey):undefined;if(tokens==undefined){tokens=parseTemplate(template,tags);isCacheEnabled&&cache.set(cacheKey,tokens)}return tokens};Writer.prototype.render=function render(template,view,partials,config){var tags=this.getConfigTags(config);var tokens=this.parse(template,tags);var context=view instanceof Context?view:new Context(view,undefined);return this.renderTokens(tokens,context,partials,template,config)};Writer.prototype.renderTokens=function renderTokens(tokens,context,partials,originalTemplate,config){var buffer="";var token,symbol,value;for(var i=0,numTokens=tokens.length;i<numTokens;++i){value=undefined;token=tokens[i];symbol=token[0];if(symbol==="#")value=this.renderSection(token,context,partials,originalTemplate,config);else if(symbol==="^")value=this.renderInverted(token,context,partials,originalTemplate,config);else if(symbol===">")value=this.renderPartial(token,context,partials,config);else if(symbol==="&")value=this.unescapedValue(token,context);else if(symbol==="name")value=this.escapedValue(token,context,config);else if(symbol==="text")value=this.rawValue(token);if(value!==undefined)buffer+=value}return buffer};Writer.prototype.renderSection=function renderSection(token,context,partials,originalTemplate,config){var self=this;var buffer="";var value=context.lookup(token[1]);function subRender(template){return self.render(template,context,partials,config)}if(!value)return;if(isArray(value)){for(var j=0,valueLength=value.length;j<valueLength;++j){buffer+=this.renderTokens(token[4],context.push(value[j]),partials,originalTemplate,config)}}else if(typeof value==="object"||typeof value==="string"||typeof value==="number"){buffer+=this.renderTokens(token[4],context.push(value),partials,originalTemplate,config)}else if(isFunction(value)){if(typeof originalTemplate!=="string")throw new Error("Cannot use higher-order sections without the original template");value=value.call(context.view,originalTemplate.slice(token[3],token[5]),subRender);if(value!=null)buffer+=value}else{buffer+=this.renderTokens(token[4],context,partials,originalTemplate,config)}return buffer};Writer.prototype.renderInverted=function renderInverted(token,context,partials,originalTemplate,config){var value=context.lookup(token[1]);if(!value||isArray(value)&&value.length===0)return this.renderTokens(token[4],context,partials,originalTemplate,config)};Writer.prototype.indentPartial=function indentPartial(partial,indentation,lineHasNonSpace){var filteredIndentation=indentation.replace(/[^ \t]/g,"");var partialByNl=partial.split("\n");for(var i=0;i<partialByNl.length;i++){if(partialByNl[i].length&&(i>0||!lineHasNonSpace)){partialByNl[i]=filteredIndentation+partialByNl[i]}}return partialByNl.join("\n")};Writer.prototype.renderPartial=function renderPartial(token,context,partials,config){if(!partials)return;var tags=this.getConfigTags(config);var value=isFunction(partials)?partials(token[1]):partials[token[1]];if(value!=null){var lineHasNonSpace=token[6];var tagIndex=token[5];var indentation=token[4];var indentedValue=value;if(tagIndex==0&&indentation){indentedValue=this.indentPartial(value,indentation,lineHasNonSpace)}var tokens=this.parse(indentedValue,tags);return this.renderTokens(tokens,context,partials,indentedValue,config)}};Writer.prototype.unescapedValue=function unescapedValue(token,context){var value=context.lookup(token[1]);if(value!=null)return value};Writer.prototype.escapedValue=function escapedValue(token,context,config){var escape=this.getConfigEscape(config)||mustache.escape;var value=context.lookup(token[1]);if(value!=null)return typeof value==="number"&&escape===mustache.escape?String(value):escape(value)};Writer.prototype.rawValue=function rawValue(token){return token[1]};Writer.prototype.getConfigTags=function getConfigTags(config){if(isArray(config)){return config}else if(config&&typeof config==="object"){return config.tags}else{return undefined}};Writer.prototype.getConfigEscape=function getConfigEscape(config){if(config&&typeof config==="object"&&!isArray(config)){return config.escape}else{return undefined}};var mustache={name:"mustache.js",version:"4.2.0",tags:["{{","}}"],clearCache:undefined,escape:undefined,parse:undefined,render:undefined,Scanner:undefined,Context:undefined,Writer:undefined,set templateCache(cache){defaultWriter.templateCache=cache},get templateCache(){return defaultWriter.templateCache}};var defaultWriter=new Writer;mustache.clearCache=function clearCache(){return defaultWriter.clearCache()};mustache.parse=function parse(template,tags){return defaultWriter.parse(template,tags)};mustache.render=function render(template,view,partials,config){if(typeof template!=="string"){throw new TypeError('Invalid template! Template should be a "string" '+'but "'+typeStr(template)+'" was given as the first '+"argument for mustache#render(template, view, partials)")}return defaultWriter.render(template,view,partials,config)};mustache.escape=escapeHtml;mustache.Scanner=Scanner;mustache.Context=Context;mustache.Writer=Writer;return mustache});]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="templates" javascript_name="ips.core.templates.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000150"><![CDATA[/* MENUS */
ips.templates.set('core.appMenu.reorder', " \
	<span data-role='reorder' style='display: none'><i class='fa-solid fa-bars'></i></span>\
");

/* CONTROL STRIP TEMPLATES */
ips.templates.set('core.controlStrip.menuItem', " \
	<li class='ipsMenu_item ipsControlStrip_menuItem' role='menuitem' id='{{id}}'>\
		{{{item}}}\
	</li>\
");

/* TREES */
ips.templates.set('core.trees.childWrapper', " \
	{{{content}}}\
");

ips.templates.set('core.trees.loadingRow', " \
	<ol class='ipsTree'><li class='ipsTree_loadingRow ipsLoading ipsLoading--tiny'>{{#lang}}loading{{/lang}}</li></ol>\
");

ips.templates.set('core.trees.loadingPane', " \
	<div class='ipsLoading' style='height: 150px'>&nbsp;</div>\
");

ips.templates.set('core.trees.noRows', " \
	<div class='i-text-align_center i-padding_3 i-color_soft'>{{#lang}}no_results{{/lang}}</div>\
");

/* LIVE SEARCH */
ips.templates.set('core.livesearch.noResults', " \
	<li class='i-text-align_center i-padding_3 i-color_soft' data-role='result'>\
		<br><br>\
	</li>\
");

/* LANGUAGES */
ips.templates.set('languages.translateString', " \
	<div class='cTranslateTable_field'>\
		<textarea class='ipsInput'>{{value}}</textarea>\
		<button type='button' href='#' data-action='saveWords' tabindex='-1' class='ipsButton ipsButton--positive ipsButton--tiny ipsButton--icon'><i class='fa-solid fa-check'></i> {{#lang}}languageSave{{/lang}}</button>\
	</div>\
");

/* Guide search result */
ips.templates.set('support.guideSearch', " \
	<li>\
		<a href=\"{{link}}\" target='_blank' rel='noopener'>{{title}}</a>\
	</li>\
");
ips.templates.set('support.guideSearch.noResults', " \
	<li class='i-color_soft'>\
		{{#lang}}no_results{{/lang}}\
	</li>\
");

ips.templates.set('support.ticket.supportSummary', " \
	<div class='i-padding-top_3'>\
		{{#lang}}health_ticket_beforeproceeding{{/lang}}\
	</div>\
");]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="templates" javascript_name="ips.templates.customization.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[ips.templates.set( 'templates.customizationMedia.grid', "\
	<ul class='cMedia_manager__items'>\
		{{{contents}}}\
	</ul>\
");

ips.templates.set( 'templates.customizationMedia.noItems', "\
	<div class='i-text-align_center i-font-size_2 i-color_soft i-padding_4'>\
		{{#lang}}mediaEmptyFolder{{/lang}}\
	</div>\
");

ips.templates.set( 'templates.customizationMedia.noSearchResults', "\
	<div class='i-text-align_center i-font-size_2 i-color_soft i-padding_4'>\
		{{#lang}}mediaNoResults{{/lang}}\
	</div>\
");]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="templates" javascript_name="ips.templates.dashboard.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[/* DASHBOARD TEMPLATES */
ips.templates.set('dashboard.widget', `
	<li id='elWidget_{{key}}' data-widgetKey='{{key}}' data-widgetName='{{name}}' data-widgetBy='{{by}}' style='display: none'>
		<div class='ipsBox acpWidget_item' data-ips-template='dashboard'>
			<h2 class='ipsBox__header' data-widgetcollapse>
				<span>{{name}} {{#by}}<span class='i-color_soft i-font-size_1 i-font-weight_normal'>By {{by}}</span>{{/by}}</span>
				<ul class='acpWidget_tools'>
					<li>
						<a href='#' class='acpWidget_reorder ipsJS_show i-cursor_move' data-ipsTooltip title='Reorder widget'><i class='fa-solid fa-arrows-up-down-left-right'></i></a>
					</li>
					<li>
						<a href='#' class='acpWidget_close' data-ipsTooltip title='Close widget'><i class='fa-solid fa-xmark'></i></a>
					</li>
				</ul>
			</h2>
			<div class='' data-role='widgetContent'>
				{{content}}
			</div>
		</div>
	</li>
`);]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="templates" javascript_name="ips.templates.members.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[
ips.templates.set( 'moderatorPermissions.checkUncheckAll', "\
	<li class='ipsFieldRow'>\
		<div class='ipsFieldRow__label'>\
		</div>\
		<div class='ipsFieldRow__content'>\
			<ul class='ipsList ipsList--inline i-font-weight_500'>\
				<li><button type='button' data-role='checkAll'>{{#lang}}check_all{{/lang}}</button></li>\
				<li><button type='button' data-role='uncheckAll'>{{#lang}}uncheck_all{{/lang}}</button></li>\
			</ul>\
		</div>\
	</li>\
");]]></file>
 <file javascript_app="core" javascript_location="admin" javascript_path="templates" javascript_name="ips.templates.system.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[ips.templates.set( 'menuManager.temporaryDropdown', "\
	<li class='ipsMenu_item {{#selected}}cMenuManager_active{{/selected}}' data-itemID='temp' data-role='menuItem'>\
		<span>\
			{{#lang}}menuManagerNewItem{{/lang}}\
			<ul class='cMenuManager_tools'>\
				<li>\
					<a href='#' data-action='removeItem' data-ipsTooltip title='{{#lang}}menuManagerRemoveItem{{/lang}}'>\
						<i class='fa-solid fa-xmark'></i></i>\
					</a>\
				</li>\
			</ul>\
		</span>\
	</li>\
");

ips.templates.set( 'menuManager.temporaryMenuItem', "\
	<li id='menu_{{id}}' data-role='menuNode'>\
		<div class='cMenuManager_leaf {{#selected}}cMenuManager_active{{/selected}}' data-itemID='temp' data-role='menuItem'>\
			<h3 class='cMenuManager_leafTitle'>{{#lang}}menuManagerNewItem{{/lang}}</h3>\
			<ul class='cMenuManager_tools'>\
				<li>\
					<a href='#' data-action='removeItem' data-ipsTooltip title='{{#lang}}menuManagerRemoveItem{{/lang}}'>\
						<i class='fa-solid fa-xmark'></i></i>\
					</a>\
				</li>\
			</ul>\
		</div>\
	</li>\
");


ips.templates.set( 'menuManager.emptyList', "\
	<li class='cMenuManager_emptyList i-color_soft i-text-align_center'>{{#lang}}menuManagerEmptyList{{/lang}}</li>\
");]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="templates" javascript_name="ips.core.templates.autocomplete.js" javascript_type="framework" javascript_version="5001403" javascript_position="50"><![CDATA[
ips.templates.set('core.autocomplete.field', " \
	<div class='ipsInput ipsField_autocomplete ipsAutoComplete' id='{{id}}_wrapper' role='combobox' aria-autocomplete='list' aria-owns='{{id}}_results'>\
		<span class='ipsField_autocomplete_loading' style='display: none' id='{{id}}_loading'></span>\
		<ul class='ipsAutoComplete__list' role='listbox'><li class='ipsAutoComplete__add' id='{{id}}_inputItem' role='option'>{{content}}</li></ul>\
	</div>\
");

ips.templates.set('core.autocomplete.addToken', " \
	<a href='#' data-action='addToken'><i class='fa-solid fa-tag i-margin-end_icon'></i>{{text}}</a> \
");

ips.templates.set('core.autocomplete.resultWrapper', " \
	<div class='ipsAutocompleteMenu' id='{{id}}_results' aria-expanded='false' style='display: none'>\
		<ul class='ipsAutocompleteMenu_itemWrapper' role='listbox' aria-expanded='false' data-role='items'></ul>\
		<div class='ipsAutocompleteMenu_empty' data-role='noresults' hidden>{{#lang}}autocomplete_no_results{{/lang}}</div>\
	</div>\
");

ips.templates.set('core.autocomplete.searchTypeAhead', " \
	<div class='ipsAutocompleteMenu__search' data-role='autocompleteSearch'>\
		<input type='search' name='autocompleteSearch' placeholder='{{#lang}}autocomplete_search_placeholder{{/lang}}'>\
	</div>\
");

ips.templates.set('core.autocomplete.resultItem', " \
	<li class='ipsAutocompleteMenu_item' data-value='{{value}}' role='option'>\
		{{{html}}}\
	</li>\
");

ips.templates.set('core.autocomplete.tagsResultItem', " \
	<li class='ipsAutocompleteMenu_item' data-value='{{value}}' role='option'>\
		<div class='i-flex i-align-items_center'>\
			<div class='i-flex_11'>{{{html}}}</div>\
			{{#recommended}}\
				<span class='i-flex_00 i-color_positive'>{{#lang}}tag_recommended{{/lang}}\
			{{/recommended}}\
		</div>\
	</li>\
");

ips.templates.set('core.autocomplete.token', " \
	<li class='cToken' data-value='{{value}}' role='option'>\
		{{{title}}} <span class='cToken_close' data-action='delete'>&times;</span>\
	</li>\
");

ips.templates.set('core.autocomplete.assignmentAddToken', " \
	<a href='#' data-action='addToken'><i class='fa-regular fa-paper-plane'></i> {{text}}</a> \
");

ips.templates.set( 'core.autocomplete.assignmentResultItem', " \
	<li class='ipsAutocompleteMenu_item' data-value=\"{{value}}\" role='option'>\
	    {{#team}}\
		<div class='ipsPhotoPanel i-align-items_center'>\
			<i class='fa-solid fa-user-group i-font-size_3 i-text-align_center i-color_soft'></i>\
			<div>\
				<div><strong>{{{name}}}</strong></div>\
				<span class='ipsBadge ipsBadge--positive'>{{#lang}}assignment_team{{/lang}}</span>\
			</div>\
		</div>\
	    {{/team}}\
	    {{^team}}\
		<div class='ipsPhotoPanel'>\
			<span class='ipsUserPhoto ipsUserPhoto--tiny'><img src='{{{photo}}}' alt='' loading='lazy'></span>\
			<div>\
				<strong>{{{name}}}</strong><br>\
				<span class='i-color_soft'>{{{extra}}}</span>\
			</div>\
		</div>\
		{{/team}}\
	</li>\
");

ips.templates.set('core.autocomplete.memberItem', " \
	<li class='ipsAutocompleteMenu_item' data-value=\"{{value}}\" role='option'>\
		<div class='ipsPhotoPanel'>\
			<span class='ipsUserPhoto ipsUserPhoto--tiny'><img src='{{{photo}}}' alt='' loading='lazy'></span>\
			<div>\
				<strong>{{{name}}}</strong><br>\
				<span class='i-color_soft'>{{{extra}}}</span>\
			</div>\
		</div>\
	</li>\
");

ips.templates.set('core.autocomplete.optional', " \
	<a href='#' data-action='showAutocomplete' class='ipsButton i-font-size_-1 ipsButton--inherit'><i class='fa-solid fa-tags'></i><span>{{langString}}...</span></a>\
");]]></file>
 <file javascript_app="global" javascript_location="framework" javascript_path="templates" javascript_name="ips.core.templates.js" javascript_type="framework" javascript_version="5001403" javascript_position="50"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 */
/* GENERAL TEMPLATES */
ips.templates.set('core.general.loading', " \
	&nbsp;<span class='i-color_soft'><i class='ipsLoadingIcon'></i>&nbsp;&nbsp;&nbsp;</span> {{text}}</span>\
");

ips.templates.set('core.general.ajax', " \
	<div id='elAjaxLoading'><i class='ipsLoading ipsLoading--tiny'></i> {{#lang}}loading{{/lang}}...</div>\
");

ips.templates.set('core.general.flashMsg', " \
	<div id='elFlashMessage'><div data-role='flashMessage' class='i-text-align_center'></div><a href='#' data-action='dismissFlashMessage'>&times;</a></div>\
");

ips.templates.set('core.hovercard.loading', " \
	<i class='ipsLoadingIcon'></i>\
");

/* POST CONTENT */
ips.templates.set('core.posts.spoiler', " \
	<span class='ipsStyle_spoilerFancy_text'><span class='ipsButton ipsButton--small ipsButton--primary ipsButton--icon'><i class='fa-solid fa-chevron-right'></i></span> {{#lang}}spoilerClickToReveal{{/lang}}</span>\
");

ips.templates.set('core.posts.spoilerOpen', " \
	<span class='ipsStyle_spoilerFancy_text'><span class='ipsButton ipsButton--small ipsButton--primary ipsButton--icon'><i class='fa-solid fa-chevron-down'></i></span> {{#lang}}spoilerClickToHide{{/lang}}</span>\
");

ips.templates.set('core.posts.multiQuoteOff', " \
	<i class='fa-solid fa-plus'></i>\
");

ips.templates.set('core.posts.multiQuoteOn', " \
	<i class='fa-solid fa-check'></i>\
");

ips.templates.set('core.posts.multiQuoter', " \
	<div id='ipsMultiQuoter' data-commentsContainer='{{commentFeedId}}'>\
		<button class='ipsButton ipsButton--soft ipsButton--small' data-role='multiQuote_{{commentFeedId}}'><i class='fa-solid fa-comments'></i> &nbsp;&nbsp;{{{count}}}</button> &nbsp;&nbsp;<a href='#' data-action='clearQuoted_{{commentFeedId}}'><i class='fa-solid fa-xmark'></i></a>\
	</div>\
");

ips.templates.set('core.menus.menuItem', " \
	<li>\
		<a href='{{link}}' {{#checked}}aria-selected='true'{{/checked}} data-ipsMenuValue='{{value}}'>{{title}}</a>\
	</li>\
");

ips.templates.set('core.menus.menuSep', " \
	<li><hr></li>\
");

ips.templates.set('core.posts.quotedSpoiler', " \
	<p><em>{{#lang}}quotedSpoiler{{/lang}}</em></p>\
");

/* NOTIFICATION TEMPLATE */
ips.templates.set('core.postNotify.single', " \
	<div class='i-flex i-align-items_center i-gap_2 i-link-color_inherit' data-role='newPostNotification'>\
		<span class='ipsUserPhoto ipsUserPhoto--tiny'><img src='{{photo}}' alt='' loading='lazy'></span>\
		<div>\
			<span class='i-font-weight_500'>{{{text}}}</span>&nbsp;&nbsp;\
			<a href='#' data-action='loadNewPosts' class='i-opacity_8'>{{#lang}}showReply{{/lang}}</a>\
		</div>\
	</div>\
");

ips.templates.set('core.postNotify.multiple', " \
	<div class='i-flex i-align-items_center i-gap_2 i-link-color_inherit' data-role='newPostNotification'>\
		<i class='fa-solid fa-comments'></i>\
		<div>\
			<span class='i-font-weight_500'>{{{text}}}</span>&nbsp;&nbsp;\
			<a href='#' data-action='loadNewPosts' class='i-opacity_8'>{{#lang}}showReplies{{/lang}}</a>\
		</div>\
	</div>\
");

ips.templates.set('core.postNotify.multipleSpillOver', " \
	<div class='i-flex i-align-items_center i-gap_2 i-link-color_inherit' data-role='newPostNotification'>\
		<i class='fa-solid fa-comments'></i>\
		<div>\
			{{text}}\
			{{#canLoadNew}}\
				&nbsp;&nbsp;&nbsp;<a href='#' data-action='loadNewPosts'>{{showFirstX}}</a>\
				&nbsp;&nbsp;&nbsp;<span class='i-opacity_8'>{{#lang}}showRepliesOr{{/lang}}</span>\
			{{/canLoadNew}}\
			&nbsp;&nbsp;&nbsp;<a href='{{spillOverUrl}}'>{{#lang}}goToNewestPage{{/lang}}</a>\
		</div>\
	</div>\
");

ips.templates.set('core.notification.flashSingle', " \
	<a href='{{url}}' data-role='newNotification'>\
		<div class='i-flex i-align-items_center i-gap_2 i-link-color_inherit'>\
			{{#icon}}<div class='i-flex_00'><span class='ipsUserPhoto ipsUserPhoto--tiny'><img src='{{icon}}' alt='' loading='lazy'></span></div>{{/icon}}\
			<div class='i-flex_11 i-text-align_start'>\
				{{text}}\
				<p class='i-opacity_8 ipsTruncate_1 i-font-weight_600'>{{{body}}}</p>\
			</div>\
		</div>\
	</a>\
");

ips.templates.set('core.notification.flashMultiple', " \
	<div class='i-flex i-align-items_center i-gap_2 i-link-color_inherit' data-role='newNotification'>\
		<i class='fa-solid fa-bell'></i>\
		<div class='i-flex_11 i-text-align_start'>\
			{{text}}\
			<p class='i-opacity_8 ipsTruncate_1 i-font-weight_600'>{{{body}}}</p>\
		</div>\
	</div>\
");

/* ALERTS */
ips.templates.set('core.alert.box', " \
<div class='ipsAlert' style='display: none' role='alertdialog' aria-describedby='{{id}}_message'>\
	<div class='ipsAlert__message' id='{{id}}_message'>\
		<div class='ipsAlert__icon'>{{{icon}}}</div>\
		<strong class='ipsAlert__title'>{{{text}}}</strong>\
		{{{subtext}}}\
	</div>\
	<ul class='ipsButtons ipsButtons--fill'>\
		{{{buttons}}}\
	</ul>\
</div>\
");

ips.templates.set('core.alert.subText', " \
<div class='ipsAlert__desc'>{{text}}</div>\
");

ips.templates.set('core.alert.subTextHtml', " \
<div class='ipsAlert__desc'>{{{text}}}</div>\
");

ips.templates.set('core.alert.icon', " \
<i class='{{icon}}'></i>\
");

ips.templates.set('core.alert.button', " \
<li><button data-action='{{action}}' class='ipsButton {{extra}}'>{{title}}</button></li>\
");

ips.templates.set('core.alert.prompt', " \
<br><br>\
<input type='text' value='{{value}}' class='ipsInput ipsInput--text ipsInput--wide' data-role='promptValue'>\
<br><br>\
");

/* LIGHTBOX TEMPLATES */
ips.templates.set('core.lightbox.meta', "{{title}}");

ips.templates.set('core.lightbox.toolsMenu', " \
<a href='{{url}}&amp;direction=right' class='ipsButton ipsButton--text ipsButton--small' title='Rotate Right' data-ipsTooltip data-action='rotateImage'>\
    <i class='fa-solid fa-rotate-right'></i>\
</a>\
<a href='{{url}}&amp;direction=left' class='ipsButton ipsButton--text ipsButton--small' title='Rotate Left' data-ipsTooltip data-action='rotateImage'>\
    <i class='fa-solid fa-rotate-left'></i>\
</a>\
");

/* DIALOG TEMPLATES */
ips.templates.set('core.dialog.main', " \
<div class='{{class}} {{#fixed}}{{class}}_fixed{{/fixed}} {{#size}}{{class}}_{{size}}{{/size}} {{extraClass}}' style='display: none' id='{{id}}' role='dialog' aria-label='{{title}}'>\
	<div>\
		{{#title}}\
			<h3 class='{{class}}_title'>{{title}}</h3>\
			<hr class='ipsHr'>\
		{{/title}}\
		{{#close}}\
			<a href='#' class='{{class}}_close' data-action='dialogClose'>&times;</a>\
		{{/close}}\
		<div class='{{class}}_content'>\
			{{content}}\
		</div>\
		<div class='{{class}}_loading {{class}}_large ipsLoading' style='display: none'></div>\
	</div>\
</div>\
")

/* TOOLTIP TEMPLATE */
ips.templates.set('core.tooltip', " \
	<div id='{{id}}' class='ipsTooltip' role='tooltip' popover='manual'>{{content}}</div>\
");

/* SEARCH TEMPLATES */
ips.templates.set('core.search.loadingPanel', " \
	<div id='{{id}}' class='ipsLoading' style='min-height: 100px'>\
		&nbsp;\
	</div>\
");

/* EDITOR TEMPLATES */
ips.templates.set('core.editor.panelWrapper', " \
	<div id='{{id}}' class='ipsRTE_panel i-padding_3'>\
		{{content}}\
	</div>\
");

ips.templates.set('core.editor.pixabayThumb', `
<div class='ipsPixabayThumb' {{#width}}{{#height}}style="--i-ratio: {{width}} / {{height}}"{{/height}}{{/width}}>
	<img loading="lazy" {{#width}}width='{{width}}'{{/width}} {{#height}}height='{{height}}'{{/height}} src="{{thumb}}" class="ipsPixabayImage" data-url="{{url}}" data-id="{{imgid}}" alt="">
</div>
`);

ips.templates.set('core.editor.emoticonSection', " \
	<div data-panel='{{id}}'>{{{content}}}</div>\
");

ips.templates.set('core.editor.emoticonCategory', " \
	<div class='i-background_2 i-padding_2'><strong>{{title}}</strong></div>\
	<div class='ipsEmoticons_category' data-categoryid='{{categoryID}}'>{{{emoticons}}}</div>\
");
ips.templates.set('core.editor.emoticonSearch', " \
	<div class='ipsEmoticons_category'>{{{emoticons}}}</div>\
");

ips.templates.set('core.editor.emoticonRow', " \
	<div class='ipsEmoticons_row ipsEmoji'>{{{emoticons}}}</div>\
");

ips.templates.set('core.editor.emoticonItem', " \
	<div class='ipsEmoticons_item' data-emoticon='{{tag}}' src='{{src}}' data-height='{{height}}' data-width='{{width}}' title='{{tag}}' loading='lazy'>{{{img}}}</div>\
");

ips.templates.set('core.editor.emoji', " \
	<div class='ipsEmoticons_item' title='{{name}}' data-emoji='{{code}}'>{{{display}}}</div>\
");

ips.templates.set('core.editor.emojiNotNative', " \
	<div class='ipsEmoticons_item' title='{{name}}' data-emoji='{{code}}'>{{{img}}}</div>\
");


ips.templates.set('core.editor.emoticonBlank', " \
	<div class='ipsEmoticons_item'>&nbsp;</div>\
");

ips.templates.set('core.editor.emoticonNoResults', " \
	<div class='i-padding_3 i-text-align_center i-color_soft'>{{#lang}}no_results{{/lang}}</div>\
");

ips.templates.set('core.editor.emojiResult', " \
	<li class='ipsMenu_item i-cursor_pointer' title='{{name}}' data-emoji='{{code}}'>\
		<a><span class='ipsEmoji_result'>{{{emoji}}}</span> <span data-role='shortCode'>{{short_code}}</span></a>\
	</li>\
");

ips.templates.set('core.editor.quote', "<blockquote class='ipsQuote' data-ipsQuote data-gramm='false' cite='{{citeurl}}'><div class='ipsQuote_citation'>{{{citation}}}</div><div class='ipsQuote_contents ipsClearfix' data-gramm='false'>{{{contents}}}</div></blockquote>");
ips.templates.set('core.editor.legacyQuoteUpcast', "<div class='ipsQuote_citation'>{{citation}}</div><div class='ipsQuote_contents ipsClearfix' data-gramm='false'>{{{contents}}}</div>");

ips.templates.set('core.editor.citation', " \
	<div class='ipsQuote_citation ipsQuote_open'>\
		<a href='#' data-action='toggleQuote' aria-label='{{#lang}}toggle_quote{{/lang}}'>&nbsp;</a>\
		{{#contenturl}}\
			<a href='{{contenturl}}' class='ipsQuote_citation-origin'><i class='fa-solid fa-share'></i></a>\
		{{/contenturl}}\
		{{{citation}}}\
	</div>\
");

ips.templates.set('core.editor.citationLink', " \
	<a href='{{baseURL}}?app=core&module=members&controller=profile&id={{userid}}' data-ipsHover data-ipshover-target='{{baseURL}}?app=core&module=members&controller=profile&id={{userid}}&do=hovercard'>{{username}}</a>\
");

ips.templates.set('core.editor.spoiler', "<div class='ipsSpoiler' data-ipsSpoiler><div class='ipsSpoiler_header'><span>{{#lang}}editorSpoiler{{/lang}}</span></div><div class='ipsSpoiler_contents ipsClearfix'></div></div>");
ips.templates.set('core.editor.legacySpoilerUpcast', "<div class='ipsSpoiler_header'><span>{{#lang}}editorSpoiler{{/lang}}</span></div><div class='ipsSpoiler_contents ipsClearfix' data-gramm='false'>{{{contents}}}</div>");
ips.templates.set('core.editor.spoilerHeader', " \
	<summary class='ipsSpoiler_header ipsSpoiler_closed'>\
		<span>{{#lang}}spoilerClickToReveal{{/lang}}</span>\
	</summary>\
");

ips.templates.set('core.editor.initLoading', " \
	<div class='ipsLoading ipsLoading--tiny'>&nbsp;</div>\
");

ips.templates.set('core.editor.previewLoading', " \
	<div data-role='previewLoading' class='ipsLoading' style='min-height: 100px'>\
		&nbsp;\
	</div>\
");

/* ATTACHMENT TEMPLATES */
ips.templates.set('core.attachments.metaInfo', " \
	<span>{{size}}</span> <span>&middot;</span> <span>{{downloads}}</span>\
");

ips.templates.set('core.attachments.attachmentPreview', " \
	<span class='ipsAttachLink_box'><span class='ipsAttachLink_title'>{{title}}</span><span class='ipsAttachLink_metaInfo'>{{#lang}}attachmentPending{{/lang}}</span></span>\
");

ips.templates.set('core.attachments.fileItemWrapper', " \
	<div class='ipsUploader__container ipsUploader__container--files'>{{{content}}}</div>\
");

ips.templates.set('core.attachments.fileItem', " \
	<div class='ipsUploader__row ipsUploader__row--file ipsAttach {{#done}}ipsAttach_done{{/done}}' id='{{id}}' data-role='file' data-fileid='{{id}}' data-filesize='{{sizeRaw}}' data-filekey='{{securityKey}}'>\
		<div class='ipsUploader__rowPreview' data-role='preview' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			{{#thumb}}\
				{{{thumb}}}\
			{{/thumb}}\
			<div class='ipsUploader__rowPreview__generic' {{#thumb}}style='display: none'{{/thumb}}>\
				<i class='fa-solid fa-{{extIcon}}'></i>\
			</div>\
		</div>\
		<div class='ipsUploader_rowMeta' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			<h2 class='ipsUploader_rowTitle' data-role='title'>{{title}}</h2>\
			<p class='ipsUploader_rowDesc'>\
				{{size}} {{#statusText}}&middot; <span class='i-color_soft' data-role='status'>{{statusText}}</span>{{/statusText}}\
			</p>\
			{{#status}}<meter class='ipsMeter' data-role='progressbar' max='100'></meter>{{/status}}\
			<div data-role='insert' class='ipsUploader__rowInsert' {{#insertable}}style='display: none'{{/insertable}}>\
				<a href='#' data-ipsTooltip title='{{#lang}}insertIntoPost{{/lang}}'>\
					{{#lang}}insert{{/lang}}\
				</a>\
			</div>\
		</div>\
		{{#supportsDelete}}\
			<div data-role='deleteFileWrapper' {{#newUpload}}style='display: none'{{/newUpload}}>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' data-role='deleteFile' class='ipsUploader__rowDelete' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>\
					&times;\
				</a>\
			</div>\
		{{/supportsDelete}}\
		{{^supportsDelete}}\
			<div data-role='deleteFileWrapper' style='display: none'>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' class='ipsUploader__rowDelete' data-role='deleteFile' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>&times;</a>\
			</div>\
		{{/supportsDelete}}\
	</div>\
");

ips.templates.set('core.attachments.imageItem', " \
	<div class='ipsUploader__row ipsUploader__row--image ipsAttach {{#done}}ipsAttach_done{{/done}}' id='{{id}}' data-role='file' data-fileid='{{id}}' data-fullsizeurl='{{imagesrc}}' data-thumbnailurl='{{thumbnail}}' data-fileType='image'>\
		<div class='ipsUploader__rowPreview' data-role='preview' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			{{#thumb}}\
				{{{thumb}}}\
			{{/thumb}}\
			<div class='ipsUploader__rowPreview__generic' {{#thumb}}style='display: none'{{/thumb}}>\
				<i class='fa-solid fa-{{extIcon}}'></i>\
			</div>\
		</div>\
		<div class='ipsUploader_rowMeta' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			<h2 class='ipsUploader_rowTitle' data-role='title'>{{title}}</h2>\
			<p class='ipsUploader_rowDesc'>\
				{{size}} {{#statusText}}&middot; <span class='i-color_soft' data-role='status'>{{statusText}}</span>{{/statusText}}\
			</p>\
			{{#status}}<meter class='ipsMeter' data-role='progressbar' max='100'></meter>{{/status}}\
			<div data-role='insert' class='ipsUploader__rowInsert' {{#insertable}}style='display: none'{{/insertable}}>\
				<a href='#' data-ipsTooltip title='{{#lang}}insertIntoPost{{/lang}}'>\
					{{#lang}}insert{{/lang}}\
				</a>\
			</div>\
		</div>\
		{{#supportsDelete}}\
			<div data-role='deleteFileWrapper' {{#newUpload}}style='display: none'{{/newUpload}}>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' data-role='deleteFile' class='ipsUploader__rowDelete' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>\
					&times;\
				</a>\
			</div>\
		{{/supportsDelete}}\
		{{^supportsDelete}}\
			<div data-role='deleteFileWrapper' style='display: none'>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' class='ipsUploader__rowDelete' data-role='deleteFile' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>&times;</a>\
			</div>\
		{{/supportsDelete}}\
	</div>\
");

ips.templates.set('core.attachments.videoItem', " \
	<div class='ipsUploader__row ipsUploader__row--image ipsAttach {{#done}}ipsAttach_done{{/done}}' id='{{id}}' data-role='file' data-fileid='{{id}}' data-fullsizeurl='{{imagesrc}}' data-thumbnailurl='{{thumbnail}}' data-fileType='video' data-mimeType='{{mime}}'>\
		<div class='ipsUploader__rowPreview' data-role='preview' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			{{#thumb}}\
				<video>\
					<source src='{{{thumb}}}' type='{{mime}}'>\
				</video>\
			{{/thumb}}\
			<div class='ipsUploader__rowPreview__generic' {{#thumb}}style='display: none'{{/thumb}}>\
				<i class='fa-solid fa-{{extIcon}}'></i>\
			</div>\
		</div>\
		<div class='ipsUploader_rowMeta' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			<h2 class='ipsUploader_rowTitle' data-role='title'>{{title}}</h2>\
			<p class='ipsUploader_rowDesc'>\
				{{size}} {{#statusText}}&middot; <span class='i-color_soft' data-role='status'>{{statusText}}</span>{{/statusText}}\
			</p>\
			{{#status}}<meter class='ipsMeter' data-role='progressbar' max='100'></meter>{{/status}}\
			<div data-role='insert' class='ipsUploader__rowInsert' {{#insertable}}style='display: none'{{/insertable}}>\
				<a href='#' data-ipsTooltip title='{{#lang}}insertIntoPost{{/lang}}'>\
					{{#lang}}insert{{/lang}}\
				</a>\
			</div>\
		</div>\
		{{#supportsDelete}}\
			<div data-role='deleteFileWrapper' {{#newUpload}}style='display: none'{{/newUpload}}>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' data-role='deleteFile' class='ipsUploader__rowDelete' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>\
					&times;\
				</a>\
			</div>\
		{{/supportsDelete}}\
		{{^supportsDelete}}\
			<div data-role='deleteFileWrapper' style='display: none'>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' class='ipsUploader__rowDelete' data-role='deleteFile' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>&times;</a>\
			</div>\
		{{/supportsDelete}}\
	</div>\
");

ips.templates.set('core.attachments.audioItem', " \
	<div class='ipsUploader__row ipsUploader__row--image ipsAttach {{#done}}ipsAttach_done{{/done}}' id='{{id}}' data-role='file' data-fileid='{{id}}' data-fullsizeurl='{{imagesrc}}' data-thumbnailurl='{{thumbnail}}' data-fileType='audio' data-mimeType='{{mime}}'>\
		<div class='ipsUploader__rowPreview' data-role='preview' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			{{#thumb}}\
				<audio src='{{{thumb}}}' type='{{mime}}'>\
				</audio>\
			{{/thumb}}\
			<div class='ipsUploader__rowPreview__generic' {{#thumb}}style='display: none'{{/thumb}}>\
				<i class='fa-solid fa-{{extIcon}}'></i>\
			</div>\
		</div>\
		<div class='ipsUploader_rowMeta' {{#insertable}}data-action='insertFile'{{/insertable}}>\
			<h2 class='ipsUploader_rowTitle' data-role='title'>{{title}}</h2>\
			<p class='ipsUploader_rowDesc'>\
				{{size}} {{#statusText}}&middot; <span class='i-color_soft' data-role='status'>{{statusText}}</span>{{/statusText}}\
			</p>\
			{{#status}}<meter class='ipsMeter' data-role='progressbar' max='100'></meter>{{/status}}\
			<div data-role='insert' class='ipsUploader__rowInsert' {{#insertable}}style='display: none'{{/insertable}}>\
				<a href='#' data-ipsTooltip title='{{#lang}}insertIntoPost{{/lang}}'>\
					{{#lang}}insert{{/lang}}\
				</a>\
			</div>\
		</div>\
		{{#supportsDelete}}\
			<div data-role='deleteFileWrapper' {{#newUpload}}style='display: none'{{/newUpload}}>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' data-role='deleteFile' class='ipsUploader__rowDelete' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>\
					&times;\
				</a>\
			</div>\
		{{/supportsDelete}}\
		{{^supportsDelete}}\
			<div data-role='deleteFileWrapper' style='display: none'>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' class='ipsUploader__rowDelete' data-role='deleteFile' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'>&times;</a>\
			</div>\
		{{/supportsDelete}}\
	</div>\
");

ips.templates.set('core.attachments.imageItemWrapper', " \
	<div class='ipsGrid ipsGrid--image-item-wrapper i-basis_160'>{{{content}}}</div>\
");

/* FORM TEMPLATES */
ips.templates.set('core.forms.validationWrapper', " \
	<ul id='{{id}}' class='i-font-size_-2 ipsForm_errorList'>{{content}}</ul>\
");

ips.templates.set('core.forms.validationItem', " \
	<li class='i-color_warning'>{{message}}</li>\
");

ips.templates.set('core.forms.advicePopup', "\
<div class='ipsHovercard' data-role='advicePopup' id='elPasswordAdvice_{{id}}'>\
	<div class='i-padding_3'>\
		<h2 class='ipsTitle ipsTitle--h4'>{{#lang}}password_advice_title{{/lang}}</h2>\
		<p class='i-margin-top_2'>\
			{{#min}}\
				{{min}} \
			{{/min}}\
			{{{text}}}\
		</p>\
	</div>\
	<span class='ipsHovercard_stem'></span>\
</div>\
");

ips.templates.set('core.forms.validateOk', "\
<span>\
	<i class='fa-solid fa-check-circle i-color_positive'></i>\
</span>\
");

ips.templates.set('core.forms.validateFail', "\
<span data-ipsTooltip data-ipsTooltip-label='{{message}}'>\
	<i class='fa-solid fa-circle-xmark i-color_negative'></i>\
</span>\
");

ips.templates.set('core.forms.validateFailText', "\
<p data-el='validate-fail' class='i-margin-top_2 i-color_negative i-font-weight_500'>\
	<i class='fa-solid fa-circle-xmark'></i> {{message}}\
</p>\
");

/* TRUNCATE TEMPLATE */
ips.templates.set('core.truncate.expand', " \
	<button type='button' class='ipsTruncate_more' data-action='expandTruncate'><span>{{text}}</span><i class='fa-solid fa-caret-down'></i></button>\
");

/* NODE SELECT */
ips.templates.set('core.selectTree.token', " \
<li><span class='ipsSelectTree_token cToken' data-nodeID='{{id}}'>{{title}}</span></li>\
");

/* ACCESSIBILITY KEYBOARD NAV TEMPLATES */
ips.templates.set('core.accessibility.border', " \
<div id='ipsAccessibility_border'></div>\
");

ips.templates.set('core.accessibility.arrow', " \
<div id='ipsAccessibility_arrow'></div>\
");

/* INFINITE SCROLL */
ips.templates.set('core.infScroll.loading', " \
	<li class='i-padding_3 i-text-align_center' data-role='infScroll_loading'>\
		{{#lang}}loading{{/lang}}...\
	</li>\
");

ips.templates.set('core.infScroll.pageBreak', " \
	<li class='i-padding_2 i-background_3' data-role='infScroll_break' data-infScrollPage='{{page}}'>\
		{{#lang}}page{{/lang}} {{page}}\
	</li>\
");

ips.templates.set('core.pageAction.actionMenuItem', " \
	<li>\
		<button type='button' class='ipsPageAction__button' id='{{id}}_{{action}}' popovertarget='{{id}}_{{action}}_menu' data-role='actionMenu' data-action='{{action}}' data-ipsTooltip title='{{title}}'>\
			<span>\
				{{#icon}}\
					<i class='fa-solid fa-{{icon}} ipsPageAction_icon'></i> <i class='fa-solid fa-caret-up'></i>\
				{{/icon}}\
				{{^icon}}\
					<span class='ipsPageAction_text'>{{title}} <i class='fa-solid fa-caret-up'></i></span>\
				{{/icon}}\
			</span>\
		</button>\
		<i-dropdown popover id='{{id}}_{{action}}_menu'>\
			<div class='iDropdown'>\
				<ul class='iDropdown__items'>\
					{{{menucontent}}}\
				</ul>\
			</div>\
		</i-dropdown>\
	</li>\
");

ips.templates.set('core.pageAction.actionItem', " \
	<li>\
		<button type='button' class='ipsPageAction__button' data-role='actionButton' data-action='{{action}}' id='{{id}}_{{action}}' data-ipsTooltip title='{{title}}'>\
			<span>\
				{{#icon}}\
					<i class='fa-solid fa-{{icon}} ipsPageAction_icon' data-ipsTooltip='{{title}}'></i></i>\
				{{/icon}}\
				{{^icon}}\
					<span class='ipsPageAction_text'>{{title}}</span>\
				{{/icon}}\
			</span>\
		</button>\
	</li>\
");

/* PAGE ACTIONS */
ips.templates.set('core.pageAction.wrapper', " \
	<div class='ipsPageAction' data-role='actionBar' id='{{id}}_bar'>\
		<ul data-role='actionItems'>\
			<li class='ipsPageAction__title'><span>{{{selectedLang}}}</span></li>\
			{{{content}}}\
		</ul>\
	</div>\
");

/* CAROUSEL */
ips.templates.set('core.carousel.bulletWrapper', "\
	<ul class='ipsCarousel_bullets'>{{content}}</ul>\
");

ips.templates.set('core.carousel.bulletItem', "\
	<li><i class='fa-solid fa-circle'></i></li>\
");

/* RATINGS */
ips.templates.set('core.rating.wrapper', "\
	<div class='ipsRating'>\
		<ul class='{{className}}' data-role='ratingList'>\
			{{{content}}}\
		</ul>\
		<div data-role='ratingStatus' class='i-color_soft i-font-size_-1'>{{status}}</div>\
	</div>\
")

ips.templates.set('core.rating.star', "\
	<li class='{{className}}' data-ratingValue='{{value}}'><a href='#'><i class='fa-solid fa-star'></i></a></li>\
");

ips.templates.set('core.rating.halfStar', "\
	<li class='ipsRating_half' data-ratingValue='{{value}}'><i class='fa-solid fa-star-half'></i><i class='fa-solid fa-star-half fa-flip-horizontal'></i></li>\
");

ips.templates.set('core.rating.loading', "\
	<i class='ipsLoadingIcon'></span>\
");

/* SIDEBAR MANAGER */
ips.templates.set('core.sidebar.managerWrapper', `\
	<div id='elSidebarManager' data-role='manager' class='ipsToolbox' hidden>
		<div class='ipsToolbox__tools'>
			<div class='i-padding_2' id="elSidebarManager_header">
				<div data-role="title">
                    <h3 class='ipsToolbox_title'>{{#lang}}sidebarManager{{/lang}}</h3>
				    <span data-role="info">
				        <i class="fa-solid fa-info-circle"></i>
                        <div data-role="description" class="ipsBox i-padding_2" >
                            <p class='i-color_soft'>{{#lang}}sidebarManagerDesc{{/lang}}</p>
                            <p class='i-color_soft i-margin-top_2'>{{#lang}}sidebarManagerDesc2{{/lang}}</p>
                        </div>
                    </span>
                </div>
				<input type="text" data-role="widgetSearch" placeholder="{{#lang}}sidebarManagerSearchPlaceholder{{/lang}}" class="ipsInput ipsInput--widget-search" />
			</div>
			<div data-role='availableBlocks' data-unloaded="true" class='ipsLoading ipsScrollbar'></div>
			<div data-role="emptyMessage" class="i-padding_2" hidden>{{#lang}}sidebarManagerSearchEmpty{{/lang}}</div>
		</div>
		<div id='elSidebarManager_submit' class='i-flex_00 i-padding_3 ipsButtons i-gap_2'>
			<button class='ipsButton ipsButton--positive ipsButton--wide' data-action='closeSidebar'><i class='fa-regular fa-floppy-disk'></i><span>{{#lang}}finishEditing{{/lang}}</span></button>
		</div>
	</div>
`);

ips.templates.set('core.sidebar.blockManage', " \
	<div class='cSidebarBlock_managing'>\
		<h4>{{title}}</h4>\
		<button type='button' id='{{id}}_edit' popovertarget='{{id}}_edit_menu' data-action='manageBlock' class='ipsButton ipsButton--icon ipsButton--primary' data-ipsTooltip title='{{#lang}}editBlock{{/lang}}'>\
			<i class='fa-solid fa-pencil'></i>\
		</button>\
		<button type='button' data-action='removeBlock' class='ipsButton ipsButton--icon ipsButton--inherit' data-ipsTooltip title='{{#lang}}removeBlock{{/lang}}'><i class='fa-solid fa-xmark'></i></button>\
		<i-dropdown popover id='{{id}}_{{action}}_menu'>\
			<div class='iDropdown'></div>\
		</i-dropdown>\
	</div>\
");

ips.templates.set('core.sidebar.blockManageNoConfig', " \
	<div class='cSidebarBlock_managing'>\
		<h4>{{title}}</h4>\
		<button type='button' data-action='removeBlock' class='ipsButton ipsButton--icon ipsButton--inherit' data-ipsTooltip title='{{#lang}}removeBlock{{/lang}}'><i class='fa-solid fa-xmark'></i></button>\
	</div>\
");

ips.templates.set('core.sidebar.blockIsEmpty', " \
	<div class='ipsWidgetBlank'>\
		{{text}}\
	</div>\
");

/* FOLLOW BUTTON LOADING */
ips.templates.set('core.follow.loading', " \
<div class='ipsLoading ipsLoading--tiny'></div>\
");

/* STATUS TEMPLATES */
ips.templates.set('core.statuses.loadingComments', " \
	<i class='ipsLoadingIcon'></i> &nbsp;<span class='i-color_soft'> &nbsp;{{#lang}}loadingComments{{/lang}}</span>\
");


/* STACKS */
ips.templates.set('core.forms.stack', " \
	<li class='ipsField_stackItem' data-role='stackItem'>\
		<span class='ipsField_stackDrag ipsDrag' data-action='stackDrag'>\
			<i class='fa-solid fa-bars ipsDrag_dragHandle'></i>\
		</span>\
		<a href='#' class='ipsField_stackDelete i-cursor_pointer' data-action='stackDelete'>\
			&times;\
		</a>\
		<div data-ipsStack-wrapper>\
			{{{field}}}\
		</div>\
	</li>\
");

/* POLLS */
ips.templates.set('core.pollEditor.question', " \
	<div class='' data-role='question' data-questionID='{{questionID}}'>\
		<div class='i-margin-bottom_2'>\
			<input type='text' data-role='questionTitle' name='{{pollName}}[questions][{{questionID}}][title]' placeholder='{{#lang}}questionPlaceholder{{/lang}}' class='ipsInput ipsInput--text ipsInput--wide' value='{{question}}'>\
		</div>\
		<div>\
			<ul class='cPollChoices i-grid' data-role='choices'>\
				<li class='i-padding-block_1 i-flex i-align-items_center i-gap_2 ipsResponsive_hidePhone'>\
					<span class='i-basis_30 i-flex_00'></span>\
					<div class='i-flex_11'><strong>{{#lang}}choicesTitle{{/lang}}</strong></div>\
					{{#showCounts}}\
						<span class='i-flex_00'><strong>{{#lang}}votesTitle{{/lang}}</strong></span>\
					{{/showCounts}}\
					<span class='i-basis_60'></span>\
				</li>\
				{{{choices}}}\
			</ul>\
			<div class='i-padding-block_1 i-flex i-align-items_center i-gap_2 i-flex-wrap_wrap'>\
				<span class='i-basis_30 i-flex_00'></span>\
				<a href='#' data-action='addChoice' class='ipsButton ipsButton--inherit'>{{#lang}}addChoice{{/lang}}</a>\
				<div class='i-flex_11 i-flex i-align-items_center i-gap_1'>\
					<input type='checkbox' id='elPoll_{{pollName}}_{{questionID}}multi' name='{{pollName}}[questions][{{questionID}}][multichoice]' {{#multiChoice}}checked{{/multiChoice}} class='ipsInput ipsInput--toggle'>\
					<label for='elPoll_{{pollName}}_{{questionID}}multi'>{{#lang}}multipleChoiceQuestion{{/lang}}</label></li>\
				</div>\
				{{#removeQuestion}}<div class='i-flex_00'><a href='#' data-action='removeQuestion' class='ipsButton ipsButton--inherit i-color_negative'>{{#lang}}removeQuestion{{/lang}}</a></div>{{/removeQuestion}}\
			</div>\
		</div>\
	</div>\
");

ips.templates.set('core.pollEditor.choice', " \
	<li class='i-padding-block_1 i-flex i-align-items_center i-gap_2' data-choiceID='{{choiceID}}'>\
		<span class='i-basis_30 i-flex_00 i-text-align_center cPollChoiceNumber'>\
			<strong data-role='choiceNumber'>{{choiceID}}</strong>\
		</span>\
		<div class='i-flex_11'>\
			<input type='text' name='{{pollName}}[questions][{{questionID}}][answers][{{choiceID}}][value]' value='{{choiceTitle}}' class='ipsInput ipsInput--text ipsInput--wide'>\
		</div>\
		<div class='i-flex_00'>\
			<a href='#' data-action='removeChoice' class='ipsButton ipsButton--inherit i-color_negative'><i class='fa-solid fa-xmark'></i></a>\
		</div>\
	</li>\
");

/* COVER PHOTOS */
ips.templates.set('core.coverPhoto.controls', " \
	<ul class='ipsCoverPhoto__overlay-buttons' data-role='coverPhotoControls'>\
		<li><a href='#' class='ipsButton ipsButton--overlay' data-action='cancelPosition'><i class='fa-solid fa-xmark'></i><span>{{#lang}}cancel{{/lang}}</span></a></li>\
		<li><a href='#' class='ipsButton ipsButton--soft' data-action='savePosition'><i class='fa-solid fa-check'></i><span>{{#lang}}save_position{{/lang}}</span></a></li>\
	</ul>\
");

/* Editor preference */
ips.templates.set('core.editor.preferences', " \
	<div id='editorPreferencesPanel' class='i-padding_3'>\
		<div class='ipsMessage ipsMessage--info'> \
			{{#lang}}papt_warning{{/lang}} \
		</div> \
		<br> \
		<ul class='ipsForm ipsForm--vertical ipsForm--editor-preferences'> \
			<li class='ipsFieldRow'> \
				<div class='ipsFieldRow__content'> \
					<input type='checkbox' {{#checked}}checked{{/checked}} name='papt' id='papt'> \
					<label for='papt'>{{#lang}}papt_label{{/lang}}</label> \
				</div> \
			</li> \
		</ul> \
		<div class='i-padding-top_2 i-text-align_center'> \
			<button class='ipsButton ipsButton--primary' id='papt_submit'>{{#lang}}save_preference{{/lang}}</button> \
		</div> \
	</div> \
");

/* Pagination */
ips.templates.set('core.pagination', " \
	<ul class='ipsPagination' data-ipsPagination data-ipsPagination-pages='{{pages}}'>\
		<li class='ipsPagination__prev'>\
			<a href='#' data-page='prev'><i class='fa-solid fa-caret-left'></i> {{#lang}}prev_page{{/lang}}</a>\
		</li>\
		<li class='ipsPagination__next'>\
			<a href='#' data-page='next'>{{#lang}}next_page{{/lang}} <i class='fa-solid fa-caret-right'></i></a>\
		</li>\
	</ul>\
");

/* selective quoting */
ips.templates.set('core.selection.quote', " \
	<div class='ipsTooltip ipsTooltip_{{direction}} ipsTooltip--inlineQuoteTooltip' data-role='inlineQuoteTooltip' popover='manual'>\
	    <a href='#' data-action='quoteSelection'>\
			<i class='fa-solid fa-quote-left'></i> {{#lang}}quote_selected_text{{/lang}}\
	    </a>\
    </div>\
");

/* Content item selector */
ips.templates.set('core.contentItem.resultItem', " \
	<li class='ipsAutocompleteMenu_item' data-id='{{{id}}}' role='option' role='listitem'>\
		{{{html}}}\
	</li>\
");

ips.templates.set('core.contentItem.field', " \
	<div class='ipsInput ipsField_autocomplete' id='{{id}}_wrapper' role='combobox' aria-autocomplete='list' aria-owns='{{id}}_results'>\
		<span class='ipsField_autocomplete_loading' style='display: none' id='{{id}}_loading'></span>\
		<ul class='ipsList ipsList--inline'><li id='{{id}}_inputItem'>{{content}}</li></ul>\
	</div>\
");

ips.templates.set('core.contentItem.resultWrapper', " \
	<div class='ipsAutocompleteMenu' id='{{id}}_results' aria-expanded='false' style='display: none'>\
		<ul class='ipsAutocompleteMenu_itemWrapper' data-role='items'></ul>\
	</div>\
");

ips.templates.set('core.contentItem.item', " \
	<li data-id='{{id}}'>\
		<span class='cContentItem_delete' data-action='delete'>&times;</span> {{{html}}} \
	</li>\
");

/* PROMOTES */
ips.templates.set('promote.imageUpload', " \
	<div class='cPromote_attachImage' id='{{id}}' data-role='file' data-fileid='{{id}}' data-fullsizeurl='{{imagesrc}}' data-thumbnailurl='{{thumbnail}}' data-fileType='image'>\
		<div data-role='preview'>\
			{{#thumbnail}}<img src='{{thumbnail}}' alt='' loading='lazy'>{{/thumbnail}}\
		</div>\
		<ul class='ipsImageAttach_controls'>\
			<li class='' {{#newUpload}}style='display: none'{{/newUpload}} data-role='deleteFileWrapper'>\
				<input type='hidden' name='{{field_name}}_keep[{{id}}]' value='1'>\
				<a href='#' data-role='deleteFile' class='ipsButton ipsButton--small ipsButton--soft' data-ipsTooltip title='{{#lang}}attachRemove{{/lang}}'><i class='fa-regular fa-trash-can'></i></a>\
			</li>\
		</ul>\
		<meter class='ipsMeter' data-role='progressbar' max='100'></meter>\
	</div>\
");

/* TABLE ROW LOADING */
ips.templates.set('table.row.loading', `
	<li class='ipsData__item ipsData__item--loading'>
		<div class='ipsData__image'></div>
		<div class='ipsData__content'>
			<div class='ipsData__main'>
				<div class='ipsData__title'></div>
				<div class='ipsData__meta'></div>
			</div>
			<div class='ipsData__stats'></div>
			<div class='ipsData__last'></div>
		</div>
	</li>
`);

/* LICENSE RENEWAL */
ips.templates.set('licenseRenewal.wrapper', " \
	<div class='acpLicenseRenewal' data-role='licenseRenewal'>\
		<div class='acpLicenseRenewal_wrap'>\
			<div class='acpLicenseRenewal_inner'>\
				<div class='acpLicenseRenewal_content i-padding_3'>\
					<h4 class='i-font-size_3 i-font-weight_600 i-color_hard i-margin-bottom_2' data-role='mainTitle'>{{#lang}}licenseRenewalTitle{{/lang}}</h4>\
					<p class='i-color_soft'>{{#lang}}licenseRenewalText{{/lang}}</p>\
					<div class='i-margin-top_2 i-flex i-align-items_center i-gap_1 i-font-weight_500'><input type='checkbox' checked='checked' name='hideRenewalNotice' id='hideRenewalNotice' class='ipsInput ipsInput--toggle'> <label for='hideRenewalNotice'>{{#lang}}licenseRenewalCheckbox{{/lang}}</label></div>\
				</div>\
				<ul class='ipsButtons i-background_2 i-border-top_1 i-border-end-start-radius_box i-border-end-end-radius_box i-padding_2'>\
					<li>\
						<a href='#' class='ipsButton ipsButton--inherit' data-action='closeLicenseRenewal'>{{#lang}}licenseRenewalNo{{/lang}}</a>\
					</li>\
					<li>\
						<a href='#' class='ipsButton ipsButton--primary' data-role='survey' data-action='closeLicenseRenewal' target='_blank'>{{#lang}}licenseRenewalYes{{/lang}}</a>\
					</li>\
				</ul>\
			</div>\
		</div>\
	</div>\
");

/* Browser Notifications Notices */
ips.templates.set( 'core.browserNotification.prompt' , "\
	<div class='cNotifcationPrompt'>\
		<div class='i-padding_3'>\
			<div class='ipsPhotoPanel ipsPhotoPanel--mini'>\
				<span class='cNotifcationPrompt_icon'></span>\
				<div>\
					<a href='#' class='cNotifcationPrompt_dismiss' data-role=\"dismissNotification\"></a>\
					<h3 class='cNotifcationPrompt_title i-font-size_2 ipsType_sectionHead'>{{#lang}}notificationsCallout{{/lang}}</h3>\
					<p class='cNotifcationPrompt_text i-margin-top_2'>\
						{{#lang}}notificationsDefaultBlurb{{/lang}}\
					</p>\
					<div class='ipsButtons i-margin-top_3'>\
						<button data-action='browserNotificationPrompt' class='ipsButton ipsButton--small ipsButton--soft ipsButton--wide'>{{#lang}}notificationsAllow{{/lang}}</button>\
					</div>\
					<p class='i-font-size_-2 i-margin-block_2 ipsHide' data-role='promptMessage'>\
						{{#lang}}notificationsAllowPrompt{{/lang}}\
					</p>\
				</div>\
			</div>\
		</div>\
	</div>\
");

ips.templates.set( 'core.browserNotification.missingSubscription' , "\
	<div class='cNotifcationPrompt'>\
		<div class='i-padding_3'>\
			<div class='ipsPhotoPanel ipsPhotoPanel--mini'>\
				<span class='cNotifcationPrompt_icon'></span>\
				<div>\
					<a href='#' class='cNotifcationPrompt_dismiss' data-role=\"dismissNotification\"></a>\
					<h3 class='cNotifcationPrompt_title i-font-size_2 ipsType_sectionHead'>{{#lang}}notificationsCalloutPush{{/lang}}</h3>\
					<p class='cNotifcationPrompt_text i-margin-block_2'>\
						{{#lang}}notificationsDefaultBlurb{{/lang}}\
					</p>\
					<div class='ipsButtons i-margin-top_3'>\
						<button data-action='browserNotificationPrompt' class='ipsButton ipsButton--small ipsButton--soft i-flex_11'>{{#lang}}notificationsAllow{{/lang}}</button>\
						<a href='#' data-action='rejectPush' class='ipsButton ipsButton--small ipsButton--text i-color_white i-flex_00'>{{#lang}}notificationsNoThanks{{/lang}}</a>\
					</div>\
					<p class='i-font-size_-2 i-margin-block_2 ipsHide' data-role='promptMessage'>\
						{{#lang}}notificationsAllowPrompt{{/lang}}\
					</p>\
				</div>\
			</div>\
		</div>\
	</div>\
");

ips.templates.set( 'core.notifications.pending' , "\
	<span class='i-color_soft'>{{#lang}}notificationsEnabling{{/lang}}</span>\
");
ips.templates.set( 'core.notifications.success' , "\
	<span class='i-color_positive'><i class='fa-solid fa-check'></i> {{#lang}}notificationsEnabled{{/lang}}</span>\
");
ips.templates.set( 'core.notifications.fail' , "\
	<span class='i-color_negative'><i class='fa-solid fa-xmark'></i> {{#lang}}notificationsFailed{{/lang}}</span>\
");
ips.templates.set( 'core.notifications.notSupported' , "\
	<span class='i-color_soft'><i class='fa-solid fa-xmark'></i> {{#lang}}notificationsNotSupported{{/lang}}</span>\
");
ips.templates.set( 'core.notifications.checking' , "\
	<span class='i-color_soft'>{{#lang}}notificationsChecking{{/lang}}</span>\
");

/* Warning form pre-set action list */
ips.templates.set('system.warningpenalty.nomodify', "\
	<ul class='ipsList ipsList--bullets' id='elWarningPenalties'>\
		{{#penalties}}\
		<li>{{.}}</li>\
		{{/penalties}}\
	</ul>\
");

ips.templates.set('core.edittags.default', "\
	<div class='i-padding_3'>\
		<span><i class='ipsLoadingIcon'></i>  &nbsp;{{#lang}}loading{{/lang}}</span>\
	</div>\
");

ips.templates.set('core.onlineUser.linked', "\
<li data-memberId='{{memberId}}'>\
	<a href='{{memberUrl}}' data-ipsHover data-ipsHover-target='{{memberHovercardUrl}}'>{{{formattedName}}}</a>\
</li>");

ips.templates.set('core.iconpicker.wrap', `
<form action="#" class="ipsIconPicker">
	<div class="ipsIconPicker__tabs">
        <div data-role="tabs">
			{{#allowedTypes}}
				<button data-role="tab" data-tab="{{type}}" type="button">{{#lang}}ips_icon_picker__tab_{{type}}{{/lang}}</button>
			{{/allowedTypes}}
        </div>
		<button class="ipsIconPicker__close" data-role="close" aria-label="close" title="{{#lang}}close{{/lang}}" type="button"><i class="fa-solid fa-xmark"></i></button>
    </div>
	<div class="ipsIconPicker__search">
    	<input type="text" name="icon_picker_search_box" data-role="search" placeholder="{{#lang}}iconpicker_prompt{{/lang}}" class='ipsInput'>
		{{#allowedTypes}}
			<div data-role="type_selectors">
				{{#typeOptions}}
					<select value="{{{current}}}" name="icon_type_selector" data-field="{{type}}" class='ipsInput'>
						{{#options}}
							<option value="{{{value}}}" title="{{title}}" aria-label="{{title}}">{{label}}</option>
						{{/options}}
					</select>
				{{/typeOptions}}
			</div>
		{{/allowedTypes}}
	</div>
    <div class="ipsIconPicker__iconWrap">
        {{#allowedTypes}}
            <article data-role="{{type}}area" class="ipsIconPicker__container" {{#hidden}}style="display: none"{{/hidden}}>
                <a href="https://fontawesome.com/v6/search?o=r&m=free" target="_blank" class="ipsIconPicker__fa-attribution" tabindex="-1">Icons by Font Awesome <i class="fa-solid fa-arrow-up-right-from-square"></i></a>
                <div data-role="icons"></div>
            </article>
        {{/allowedTypes}}
    </div>
	<div data-role="selected_icons"></div>
    <div class="ipsSubmitRow">
        <button type="submit" aria-label="{{selectlang}}" class="ipsButton ipsButton--primary">{{selectlang}}</button>
    </div>
</form>
`)

ips.templates.set('core.iconpicker.category', `\
<section class="ipsIconPicker__category" data-icon-category="{{{name}}}">
    <h4 class="ipsIconPicker__category-title">{{name}} ({{icons.length}})</h4>
    <div data-role="iconarea">
    {{#icons}}
        <button
            type="button"
            data-role="iconpicker_item"
            data-ips-tooltip
            class="ipsIconPicker__option {{#disabled}}ipsButton--disabled{{/disabled}}"
            title="{{#disabled}}{{#lang}}iconpicker_icon_cannot_add{{/lang}}{{/disabled}}{{^disabled}}{{title}}{{/disabled}}"
            data-icon-type="{{type}}"
            data-icon-title="{{title}}"
            data-icon-key="{{key}}"
            {{#selected}}data-icon-selected{{/selected}}
            data-icon-hair-style="{{hairStyle}}"
            data-icon-skin-tone="{{skinTone}}"
        >
<!--            <div class="ipsIconPicker__content">-->
                {{#raw}}
                    {{{raw}}}
                {{/raw}}
                {{#image}}
                    <span class="ipsEmoji">
                        <img src="{{{image}}}" alt="" />
                    </span>
                {{/image}}
<!--            </div>-->
            <div class="ipsIconPicker__title">{{title}}</div>
        </button>
    {{/icons}}
    </div>
</section>\
`)


ips.templates.set('core.iconpicker.selectedicon', `\
<li
    data-role="iconpicker_item"
    data-ips-tooltip
    title="{{#disabled}}{{#lang}}iconpicker_icon_cannot_add{{/lang}}{{/disabled}}{{^disabled}}{{title}}{{/disabled}}"
    data-icon-type="{{type}}"
    data-icon-title="{{title}}"
    data-icon-key="{{key}}"
    data-icon-hair-style="{{hairStyle}}"
    data-icon-skin-tone="{{skinTone}}"
>
    <div class="ipsIconPicker__content">
        {{{raw}}}
    </div>
    <div class="ipsIconPicker__title">{{title}}</div>
</li>\
`)


/**
 * Table of Contents
 */
ips.templates.set('tableOfContents.linkOptions', `\
<span class="ipsTableOfContents__linkOptions">
	<a href="#{{id}}" class="ipsButton ipsButton--text" data-role="link" aria-label="{{#lang}}table_of_contents_link{{/lang}}" data-ipstooltip title="{{#lang}}table_of_contents_link{{/lang}}" >
		<i class="fa-solid fa-link"></i>
	</a>
	{{#canEdit}}
		<button type="button" class="ipsButton ipsButton--primary" data-ipstooltip title="{{#lang}}table_of_contents_add{{/lang}}" data-role="add" aria-label="{{#lang}}table_of_contents_add{{/lang}}" >
			<i class="fa-solid fa-plus"></i>
		</button>
		<span class="ipsTableOfContents__incrementOptions">
			<button type="button" class="ipsButton ipsButton--text" data-ipstooltip title="{{#lang}}table_of_contents_decrement{{/lang}}" data-role="decrement" aria-label="{{#lang}}table_of_contents_decrement{{/lang}}" >
				<i class="fa-solid fa-outdent"></i>
			</button>
			<button type="button" class="ipsButton ipsButton--text" data-ipstooltip title="{{#lang}}table_of_contents_increment{{/lang}}" data-role="increment" aria-label="{{#lang}}table_of_contents_increment{{/lang}}" >
				<i class="fa-solid fa-indent"></i>
			</button>
		</span>
		<button type="button" class="ipsButton ipsButton--negative" data-ipstooltip title="{{#lang}}table_of_contents_remove{{/lang}}" data-role="remove" aria-label="{{#lang}}table_of_contents_remove{{/lang}}" >
			<i class="fa-solid fa-times"></i>
		</button>
	{{/canEdit}}
</span>
`);

/**
 * Controls ajax load failed
 */
ips.templates.set('ips.ui.controls.cannot_load', `
<div class="{{{classList}}} ipsControls__fail-message">{{message}}</div>
`, {
    classList: 'ipsMessage ipsMessage--info',
    get message() {
        return ips.getString('ips.ui.controls.cannot_load')
    }
})]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="templates" javascript_name="ips.templates.clubs.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[ips.templates.set('club.request.approve', "\
	<span class='cClubRequestCover_icon i-background_positive'>\
		<i class='fa-solid fa-check'></i>\
	</span>\
	<br>\
	<span class='ipsBadge ipsBadge--large ipsBadge--positive'>{{#lang}}clubRequestApproved{{/lang}}</span>\
");

ips.templates.set('club.request.decline', "\
	<span class='cClubRequestCover_icon i-background_negative'>\
		<i class='fa-solid fa-xmark'></i>\
	</span>\
	<br>\
	<span class='ipsBadge ipsBadge--large ipsBadge--negative'>{{#lang}}clubRequestDenied{{/lang}}</span>\
");

ips.templates.set('club.menu.dragHandle', "\
	<span data-role='clubMenuDrag' style='display: none'><i class='fa-solid fa-bars'></i> &nbsp;</span>\
");]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="templates" javascript_name="ips.templates.messages.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[/* VIEW TEMPLATES */
ips.templates.set('messages.view.placeholder', " \
<div class='ipsEmpty'>\
	<i class='fa-solid fa-inbox i-opacity_2'></i>\
	<p class='i-margin-top_1'>{{#lang}}no_message_selected{{/lang}}</p>\
</div>\
");

ips.templates.set('messages.main.folderMenu', "\
<li data-role='folderInMenu'><button type='button' data-ipsMenuValue='{{key}}'><span data-role='folderName'>{{name}}</span> <span class='ipsMenu_itemCount' data-role='folderCount'>{{count}}</span></button></li>\
");]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="templates" javascript_name="ips.templates.streams.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[ips.templates.set('core.streams.teaser', `
	<li data-action='insertNewItems' class='ipsStream__loadMore' style='display: none'>
		<button>{{{words}}}</button>
	</li>
`);

ips.templates.set('core.streams.unreadBar', `
	<li data-role='unreadBar' class='ipsStreamItem_bar'><hr class='ipsHr'></li>
`);

ips.templates.set('core.streams.noMore', `
	<div class='ipsEmptyMessage i-padding_0' data-role="loadMoreContainer">
		{{#lang}}noMoreActivity{{/lang}}
	</div>
`);

ips.templates.set('core.streams.loadMore', `
	<a href='#' class='ipsButton ipsButton--inherit' data-action='loadMore'>{{#lang}}loadNewActivity{{/lang}}</a>
`);]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="templates" javascript_name="ips.templates.system.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[ips.templates.set('follow.frequency', "\
	{{#hasNotifications}}\
		<i class='fa-regular fa-bell'></i>\
	{{/hasNotifications}}\
	{{^hasNotifications}}\
		<i class='fa-regular fa-bell-slash'></i>\
	{{/hasNotifications}}\
	{{text}}\
");]]></file>
 <file javascript_app="core" javascript_location="front" javascript_path="templates" javascript_name="ips.templates.vse.js" javascript_type="template" javascript_version="5001403" javascript_position="1000100"><![CDATA[/* CLASS LIST TEMPLATES */
ips.templates.set('vse.classes.title', " \
<li class='ipsToolbox_sectionTitle' data-role='{{role}}'>{{title}}</li>\
");

ips.templates.set('vse.classes.item', " \
<li data-styleID='{{styleid}}' data-themeKey='{{themekey}}'>\
	{{#swatch.back}}\
		<input class='vseClass_swatch vseClass_swatch--back' value='{{swatch.back.color}}' data-key='{{swatch.back.key}}'>\
	{{/swatch.back}}\
	{{^swatch.back}}\
	 	<span class='vseClass_swatch vseClass_swatch--back vseClass_swatch--noStyle'>&times;</span>\
	{{/swatch.back}}\
	{{#swatch.fore}}\
		<input class='vseClass_swatch vseClass_swatch--fore' value='{{swatch.fore.color}}' data-key='{{swatch.fore.key}}'>\
	{{/swatch.fore}}\
	{{^swatch.fore}}\
	 	<span class='vseClass_swatch vseClass_swatch--fore vseClass_swatch--noStyle'>&times;</span>\
	{{/swatch.fore}}\
	{{title}}\
</li>\
");

ips.templates.set('vse.panels.header', " \
	<h2 class='ipsTitle ipsTitle--h3'>{{title}}</h2>\
	{{#desc}}\
		<p class='i-color_soft i-font-size_-2'>\
			{{desc}}\
		</p>\
	{{/desc}}\
	<br>\
");

ips.templates.set('vse.panels.wrapper', " \
	<div class='vseStyleSection' data-role='{{type}}Panel'>\
		{{{content}}}\
	</div>\
");

ips.templates.set('vse.panels.background', " \
	<h3>{{#lang}}vseBackground{{/lang}}</h3>\
	<div data-role='backgroundControls' class='ipsSpanGrid'>\
		<div class='ipsGrid_span3'>\
			<div data-role='backgroundPreview' class='vseBackground_preview'>&nbsp;</div>\
		</div>\
		<div class='ipsGrid_span9'>\
			<input type='text' class='ipsInput--wide color vseBackground_color' data-role='backgroundColor' value='{{backgroundColor}}'>\
			<br>\
			<div class='ipsSpanGrid'>\
				<!--<div class='ipsGrid_span6'>\
					<button data-ipsTooltip title='{{#lang}}vseBackground_image{{/lang}}' class='ipsButton ipsButton--primary ipsButton--small ipsButton--wide i-text-align_center i-font-size_2'><i class='fa-regular fa-image'></i></button>\
				</div>-->\
				<div class='ipsGrid_span6'>\
					<button data-ipsTooltip title='{{#lang}}vseBackground_gradient{{/lang}}' data-action='launchGradientEditor' class='ipsButton ipsButton--primary ipsButton--small ipsButton--wide i-text-align_center i-font-size_2'><i class='fa-solid fa-barcode'></i></button>\
				</div>\
			</div>\
		</div>\
	</div>\
");

ips.templates.set('vse.panels.font', " \
	<h3>{{#lang}}vseFont_color{{/lang}}</h3>\
	<input type='text' class='ipsInput--wide color' data-role='fontColor' value='{{fontColor}}'>\
");

ips.templates.set('vse.gradient.editor', " \
	<div data-role='gradientPreview' class='vseBackground_gradient'></div>\
	<div class='ipsSpanGrid'>\
		<button data-action='gradientAngle' data-angle='90' class='ipsButton ipsButton--primary ipsButton--small ipsGrid_span3'>\
				<i class='fa-solid fa-arrow-down'></i>\
		</button>\
		<button data-action='gradientAngle' data-angle='0' class='ipsButton ipsButton--primary ipsButton--small ipsGrid_span3'>\
			<i class='fa-solid fa-arrow-left'></i>\
		</button>\
		<button data-action='gradientAngle' data-angle='45' class='ipsButton ipsButton--primary ipsButton--small ipsGrid_span3'>\
			<i class='fa-solid fa-arrow-up'></i>\
		</button>\
		<button data-action='gradientAngle' data-angle='120' class='ipsButton ipsButton--primary ipsButton--small ipsGrid_span3'>\
			<i class='fa-solid fa-arrow-right'></i>\
		</button>\
	</div>\
	<hr class='ipsHr'>\
	<ul data-role='gradientStops'>\
		<li class='ipsSpanGrid'>\
			<p class='ipsGrid_span1'>&nbsp;</p>\
			<p class='i-color_soft i-font-size_-2 ipsGrid_span5'>{{#lang}}vseGradient_color{{/lang}}</p>\
			<p class='i-color_soft i-font-size_-2 ipsGrid_span6'>{{#lang}}vseGradient_position{{/lang}}</p>\
		</li>\
		<li class='ipsSpanGrid'>\
			<p class='ipsGrid_span1'>&nbsp;</p>\
			<p class='ipsGrid_span11'><a href='#' data-action='gradientAddStop'>{{#lang}}vseAddStop{{/lang}}</a></p>\
		</li>\
	</ul>\
	<hr class='ipsHr'>\
	<div class='ipsSpanGrid'>\
		{{{buttons}}}\
	</div>\
");

ips.templates.set('vse.gradient.twoButtons', "\
	<button data-action='saveGradient' class='ipsGrid_span8 ipsButton ipsButton--secondary ipsButton--small ipsButton--wide'>{{#lang}}vseGradient_save{{/lang}}</button>\
	<button data-action='cancelGradient' class='ipsGrid_span4 ipsButton ipsButton--secondary ipsButton--small ipsButton--wide'>{{#lang}}vseCancel{{/lang}}</button>\
");

ips.templates.set('vse.gradient.threeButtons', "\
	<button data-action='saveGradient' class='ipsGrid_span4 ipsButton ipsButton--secondary ipsButton--small ipsButton--wide'>{{#lang}}vseSave{{/lang}}</button>\
	<button data-action='cancelGradient' class='ipsGrid_span4 ipsButton ipsButton--secondary ipsButton--small ipsButton--wide'>{{#lang}}vseCancel{{/lang}}</button>\
	<button data-action='removeGradient' class='ipsGrid_span4 ipsButton ipsButton--primary ipsButton--small ipsButton--wide'>{{#lang}}vseDelete{{/lang}}</button>\
");

ips.templates.set('vse.gradient.stop', " \
	<li class='ipsSpanGrid'>\
		<span class='ipsGrid_span1 i-color_soft i-text-align_center'><i class='fa-solid fa-bars'></i></span>\
		<input type='text' class='ipsGrid_span5' value='{{color}}' maxlength='6' pattern='^([0-9a-zA-Z]{6})$'>\
		<input type='range' class='ipsGrid_span5' min='0' max='100' value='{{location}}'>\
		<p class='i-text-align_center ipsGrid_span1'><a href='#' data-action='gradientRemoveStop'><i class='fa-solid fa-xmark'></i></a></p>\
	</li>\
");

ips.templates.set('vse.colorizer.panel', " \
	<p class='i-color_soft i-padding_3'>\
		{{#lang}}vseColorizer_desc{{/lang}}\
	</p>\
	<div class='i-padding_3'>\
		<div class='ipsSpanGrid'>\
			<div class='ipsGrid_span5 i-text-align_center'>\
				<input type='text' class='vseColorizer_swatch color' data-role='primaryColor' value='{{primaryColor}}'>\
				<span class='i-color_soft'>{{#lang}}vseColorizer_primary{{/lang}}</span>\
			</div>\
			<div class='ipsGrid_span2'></div>\
			<div class='ipsGrid_span5 i-text-align_center'>\
				<input type='text' class='vseColorizer_swatch color' data-role='secondaryColor' value='{{secondaryColor}}'>\
				<span class='i-color_soft'>{{#lang}}vseColorizer_secondary{{/lang}}</span>\
			</div>\
		</div>\
		<br>\
		<div class='ipsGrid_span4 i-text-align_center'>\
			<input type='text' class='vseColorizer_swatch color' data-role='textColor' value='{{textColor}}'>\
			<span class='i-color_soft'>{{#lang}}vseColorizer_text{{/lang}}</span>\
		</div>\
		<br><br>\
		<button class='ipsButton ipsButton--soft ipsButton--small ipsButton--wide' data-action='invertColors'>{{#lang}}vseColorizer_invert{{/lang}}</button>\
		<br>\
		<button class='ipsButton ipsButton--soft ipsButton--small ipsButton--wide' data-action='revertColorizer' disabled>{{#lang}}vseColorizer_revert{{/lang}}</button>\
	</div>\
");]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="ui" javascript_name="ips.ui.controlStrip.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.controlStrip.js - Handles functionality for control strips (button rows) in the AdminCP
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.controlStrip', function(){

		var respond = function (elem, options) {
			if( !$( elem ).data('_controlStrip') ){
				$( elem ).data('_controlStrip', controlStripObj( elem ) );
			}
		};

		ips.ui.registerWidget( 'controlStrip', ips.ui.controlStrip );

		return {
			respond: respond
		};
	});

	/**
	 * Control strip instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @returns {void}
	 */
	var controlStripObj = function (elem) {

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			// Set up the events we'll handle here
			elem
				.on( 'click', '[data-replace], [data-remove], [data-bubble]', _remoteAction );
		},

		_remoteAction = function (e) {
			e.preventDefault();
			var link = $( e.currentTarget );
			var url = link.attr('href');

			ips.getAjax()( url, {
				dataType: 'json',
				showLoading: true
			})
				.done( function (response) {
					if( link.is('[data-replace]') ){
						_replaceButton( link, response );
					} else if( link.is('[data-remove]') ){
						_removeButton( link, response );
					} else if( link.is('[data-bubble]') ){
						_bubbleAction( link, response );
					}
				})
				.fail( function () {
					window.location = url;
				});
		},

		/**
		 * Simply triggers an event that bubbles up, which can be caught by page controllers/widgets.
		 *
		 * @param	{element}	link 		Link element that was clicked
		 * @param	{object} 	response 	Response object from the ajax request
		 * @returns {void}
		 */
		_bubbleAction = function (link, response) {
			link.trigger( 'buttonAction', response );
		},

		/**
		 * Event handler for a button that replaces itself with a different button when clicked
		 *
		 * @param	{element}	link 		Link element that was clicked
		 * @param	{object} 	response 	Response object from the ajax request
		 * @returns {void}
		 */
		_replaceButton = function (link, response) {
			ips.ui.flashMsg.show( response );

			var item = link.closest('.ipsControlStrip_button, .ipsControlStrip_menuItem');
			var newItem = $('#' + link.attr('data-replacewith') );

			if( item.hasClass('ipsControlStrip_button') ){
				item.hide();
				newItem.show();
			} else {
				if( !newItem.hasClass('ipsControlStrip_menuItem') ){
					var newHTML = _getMenuItemFromButton( newItem );
					item.hide().after( newHTML );
				} else {
					item.hide();
					newItem.show();
				}
			}
		},

		/**
		 * Event handler for a button that removes itself after being clicked
		 *
		 * @param	{element} 	link 		Link element that was clicked
		 * @param	{object} 	response	Response object from the ajax request
		 * @returns {void}
		 */
		_removeButton = function (link, response) {
			ips.ui.flashMsg.show( response );

			var dropdown = $( elem ).find('[data-dropdown]');

			// Do we have any others to remove too?
			if( link.attr('data-alsoremove') ){
				var also = ips.utils.getIDsFromList( link.attr('data-alsoremove') );
			}

			// Get a jquery object containing the buttons or menu items for each item to remove
			var toRemove = $( link ).add( also || '' ).closest('.ipsControlStrip_button, .ipsControlStrip_menuItem');
			// .. and then remove them.
			toRemove.remove();

			// See if we need to remove the menu & dropdown
			if( dropdown.length ){
				var menu = $( dropdown.attr('id') + '_menu' );

				if( !menu.find('.ipsControlStrip_menuItem').length ){
					menu.remove();
					dropdown.remove();
				}
			}
		},

		/**
		 * Builds an individual menu item from a provided button
		 *
		 * @param	{element} 	button 	Button element to build from
		 * @returns {string} 	Menu item HTML
		 */
		_getMenuItemFromButton = function (button) {
			$( button ).find('[data-ipsTooltip]').removeAttr('data-ipsTooltip');

			return ips.templates.render('core.controlStrip.menuItem', {
				id: $( button ).attr('id') || '',
				item: $( button ).html()
			});
		};

		init();

		return {
		
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="ui" javascript_name="ips.ui.customtags.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.customtags.js - Controller for inserting custom tags into textareas - custom tags are defined by data-textareacustomtag attributes on elements.
 *
 * Author: Rikki Tissier & Brandon Farber
 */
;( function($, _, undefined){
	"use strict";

	ips.controller.register('textarea.customtags', {

		initialize: function () {
			this.on( 'click', '[data-textareacustomtag]', this.insertTag );
		},

		/**
		 * Event handler for inserting custom tags defined on the page
		 *
		 * @param 		{event} 	e 		Event object
		 * @returns 	{void}
		 */
		insertTag: function (e) {
			console.log( 'Inserting custom tag: ' + $( e.currentTarget ).attr('data-textareacustomtag') );

			$( '#' + this.scope.data('textareaid') ).focus();
			$( '#' + this.scope.data('textareaid') ).insertText( $( e.currentTarget ).attr('data-textareacustomtag'),
				$( '#' + this.scope.data('textareaid') ).getSelection().start,
				"collapseToEnd" );
		}
	});
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="ui" javascript_name="ips.ui.matrix.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.matrix.js - Matrix widget for the AdminCP permissions systems
 *
 * Author: Mark Wade & Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.matrix', function(){

		var defaults = {
			manageable: true,
			sortable: false,
			squashFields: false
		};

		var respond = function (elem, options) {
			var matrix = $( elem ).data('_matrix');
			if( !matrix ){
				$( elem ).data('_matrix', matrixObj(elem, _.defaults( options, defaults ) ) );
			} else {
				matrix.checkRows();
			}
		},
		refresh = function (elem) {
			try {
				var obj = $( elem ).data('_matrix');
				obj.checkRows();
			} catch (err) {
				Debug.log("Couldn't refresh matrix " + $( elem ).identify().attr('id') );
			}
		};

		ips.ui.registerWidget( 'matrix', ips.ui.matrix, [ 'manageable', 'sortable', 'squashFields' ] );

		return {
			respond: respond,
			refresh: refresh
		};
	});

	/**
	 * Matrix instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var matrixObj = function (elem, options) {

		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {
			_setUpEvent();

			if( options.manageable ){
				_setUpManageable();
			}
			
			if( options.sortable ){
				ips.loader.get( ['core/interface/jquery/jquery-ui.js'] ).then( function () {
					elem.find('tbody').sortable( {
						handle: '.ipsTree_drag'
					});
				});
			}

			_checkRows();
		},

		/**
		 * Sets up the various events the matrix needs
		 *
		 * @returns {void}
		 */
		_setUpEvent = function () {
			elem.on( 'click', 'td, th', _clickCell );
			elem.on( 'click', 'td input, th input', _clickInputInCell );
			elem.on( 'click', '.matrixAdd', _addRow );
			elem.on( 'click', '.matrixDelete', _deleteRow );
			elem.on( 'click', '[data-action="checkRow"]', _checkRow );
			elem.on( 'click', '[data-action="unCheckRow"]', _unCheckRow );
			elem.on( 'change', '[data-action="checkAll"]', _checkAll ); 
			elem.on( 'change', 'td input[type="checkbox"]', _checkboxChanged );
			elem.closest('form').on( 'submit', _submitForm );
			$( document ).on( 'tabShown', function () {
				_checkRows();
			});
		},

		/**
		 * Called when any cell checkbox is checked. Checks all checkboxes in the column to see if all are checked.
		 * If all are checked, checks the column header. Otherwise, unchecks column header.
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_checkboxChanged = function (e){
			// Which column are we in?
			var col = $( e.currentTarget ).closest('[data-col]').attr('data-col');
			var colHead = elem.find('[data-checkallheader="' + col + '"]');

			if( _.isUndefined( col ) || !elem.find('[data-checkallheader="' + col + '"]').length ){
				return;
			}

			// Get all checkboxes with the same column key
			var similar = elem.find('[data-col="' + col + '"] input[type="checkbox"]');

			colHead.prop('checked', similar.filter(':checked').length == similar.length );
		},

		/**
		 * Event handler for clicking in a cell
		 * Check a checkbox if it exists in a cell, otherwise focus the input
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_clickCell = function (e) {
										
			// find input
			if( !$( e.target ).is('td') && !$( e.target ).is('th') ){
				return;
			}

			var input = $( e.currentTarget ).find('input:not([type="hidden"]),select,textarea');

			if( input.attr('type') == 'checkbox' ){
				input.click();
			} else {
				input.focus();
			}
		},
		
		/**
		 * Checks all checkboxes in the row
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_checkRow = function (e) {
			e.preventDefault();

			$( e.target )
				.closest('tr')
				.find('input[type="checkbox"]:not(:disabled)')
					.prop( 'checked', true )
					.trigger('change');
		},
		
		/**
		 * Unchecks all checkboxes in the row
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_unCheckRow = function (e) {
			e.preventDefault();

			$( e.target )
				.closest('tr')
				.find('input[type="checkbox"]:not(:disabled)')
					.prop( 'checked', false )
					.trigger('change');
		},

		/**
		 * Checks all checkboxes that match the column
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_checkAll = function (e) {
			var regex = '^.*\\[' + $(this).attr('data-checkallheader') + '_checkbox\\]$';

			$(this).closest( 'table.ipsMatrix' ).find( 'input[type="checkbox"]:not(:disabled)' ).filter( function () {
				return $(this).attr('name').match( regex );
			} ).prop( 'checked', $(this).is(':checked') );
		},

		/**
		 * Event handler for deleting a row of the matrix
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_deleteRow = function (e) {
			e.preventDefault();
			var row = $( this ).closest('tr');

			// Change the value of the hidden input
			row.closest('form').find('input[data-matrixrowid="' + row.attr('data-matrixrowid') + '"]').val( 0 );

			// Fade it out them remove
			ips.utils.anim.go( 'fadeOut', row )
				.done( function () {
					row.remove();
					_checkRows();
				});
		},

		/**
		 * Event handler for the Add Row button
		 * Adds a new row by cloning the blank row
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_addRow = function (e) {
			var table = elem.find( '.ipsTable[data-matrixID="' + $( this ).attr('data-matrixID') + '"]' );
			var blankRow = table.find('tbody tr:not( .ipsMatrix_empty ):last-child');

			// Clone the blank row and insert the copy to form our new row
			var newRow = blankRow.clone();
			newRow.insertBefore( blankRow );
			
			// Rename the form fields inside the new row
			var index = newRow.index();
			newRow.find('input,textarea,select,option').each( function () {
				var input = $( this );

				if( input.attr( 'name' ) ){
					input.attr( 'name', input.attr( 'name' ).replace( /_new_\[x\]/g, '_new_[' + index + ']' ) ).show();
				}

				if( input.attr( 'id' ) ){
					input.attr( 'id', input.attr( 'id' ).replace( /_new__x_/g, '_new__' + index + '_' ) );
				}

				if( input.attr( 'data-toggles' ) ){
					input.attr( 'data-toggles', input.attr( 'data-toggles' ).replace( /_new__x_/g, '_new__' + index + '_' ) );
				}

				if( input.attr( 'data-toggle-id' ) ){
					input.attr( 'data-toggle-id', input.attr( 'data-toggle-id' ).replace( /_new__x_/g, '_new__' + index + '_' ) );
				}

				// Allow color fields to reinit
				if( input.attr( 'data-ipsFormData' ) ){
					input.removeAttr( 'data-ipsFormData' );
				}
			});

			// Remove dummy yes/no toggle
			newRow.find('#check__new__x__yesno__wrapper').remove();

			// Animate
			ips.utils.anim.go( 'fadeIn', newRow )
				.done( function () {
					// Hide the empty row if necessary
					_checkRows();
				});
				
			// Let the document know
			$( document ).trigger( 'contentChange', [ newRow ] );

			// Scroll to it
			$('html, body').animate( { scrollTop: String(newRow.offset().top) } );

			newRow.find('input,textarea,select').first().focus();
			
			return false;
		},

		/**
		 * Shows the 'empty' row if there's no real rows
		 *
		 * @returns {void}
		 */
		_checkRows = function () {
			if( elem.find('[data-matrixrowid]:visible').length > 0 ){
				elem.find('.ipsMatrix_empty').addClass('ipsHide');
			} else {
				elem.find('.ipsMatrix_empty').removeClass('ipsHide');
			}
		},

		/**
		 * Event handler for clicking an input within a cell
		 * Simply stops propagation
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_clickInputInCell = function (e) {
			e.stopPropagation();
		},

		/**
		 * Hooks into the submit event for the form, to wipe out the name on the blank row inputs
		 *
		 * @param 	{event} 	e 	Event object
		 * @returns {void}
		 */
		_submitForm = function (e) {
			// Remove names from the inputs in the blank row
			elem.find('[data-matrixrowid]:hidden')
				.find('input, select, textarea')
				.attr( 'name', '' )
				.prop( 'disabled', true );

			// Are we squashing fields?
			if( !options.squashFields ){
				return;
			}

			// Get all values from the matrix
			var formElements = elem.find('[data-matrixid] *').filter(':input:enabled:not([data-role="noMatrixSquash"])');
			var output = ips.utils.form.serializeAsObject( formElements );
			var matrixID = elem.find('[data-matrixid]').attr('data-matrixid');
			var newInput = $('<input />').attr('type', 'hidden').attr('name', matrixID + '_squashed');

			// JSON encode the data
			Debug.log("Before encoding, matrix data is:");
			Debug.log( output );			
			output = JSON.stringify( output );

			// Add a new hidden form field
			elem.prepend( newInput.val( output ) );

			// Disable all of the elements we squashed so that they don't get sent
			formElements.prop('disabled', true);
		},

		/**
		 * Initializes the blank row by removing the required attribute, and hiding it
		 *
		 * @returns {void}
		 */
		_setUpManageable = function () {
			elem.find('tr:last-child').find('input, select[required], textarea').removeAttr('required');
			elem.find('tbody tr:not( .ipsMatrix_empty ):last-child').hide();
		};

		init();

		return {
			init: init,
			checkRows: _checkRows
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="admin" javascript_path="ui" javascript_name="ips.ui.statusToggle.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000050">/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.statusToggle.js - Toggles things between enabled/disabled, online/offline etc.
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	&quot;use strict&quot;;

	ips.createModule('ips.ui.statusToggle', function(){

		/**
		 * Respond method for statusToggles
		 * Finds the active item, and determines the next state. Fires an ajax request to set the state,
		 * and updates the badge shown as needed.
		 *
		 * @param		{element} 	elem 		The element the widget is registered on
		 * @param		{object} 	options		Options object for this widget instance
		 * @param 		{event} 	e 			Event object
		 * @returns 	{void}
		 */
		var respond = function (elem, options, e) {
			e.preventDefault();

			elem = $( elem );
			
			if( elem.attr('data-loading') ){
				return;
			}

			// What's selected now?
			var currentBadge = elem.find('[data-state]:visible');
			var currentState = currentBadge.attr('data-state');
			var url = currentBadge.attr('href');
			
			// Don't do anything if the button opens a dialog
			if ( currentBadge.attr('data-ipsdialog' ) ) {
				return;
			}

			var nextState;

			if( options.intermediate ){
				nextState = ( currentState == 'enabled' ) ? 'intermediate' : ( currentState == 'disabled' ) ? 'enabled' : 'disabled';
			} else {
				nextState = ( currentState == 'enabled' ) ? 'disabled' : 'enabled';
			}

			var nextBadge = elem.find('[data-state=&quot;' + nextState + '&quot;]');

			if( !nextBadge.length ){
				Debug.warn( &quot;No badge found for &quot; + nextState + &quot; state&quot;);
				return;
			}

			elem.attr( 'data-loading', true );
			currentBadge.css({ opacity: &quot;0.5&quot; });

			// Send ajax request to make the change
			ips.getAjax()( url, {
				showLoading: true // show our global loading indicator
			})
				.done( function (response) {
					currentBadge.attr('hidden', '').css({ opacity: &quot;1&quot; });
					nextBadge.removeAttr('hidden');

					elem.removeAttr('data-loading');

					// Trigger an event to let the page know
					elem.trigger( 'stateChanged', {
						status: nextState
					});
				})
				.fail( function (jqXHR, textStatus, errorThrown) {
					window.location = url;
				});

		};

		ips.ui.registerWidget( 'statusToggle', ips.ui.statusToggle, [
			'intermediate'
		], { lazyLoad: true, lazyEvent: 'click' } );

		return {
			respond: respond
		};
	});
}(jQuery, _));</file>
 <file javascript_app="global" javascript_location="admin" javascript_path="ui" javascript_name="ips.ui.tree.js" javascript_type="ui" javascript_version="5001403" javascript_position="1000050"><![CDATA[/**
 * Invision Community
 * (c) Invision Power Services, Inc. - https://www.invisioncommunity.com
 *
 * ips.ui.tree.js - Tree widget
 *
 * Author: Rikki Tissier
 */
;( function($, _, undefined){
	"use strict";

	ips.createModule('ips.ui.tree', function(){

		var defaults = {
			openClass: 'ipsTree_open',
			closedClass: 'ipsTree_closed',
			searchable: false,
			sortable: true
		};

		var respond = function (elem, options) {
			if( !$( elem ).data('_tree') ){
				$( elem ).data('_tree', treeObj(elem, _.defaults( options, defaults ) ) );
			}
		};

		ips.ui.registerWidget( 'tree', ips.ui.tree, [
			'openClass', 'closedClass', 'searchable', 'results', 'url', 'sortable', 'lockParents', 'protectRoots'
		]);

		return {
			respond: respond
		};
	});

	/**
	 * Tree instance
	 *
	 * @param	{element} 	elem 		The element this widget is being created on
	 * @param	{object} 	options 	The options passed into this instance
	 * @returns {void}
	 */
	var treeObj = function (elem, options, e) {

		var _timer = null;
		var _searchAjax = null;
		var _currentParentOver = null;


		/**
		 * Sets up this instance
		 *
		 * @returns 	{void}
		 */
		var init = function () {

			if( !options.url ){
				Debug.error( "No URL provided for tree widget on " + elem.identify().attr('id') );
			}

			// Add a class to this widget so we can show/hide appropriate elements
			elem.addClass('ipsTree_js');
			
			// Set up sortables
			if( options.sortable ){
				_makeSortable();
			}
			/*$( elem ).find('.ipsTree_node').each( function () {
				_makeSortable( $( this ) );
			});*/


			// Set up events
			elem.on( 'click', '.ipsTree_parent:not(.ipsTree_noToggle)', _toggleRow ); 

			if( options.searchable && $( options.searchable ).length ){
				$( options.searchable )
					.on( 'keydown', _searchKeyPress )
					.on( 'search', _doSearch );
			}
		},

		/**
		 * Event handler for searching the tree
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		_searchKeyPress = function (e) {
			clearTimeout( _timer );
			_timer = setTimeout( _doSearch, 500 );
		},

		/**
		 * Executes a search
		 *
		 * @returns 	{void}
		 */
		_doSearch = function () {

			// Abort existing ajax if possible
			if( _searchAjax && _searchAjax.abort ){
				_searchAjax.abort();
			}

			var value = $( options.searchable ).val().trim();
			var searchPane = elem.find('[data-role="treeResults"]');
			var listPane = elem.find('[data-role="treeListing"]');

			if( !_.isEmpty( value ) ){
				// Show results pane
				listPane.hide();
				searchPane.show();

				// Set loading
				searchPane.html( ips.templates.render('core.trees.loadingPane') );

				// Do the search
				_searchAjax = ips.getAjax()( options.url + '&do=search', {
					data: {
						input: value
					}
				})
					.done( function (response) {
						// Show rows if there were results
						if( _.isEmpty( response.trim() ) ){
							searchPane.html( ips.templates.render('core.trees.noRows') );
						} else {
							searchPane.html( response );
							$( document ).trigger( 'contentChange', [ searchPane ] );							
						}
					});

			} else {
				listPane.show();
				searchPane.hide().html('');
			}
		},

		/**
		 * Event handler for clicking on a row
		 *
		 * @param 		{event} 	e 	Event object
		 * @returns 	{void}
		 */
		_toggleRow = function (e) {
			var target = $( e.target );
			var row = $( e.currentTarget );
			
			if( target.closest('.ipsTree_controls').length || target.closest('[data-ipsStatusToggle]').length ){
				return;
			}

			if( row.hasClass( options.openClass ) ){
				_closeRow( row );
			} else {
				_openRow( row );
			}
		},

		/**
		 * Closes an open row
		 *
		 * @param 		{element} 	row 	The row to close
		 * @returns 	{void}
		 */
		_closeRow = function (row) {
			row.removeClass( options.openClass ).addClass( options.closedClass );

			var realRow = row.closest('[data-role="node"]');
			var rowID = realRow.find('[data-nodeid]').first().attr('data-nodeid');

			if( realRow.find('> ol').length ){
				ips.utils.anim.go( 'fadeOut fast', realRow.find('> ol') );
			}
		},

		/**
		 * Opens a closed row
		 *
		 * @param 		{element} 	row 	The row to open
		 * @returns 	{void}
		 */
		_openRow = function (row) {
			row.removeClass( options.closedClass ).addClass( options.openClass );
			var realRow = row.closest('[data-role="node"]');
			
			var rowID = realRow.find('[data-nodeid]').first().attr('data-nodeid');
			realRow.attr('data-nodeid', rowID);

			if( _.isUndefined( rowID ) ){
				Debug.warn( 'No rowID for row ' + realRow.identify().attr('id') );
				return;
			}

			// Do we have results loaded or loading? Show them immediately if so
			if( realRow.data('_childrenLoaded') || realRow.data('_childrenLoading') ){
				ips.utils.anim.go('fadeInDown fast', realRow.find('> ol') );
				return;
			} 

			// Not loaded or loading, so we need to do that here
			// First build the loading box
			var loading = ips.templates.render('core.trees.loadingRow');
			var content = ips.templates.render('core.trees.childWrapper', {
				content: loading
			});

			// Set to loading, append loading content
			realRow
				.data('_childrenLoading', true)
				.append( content );

			// Fetch real content
			ips.getAjax()( options.url + '&root=' + rowID )
				.done( function (response) {
					const doc = (new DOMParser()).parseFromString(response, 'text/html').body;
					[...doc.querySelectorAll(':is(ol,ul).ipsTree > li')].forEach(el => {
						if (!el.querySelector(":scope > div")) {
							Debug.warn('A tree row has no child div element, which will break the sort functionality. One has been created to prevent errors, but the backend should not create <li> tags without a <div> directly inside it.');
							el.remove();
						}
					});
					realRow.find('> ol').remove();
					realRow.find('> .ipsTree_row').after(doc.innerHTML);

					realRow
						.data('_childrenLoaded', true)
						.removeData('_childrenLoading');

					// Now animate
					ips.utils.anim.go( 'fadeInDown', realRow.find('> ol') );

					// Let document know
					$( document ).trigger( 'contentChange', [ realRow ] );

					// Are we sorting?
					if( options.sortable ){
						elem.find('.ipsTree_rows > .ipsTree').nestedSortable('refresh');
						elem.find('.ipsTree_rows > .ipsTree').nestedSortable('refreshPositions');
						//_makeSortable( realRow.find('.ipsTree_node') );
					}
				})
				.fail( function () {
					window.location = options.url + '&root=' + rowID;
				});
		},

		_checkParentStatus = function () {
			Debug.log( 'check parent status' );

			// Find each tree row and loop
			elem.find('.ipsTree_row:not( .ipsTree_root )').each( function () {
				var row = $( this );

				// Ignore if the row is closed since we don't know what's inside it
				if( row.hasClass('ipsTree_parent') && !row.hasClass('ipsTree_open') ){
					return;
				}

				var subList = row.siblings('ol');
				var currentlyParent = row.is('ipsTree_parent');
				var hasChildren = subList.find('> li').length > 0;

				Debug.log( 'sublist: ');
				Debug.log( subList );

				row.toggleClass('ipsTree_parent', hasChildren );

				if( hasChildren && !currentlyParent ){
					row.addClass('ipsTree_open');
				}

				// sortable removes the <ol> if it's now empty, so we need to add it back here
				// so that the user can carry on sorting properly
				if( row.hasClass('ipsTree_acceptsChildren') && !subList.length ){
					var newRow = $('<ol/>').addClass('ipsTree ipsTree_node');
					row.after( newRow );
					//newRow.find('li').remove();
				}
			});
		},

		/**
		 * Makes the tree sortable
		 *
		 * @returns 	{void}
		 */
		_makeSortable = function () {
			var sortableOptions = {
				placeholder: 'sortable-placeholder',
				handle: '.ipsTree_dragHandle',
				items: '[data-role="node"]',
				excludeRoot: true,
				update: function (event, ui) {
					var url = options.url + '&do=reorder';
					var rootID = elem.find('.ipsTree_root').attr('data-nodeid');
					var data = '';

					// We need to run this after a short delay to let sortable clean itself up first
					setTimeout( function () {
						_checkParentStatus();	
					}, 200);					

					let failed = false;
					if( rootID ){
						url += '&root=' + rootID;

						// If we have a root item (that isn't technically part of the tree) we can't
						// use the standard serialize method or all items have the value null. Instead
						// we have to build a manual param string and replace null with the parent id.
						var dataArray = $( this ).nestedSortable( 'toArray', { key: 'ajax_order'} );
						var outputArray = [];

						for( var i = 0; i < dataArray.length; i++ ) {
							let id = dataArray[i].item_id !== undefined ? dataArray[i].item_id : dataArray[i].id;
							if ( [undefined, null, NaN].includes(id) ) {
								failed = true;
								break;
							}
							outputArray.push( 'ajax_order[' + id + ']=' + ( ( dataArray[i].parent_id == null ) ? rootID : dataArray[i].parent_id ) );
						}

						data = outputArray.join('&');
					} else {
						data = $( this ).nestedSortable( 'serialize', { key: 'ajax_order' } );	
					}

					if (failed) {
						window.location.reload();
					}

					data = data + '&csrfKey=' + ips.getSetting('csrfKey');
					ips.getAjax()( url, {
						data: data,
						method: 'POST'
					})
						.fail( function () {
							window.location = url + "&" + data;
						});
				},
				toleranceElement: '> div',
				listType: 'ol',
				isTree: true,
				// Called by nestedSortable to determine whether an item can be dragged into
				// the current location. We check for the ipsTree_acceptsChildren class which
				// indicates it can be a parent item.
				isAllowed: function (placeholder, placeholderParent, currentItem) {
					// Hide tooltip
					$('#ipsTooltip')[0].hidePopover();

					var parent = null;

					// Find nearest list
					if( _.isUndefined( placeholderParent ) || placeholderParent === null ){
						parent = elem.find('> .ipsTree_root');
					} else {
						parent = placeholderParent.closest('[data-role="node"]').find('> .ipsTree_row');	
					}			
					
					if( parent.hasClass('ipsTree_acceptsChildren') || ( !parent.length && !currentItem.find('> .ipsTree_row').hasClass('ipsTree_noRoot') ) ) {
						placeholder.removeAttr('data-error');
						return true;
					} else {
						placeholder.attr('data-error', ips.getString('cannotDragInto') );
						return false;
					}
				},
				// This method is triggered by nestedSortable, and we piggy pack on it to call our _openRow
				// method to load closed nodes. _openRow calls the refresh() method of nestedSortable to enable
				// the item currently being dragged to be dropped in the newly-opened list. Phew.
				expand: function (event, ui) {
					var row = $( this ).find('.mjs-nestedSortable-hovering > .ipsTree_parent[data-nodeid]').first();

					if( !row.hasClass('ipsTree_open') ){
						_openRow( row );	
					}					
				},
				// Triggered when the dom position of the item changes.
				// We highlight the parent of the new position so it's clearer to users where the item is going
				change: function (event, ui) {
					// Remove the class from everywhere first
					$( this ).find('.ipsTree_draggingInto').removeClass('ipsTree_draggingInto');

					// Find the nearest list
					ui.placeholder.closest('[data-role="node"]').find('> .ipsTree_row').addClass('ipsTree_draggingInto');
				},
				// Triggered when dragging starts
				// Highlight the current parent
				start: function (event, ui) {
					// Find the nearest list
					ui.placeholder.closest('[data-role="node"]').find('> .ipsTree_row').addClass('ipsTree_draggingInto');
				},
				// Triggered when dragging stops
				// Remove all parent highlights
				stop: function (event, ui) {
					$( this ).find('.ipsTree_draggingInto').removeClass('ipsTree_draggingInto');
				}
			};

			// Locks the parents, allowing any items to be reordered but not moved out of their current list
			if( options.lockParents ){
				sortableOptions['disableParentChange'] = true;
			}

			// Protects the root items, preventing them from being turned into subitems, or subitems to be turned into roots
			if( options.protectRoots ){
				sortableOptions['protectRoot'] = true;
			}

			// Create the sortable
			elem.find('.ipsTree_rows > .ipsTree').nestedSortable( sortableOptions );
		};

		init();

		return {
			init: init
		};
	};
}(jQuery, _));]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="underscore" javascript_name="underscore.js" javascript_type="framework" javascript_version="5001403" javascript_position="50"><![CDATA[!function(n,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define("underscore",r):(n="undefined"!=typeof globalThis?globalThis:n||self,function(){var t=n._,e=n._=r();e.noConflict=function(){return n._=t,e}}())}(this,(function(){
    //     Underscore.js 1.13.1
    //     https://underscorejs.org
    //     (c) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    var n="1.13.1",r="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||Function("return this")()||{},t=Array.prototype,e=Object.prototype,u="undefined"!=typeof Symbol?Symbol.prototype:null,o=t.push,i=t.slice,a=e.toString,f=e.hasOwnProperty,c="undefined"!=typeof ArrayBuffer,l="undefined"!=typeof DataView,s=Array.isArray,p=Object.keys,v=Object.create,h=c&&ArrayBuffer.isView,y=isNaN,d=isFinite,g=!{toString:null}.propertyIsEnumerable("toString"),b=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],m=Math.pow(2,53)-1;function j(n,r){return r=null==r?n.length-1:+r,function(){for(var t=Math.max(arguments.length-r,0),e=Array(t),u=0;u<t;u++)e[u]=arguments[u+r];switch(r){case 0:return n.call(this,e);case 1:return n.call(this,arguments[0],e);case 2:return n.call(this,arguments[0],arguments[1],e)}var o=Array(r+1);for(u=0;u<r;u++)o[u]=arguments[u];return o[r]=e,n.apply(this,o)}}function _(n){var r=typeof n;return"function"===r||"object"===r&&!!n}function w(n){return void 0===n}function A(n){return!0===n||!1===n||"[object Boolean]"===a.call(n)}function x(n){var r="[object "+n+"]";return function(n){return a.call(n)===r}}var S=x("String"),O=x("Number"),M=x("Date"),E=x("RegExp"),B=x("Error"),N=x("Symbol"),I=x("ArrayBuffer"),T=x("Function"),k=r.document&&r.document.childNodes;"function"!=typeof/./&&"object"!=typeof Int8Array&&"function"!=typeof k&&(T=function(n){return"function"==typeof n||!1});var D=T,R=x("Object"),F=l&&R(new DataView(new ArrayBuffer(8))),V="undefined"!=typeof Map&&R(new Map),P=x("DataView");var q=F?function(n){return null!=n&&D(n.getInt8)&&I(n.buffer)}:P,U=s||x("Array");function W(n,r){return null!=n&&f.call(n,r)}var z=x("Arguments");!function(){z(arguments)||(z=function(n){return W(n,"callee")})}();var L=z;function $(n){return O(n)&&y(n)}function C(n){return function(){return n}}function K(n){return function(r){var t=n(r);return"number"==typeof t&&t>=0&&t<=m}}function J(n){return function(r){return null==r?void 0:r[n]}}var G=J("byteLength"),H=K(G),Q=/\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;var X=c?function(n){return h?h(n)&&!q(n):H(n)&&Q.test(a.call(n))}:C(!1),Y=J("length");function Z(n,r){r=function(n){for(var r={},t=n.length,e=0;e<t;++e)r[n[e]]=!0;return{contains:function(n){return r[n]},push:function(t){return r[t]=!0,n.push(t)}}}(r);var t=b.length,u=n.constructor,o=D(u)&&u.prototype||e,i="constructor";for(W(n,i)&&!r.contains(i)&&r.push(i);t--;)(i=b[t])in n&&n[i]!==o[i]&&!r.contains(i)&&r.push(i)}function nn(n){if(!_(n))return[];if(p)return p(n);var r=[];for(var t in n)W(n,t)&&r.push(t);return g&&Z(n,r),r}function rn(n,r){var t=nn(r),e=t.length;if(null==n)return!e;for(var u=Object(n),o=0;o<e;o++){var i=t[o];if(r[i]!==u[i]||!(i in u))return!1}return!0}function tn(n){return n instanceof tn?n:this instanceof tn?void(this._wrapped=n):new tn(n)}function en(n){return new Uint8Array(n.buffer||n,n.byteOffset||0,G(n))}tn.VERSION=n,tn.prototype.value=function(){return this._wrapped},tn.prototype.valueOf=tn.prototype.toJSON=tn.prototype.value,tn.prototype.toString=function(){return String(this._wrapped)};var un="[object DataView]";function on(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(null==n||null==r)return!1;if(n!=n)return r!=r;var o=typeof n;return("function"===o||"object"===o||"object"==typeof r)&&function n(r,t,e,o){r instanceof tn&&(r=r._wrapped);t instanceof tn&&(t=t._wrapped);var i=a.call(r);if(i!==a.call(t))return!1;if(F&&"[object Object]"==i&&q(r)){if(!q(t))return!1;i=un}switch(i){case"[object RegExp]":case"[object String]":return""+r==""+t;case"[object Number]":return+r!=+r?+t!=+t:0==+r?1/+r==1/t:+r==+t;case"[object Date]":case"[object Boolean]":return+r==+t;case"[object Symbol]":return u.valueOf.call(r)===u.valueOf.call(t);case"[object ArrayBuffer]":case un:return n(en(r),en(t),e,o)}var f="[object Array]"===i;if(!f&&X(r)){if(G(r)!==G(t))return!1;if(r.buffer===t.buffer&&r.byteOffset===t.byteOffset)return!0;f=!0}if(!f){if("object"!=typeof r||"object"!=typeof t)return!1;var c=r.constructor,l=t.constructor;if(c!==l&&!(D(c)&&c instanceof c&&D(l)&&l instanceof l)&&"constructor"in r&&"constructor"in t)return!1}o=o||[];var s=(e=e||[]).length;for(;s--;)if(e[s]===r)return o[s]===t;if(e.push(r),o.push(t),f){if((s=r.length)!==t.length)return!1;for(;s--;)if(!on(r[s],t[s],e,o))return!1}else{var p,v=nn(r);if(s=v.length,nn(t).length!==s)return!1;for(;s--;)if(p=v[s],!W(t,p)||!on(r[p],t[p],e,o))return!1}return e.pop(),o.pop(),!0}(n,r,t,e)}function an(n){if(!_(n))return[];var r=[];for(var t in n)r.push(t);return g&&Z(n,r),r}function fn(n){var r=Y(n);return function(t){if(null==t)return!1;var e=an(t);if(Y(e))return!1;for(var u=0;u<r;u++)if(!D(t[n[u]]))return!1;return n!==hn||!D(t[cn])}}var cn="forEach",ln="has",sn=["clear","delete"],pn=["get",ln,"set"],vn=sn.concat(cn,pn),hn=sn.concat(pn),yn=["add"].concat(sn,cn,ln),dn=V?fn(vn):x("Map"),gn=V?fn(hn):x("WeakMap"),bn=V?fn(yn):x("Set"),mn=x("WeakSet");function jn(n){for(var r=nn(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=n[r[u]];return e}function _n(n){for(var r={},t=nn(n),e=0,u=t.length;e<u;e++)r[n[t[e]]]=t[e];return r}function wn(n){var r=[];for(var t in n)D(n[t])&&r.push(t);return r.sort()}function An(n,r){return function(t){var e=arguments.length;if(r&&(t=Object(t)),e<2||null==t)return t;for(var u=1;u<e;u++)for(var o=arguments[u],i=n(o),a=i.length,f=0;f<a;f++){var c=i[f];r&&void 0!==t[c]||(t[c]=o[c])}return t}}var xn=An(an),Sn=An(nn),On=An(an,!0);function Mn(n){if(!_(n))return{};if(v)return v(n);var r=function(){};r.prototype=n;var t=new r;return r.prototype=null,t}function En(n){return _(n)?U(n)?n.slice():xn({},n):n}function Bn(n){return U(n)?n:[n]}function Nn(n){return tn.toPath(n)}function In(n,r){for(var t=r.length,e=0;e<t;e++){if(null==n)return;n=n[r[e]]}return t?n:void 0}function Tn(n,r,t){var e=In(n,Nn(r));return w(e)?t:e}function kn(n){return n}function Dn(n){return n=Sn({},n),function(r){return rn(r,n)}}function Rn(n){return n=Nn(n),function(r){return In(r,n)}}function Fn(n,r,t){if(void 0===r)return n;switch(null==t?3:t){case 1:return function(t){return n.call(r,t)};case 3:return function(t,e,u){return n.call(r,t,e,u)};case 4:return function(t,e,u,o){return n.call(r,t,e,u,o)}}return function(){return n.apply(r,arguments)}}function Vn(n,r,t){return null==n?kn:D(n)?Fn(n,r,t):_(n)&&!U(n)?Dn(n):Rn(n)}function Pn(n,r){return Vn(n,r,1/0)}function qn(n,r,t){return tn.iteratee!==Pn?tn.iteratee(n,r):Vn(n,r,t)}function Un(){}function Wn(n,r){return null==r&&(r=n,n=0),n+Math.floor(Math.random()*(r-n+1))}tn.toPath=Bn,tn.iteratee=Pn;var zn=Date.now||function(){return(new Date).getTime()};function Ln(n){var r=function(r){return n[r]},t="(?:"+nn(n).join("|")+")",e=RegExp(t),u=RegExp(t,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,r):n}}var $n={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},Cn=Ln($n),Kn=Ln(_n($n)),Jn=tn.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g},Gn=/(.)^/,Hn={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},Qn=/\\|'|\r|\n|\u2028|\u2029/g;function Xn(n){return"\\"+Hn[n]}var Yn=/^\s*(\w|\$)+\s*$/;var Zn=0;function nr(n,r,t,e,u){if(!(e instanceof r))return n.apply(t,u);var o=Mn(n.prototype),i=n.apply(o,u);return _(i)?i:o}var rr=j((function(n,r){var t=rr.placeholder,e=function(){for(var u=0,o=r.length,i=Array(o),a=0;a<o;a++)i[a]=r[a]===t?arguments[u++]:r[a];for(;u<arguments.length;)i.push(arguments[u++]);return nr(n,e,this,this,i)};return e}));rr.placeholder=tn;var tr=j((function(n,r,t){if(!D(n))throw new TypeError("Bind must be called on a function");var e=j((function(u){return nr(n,e,r,this,t.concat(u))}));return e})),er=K(Y);function ur(n,r,t,e){if(e=e||[],r||0===r){if(r<=0)return e.concat(n)}else r=1/0;for(var u=e.length,o=0,i=Y(n);o<i;o++){var a=n[o];if(er(a)&&(U(a)||L(a)))if(r>1)ur(a,r-1,t,e),u=e.length;else for(var f=0,c=a.length;f<c;)e[u++]=a[f++];else t||(e[u++]=a)}return e}var or=j((function(n,r){var t=(r=ur(r,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var e=r[t];n[e]=tr(n[e],n)}return n}));var ir=j((function(n,r,t){return setTimeout((function(){return n.apply(null,t)}),r)})),ar=rr(ir,tn,1);function fr(n){return function(){return!n.apply(this,arguments)}}function cr(n,r){var t;return function(){return--n>0&&(t=r.apply(this,arguments)),n<=1&&(r=null),t}}var lr=rr(cr,2);function sr(n,r,t){r=qn(r,t);for(var e,u=nn(n),o=0,i=u.length;o<i;o++)if(r(n[e=u[o]],e,n))return e}function pr(n){return function(r,t,e){t=qn(t,e);for(var u=Y(r),o=n>0?0:u-1;o>=0&&o<u;o+=n)if(t(r[o],o,r))return o;return-1}}var vr=pr(1),hr=pr(-1);function yr(n,r,t,e){for(var u=(t=qn(t,e,1))(r),o=0,i=Y(n);o<i;){var a=Math.floor((o+i)/2);t(n[a])<u?o=a+1:i=a}return o}function dr(n,r,t){return function(e,u,o){var a=0,f=Y(e);if("number"==typeof o)n>0?a=o>=0?o:Math.max(o+f,a):f=o>=0?Math.min(o+1,f):o+f+1;else if(t&&o&&f)return e[o=t(e,u)]===u?o:-1;if(u!=u)return(o=r(i.call(e,a,f),$))>=0?o+a:-1;for(o=n>0?a:f-1;o>=0&&o<f;o+=n)if(e[o]===u)return o;return-1}}var gr=dr(1,vr,yr),br=dr(-1,hr);function mr(n,r,t){var e=(er(n)?vr:sr)(n,r,t);if(void 0!==e&&-1!==e)return n[e]}function jr(n,r,t){var e,u;if(r=Fn(r,t),er(n))for(e=0,u=n.length;e<u;e++)r(n[e],e,n);else{var o=nn(n);for(e=0,u=o.length;e<u;e++)r(n[o[e]],o[e],n)}return n}function _r(n,r,t){r=qn(r,t);for(var e=!er(n)&&nn(n),u=(e||n).length,o=Array(u),i=0;i<u;i++){var a=e?e[i]:i;o[i]=r(n[a],a,n)}return o}function wr(n){var r=function(r,t,e,u){var o=!er(r)&&nn(r),i=(o||r).length,a=n>0?0:i-1;for(u||(e=r[o?o[a]:a],a+=n);a>=0&&a<i;a+=n){var f=o?o[a]:a;e=t(e,r[f],f,r)}return e};return function(n,t,e,u){var o=arguments.length>=3;return r(n,Fn(t,u,4),e,o)}}var Ar=wr(1),xr=wr(-1);function Sr(n,r,t){var e=[];return r=qn(r,t),jr(n,(function(n,t,u){r(n,t,u)&&e.push(n)})),e}function Or(n,r,t){r=qn(r,t);for(var e=!er(n)&&nn(n),u=(e||n).length,o=0;o<u;o++){var i=e?e[o]:o;if(!r(n[i],i,n))return!1}return!0}function Mr(n,r,t){r=qn(r,t);for(var e=!er(n)&&nn(n),u=(e||n).length,o=0;o<u;o++){var i=e?e[o]:o;if(r(n[i],i,n))return!0}return!1}function Er(n,r,t,e){return er(n)||(n=jn(n)),("number"!=typeof t||e)&&(t=0),gr(n,r,t)>=0}var Br=j((function(n,r,t){var e,u;return D(r)?u=r:(r=Nn(r),e=r.slice(0,-1),r=r[r.length-1]),_r(n,(function(n){var o=u;if(!o){if(e&&e.length&&(n=In(n,e)),null==n)return;o=n[r]}return null==o?o:o.apply(n,t)}))}));function Nr(n,r){return _r(n,Rn(r))}function Ir(n,r,t){var e,u,o=-1/0,i=-1/0;if(null==r||"number"==typeof r&&"object"!=typeof n[0]&&null!=n)for(var a=0,f=(n=er(n)?n:jn(n)).length;a<f;a++)null!=(e=n[a])&&e>o&&(o=e);else r=qn(r,t),jr(n,(function(n,t,e){((u=r(n,t,e))>i||u===-1/0&&o===-1/0)&&(o=n,i=u)}));return o}function Tr(n,r,t){if(null==r||t)return er(n)||(n=jn(n)),n[Wn(n.length-1)];var e=er(n)?En(n):jn(n),u=Y(e);r=Math.max(Math.min(r,u),0);for(var o=u-1,i=0;i<r;i++){var a=Wn(i,o),f=e[i];e[i]=e[a],e[a]=f}return e.slice(0,r)}function kr(n,r){return function(t,e,u){var o=r?[[],[]]:{};return e=qn(e,u),jr(t,(function(r,u){var i=e(r,u,t);n(o,r,i)})),o}}var Dr=kr((function(n,r,t){W(n,t)?n[t].push(r):n[t]=[r]})),Rr=kr((function(n,r,t){n[t]=r})),Fr=kr((function(n,r,t){W(n,t)?n[t]++:n[t]=1})),Vr=kr((function(n,r,t){n[t?0:1].push(r)}),!0),Pr=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;function qr(n,r,t){return r in t}var Ur=j((function(n,r){var t={},e=r[0];if(null==n)return t;D(e)?(r.length>1&&(e=Fn(e,r[1])),r=an(n)):(e=qr,r=ur(r,!1,!1),n=Object(n));for(var u=0,o=r.length;u<o;u++){var i=r[u],a=n[i];e(a,i,n)&&(t[i]=a)}return t})),Wr=j((function(n,r){var t,e=r[0];return D(e)?(e=fr(e),r.length>1&&(t=r[1])):(r=_r(ur(r,!1,!1),String),e=function(n,t){return!Er(r,t)}),Ur(n,e,t)}));function zr(n,r,t){return i.call(n,0,Math.max(0,n.length-(null==r||t?1:r)))}function Lr(n,r,t){return null==n||n.length<1?null==r||t?void 0:[]:null==r||t?n[0]:zr(n,n.length-r)}function $r(n,r,t){return i.call(n,null==r||t?1:r)}var Cr=j((function(n,r){return r=ur(r,!0,!0),Sr(n,(function(n){return!Er(r,n)}))})),Kr=j((function(n,r){return Cr(n,r)}));function Jr(n,r,t,e){A(r)||(e=t,t=r,r=!1),null!=t&&(t=qn(t,e));for(var u=[],o=[],i=0,a=Y(n);i<a;i++){var f=n[i],c=t?t(f,i,n):f;r&&!t?(i&&o===c||u.push(f),o=c):t?Er(o,c)||(o.push(c),u.push(f)):Er(u,f)||u.push(f)}return u}var Gr=j((function(n){return Jr(ur(n,!0,!0))}));function Hr(n){for(var r=n&&Ir(n,Y).length||0,t=Array(r),e=0;e<r;e++)t[e]=Nr(n,e);return t}var Qr=j(Hr);function Xr(n,r){return n._chain?tn(r).chain():r}function Yr(n){return jr(wn(n),(function(r){var t=tn[r]=n[r];tn.prototype[r]=function(){var n=[this._wrapped];return o.apply(n,arguments),Xr(this,t.apply(tn,n))}})),tn}jr(["pop","push","reverse","shift","sort","splice","unshift"],(function(n){var r=t[n];tn.prototype[n]=function(){var t=this._wrapped;return null!=t&&(r.apply(t,arguments),"shift"!==n&&"splice"!==n||0!==t.length||delete t[0]),Xr(this,t)}})),jr(["concat","join","slice"],(function(n){var r=t[n];tn.prototype[n]=function(){var n=this._wrapped;return null!=n&&(n=r.apply(n,arguments)),Xr(this,n)}}));var Zr=Yr({__proto__:null,VERSION:n,restArguments:j,isObject:_,isNull:function(n){return null===n},isUndefined:w,isBoolean:A,isElement:function(n){return!(!n||1!==n.nodeType)},isString:S,isNumber:O,isDate:M,isRegExp:E,isError:B,isSymbol:N,isArrayBuffer:I,isDataView:q,isArray:U,isFunction:D,isArguments:L,isFinite:function(n){return!N(n)&&d(n)&&!isNaN(parseFloat(n))},isNaN:$,isTypedArray:X,isEmpty:function(n){if(null==n)return!0;var r=Y(n);return"number"==typeof r&&(U(n)||S(n)||L(n))?0===r:0===Y(nn(n))},isMatch:rn,isEqual:function(n,r){return on(n,r)},isMap:dn,isWeakMap:gn,isSet:bn,isWeakSet:mn,keys:nn,allKeys:an,values:jn,pairs:function(n){for(var r=nn(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=[r[u],n[r[u]]];return e},invert:_n,functions:wn,methods:wn,extend:xn,extendOwn:Sn,assign:Sn,defaults:On,create:function(n,r){var t=Mn(n);return r&&Sn(t,r),t},clone:En,tap:function(n,r){return r(n),n},get:Tn,has:function(n,r){for(var t=(r=Nn(r)).length,e=0;e<t;e++){var u=r[e];if(!W(n,u))return!1;n=n[u]}return!!t},mapObject:function(n,r,t){r=qn(r,t);for(var e=nn(n),u=e.length,o={},i=0;i<u;i++){var a=e[i];o[a]=r(n[a],a,n)}return o},identity:kn,constant:C,noop:Un,toPath:Bn,property:Rn,propertyOf:function(n){return null==n?Un:function(r){return Tn(n,r)}},matcher:Dn,matches:Dn,times:function(n,r,t){var e=Array(Math.max(0,n));r=Fn(r,t,1);for(var u=0;u<n;u++)e[u]=r(u);return e},random:Wn,now:zn,escape:Cn,unescape:Kn,templateSettings:Jn,template:function(n,r,t){!r&&t&&(r=t),r=On({},r,tn.templateSettings);var e=RegExp([(r.escape||Gn).source,(r.interpolate||Gn).source,(r.evaluate||Gn).source].join("|")+"|$","g"),u=0,o="__p+='";n.replace(e,(function(r,t,e,i,a){return o+=n.slice(u,a).replace(Qn,Xn),u=a+r.length,t?o+="'+\n((__t=("+t+"))==null?'':_.escape(__t))+\n'":e?o+="'+\n((__t=("+e+"))==null?'':__t)+\n'":i&&(o+="';\n"+i+"\n__p+='"),r})),o+="';\n";var i,a=r.variable;if(a){if(!Yn.test(a))throw new Error("variable is not a bare identifier: "+a)}else o="with(obj||{}){\n"+o+"}\n",a="obj";o="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+o+"return __p;\n";try{i=new Function(a,"_",o)}catch(n){throw n.source=o,n}var f=function(n){return i.call(this,n,tn)};return f.source="function("+a+"){\n"+o+"}",f},result:function(n,r,t){var e=(r=Nn(r)).length;if(!e)return D(t)?t.call(n):t;for(var u=0;u<e;u++){var o=null==n?void 0:n[r[u]];void 0===o&&(o=t,u=e),n=D(o)?o.call(n):o}return n},uniqueId:function(n){var r=++Zn+"";return n?n+r:r},chain:function(n){var r=tn(n);return r._chain=!0,r},iteratee:Pn,partial:rr,bind:tr,bindAll:or,memoize:function(n,r){var t=function(e){var u=t.cache,o=""+(r?r.apply(this,arguments):e);return W(u,o)||(u[o]=n.apply(this,arguments)),u[o]};return t.cache={},t},delay:ir,defer:ar,throttle:function(n,r,t){var e,u,o,i,a=0;t||(t={});var f=function(){a=!1===t.leading?0:zn(),e=null,i=n.apply(u,o),e||(u=o=null)},c=function(){var c=zn();a||!1!==t.leading||(a=c);var l=r-(c-a);return u=this,o=arguments,l<=0||l>r?(e&&(clearTimeout(e),e=null),a=c,i=n.apply(u,o),e||(u=o=null)):e||!1===t.trailing||(e=setTimeout(f,l)),i};return c.cancel=function(){clearTimeout(e),a=0,e=u=o=null},c},debounce:function(n,r,t){var e,u,o,i,a,f=function(){var c=zn()-u;r>c?e=setTimeout(f,r-c):(e=null,t||(i=n.apply(a,o)),e||(o=a=null))},c=j((function(c){return a=this,o=c,u=zn(),e||(e=setTimeout(f,r),t&&(i=n.apply(a,o))),i}));return c.cancel=function(){clearTimeout(e),e=o=a=null},c},wrap:function(n,r){return rr(r,n)},negate:fr,compose:function(){var n=arguments,r=n.length-1;return function(){for(var t=r,e=n[r].apply(this,arguments);t--;)e=n[t].call(this,e);return e}},after:function(n,r){return function(){if(--n<1)return r.apply(this,arguments)}},before:cr,once:lr,findKey:sr,findIndex:vr,findLastIndex:hr,sortedIndex:yr,indexOf:gr,lastIndexOf:br,find:mr,detect:mr,findWhere:function(n,r){return mr(n,Dn(r))},each:jr,forEach:jr,map:_r,collect:_r,reduce:Ar,foldl:Ar,inject:Ar,reduceRight:xr,foldr:xr,filter:Sr,select:Sr,reject:function(n,r,t){return Sr(n,fr(qn(r)),t)},every:Or,all:Or,some:Mr,any:Mr,contains:Er,includes:Er,include:Er,invoke:Br,pluck:Nr,where:function(n,r){return Sr(n,Dn(r))},max:Ir,min:function(n,r,t){var e,u,o=1/0,i=1/0;if(null==r||"number"==typeof r&&"object"!=typeof n[0]&&null!=n)for(var a=0,f=(n=er(n)?n:jn(n)).length;a<f;a++)null!=(e=n[a])&&e<o&&(o=e);else r=qn(r,t),jr(n,(function(n,t,e){((u=r(n,t,e))<i||u===1/0&&o===1/0)&&(o=n,i=u)}));return o},shuffle:function(n){return Tr(n,1/0)},sample:Tr,sortBy:function(n,r,t){var e=0;return r=qn(r,t),Nr(_r(n,(function(n,t,u){return{value:n,index:e++,criteria:r(n,t,u)}})).sort((function(n,r){var t=n.criteria,e=r.criteria;if(t!==e){if(t>e||void 0===t)return 1;if(t<e||void 0===e)return-1}return n.index-r.index})),"value")},groupBy:Dr,indexBy:Rr,countBy:Fr,partition:Vr,toArray:function(n){return n?U(n)?i.call(n):S(n)?n.match(Pr):er(n)?_r(n,kn):jn(n):[]},size:function(n){return null==n?0:er(n)?n.length:nn(n).length},pick:Ur,omit:Wr,first:Lr,head:Lr,take:Lr,initial:zr,last:function(n,r,t){return null==n||n.length<1?null==r||t?void 0:[]:null==r||t?n[n.length-1]:$r(n,Math.max(0,n.length-r))},rest:$r,tail:$r,drop:$r,compact:function(n){return Sr(n,Boolean)},flatten:function(n,r){return ur(n,r,!1)},without:Kr,uniq:Jr,unique:Jr,union:Gr,intersection:function(n){for(var r=[],t=arguments.length,e=0,u=Y(n);e<u;e++){var o=n[e];if(!Er(r,o)){var i;for(i=1;i<t&&Er(arguments[i],o);i++);i===t&&r.push(o)}}return r},difference:Cr,unzip:Hr,transpose:Hr,zip:Qr,object:function(n,r){for(var t={},e=0,u=Y(n);e<u;e++)r?t[n[e]]=r[e]:t[n[e][0]]=n[e][1];return t},range:function(n,r,t){null==r&&(r=n||0,n=0),t||(t=r<n?-1:1);for(var e=Math.max(Math.ceil((r-n)/t),0),u=Array(e),o=0;o<e;o++,n+=t)u[o]=n;return u},chunk:function(n,r){if(null==r||r<1)return[];for(var t=[],e=0,u=n.length;e<u;)t.push(i.call(n,e,e+=r));return t},mixin:Yr,default:tn});return Zr._=Zr,Zr}));]]></file>
 <file javascript_app="global" javascript_location="library" javascript_path="xregexp" javascript_name="xregexp-all.js" javascript_type="framework" javascript_version="5001403" javascript_position="1000450"><![CDATA[(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.XRegExp = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * XRegExp.build 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2012-2017 MIT License
 * Inspired by Lea Verou's RegExp.create <lea.verou.me>
 */

module.exports = function(XRegExp) {
    'use strict';

    var REGEX_DATA = 'xregexp';
    var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g', {
        conjunction: 'or'
    });

    /**
     * Strips a leading `^` and trailing unescaped `$`, if both are present.
     *
     * @private
     * @param {String} pattern Pattern to process.
     * @returns {String} Pattern with edge anchors removed.
     */
    function deanchor(pattern) {
        // Allow any number of empty noncapturing groups before/after anchors, because regexes
        // built/generated by XRegExp sometimes include them
        var leadingAnchor = /^(?:\(\?:\))*\^/;
        var trailingAnchor = /\$(?:\(\?:\))*$/;

        if (
            leadingAnchor.test(pattern) &&
            trailingAnchor.test(pattern) &&
            // Ensure that the trailing `$` isn't escaped
            trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))
        ) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

    /**
     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
     *
     * @private
     * @param {String|RegExp} value Value to convert.
     * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
     *   already a regex generated by XRegExp
     * @returns {RegExp} XRegExp object with XRegExp syntax applied.
     */
    function asXRegExp(value, addFlagX) {
        var flags = addFlagX ? 'x' : '';
        return XRegExp.isRegExp(value) ?
            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                // Don't recompile, to preserve capture names
                value :
                // Recompile as XRegExp
                XRegExp(value.source, flags)
            ) :
            // Compile string as XRegExp
            XRegExp(value, flags);
    }

    /**
     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
     *
     * @memberOf XRegExp
     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
     *   character classes.
     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
     * @param {String} [flags] Any combination of XRegExp flags.
     * @returns {RegExp} Regex with interpolated subpatterns.
     * @example
     *
     * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
     *     h12: /1[0-2]|0?[1-9]/,
     *     h24: /2[0-3]|[01][0-9]/
     *   }, 'x'),
     *   minutes: /^[0-5][0-9]$/
     * });
     * time.test('10:59'); // -> true
     * XRegExp.exec('10:59', time).minutes; // -> '59'
     */
    XRegExp.build = function(pattern, subs, flags) {
        flags = flags || '';
        // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
        // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
        // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.
        var addFlagX = flags.indexOf('x') > -1;
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
        }

        var data = {};
        for (var p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity.
                var sub = asXRegExp(subs[p], addFlagX);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`).
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back.
        var patternAsRegex = asXRegExp(pattern, addFlagX);

        // 'Caps' is short for 'captures'
        var numCaps = 0;
        var numPriorCaps;
        var numOuterCaps = 0;
        var outerCapsMap = [0];
        var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
        var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
            var subName = $1 || $2;
            var capName;
            var intro;
            var localCapIndex;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                    // Backreference
                    } else if (backref) {
                        localCapIndex = +backref - 1;
                        // Rewrite the backreference
                        return data[subName].names[localCapIndex] ?
                            // Need to preserve the backreference name in case using flag `n`
                            '\\k<' + data[subName].names[localCapIndex] + '>' :
                            '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                }) + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
            // Backreference
            } else if ($4) {
                localCapIndex = +$4 - 1;
                // Rewrite the backreference
                return outerCapNames[localCapIndex] ?
                    // Need to preserve the backreference name in case using flag `n`
                    '\\k<' + outerCapNames[localCapIndex] + '>' :
                    '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(output, flags);
    };

};

},{}],2:[function(require,module,exports){
/*!
 * XRegExp.matchRecursive 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2009-2017 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Returns a match detail object composed of the provided values.
     *
     * @private
     */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

    /**
     * Returns an array of match strings between outermost left and right delimiters, or an array of
     * objects with detailed match parts and position data. An error is thrown if delimiters are
     * unbalanced within the data.
     *
     * @memberOf XRegExp
     * @param {String} str String to search.
     * @param {String} left Left delimiter as an XRegExp pattern.
     * @param {String} right Right delimiter as an XRegExp pattern.
     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
     * @returns {Array} Array of matches, or an empty array.
     * @example
     *
     * // Basic usage
     * var str = '(t((e))s)t()(ing)';
     * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
     * // -> ['t((e))s', '', 'ing']
     *
     * // Extended information mode with valueNames
     * str = 'Here is <div> <div>an</div></div> example';
     * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
     *   valueNames: ['between', 'left', 'match', 'right']
     * });
     * // -> [
     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
     * // {name: 'right',   value: '</div>',         start: 27, end: 33},
     * // {name: 'between', value: ' example',       start: 33, end: 41}
     * // ]
     *
     * // Omitting unneeded parts with null valueNames, and using escapeChar
     * str = '...{1}.\\{{function(x,y){return {y:x}}}';
     * XRegExp.matchRecursive(str, '{', '}', 'g', {
     *   valueNames: ['literal', null, 'value', null],
     *   escapeChar: '\\'
     * });
     * // -> [
     * // {name: 'literal', value: '...',  start: 0, end: 3},
     * // {name: 'value',   value: '1',    start: 4, end: 5},
     * // {name: 'literal', value: '.\\{', start: 6, end: 9},
     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
     * // ]
     *
     * // Sticky mode via flag y
     * str = '<1><<<2>>><3>4<5>';
     * XRegExp.matchRecursive(str, '<', '>', 'gy');
     * // -> ['1', '<<2>>', '3']
     */
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') > -1;
        var sticky = flags.indexOf('y') > -1;
        // Flag `y` is controlled internally
        var basicFlags = flags.replace(/y/g, '');
        var escapeChar = options.escapeChar;
        var vN = options.valueNames;
        var output = [];
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart;
        var innerStart;
        var leftMatch;
        var rightMatch;
        var esc;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Example of concatenated `esc` regex:
            // `escapeChar`: '%'
            // `left`: '<'
            // `right`: '>'
            // Regex is: /(?:%[\S\s]|(?:(?!<|>)[^%])+)+/
            esc = new RegExp(
                '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                    // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                    // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                    // transformation resulting from those flags was already applied to `left` and
                    // `right` when they were passed through the XRegExp constructor above.
                    XRegExp.union([left, right], '', {conjunction: 'or'}).source +
                    ')[^' + escapeChar + '])+)+',
                // Flags `gy` not needed here
                flags.replace(/[^imu]+/g, '')
            );
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (!--openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };

};

},{}],3:[function(require,module,exports){
/*!
 * XRegExp Unicode Base 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2008-2017 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds base support for Unicode matching:
     * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
     *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
     *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
     * - Adds flag A (astral), which enables 21-bit Unicode support.
     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
     *
     * Unicode Base relies on externally provided Unicode character data. Official addons are
     * available to provide data for Unicode categories, scripts, blocks, and properties.
     *
     * @requires XRegExp
     */

    // ==--------------------------==
    // Private stuff
    // ==--------------------------==

    // Storage for Unicode data
    var unicode = {};

    // Reuse utils
    var dec = XRegExp._dec;
    var hex = XRegExp._hex;
    var pad4 = XRegExp._pad4;

    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

    // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ?
            dec(esc[1]) :
            chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
    }

    // Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '';
        var lastEnd = -1;

        XRegExp.forEach(
            range,
            /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/,
            function(m) {
                var start = charCode(m[1]);
                if (start > (lastEnd + 1)) {
                    output += '\\u' + pad4(hex(lastEnd + 1));
                    if (start > (lastEnd + 2)) {
                        output += '-\\u' + pad4(hex(start - 1));
                    }
                }
                lastEnd = charCode(m[2] || m[1]);
            }
        );

        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }

        return output;
    }

    // Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return (
            unicode[slug][prop] ||
            (unicode[slug][prop] = invertBmp(unicode[slug].bmp))
        );
    }

    // Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug];
        var combined = '';

        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }

        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ?
            '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
            '(?:' + combined + ')';
    }

    // Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return (
            unicode[slug][prop] ||
            (unicode[slug][prop] = buildAstral(slug, isNegated))
        );
    }

    // ==--------------------------==
    // Core functionality
    // ==--------------------------==

    /*
     * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
     */
    XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
            var ERR_DOUBLE_NEG = 'Invalid double negation ';
            var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
            var ERR_UNKNOWN_REF = 'Unicode token missing data ';
            var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
            var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';
            // Negated via \P{..} or \p{^..}
            var isNegated = match[1] === 'P' || !!match[2];
            // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
            var isAstralMode = flags.indexOf('A') > -1;
            // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
            var slug = normalize(match[4] || match[3]);
            // Token data object
            var item = unicode[slug];

            if (match[1] === 'P' && match[2]) {
                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
            }
            if (!unicode.hasOwnProperty(slug)) {
                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
            }

            // Switch to the negated form of the referenced Unicode token
            if (item.inverseOf) {
                slug = normalize(item.inverseOf);
                if (!unicode.hasOwnProperty(slug)) {
                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                }
                item = unicode[slug];
                isNegated = !isNegated;
            }

            if (!(item.bmp || isAstralMode)) {
                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
            }
            if (isAstralMode) {
                if (scope === 'class') {
                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                }

                return cacheAstral(slug, isNegated);
            }

            return scope === 'class' ?
                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                (isNegated ? '[^' : '[') + item.bmp + ']';
        },
        {
            scope: 'all',
            optionalFlags: 'A',
            leadChar: '\\'
        }
    );

    /**
     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
     *
     * @memberOf XRegExp
     * @param {Array} data Objects with named character ranges. Each object may have properties
     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
     *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
     *   character classes and alternation, and should use surrogate pairs to represent astral code
     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
     *   defined as the exact inverse of another token.
     * @example
     *
     * // Basic use
     * XRegExp.addUnicodeData([{
     *   name: 'XDigit',
     *   alias: 'Hexadecimal',
     *   bmp: '0-9A-Fa-f'
     * }]);
     * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
     */
    XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = 'Unicode token requires name';
        var ERR_NO_DATA = 'Unicode token has no character data ';
        var item;

        for (var i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

    /**
     * @ignore
     *
     * Return a reference to the internal Unicode definition structure for the given Unicode
     * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
     * constructs.
     *
     * @memberOf XRegExp
     * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),
     *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode
     *   Properties and Property Aliases.
     * @returns {Object} Reference to definition structure when the name matches a Unicode Property.
     *
     * @note
     * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.
     *
     * @note
     * This method is *not* part of the officially documented API and may change or be removed in
     * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode
     * structures set up by XRegExp.
     */
    XRegExp._getUnicodeProperty = function(name) {
        var slug = normalize(name);
        return unicode[slug];
    };

};

},{}],4:[function(require,module,exports){
/*!
 * XRegExp Unicode Blocks 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
     * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
     * underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([
        {
            name: 'InAdlam',
            astral: '\uD83A[\uDD00-\uDD5F]'
        },
        {
            name: 'InAegean_Numbers',
            astral: '\uD800[\uDD00-\uDD3F]'
        },
        {
            name: 'InAhom',
            astral: '\uD805[\uDF00-\uDF3F]'
        },
        {
            name: 'InAlchemical_Symbols',
            astral: '\uD83D[\uDF00-\uDF7F]'
        },
        {
            name: 'InAlphabetic_Presentation_Forms',
            bmp: '\uFB00-\uFB4F'
        },
        {
            name: 'InAnatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE7F]'
        },
        {
            name: 'InAncient_Greek_Musical_Notation',
            astral: '\uD834[\uDE00-\uDE4F]'
        },
        {
            name: 'InAncient_Greek_Numbers',
            astral: '\uD800[\uDD40-\uDD8F]'
        },
        {
            name: 'InAncient_Symbols',
            astral: '\uD800[\uDD90-\uDDCF]'
        },
        {
            name: 'InArabic',
            bmp: '\u0600-\u06FF'
        },
        {
            name: 'InArabic_Extended_A',
            bmp: '\u08A0-\u08FF'
        },
        {
            name: 'InArabic_Mathematical_Alphabetic_Symbols',
            astral: '\uD83B[\uDE00-\uDEFF]'
        },
        {
            name: 'InArabic_Presentation_Forms_A',
            bmp: '\uFB50-\uFDFF'
        },
        {
            name: 'InArabic_Presentation_Forms_B',
            bmp: '\uFE70-\uFEFF'
        },
        {
            name: 'InArabic_Supplement',
            bmp: '\u0750-\u077F'
        },
        {
            name: 'InArmenian',
            bmp: '\u0530-\u058F'
        },
        {
            name: 'InArrows',
            bmp: '\u2190-\u21FF'
        },
        {
            name: 'InAvestan',
            astral: '\uD802[\uDF00-\uDF3F]'
        },
        {
            name: 'InBalinese',
            bmp: '\u1B00-\u1B7F'
        },
        {
            name: 'InBamum',
            bmp: '\uA6A0-\uA6FF'
        },
        {
            name: 'InBamum_Supplement',
            astral: '\uD81A[\uDC00-\uDE3F]'
        },
        {
            name: 'InBasic_Latin',
            bmp: '\0-\x7F'
        },
        {
            name: 'InBassa_Vah',
            astral: '\uD81A[\uDED0-\uDEFF]'
        },
        {
            name: 'InBatak',
            bmp: '\u1BC0-\u1BFF'
        },
        {
            name: 'InBengali',
            bmp: '\u0980-\u09FF'
        },
        {
            name: 'InBhaiksuki',
            astral: '\uD807[\uDC00-\uDC6F]'
        },
        {
            name: 'InBlock_Elements',
            bmp: '\u2580-\u259F'
        },
        {
            name: 'InBopomofo',
            bmp: '\u3100-\u312F'
        },
        {
            name: 'InBopomofo_Extended',
            bmp: '\u31A0-\u31BF'
        },
        {
            name: 'InBox_Drawing',
            bmp: '\u2500-\u257F'
        },
        {
            name: 'InBrahmi',
            astral: '\uD804[\uDC00-\uDC7F]'
        },
        {
            name: 'InBraille_Patterns',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'InBuginese',
            bmp: '\u1A00-\u1A1F'
        },
        {
            name: 'InBuhid',
            bmp: '\u1740-\u175F'
        },
        {
            name: 'InByzantine_Musical_Symbols',
            astral: '\uD834[\uDC00-\uDCFF]'
        },
        {
            name: 'InCJK_Compatibility',
            bmp: '\u3300-\u33FF'
        },
        {
            name: 'InCJK_Compatibility_Forms',
            bmp: '\uFE30-\uFE4F'
        },
        {
            name: 'InCJK_Compatibility_Ideographs',
            bmp: '\uF900-\uFAFF'
        },
        {
            name: 'InCJK_Compatibility_Ideographs_Supplement',
            astral: '\uD87E[\uDC00-\uDE1F]'
        },
        {
            name: 'InCJK_Radicals_Supplement',
            bmp: '\u2E80-\u2EFF'
        },
        {
            name: 'InCJK_Strokes',
            bmp: '\u31C0-\u31EF'
        },
        {
            name: 'InCJK_Symbols_and_Punctuation',
            bmp: '\u3000-\u303F'
        },
        {
            name: 'InCJK_Unified_Ideographs',
            bmp: '\u4E00-\u9FFF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_A',
            bmp: '\u3400-\u4DBF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_B',
            astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_C',
            astral: '\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_D',
            astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_E',
            astral: '\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]'
        },
        {
            name: 'InCarian',
            astral: '\uD800[\uDEA0-\uDEDF]'
        },
        {
            name: 'InCaucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD6F]'
        },
        {
            name: 'InChakma',
            astral: '\uD804[\uDD00-\uDD4F]'
        },
        {
            name: 'InCham',
            bmp: '\uAA00-\uAA5F'
        },
        {
            name: 'InCherokee',
            bmp: '\u13A0-\u13FF'
        },
        {
            name: 'InCherokee_Supplement',
            bmp: '\uAB70-\uABBF'
        },
        {
            name: 'InCombining_Diacritical_Marks',
            bmp: '\u0300-\u036F'
        },
        {
            name: 'InCombining_Diacritical_Marks_Extended',
            bmp: '\u1AB0-\u1AFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_Supplement',
            bmp: '\u1DC0-\u1DFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_for_Symbols',
            bmp: '\u20D0-\u20FF'
        },
        {
            name: 'InCombining_Half_Marks',
            bmp: '\uFE20-\uFE2F'
        },
        {
            name: 'InCommon_Indic_Number_Forms',
            bmp: '\uA830-\uA83F'
        },
        {
            name: 'InControl_Pictures',
            bmp: '\u2400-\u243F'
        },
        {
            name: 'InCoptic',
            bmp: '\u2C80-\u2CFF'
        },
        {
            name: 'InCoptic_Epact_Numbers',
            astral: '\uD800[\uDEE0-\uDEFF]'
        },
        {
            name: 'InCounting_Rod_Numerals',
            astral: '\uD834[\uDF60-\uDF7F]'
        },
        {
            name: 'InCuneiform',
            astral: '\uD808[\uDC00-\uDFFF]'
        },
        {
            name: 'InCuneiform_Numbers_and_Punctuation',
            astral: '\uD809[\uDC00-\uDC7F]'
        },
        {
            name: 'InCurrency_Symbols',
            bmp: '\u20A0-\u20CF'
        },
        {
            name: 'InCypriot_Syllabary',
            astral: '\uD802[\uDC00-\uDC3F]'
        },
        {
            name: 'InCyrillic',
            bmp: '\u0400-\u04FF'
        },
        {
            name: 'InCyrillic_Extended_A',
            bmp: '\u2DE0-\u2DFF'
        },
        {
            name: 'InCyrillic_Extended_B',
            bmp: '\uA640-\uA69F'
        },
        {
            name: 'InCyrillic_Extended_C',
            bmp: '\u1C80-\u1C8F'
        },
        {
            name: 'InCyrillic_Supplement',
            bmp: '\u0500-\u052F'
        },
        {
            name: 'InDeseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'InDevanagari',
            bmp: '\u0900-\u097F'
        },
        {
            name: 'InDevanagari_Extended',
            bmp: '\uA8E0-\uA8FF'
        },
        {
            name: 'InDingbats',
            bmp: '\u2700-\u27BF'
        },
        {
            name: 'InDomino_Tiles',
            astral: '\uD83C[\uDC30-\uDC9F]'
        },
        {
            name: 'InDuployan',
            astral: '\uD82F[\uDC00-\uDC9F]'
        },
        {
            name: 'InEarly_Dynastic_Cuneiform',
            astral: '\uD809[\uDC80-\uDD4F]'
        },
        {
            name: 'InEgyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
        },
        {
            name: 'InElbasan',
            astral: '\uD801[\uDD00-\uDD2F]'
        },
        {
            name: 'InEmoticons',
            astral: '\uD83D[\uDE00-\uDE4F]'
        },
        {
            name: 'InEnclosed_Alphanumeric_Supplement',
            astral: '\uD83C[\uDD00-\uDDFF]'
        },
        {
            name: 'InEnclosed_Alphanumerics',
            bmp: '\u2460-\u24FF'
        },
        {
            name: 'InEnclosed_CJK_Letters_and_Months',
            bmp: '\u3200-\u32FF'
        },
        {
            name: 'InEnclosed_Ideographic_Supplement',
            astral: '\uD83C[\uDE00-\uDEFF]'
        },
        {
            name: 'InEthiopic',
            bmp: '\u1200-\u137F'
        },
        {
            name: 'InEthiopic_Extended',
            bmp: '\u2D80-\u2DDF'
        },
        {
            name: 'InEthiopic_Extended_A',
            bmp: '\uAB00-\uAB2F'
        },
        {
            name: 'InEthiopic_Supplement',
            bmp: '\u1380-\u139F'
        },
        {
            name: 'InGeneral_Punctuation',
            bmp: '\u2000-\u206F'
        },
        {
            name: 'InGeometric_Shapes',
            bmp: '\u25A0-\u25FF'
        },
        {
            name: 'InGeometric_Shapes_Extended',
            astral: '\uD83D[\uDF80-\uDFFF]'
        },
        {
            name: 'InGeorgian',
            bmp: '\u10A0-\u10FF'
        },
        {
            name: 'InGeorgian_Supplement',
            bmp: '\u2D00-\u2D2F'
        },
        {
            name: 'InGlagolitic',
            bmp: '\u2C00-\u2C5F'
        },
        {
            name: 'InGlagolitic_Supplement',
            astral: '\uD838[\uDC00-\uDC2F]'
        },
        {
            name: 'InGothic',
            astral: '\uD800[\uDF30-\uDF4F]'
        },
        {
            name: 'InGrantha',
            astral: '\uD804[\uDF00-\uDF7F]'
        },
        {
            name: 'InGreek_Extended',
            bmp: '\u1F00-\u1FFF'
        },
        {
            name: 'InGreek_and_Coptic',
            bmp: '\u0370-\u03FF'
        },
        {
            name: 'InGujarati',
            bmp: '\u0A80-\u0AFF'
        },
        {
            name: 'InGurmukhi',
            bmp: '\u0A00-\u0A7F'
        },
        {
            name: 'InHalfwidth_and_Fullwidth_Forms',
            bmp: '\uFF00-\uFFEF'
        },
        {
            name: 'InHangul_Compatibility_Jamo',
            bmp: '\u3130-\u318F'
        },
        {
            name: 'InHangul_Jamo',
            bmp: '\u1100-\u11FF'
        },
        {
            name: 'InHangul_Jamo_Extended_A',
            bmp: '\uA960-\uA97F'
        },
        {
            name: 'InHangul_Jamo_Extended_B',
            bmp: '\uD7B0-\uD7FF'
        },
        {
            name: 'InHangul_Syllables',
            bmp: '\uAC00-\uD7AF'
        },
        {
            name: 'InHanunoo',
            bmp: '\u1720-\u173F'
        },
        {
            name: 'InHatran',
            astral: '\uD802[\uDCE0-\uDCFF]'
        },
        {
            name: 'InHebrew',
            bmp: '\u0590-\u05FF'
        },
        {
            name: 'InHigh_Private_Use_Surrogates',
            bmp: '\uDB80-\uDBFF'
        },
        {
            name: 'InHigh_Surrogates',
            bmp: '\uD800-\uDB7F'
        },
        {
            name: 'InHiragana',
            bmp: '\u3040-\u309F'
        },
        {
            name: 'InIPA_Extensions',
            bmp: '\u0250-\u02AF'
        },
        {
            name: 'InIdeographic_Description_Characters',
            bmp: '\u2FF0-\u2FFF'
        },
        {
            name: 'InIdeographic_Symbols_and_Punctuation',
            astral: '\uD81B[\uDFE0-\uDFFF]'
        },
        {
            name: 'InImperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC5F]'
        },
        {
            name: 'InInscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF7F]'
        },
        {
            name: 'InInscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF5F]'
        },
        {
            name: 'InJavanese',
            bmp: '\uA980-\uA9DF'
        },
        {
            name: 'InKaithi',
            astral: '\uD804[\uDC80-\uDCCF]'
        },
        {
            name: 'InKana_Supplement',
            astral: '\uD82C[\uDC00-\uDCFF]'
        },
        {
            name: 'InKanbun',
            bmp: '\u3190-\u319F'
        },
        {
            name: 'InKangxi_Radicals',
            bmp: '\u2F00-\u2FDF'
        },
        {
            name: 'InKannada',
            bmp: '\u0C80-\u0CFF'
        },
        {
            name: 'InKatakana',
            bmp: '\u30A0-\u30FF'
        },
        {
            name: 'InKatakana_Phonetic_Extensions',
            bmp: '\u31F0-\u31FF'
        },
        {
            name: 'InKayah_Li',
            bmp: '\uA900-\uA92F'
        },
        {
            name: 'InKharoshthi',
            astral: '\uD802[\uDE00-\uDE5F]'
        },
        {
            name: 'InKhmer',
            bmp: '\u1780-\u17FF'
        },
        {
            name: 'InKhmer_Symbols',
            bmp: '\u19E0-\u19FF'
        },
        {
            name: 'InKhojki',
            astral: '\uD804[\uDE00-\uDE4F]'
        },
        {
            name: 'InKhudawadi',
            astral: '\uD804[\uDEB0-\uDEFF]'
        },
        {
            name: 'InLao',
            bmp: '\u0E80-\u0EFF'
        },
        {
            name: 'InLatin_Extended_Additional',
            bmp: '\u1E00-\u1EFF'
        },
        {
            name: 'InLatin_Extended_A',
            bmp: '\u0100-\u017F'
        },
        {
            name: 'InLatin_Extended_B',
            bmp: '\u0180-\u024F'
        },
        {
            name: 'InLatin_Extended_C',
            bmp: '\u2C60-\u2C7F'
        },
        {
            name: 'InLatin_Extended_D',
            bmp: '\uA720-\uA7FF'
        },
        {
            name: 'InLatin_Extended_E',
            bmp: '\uAB30-\uAB6F'
        },
        {
            name: 'InLatin_1_Supplement',
            bmp: '\x80-\xFF'
        },
        {
            name: 'InLepcha',
            bmp: '\u1C00-\u1C4F'
        },
        {
            name: 'InLetterlike_Symbols',
            bmp: '\u2100-\u214F'
        },
        {
            name: 'InLimbu',
            bmp: '\u1900-\u194F'
        },
        {
            name: 'InLinear_A',
            astral: '\uD801[\uDE00-\uDF7F]'
        },
        {
            name: 'InLinear_B_Ideograms',
            astral: '\uD800[\uDC80-\uDCFF]'
        },
        {
            name: 'InLinear_B_Syllabary',
            astral: '\uD800[\uDC00-\uDC7F]'
        },
        {
            name: 'InLisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'InLow_Surrogates',
            bmp: '\uDC00-\uDFFF'
        },
        {
            name: 'InLycian',
            astral: '\uD800[\uDE80-\uDE9F]'
        },
        {
            name: 'InLydian',
            astral: '\uD802[\uDD20-\uDD3F]'
        },
        {
            name: 'InMahajani',
            astral: '\uD804[\uDD50-\uDD7F]'
        },
        {
            name: 'InMahjong_Tiles',
            astral: '\uD83C[\uDC00-\uDC2F]'
        },
        {
            name: 'InMalayalam',
            bmp: '\u0D00-\u0D7F'
        },
        {
            name: 'InMandaic',
            bmp: '\u0840-\u085F'
        },
        {
            name: 'InManichaean',
            astral: '\uD802[\uDEC0-\uDEFF]'
        },
        {
            name: 'InMarchen',
            astral: '\uD807[\uDC70-\uDCBF]'
        },
        {
            name: 'InMathematical_Alphanumeric_Symbols',
            astral: '\uD835[\uDC00-\uDFFF]'
        },
        {
            name: 'InMathematical_Operators',
            bmp: '\u2200-\u22FF'
        },
        {
            name: 'InMeetei_Mayek',
            bmp: '\uABC0-\uABFF'
        },
        {
            name: 'InMeetei_Mayek_Extensions',
            bmp: '\uAAE0-\uAAFF'
        },
        {
            name: 'InMende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCDF]'
        },
        {
            name: 'InMeroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDFF]'
        },
        {
            name: 'InMeroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'InMiao',
            astral: '\uD81B[\uDF00-\uDF9F]'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_A',
            bmp: '\u27C0-\u27EF'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_B',
            bmp: '\u2980-\u29FF'
        },
        {
            name: 'InMiscellaneous_Symbols',
            bmp: '\u2600-\u26FF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Arrows',
            bmp: '\u2B00-\u2BFF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Pictographs',
            astral: '\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]'
        },
        {
            name: 'InMiscellaneous_Technical',
            bmp: '\u2300-\u23FF'
        },
        {
            name: 'InModi',
            astral: '\uD805[\uDE00-\uDE5F]'
        },
        {
            name: 'InModifier_Tone_Letters',
            bmp: '\uA700-\uA71F'
        },
        {
            name: 'InMongolian',
            bmp: '\u1800-\u18AF'
        },
        {
            name: 'InMongolian_Supplement',
            astral: '\uD805[\uDE60-\uDE7F]'
        },
        {
            name: 'InMro',
            astral: '\uD81A[\uDE40-\uDE6F]'
        },
        {
            name: 'InMultani',
            astral: '\uD804[\uDE80-\uDEAF]'
        },
        {
            name: 'InMusical_Symbols',
            astral: '\uD834[\uDD00-\uDDFF]'
        },
        {
            name: 'InMyanmar',
            bmp: '\u1000-\u109F'
        },
        {
            name: 'InMyanmar_Extended_A',
            bmp: '\uAA60-\uAA7F'
        },
        {
            name: 'InMyanmar_Extended_B',
            bmp: '\uA9E0-\uA9FF'
        },
        {
            name: 'InNKo',
            bmp: '\u07C0-\u07FF'
        },
        {
            name: 'InNabataean',
            astral: '\uD802[\uDC80-\uDCAF]'
        },
        {
            name: 'InNew_Tai_Lue',
            bmp: '\u1980-\u19DF'
        },
        {
            name: 'InNewa',
            astral: '\uD805[\uDC00-\uDC7F]'
        },
        {
            name: 'InNumber_Forms',
            bmp: '\u2150-\u218F'
        },
        {
            name: 'InOgham',
            bmp: '\u1680-\u169F'
        },
        {
            name: 'InOl_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'InOld_Hungarian',
            astral: '\uD803[\uDC80-\uDCFF]'
        },
        {
            name: 'InOld_Italic',
            astral: '\uD800[\uDF00-\uDF2F]'
        },
        {
            name: 'InOld_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'InOld_Permic',
            astral: '\uD800[\uDF50-\uDF7F]'
        },
        {
            name: 'InOld_Persian',
            astral: '\uD800[\uDFA0-\uDFDF]'
        },
        {
            name: 'InOld_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'InOld_Turkic',
            astral: '\uD803[\uDC00-\uDC4F]'
        },
        {
            name: 'InOptical_Character_Recognition',
            bmp: '\u2440-\u245F'
        },
        {
            name: 'InOriya',
            bmp: '\u0B00-\u0B7F'
        },
        {
            name: 'InOrnamental_Dingbats',
            astral: '\uD83D[\uDE50-\uDE7F]'
        },
        {
            name: 'InOsage',
            astral: '\uD801[\uDCB0-\uDCFF]'
        },
        {
            name: 'InOsmanya',
            astral: '\uD801[\uDC80-\uDCAF]'
        },
        {
            name: 'InPahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF8F]'
        },
        {
            name: 'InPalmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'InPau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEFF]'
        },
        {
            name: 'InPhags_pa',
            bmp: '\uA840-\uA87F'
        },
        {
            name: 'InPhaistos_Disc',
            astral: '\uD800[\uDDD0-\uDDFF]'
        },
        {
            name: 'InPhoenician',
            astral: '\uD802[\uDD00-\uDD1F]'
        },
        {
            name: 'InPhonetic_Extensions',
            bmp: '\u1D00-\u1D7F'
        },
        {
            name: 'InPhonetic_Extensions_Supplement',
            bmp: '\u1D80-\u1DBF'
        },
        {
            name: 'InPlaying_Cards',
            astral: '\uD83C[\uDCA0-\uDCFF]'
        },
        {
            name: 'InPrivate_Use_Area',
            bmp: '\uE000-\uF8FF'
        },
        {
            name: 'InPsalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDFAF]'
        },
        {
            name: 'InRejang',
            bmp: '\uA930-\uA95F'
        },
        {
            name: 'InRumi_Numeral_Symbols',
            astral: '\uD803[\uDE60-\uDE7F]'
        },
        {
            name: 'InRunic',
            bmp: '\u16A0-\u16FF'
        },
        {
            name: 'InSamaritan',
            bmp: '\u0800-\u083F'
        },
        {
            name: 'InSaurashtra',
            bmp: '\uA880-\uA8DF'
        },
        {
            name: 'InSharada',
            astral: '\uD804[\uDD80-\uDDDF]'
        },
        {
            name: 'InShavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'InShorthand_Format_Controls',
            astral: '\uD82F[\uDCA0-\uDCAF]'
        },
        {
            name: 'InSiddham',
            astral: '\uD805[\uDD80-\uDDFF]'
        },
        {
            name: 'InSinhala',
            bmp: '\u0D80-\u0DFF'
        },
        {
            name: 'InSinhala_Archaic_Numbers',
            astral: '\uD804[\uDDE0-\uDDFF]'
        },
        {
            name: 'InSmall_Form_Variants',
            bmp: '\uFE50-\uFE6F'
        },
        {
            name: 'InSora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCFF]'
        },
        {
            name: 'InSpacing_Modifier_Letters',
            bmp: '\u02B0-\u02FF'
        },
        {
            name: 'InSpecials',
            bmp: '\uFFF0-\uFFFF'
        },
        {
            name: 'InSundanese',
            bmp: '\u1B80-\u1BBF'
        },
        {
            name: 'InSundanese_Supplement',
            bmp: '\u1CC0-\u1CCF'
        },
        {
            name: 'InSuperscripts_and_Subscripts',
            bmp: '\u2070-\u209F'
        },
        {
            name: 'InSupplemental_Arrows_A',
            bmp: '\u27F0-\u27FF'
        },
        {
            name: 'InSupplemental_Arrows_B',
            bmp: '\u2900-\u297F'
        },
        {
            name: 'InSupplemental_Arrows_C',
            astral: '\uD83E[\uDC00-\uDCFF]'
        },
        {
            name: 'InSupplemental_Mathematical_Operators',
            bmp: '\u2A00-\u2AFF'
        },
        {
            name: 'InSupplemental_Punctuation',
            bmp: '\u2E00-\u2E7F'
        },
        {
            name: 'InSupplemental_Symbols_and_Pictographs',
            astral: '\uD83E[\uDD00-\uDDFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_A',
            astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_B',
            astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSutton_SignWriting',
            astral: '\uD836[\uDC00-\uDEAF]'
        },
        {
            name: 'InSyloti_Nagri',
            bmp: '\uA800-\uA82F'
        },
        {
            name: 'InSyriac',
            bmp: '\u0700-\u074F'
        },
        {
            name: 'InTagalog',
            bmp: '\u1700-\u171F'
        },
        {
            name: 'InTagbanwa',
            bmp: '\u1760-\u177F'
        },
        {
            name: 'InTags',
            astral: '\uDB40[\uDC00-\uDC7F]'
        },
        {
            name: 'InTai_Le',
            bmp: '\u1950-\u197F'
        },
        {
            name: 'InTai_Tham',
            bmp: '\u1A20-\u1AAF'
        },
        {
            name: 'InTai_Viet',
            bmp: '\uAA80-\uAADF'
        },
        {
            name: 'InTai_Xuan_Jing_Symbols',
            astral: '\uD834[\uDF00-\uDF5F]'
        },
        {
            name: 'InTakri',
            astral: '\uD805[\uDE80-\uDECF]'
        },
        {
            name: 'InTamil',
            bmp: '\u0B80-\u0BFF'
        },
        {
            name: 'InTangut',
            astral: '[\uD81C-\uD821][\uDC00-\uDFFF]'
        },
        {
            name: 'InTangut_Components',
            astral: '\uD822[\uDC00-\uDEFF]'
        },
        {
            name: 'InTelugu',
            bmp: '\u0C00-\u0C7F'
        },
        {
            name: 'InThaana',
            bmp: '\u0780-\u07BF'
        },
        {
            name: 'InThai',
            bmp: '\u0E00-\u0E7F'
        },
        {
            name: 'InTibetan',
            bmp: '\u0F00-\u0FFF'
        },
        {
            name: 'InTifinagh',
            bmp: '\u2D30-\u2D7F'
        },
        {
            name: 'InTirhuta',
            astral: '\uD805[\uDC80-\uDCDF]'
        },
        {
            name: 'InTransport_and_Map_Symbols',
            astral: '\uD83D[\uDE80-\uDEFF]'
        },
        {
            name: 'InUgaritic',
            astral: '\uD800[\uDF80-\uDF9F]'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics',
            bmp: '\u1400-\u167F'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
            bmp: '\u18B0-\u18FF'
        },
        {
            name: 'InVai',
            bmp: '\uA500-\uA63F'
        },
        {
            name: 'InVariation_Selectors',
            bmp: '\uFE00-\uFE0F'
        },
        {
            name: 'InVariation_Selectors_Supplement',
            astral: '\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'InVedic_Extensions',
            bmp: '\u1CD0-\u1CFF'
        },
        {
            name: 'InVertical_Forms',
            bmp: '\uFE10-\uFE1F'
        },
        {
            name: 'InWarang_Citi',
            astral: '\uD806[\uDCA0-\uDCFF]'
        },
        {
            name: 'InYi_Radicals',
            bmp: '\uA490-\uA4CF'
        },
        {
            name: 'InYi_Syllables',
            bmp: '\uA000-\uA48F'
        },
        {
            name: 'InYijing_Hexagram_Symbols',
            bmp: '\u4DC0-\u4DFF'
        }
    ]);

};

},{}],5:[function(require,module,exports){
/*!
 * XRegExp Unicode Categories 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
     * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
     * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([
        {
            name: 'C',
            alias: 'Other',
            isBmpLast: true,
            bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
            astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]'
        },
        {
            name: 'Cc',
            alias: 'Control',
            bmp: '\0-\x1F\x7F-\x9F'
        },
        {
            name: 'Cf',
            alias: 'Format',
            bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
            astral: '\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]'
        },
        {
            name: 'Cn',
            alias: 'Unassigned',
            bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
            astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]'
        },
        {
            name: 'Co',
            alias: 'Private_Use',
            bmp: '\uE000-\uF8FF',
            astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
        },
        {
            name: 'Cs',
            alias: 'Surrogate',
            bmp: '\uD800-\uDFFF'
        },
        {
            name: 'L',
            alias: 'Letter',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
        },
        {
            name: 'Ll',
            alias: 'Lowercase_Letter',
            bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
        },
        {
            name: 'Lm',
            alias: 'Modifier_Letter',
            bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
            astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]'
        },
        {
            name: 'Lo',
            alias: 'Other_Letter',
            bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
        },
        {
            name: 'Lt',
            alias: 'Titlecase_Letter',
            bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
        },
        {
            name: 'Lu',
            alias: 'Uppercase_Letter',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]'
        },
        {
            name: 'M',
            alias: 'Mark',
            bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Mc',
            alias: 'Spacing_Mark',
            bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
            astral: '\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4]|\uD81B[\uDF51-\uDF7E]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]'
        },
        {
            name: 'Me',
            alias: 'Enclosing_Mark',
            bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
        },
        {
            name: 'Mn',
            alias: 'Nonspacing_Mark',
            bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'N',
            alias: 'Number',
            bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83C[\uDD00-\uDD0C]'
        },
        {
            name: 'Nd',
            alias: 'Decimal_Number',
            bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD807[\uDC50-\uDC59]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]'
        },
        {
            name: 'Nl',
            alias: 'Letter_Number',
            bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
            astral: '\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]'
        },
        {
            name: 'No',
            alias: 'Other_Number',
            bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
            astral: '\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]'
        },
        {
            name: 'P',
            alias: 'Punctuation',
            bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
            astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
        },
        {
            name: 'Pc',
            alias: 'Connector_Punctuation',
            bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
        },
        {
            name: 'Pd',
            alias: 'Dash_Punctuation',
            bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
        },
        {
            name: 'Pe',
            alias: 'Close_Punctuation',
            bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
        },
        {
            name: 'Pf',
            alias: 'Final_Punctuation',
            bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
        },
        {
            name: 'Pi',
            alias: 'Initial_Punctuation',
            bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
        },
        {
            name: 'Po',
            alias: 'Other_Punctuation',
            bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43\u2E44\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
            astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
        },
        {
            name: 'Ps',
            alias: 'Open_Punctuation',
            bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
        },
        {
            name: 'S',
            alias: 'Symbol',
            bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
            astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B[\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
        },
        {
            name: 'Sc',
            alias: 'Currency_Symbol',
            bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
        },
        {
            name: 'Sk',
            alias: 'Modifier_Symbol',
            bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
            astral: '\uD83C[\uDFFB-\uDFFF]'
        },
        {
            name: 'Sm',
            alias: 'Math_Symbol',
            bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
            astral: '\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]'
        },
        {
            name: 'So',
            alias: 'Other_Symbol',
            bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
            astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
        },
        {
            name: 'Z',
            alias: 'Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        },
        {
            name: 'Zl',
            alias: 'Line_Separator',
            bmp: '\u2028'
        },
        {
            name: 'Zp',
            alias: 'Paragraph_Separator',
            bmp: '\u2029'
        },
        {
            name: 'Zs',
            alias: 'Space_Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
        }
    ]);

};

},{}],6:[function(require,module,exports){
/*!
 * XRegExp Unicode Properties 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2012-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
     * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
     * UAX #44 <http://unicode.org/reports/tr44/>:
     *
     * - Alphabetic
     *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
     *   Lo + Nl + Other_Alphabetic.
     *
     * - Default_Ignorable_Code_Point
     *   For programmatic determination of default ignorable code points. New characters that should
     *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
     *   permitting programs to correctly handle the default rendering of such characters when not
     *   otherwise supported.
     *
     * - Lowercase
     *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
     *
     * - Noncharacter_Code_Point
     *   Code points permanently reserved for internal use.
     *
     * - Uppercase
     *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
     *
     * - White_Space
     *   Spaces, separator characters and other control characters which should be treated by
     *   programming languages as "white space" for the purpose of parsing elements.
     *
     * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
     * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
     * included in XRegExp's Unicode Categories and Unicode Scripts addons.
     *
     * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [
        {
            name: 'ASCII',
            bmp: '\0-\x7F'
        },
        {
            name: 'Alphabetic',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
        },
        {
            name: 'Any',
            isBmpLast: true,
            bmp: '\0-\uFFFF',
            astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'Default_Ignorable_Code_Point',
            bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
            astral: '\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]'
        },
        {
            name: 'Lowercase',
            bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
        },
        {
            name: 'Noncharacter_Code_Point',
            bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
            astral: '[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]'
        },
        {
            name: 'Uppercase',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
        },
        {
            name: 'White_Space',
            bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        }
    ];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);

};

},{}],7:[function(require,module,exports){
/*!
 * XRegExp Unicode Scripts 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
     * and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([
        {
            name: 'Adlam',
            astral: '\uD83A[\uDD00-\uDD4A\uDD50-\uDD59\uDD5E\uDD5F]'
        },
        {
            name: 'Ahom',
            astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
        },
        {
            name: 'Anatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE46]'
        },
        {
            name: 'Arabic',
            bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
            astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
        },
        {
            name: 'Armenian',
            bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
        },
        {
            name: 'Avestan',
            astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
        },
        {
            name: 'Balinese',
            bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
        },
        {
            name: 'Bamum',
            bmp: '\uA6A0-\uA6F7',
            astral: '\uD81A[\uDC00-\uDE38]'
        },
        {
            name: 'Bassa_Vah',
            astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
        },
        {
            name: 'Batak',
            bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
        },
        {
            name: 'Bengali',
            bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
        },
        {
            name: 'Bhaiksuki',
            astral: '\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]'
        },
        {
            name: 'Bopomofo',
            bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
        },
        {
            name: 'Brahmi',
            astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
        },
        {
            name: 'Braille',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'Buginese',
            bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
        },
        {
            name: 'Buhid',
            bmp: '\u1740-\u1753'
        },
        {
            name: 'Canadian_Aboriginal',
            bmp: '\u1400-\u167F\u18B0-\u18F5'
        },
        {
            name: 'Carian',
            astral: '\uD800[\uDEA0-\uDED0]'
        },
        {
            name: 'Caucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD63\uDD6F]'
        },
        {
            name: 'Chakma',
            astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
        },
        {
            name: 'Cham',
            bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
        },
        {
            name: 'Cherokee',
            bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
        },
        {
            name: 'Common',
            bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FE\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E44\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
            astral: '\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]|\uDB40[\uDC01\uDC20-\uDC7F]'
        },
        {
            name: 'Coptic',
            bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
        },
        {
            name: 'Cuneiform',
            astral: '\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]'
        },
        {
            name: 'Cypriot',
            astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
        },
        {
            name: 'Cyrillic',
            bmp: '\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
        },
        {
            name: 'Deseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'Devanagari',
            bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
        },
        {
            name: 'Duployan',
            astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
        },
        {
            name: 'Egyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
        },
        {
            name: 'Elbasan',
            astral: '\uD801[\uDD00-\uDD27]'
        },
        {
            name: 'Ethiopic',
            bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
        },
        {
            name: 'Georgian',
            bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
        },
        {
            name: 'Glagolitic',
            bmp: '\u2C00-\u2C2E\u2C30-\u2C5E',
            astral: '\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]'
        },
        {
            name: 'Gothic',
            astral: '\uD800[\uDF30-\uDF4A]'
        },
        {
            name: 'Grantha',
            astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
        },
        {
            name: 'Greek',
            bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
            astral: '\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]'
        },
        {
            name: 'Gujarati',
            bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
        },
        {
            name: 'Gurmukhi',
            bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
        },
        {
            name: 'Han',
            bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
            astral: '[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
        },
        {
            name: 'Hangul',
            bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
        },
        {
            name: 'Hanunoo',
            bmp: '\u1720-\u1734'
        },
        {
            name: 'Hatran',
            astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
        },
        {
            name: 'Hebrew',
            bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
        },
        {
            name: 'Hiragana',
            bmp: '\u3041-\u3096\u309D-\u309F',
            astral: '\uD82C\uDC01|\uD83C\uDE00'
        },
        {
            name: 'Imperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
        },
        {
            name: 'Inherited',
            bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
            astral: '\uD800[\uDDFD\uDEE0]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Inscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
        },
        {
            name: 'Inscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
        },
        {
            name: 'Javanese',
            bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
        },
        {
            name: 'Kaithi',
            astral: '\uD804[\uDC80-\uDCC1]'
        },
        {
            name: 'Kannada',
            bmp: '\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
        },
        {
            name: 'Katakana',
            bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
            astral: '\uD82C\uDC00'
        },
        {
            name: 'Kayah_Li',
            bmp: '\uA900-\uA92D\uA92F'
        },
        {
            name: 'Kharoshthi',
            astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
        },
        {
            name: 'Khmer',
            bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
        },
        {
            name: 'Khojki',
            astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3E]'
        },
        {
            name: 'Khudawadi',
            astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
        },
        {
            name: 'Lao',
            bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
        },
        {
            name: 'Latin',
            bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
        },
        {
            name: 'Lepcha',
            bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
        },
        {
            name: 'Limbu',
            bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
        },
        {
            name: 'Linear_A',
            astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
        },
        {
            name: 'Linear_B',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
        },
        {
            name: 'Lisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'Lycian',
            astral: '\uD800[\uDE80-\uDE9C]'
        },
        {
            name: 'Lydian',
            astral: '\uD802[\uDD20-\uDD39\uDD3F]'
        },
        {
            name: 'Mahajani',
            astral: '\uD804[\uDD50-\uDD76]'
        },
        {
            name: 'Malayalam',
            bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F'
        },
        {
            name: 'Mandaic',
            bmp: '\u0840-\u085B\u085E'
        },
        {
            name: 'Manichaean',
            astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
        },
        {
            name: 'Marchen',
            astral: '\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]'
        },
        {
            name: 'Meetei_Mayek',
            bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
        },
        {
            name: 'Mende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
        },
        {
            name: 'Meroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
        },
        {
            name: 'Meroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'Miao',
            astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
        },
        {
            name: 'Modi',
            astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
        },
        {
            name: 'Mongolian',
            bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA',
            astral: '\uD805[\uDE60-\uDE6C]'
        },
        {
            name: 'Mro',
            astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
        },
        {
            name: 'Multani',
            astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
        },
        {
            name: 'Myanmar',
            bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
        },
        {
            name: 'Nabataean',
            astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
        },
        {
            name: 'New_Tai_Lue',
            bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
        },
        {
            name: 'Newa',
            astral: '\uD805[\uDC00-\uDC59\uDC5B\uDC5D]'
        },
        {
            name: 'Nko',
            bmp: '\u07C0-\u07FA'
        },
        {
            name: 'Ogham',
            bmp: '\u1680-\u169C'
        },
        {
            name: 'Ol_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'Old_Hungarian',
            astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
        },
        {
            name: 'Old_Italic',
            astral: '\uD800[\uDF00-\uDF23]'
        },
        {
            name: 'Old_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'Old_Permic',
            astral: '\uD800[\uDF50-\uDF7A]'
        },
        {
            name: 'Old_Persian',
            astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
        },
        {
            name: 'Old_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'Old_Turkic',
            astral: '\uD803[\uDC00-\uDC48]'
        },
        {
            name: 'Oriya',
            bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
        },
        {
            name: 'Osage',
            astral: '\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]'
        },
        {
            name: 'Osmanya',
            astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
        },
        {
            name: 'Pahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
        },
        {
            name: 'Palmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'Pau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEF8]'
        },
        {
            name: 'Phags_Pa',
            bmp: '\uA840-\uA877'
        },
        {
            name: 'Phoenician',
            astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
        },
        {
            name: 'Psalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
        },
        {
            name: 'Rejang',
            bmp: '\uA930-\uA953\uA95F'
        },
        {
            name: 'Runic',
            bmp: '\u16A0-\u16EA\u16EE-\u16F8'
        },
        {
            name: 'Samaritan',
            bmp: '\u0800-\u082D\u0830-\u083E'
        },
        {
            name: 'Saurashtra',
            bmp: '\uA880-\uA8C5\uA8CE-\uA8D9'
        },
        {
            name: 'Sharada',
            astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
        },
        {
            name: 'Shavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'Siddham',
            astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
        },
        {
            name: 'SignWriting',
            astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
        },
        {
            name: 'Sinhala',
            bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
            astral: '\uD804[\uDDE1-\uDDF4]'
        },
        {
            name: 'Sora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
        },
        {
            name: 'Sundanese',
            bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
        },
        {
            name: 'Syloti_Nagri',
            bmp: '\uA800-\uA82B'
        },
        {
            name: 'Syriac',
            bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
        },
        {
            name: 'Tagalog',
            bmp: '\u1700-\u170C\u170E-\u1714'
        },
        {
            name: 'Tagbanwa',
            bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
        },
        {
            name: 'Tai_Le',
            bmp: '\u1950-\u196D\u1970-\u1974'
        },
        {
            name: 'Tai_Tham',
            bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
        },
        {
            name: 'Tai_Viet',
            bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
        },
        {
            name: 'Takri',
            astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
        },
        {
            name: 'Tamil',
            bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
        },
        {
            name: 'Tangut',
            astral: '\uD81B\uDFE0|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]'
        },
        {
            name: 'Telugu',
            bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
        },
        {
            name: 'Thaana',
            bmp: '\u0780-\u07B1'
        },
        {
            name: 'Thai',
            bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
        },
        {
            name: 'Tibetan',
            bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
        },
        {
            name: 'Tifinagh',
            bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
        },
        {
            name: 'Tirhuta',
            astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
        },
        {
            name: 'Ugaritic',
            astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
        },
        {
            name: 'Vai',
            bmp: '\uA500-\uA62B'
        },
        {
            name: 'Warang_Citi',
            astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
        },
        {
            name: 'Yi',
            bmp: '\uA000-\uA48C\uA490-\uA4C6'
        }
    ]);

};

},{}],8:[function(require,module,exports){
var XRegExp = require('./xregexp');

require('./addons/build')(XRegExp);
require('./addons/matchrecursive')(XRegExp);
require('./addons/unicode-base')(XRegExp);
require('./addons/unicode-blocks')(XRegExp);
require('./addons/unicode-categories')(XRegExp);
require('./addons/unicode-properties')(XRegExp);
require('./addons/unicode-scripts')(XRegExp);

module.exports = XRegExp;

},{"./addons/build":1,"./addons/matchrecursive":2,"./addons/unicode-base":3,"./addons/unicode-blocks":4,"./addons/unicode-categories":5,"./addons/unicode-properties":6,"./addons/unicode-scripts":7,"./xregexp":9}],9:[function(require,module,exports){
/*!
 * XRegExp 3.2.0
 * <xregexp.com>
 * Steven Levithan (c) 2007-2017 MIT License
 */

'use strict';

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */

// ==--------------------------==
// Private stuff
// ==--------------------------==

// Property name used for extended regex instance data
var REGEX_DATA = 'xregexp';
// Optional features that can be installed and uninstalled
var features = {
    astral: false,
    natives: false
};
// Native methods to use and restore ('native' is an ES3 reserved keyword)
var nativ = {
    exec: RegExp.prototype.exec,
    test: RegExp.prototype.test,
    match: String.prototype.match,
    replace: String.prototype.replace,
    split: String.prototype.split
};
// Storage for fixed/extended native methods
var fixed = {};
// Storage for regexes cached by `XRegExp.cache`
var regexCache = {};
// Storage for pattern details cached by the `XRegExp` constructor
var patternCache = {};
// Storage for regex syntax tokens added internally or by `XRegExp.addToken`
var tokens = [];
// Token scopes
var defaultScope = 'default';
var classScope = 'class';
// Regexes that match native regex syntax, including octals
var nativeTokens = {
    // Any native multicharacter token in default scope, or any single character
    'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
    // Any native multicharacter token in character class scope, or any single character
    'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
// Any backreference or dollar-prefixed character in replacement strings
var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g;
// Check for correct `exec` handling of nonparticipating capturing groups
var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;
// Check for ES6 `flags` prop support
var hasFlagsProp = /x/.flags !== undefined;
// Shortcut to `Object.prototype.toString`
var toString = {}.toString;

function hasNativeFlag(flag) {
    // Can't check based on the presence of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}
// Check for ES6 `u` flag support
var hasNativeU = hasNativeFlag('u');
// Check for ES6 `y` flag support
var hasNativeY = hasNativeFlag('y');
// Tracker for known flags, including addon flags
var registeredFlags = {
    g: true,
    i: true,
    m: true,
    u: hasNativeU,
    y: hasNativeY
};

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
    var p;

    regex[REGEX_DATA] = {
        captureNames: captureNames
    };

    if (isInternalOnly) {
        return regex;
    }

    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
    if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
    } else {
        for (p in XRegExp.prototype) {
            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
            // extensions exist on `regex.prototype` anyway
            regex[p] = XRegExp.prototype[p];
        }
    }

    regex[REGEX_DATA].source = xSource;
    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

    return regex;
}

/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   - `addG` {Boolean} Add flag g while copying the regex.
 *   - `addY` {Boolean} Add flag y while copying the regex.
 *   - `removeG` {Boolean} Remove flag g while copying the regex.
 *   - `removeY` {Boolean} Remove flag y while copying the regex.
 *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 *   - `source` {String} Overrides `<regex>.source`, for special cases.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
function copyRegex(regex, options) {
    if (!XRegExp.isRegExp(regex)) {
        throw new TypeError('Type RegExp expected');
    }

    var xData = regex[REGEX_DATA] || {};
    var flags = getNativeFlags(regex);
    var flagsToAdd = '';
    var flagsToRemove = '';
    var xregexpSource = null;
    var xregexpFlags = null;

    options = options || {};

    if (options.removeG) {flagsToRemove += 'g';}
    if (options.removeY) {flagsToRemove += 'y';}
    if (flagsToRemove) {
        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
    }

    if (options.addG) {flagsToAdd += 'g';}
    if (options.addY) {flagsToAdd += 'y';}
    if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
    }

    if (!options.isInternalOnly) {
        if (xData.source !== undefined) {
            xregexpSource = xData.source;
        }
        // null or undefined; don't want to add to `flags` if the previous value was null, since
        // that indicates we're not tracking original precompilation flags
        if (xData.flags != null) {
            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
            // removed for non-internal regexes, so don't need to handle it
            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
        }
    }

    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
    // translation to native regex syntax
    regex = augment(
        new RegExp(options.source || regex.source, flags),
        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
        xregexpSource,
        xregexpFlags,
        options.isInternalOnly
    );

    return regex;
}

/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {Number}
 */
function dec(hex) {
    return parseInt(hex, 16);
}

/**
 * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an
 * inline comment or whitespace with flag x. This is used directly as a token handler function
 * passed to `XRegExp.addToken`.
 *
 * @private
 * @param {String} match Match arg of `XRegExp.addToken` handler
 * @param {String} scope Scope arg of `XRegExp.addToken` handler
 * @param {String} flags Flags arg of `XRegExp.addToken` handler
 * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.
 */
function getContextualTokenSeparator(match, scope, flags) {
    if (
        // No need to separate tokens if at the beginning or end of a group
        match.input.charAt(match.index - 1) === '(' ||
        match.input.charAt(match.index + match[0].length) === ')' ||
        // Avoid separating tokens when the following token is a quantifier
        isPatternNext(match.input, match.index + match[0].length, flags, '[?*+]|{\\d+(?:,\\d*)?}')
    ) {
        return '';
    }
    // Keep tokens separated. This avoids e.g. inadvertedly changing `\1 1` or `\1(?#)1` to `\11`.
    // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax
    // error `(? :` into `(?:`.
    return '(?:)';
}

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
function getNativeFlags(regex) {
    return hasFlagsProp ?
        regex.flags :
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overridden
        nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
}

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
function hasNamedCapture(regex) {
    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}

/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {String}
 */
function hex(dec) {
    return parseInt(dec, 10).toString(16);
}

/**
 * Returns the first index at which a given value can be found in an array.
 *
 * @private
 * @param {Array} array Array to search.
 * @param {*} value Value to locate in the array.
 * @returns {Number} Zero-based index at which the item is found, or -1.
 */
function indexOf(array, value) {
    var len = array.length;
    var i;

    for (i = 0; i < len; ++i) {
        if (array[i] === value) {
            return i;
        }
    }

    return -1;
}

/**
 * Checks whether the next nonignorable token after the specified position matches the
 * `needlePattern`
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @param {String} needlePattern Pattern to match the next token against.
 * @returns {Boolean} Whether the next nonignorable token matches `needlePattern`
 */
function isPatternNext(pattern, pos, flags, needlePattern) {
    var inlineCommentPattern = '\\(\\?#[^)]*\\)';
    var lineCommentPattern = '#[^#\\n]*';
    var patternsToIgnore = flags.indexOf('x') > -1 ?
        // Ignore any leading whitespace, line comments, and inline comments
        ['\\s', lineCommentPattern, inlineCommentPattern] :
        // Ignore any leading inline comments
        [inlineCommentPattern];
    return nativ.test.call(
        new RegExp('^(?:' + patternsToIgnore.join('|') + ')*(?:' + needlePattern + ')'),
        pattern.slice(pos)
    );
}

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
function isType(value, type) {
    return toString.call(value) === '[object ' + type + ']';
}

/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {String}
 */
function pad4(str) {
    while (str.length < 4) {
        str = '0' + str;
    }
    return str;
}

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
function prepareFlags(pattern, flags) {
    var i;

    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
    if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError('Invalid duplicate regex flag ' + flags);
    }

    // Strip and apply a leading mode modifier with any combination of flags except g or y
    pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
        }
        // Allow duplicate flags within the mode modifier
        flags = clipDuplicates(flags + $1);
        return '';
    });

    // Throw on unknown native or nonnative flags
    for (i = 0; i < flags.length; ++i) {
        if (!registeredFlags[flags.charAt(i)]) {
            throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
        }
    }

    return {
        pattern: pattern,
        flags: flags
    };
}

/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
function prepareOptions(value) {
    var options = {};

    if (isType(value, 'String')) {
        XRegExp.forEach(value, /[^\s,]+/, function(match) {
            options[match] = true;
        });

        return options;
    }

    return value;
}

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */
function registerFlag(flag) {
    if (!/^[\w$]$/.test(flag)) {
        throw new Error('Flag must be a single character A-Za-z0-9_$');
    }

    registeredFlags[flag] = true;
}

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
function runTokens(pattern, flags, pos, scope, context) {
    var i = tokens.length;
    var leadChar = pattern.charAt(pos);
    var result = null;
    var match;
    var t;

    // Run in reverse insertion order
    while (i--) {
        t = tokens[i];
        if (
            (t.leadChar && t.leadChar !== leadChar) ||
            (t.scope !== scope && t.scope !== 'all') ||
            (t.flag && flags.indexOf(t.flag) === -1)
        ) {
            continue;
        }

        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');
        if (match) {
            result = {
                matchLength: match[0].length,
                output: t.handler.call(context, match, scope, flags),
                reparse: t.reparse
            };
            // Finished with token tests
            break;
        }
    }

    return result;
}

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setAstral(on) {
    features.astral = on;
}

/**
 * Enables or disables native method overrides.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setNatives(on) {
    RegExp.prototype.exec = (on ? fixed : nativ).exec;
    RegExp.prototype.test = (on ? fixed : nativ).test;
    String.prototype.match = (on ? fixed : nativ).match;
    String.prototype.replace = (on ? fixed : nativ).replace;
    String.prototype.split = (on ? fixed : nativ).split;

    features.natives = on;
}

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
function toObject(value) {
    // null or undefined
    if (value == null) {
        throw new TypeError('Cannot convert null or undefined to object');
    }

    return value;
}

// ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     - `g` - global
 *     - `i` - ignore case
 *     - `m` - multiline anchors
 *     - `u` - unicode (ES6)
 *     - `y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     - `n` - explicit capture
 *     - `s` - dot matches all (aka singleline)
 *     - `x` - free-spacing and line comments (aka extended)
 *     - `A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
 *          (?<month> [0-9]{2} ) -?  # month \n\
 *          (?<day>   [0-9]{2} )     # day   ', 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos < appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result && result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result && result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' && scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' && scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}

// Add `RegExp.prototype` to the prototype chain
XRegExp.prototype = new RegExp();

// ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * '2.0.0-beta-3'.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */
XRegExp.version = '3.2.0';

// ==--------------------------==
// Public methods
// ==--------------------------==

// Intentionally undocumented; used in tests and addons
XRegExp._clipDuplicates = clipDuplicates;
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   - The match array, with named backreference properties.
 *   - The regex scope where the match was found: 'default' or 'class'.
 *   - The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   - `flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   - `leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance
 *     since the token can be skipped at any positions where this character doesn't appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   function() {return '\\x07';},
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   function(match) {return match[1] + (match[2] ? '' : '?');},
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
XRegExp.addToken = function(regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i < optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
};

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
};

// Intentionally undocumented; used in tests
XRegExp.cache.flush = function(cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
};

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
XRegExp.escape = function(str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * var pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
XRegExp.exec = function(str, regex, pos, sticky) {
    var cacheKey = 'g';
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
    if (addY) {
        cacheKey += 'y';
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We'll know that the original regex
        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += 'FakeY';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + '|()' : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY && match && match.pop() === '') {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
};

/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex's `global` property and
 * initial `lastIndex`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   - The match array, with named backreference properties.
 *   - The zero-based match index.
 *   - The string being traversed.
 *   - The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * var evens = [];
 * XRegExp.forEach('1a2345', /\d/, function(match, i) {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -> [2, 4]
 */
XRegExp.forEach = function(str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
};

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // DEPRECATED: Overrides native regex methods with fixed/extended versions
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
XRegExp.install = function(options) {
    options = prepareOptions(options);

    if (!features.astral && options.astral) {
        setAstral(true);
    }

    if (!features.natives && options.natives) {
        setNatives(true);
    }
};

/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   - `astral`
 *   - `natives`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('astral');
 */
XRegExp.isInstalled = function(feature) {
    return !!(features[feature]);
};

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
XRegExp.isRegExp = function(value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
};

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
XRegExp.match = function(str, regex, scope) {
    var global = (regex.global && scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' && result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result && result[0]);
};

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
XRegExp.matchChain = function(str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i < values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
};

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
 * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
 * to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     - $$ - Inserts a literal $ character.
 *     - $&, $0 - Inserts the matched substring.
 *     - $` - Inserts the string that precedes the matched substring (left context).
 *     - $' - Inserts the string that follows the matched substring (right context).
 *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     - ${n} - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     - The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     - The zero-based index of the match within the total search string.
 *     - The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '${last}, ${first}');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, function(match) {
 *   return match.last + ', ' + match.first;
 * });
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
XRegExp.replace = function(str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global && scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex && search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
};

/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, function($0) {
 *     return $0.toUpperCase();
 *   }]
 * ]);
 */
XRegExp.replaceEach = function(str, replacements) {
    var i;
    var r;

    for (i = 0; i < replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
};

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
XRegExp.split = function(str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
};

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
 */
XRegExp.test = function(str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
};

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of `XRegExp.install`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // DEPRECATED: Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
XRegExp.uninstall = function(options) {
    options = prepareOptions(options);

    if (features.astral && options.astral) {
        setAstral(false);
    }

    if (features.natives && options.natives) {
        setNatives(false);
    }
};

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @param {Object} [options] Options object with optional properties:
 *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 *
 * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});
 * // -> /manbearpig/i
 */
XRegExp.union = function(patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || 'or';
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?<' + name + '>';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') && patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i < patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === 'none' ? '' : '|';
    return XRegExp(output.join(separator), flags);
};

// ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
fixed.exec = function(str) {
    var origLastIndex = this.lastIndex;
    var match = nativ.exec.apply(this, arguments);
    var name;
    var r2;
    var i;

    if (match) {
        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
        // in standards mode follows the spec.
        if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
            r2 = copyRegex(this, {
                removeG: true,
                isInternalOnly: true
            });
            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
            // matching due to characters outside the match
            nativ.replace.call(String(str).slice(match.index), r2, function() {
                var len = arguments.length;
                var i;
                // Skip index 0 and the last 2
                for (i = 1; i < len - 2; ++i) {
                    if (arguments[i] === undefined) {
                        match[i] = undefined;
                    }
                }
            });
        }

        // Attach named capture properties
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
            // Skip index 0
            for (i = 1; i < match.length; ++i) {
                name = this[REGEX_DATA].captureNames[i - 1];
                if (name) {
                    match[name] = match[i];
                }
            }
        }

        // Fix browsers that increment `lastIndex` after zero-length matches
        if (this.global && !match[0].length && (this.lastIndex > match.index)) {
            this.lastIndex = match.index;
        }
    }

    if (!this.global) {
        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
        this.lastIndex = origLastIndex;
    }

    return match;
};

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
fixed.test = function(str) {
    // Do this the easy way :-)
    return !!fixed.exec.call(this, str);
};

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @memberOf String
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
fixed.match = function(regex) {
    var result;

    if (!XRegExp.isRegExp(regex)) {
        // Use the native `RegExp` rather than `XRegExp`
        regex = new RegExp(regex);
    } else if (regex.global) {
        result = nativ.match.apply(this, arguments);
        // Fixes IE bug
        regex.lastIndex = 0;

        return result;
    }

    return fixed.exec.call(regex, toObject(this));
};

/**
 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
 * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
 * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
 * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
 * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
 * `XRegExp.replace` without overriding natives.
 *
 * @memberOf String
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
fixed.replace = function(search, replacement) {
    var isRegex = XRegExp.isRegExp(search);
    var origLastIndex;
    var captureNames;
    var result;

    if (isRegex) {
        if (search[REGEX_DATA]) {
            captureNames = search[REGEX_DATA].captureNames;
        }
        // Only needed if `search` is nonglobal
        origLastIndex = search.lastIndex;
    } else {
        search += ''; // Type-convert
    }

    // Don't use `typeof`; some older browsers return 'function' for regex objects
    if (isType(replacement, 'Function')) {
        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
        // functions isn't type-converted to a string
        result = nativ.replace.call(String(this), search, function() {
            var args = arguments;
            var i;
            if (captureNames) {
                // Change the `arguments[0]` string primitive to a `String` object that can store
                // properties. This really does need to use `String` as a constructor
                args[0] = new String(args[0]);
                // Store named backreferences on the first argument
                for (i = 0; i < captureNames.length; ++i) {
                    if (captureNames[i]) {
                        args[0][captureNames[i]] = args[i + 1];
                    }
                }
            }
            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
            if (isRegex && search.global) {
                search.lastIndex = args[args.length - 2] + args[0].length;
            }
            // ES6 specs the context for replacement functions as `undefined`
            return replacement.apply(undefined, args);
        });
    } else {
        // Ensure that the last value of `args` will be a string when given nonstring `this`,
        // while still throwing on null or undefined context
        result = nativ.replace.call(this == null ? this : String(this), search, function() {
            // Keep this function's `arguments` available through closure
            var args = arguments;
            return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                var n;
                // Named or numbered backreference with curly braces
                if ($1) {
                    // XRegExp behavior for `${n}`:
                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
                    //    entire match. Any number of leading zeros may be used.
                    // 2. Backreference to named capture `n`, if it exists and is not an integer
                    //    overridden by numbered capture. In practice, this does not overlap with
                    //    numbered capture since XRegExp does not allow named capture to use a bare
                    //    integer as the name.
                    // 3. If the name or number does not refer to an existing capturing group, it's
                    //    an error.
                    n = +$1; // Type-convert; drop leading zeros
                    if (n <= args.length - 3) {
                        return args[n] || '';
                    }
                    // Groups with the same name is an error, else would need `lastIndexOf`
                    n = captureNames ? indexOf(captureNames, $1) : -1;
                    if (n < 0) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[n + 1] || '';
                }
                // Else, special variable or numbered backreference without curly braces
                if ($2 === '$') { // $$
                    return '$';
                }
                if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                    return args[0];
                }
                if ($2 === '`') { // $` (left context)
                    return args[args.length - 1].slice(0, args[args.length - 2]);
                }
                if ($2 === "'") { // $' (right context)
                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                }
                // Else, numbered backreference without curly braces
                $2 = +$2; // Type-convert; drop leading zero
                // XRegExp behavior for `$n` and `$nn`:
                // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                // - `$1` is an error if no capturing groups.
                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                // - `$01` is `$1` if at least one capturing group, else it's an error.
                // - `$0` (not followed by 1-9) and `$00` are the entire match.
                // Native behavior, for comparison:
                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                // - `$1` is a literal `$1` if no capturing groups.
                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                // - `$0` is a literal `$0`.
                if (!isNaN($2)) {
                    if ($2 > args.length - 3) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[$2] || '';
                }
                // `$` followed by an unsupported char is an error, unlike native JS
                throw new SyntaxError('Invalid token ' + $0);
            });
        });
    }

    if (isRegex) {
        if (search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        } else {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            search.lastIndex = origLastIndex;
        }
    }

    return result;
};

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @memberOf String
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
fixed.split = function(separator, limit) {
    if (!XRegExp.isRegExp(separator)) {
        // Browsers handle nonregex split correctly, so use the faster native method
        return nativ.split.apply(this, arguments);
    }

    var str = String(this);
    var output = [];
    var origLastIndex = separator.lastIndex;
    var lastLastIndex = 0;
    var lastLength;

    // Values for `limit`, per the spec:
    // If undefined: pow(2,32) - 1
    // If 0, Infinity, or NaN: 0
    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
    // If negative number: pow(2,32) - floor(abs(limit))
    // If other: Type-convert, then use the above rules
    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
    limit = (limit === undefined ? -1 : limit) >>> 0;

    XRegExp.forEach(str, separator, function(match) {
        // This condition is not the same as `if (match[0].length)`
        if ((match.index + match[0].length) > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = match.index + lastLength;
        }
    });

    if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, '') || lastLength) {
            output.push('');
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    separator.lastIndex = origLastIndex;
    return output.length > limit ? output.slice(0, limit) : output;
};

// ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
XRegExp.addToken(
    /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
    function(match, scope) {
        // \B is allowed in default scope only
        if (match[1] === 'B' && scope === defaultScope) {
            return match[0];
        }
        throw new SyntaxError('Invalid escape ' + match[0]);
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
XRegExp.addToken(
    /\\u{([\dA-Fa-f]+)}/,
    function(match, scope, flags) {
        var code = dec(match[1]);
        if (code > 0x10FFFF) {
            throw new SyntaxError('Invalid Unicode code point ' + match[0]);
        }
        if (code <= 0xFFFF) {
            // Converting to \uNNNN avoids needing to escape the literal character and keep it
            // separate from preceding tokens
            return '\\u' + pad4(hex(code));
        }
        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
        if (hasNativeU && flags.indexOf('u') > -1) {
            return match[0];
        }
        throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
XRegExp.addToken(
    /\[(\^?)\]/,
    function(match) {
        // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
        // (?!) should work like \b\B, but is unreliable in some versions of Firefox
        return match[1] ? '[\\s\\S]' : '\\b\\B';
    },
    {leadChar: '['}
);

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
XRegExp.addToken(
    /\(\?#[^)]*\)/,
    getContextualTokenSeparator,
    {leadChar: '('}
);

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
XRegExp.addToken(
    /\s+|#[^\n]*\n?/,
    getContextualTokenSeparator,
    {flag: 'x'}
);

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
XRegExp.addToken(
    /\./,
    function() {
        return '[\\s\\S]';
    },
    {
        flag: 's',
        leadChar: '.'
    }
);

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
XRegExp.addToken(
    /\\k<([\w$]+)>/,
    function(match) {
        // Groups with the same name is an error, else would need `lastIndexOf`
        var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1];
        var endIndex = match.index + match[0].length;
        if (!index || index > this.captureNames.length) {
            throw new SyntaxError('Backreference to undefined group ' + match[0]);
        }
        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
        // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.
        return '\\' + index + (
            endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                '' : '(?:)'
        );
    },
    {leadChar: '\\'}
);

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
XRegExp.addToken(
    /\\(\d+)/,
    function(match, scope) {
        if (
            !(
                scope === defaultScope &&
                /^[1-9]/.test(match[1]) &&
                +match[1] <= this.captureNames.length
            ) &&
            match[1] !== '0'
        ) {
            throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                match[0]);
        }
        return match[0];
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
XRegExp.addToken(
    /\(\?P?<([\w$]+)>/,
    function(match) {
        // Disallow bare integers as names because named backreferences are added to match arrays
        // and therefore numeric properties may lead to incorrect lookups
        if (!isNaN(match[1])) {
            throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
        }
        if (match[1] === 'length' || match[1] === '__proto__') {
            throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
        }
        if (indexOf(this.captureNames, match[1]) > -1) {
            throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
        }
        this.captureNames.push(match[1]);
        this.hasNamedCapture = true;
        return '(';
    },
    {leadChar: '('}
);

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
XRegExp.addToken(
    /\((?!\?)/,
    function(match, scope, flags) {
        if (flags.indexOf('n') > -1) {
            return '(?:';
        }
        this.captureNames.push(null);
        return '(';
    },
    {
        optionalFlags: 'n',
        leadChar: '('
    }
);

module.exports = XRegExp;

},{}]},{},[8])(8)
});]]></file>
 <order app="global" path="/dev/js//framework/">templates
common/ips.loader.js
common/ui
common/utils
common
controllers</order>
 <order app="global" path="/dev/js//library/">underscore
jquery
mustache
Debug.js
app.js</order>
 <order app="global" path="/dev/js//library//jquery">jquery.js
jquery-migrate.js</order>
 <order app="global" path="/dev/js//library//linkify">linkify.min.js
linkify-jquery.min.js</order>
</javascript>
